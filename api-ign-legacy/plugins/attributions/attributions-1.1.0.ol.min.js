!function(t){var e={};function n(i){if(e[i])return e[i].exports;var s=e[i]={i:i,l:!1,exports:{}};return t[i].call(s.exports,s,s.exports,n),s.l=!0,s.exports}n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var s in t)n.d(i,s,function(e){return t[e]}.bind(null,s));return i},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=4)}([function(t){t.exports=JSON.parse('{"exception":{"impl":"The implementation used cannot create Attributions controls.","mode":"Options mode is bad setted. Tip: {mode: 1 | 2 | 3}.","type":"Missing \'type\' options. When \'url\' option is setted the plugin needs \'type\' option. Values = geojson | kml | topojson.","layer_name":"Missing \'layerName\' options. When \'url\' option is setted the plugin needs \'layerName\' option.","attribution_obsolete":"Developer message: M.plugin.Attributions has been deprecated, use the Attributions control instead"},"attribution":"attribution","tooltip":"Acknowledgments"}')},function(t){t.exports=JSON.parse('{"exception":{"impl":"La implementación no puede crear controles de Attribution.","mode":"La opción \'mode\' no ha sido establecida correctamente. Consejo: {mode: 1 | 2 | 3}.","type":"La opción \'type\' no ha sido establecida. Cuando la opción \'url\' es usada el plugin necesita la opción \'type\'. Valores = geojson | kml | topojson.","layer_name":"La opción \'layerName\' no ha sido establecida. Cuando la opción \'url\' es usada el plugin necesita la opción \'layerName\'.","attribution_obsolete":"Mensaje para el desarrollador: M.plugin.Attributions ha quedado obsoleto, utilice en su lugar el control Attributions"},"attribution":"atribución","tooltip":"Reconocimientos"}')},function(t,e){t.exports='<div id="m-attributions-container" class="m-control m-container m-attributions">\n    <button id=\'close-button\' class="{{icon}}"></button>\n</div>'},function(t,e,n){},function(t,e,n){"use strict";n.r(e);n(3);function i(t){return(i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function s(t,e){for(var n=0;n<e.length;n++){var s=e[n];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(t,(r=s.key,o=void 0,o=function(t,e){if("object"!==i(t)||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var s=n.call(t,e||"default");if("object"!==i(s))return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(r,"string"),"symbol"===i(o)?o:String(o)),s)}var r,o}function r(t,e){return(r=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function o(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,i=a(t);if(e){var s=a(this).constructor;n=Reflect.construct(i,arguments,s)}else n=i.apply(this,arguments);return l(this,n)}}function l(t,e){if(e&&("object"===i(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}function a(t){return(a=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var c=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&r(t,e)}(a,M.Object);var e,n,i,l=o(a);function a(t){var e;return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,a),(e=l.call(this)).map_=t,e}return e=a,(n=[{key:"registerEvent",value:function(t,e){this.map_.getMapImpl().on(t,e)}}])&&s(e.prototype,n),i&&s(e,i),Object.defineProperty(e,"prototype",{writable:!1}),a}();function h(t){return(h="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function u(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function g(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,(s=i.key,r=void 0,r=function(t,e){if("object"!==h(t)||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var i=n.call(t,e||"default");if("object"!==h(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(s,"string"),"symbol"===h(r)?r:String(r)),i)}var s,r}function f(){return(f="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,n){var i=p(t,e);if(i){var s=Object.getOwnPropertyDescriptor(i,e);return s.get?s.get.call(arguments.length<3?t:n):s.value}}).apply(this,arguments)}function p(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=m(t)););return t}function d(t,e){return(d=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function _(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,i=m(t);if(e){var s=m(this).constructor;n=Reflect.construct(i,arguments,s)}else n=i.apply(this,arguments);return y(this,n)}}function y(t,e){if(e&&("object"===h(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}function m(t){return(m=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var E=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&d(t,e)}(r,M.impl.Control);var e,n,i,s=_(r);function r(){return u(this,r),s.apply(this,arguments)}return e=r,(n=[{key:"addTo",value:function(t,e){var n=this;t.getMapImpl().getInteractions().forEach((function(t){t instanceof ol.interaction.DoubleClickZoom&&(n.dblClickInteraction_=t)})),f(m(r.prototype),"addTo",this).call(this,t,e)}},{key:"destroy",value:function(){this.facadeMap_.getMapImpl().removeControl(this),this.facadeMap_=null}}])&&g(e.prototype,n),i&&g(e,i),Object.defineProperty(e,"prototype",{writable:!1}),r}(),I=n(2),x=n.n(I),N=n(0),T=n(1),R={en:N,es:T},O=function(){var t="es";return"function"==typeof M.language.getLang&&(t=M.language.getLang()),t},b=function(t){return"es"===t||"en"===t?R[t]:M.language.getTranslation(t).attributions},w=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:O(),n=b(e),i="";return M.utils.isNullOrEmpty(n)?console.warn("The translation '".concat(e,"' has not been defined.")):i=t.split(".").reduce((function(t,e){return t[e]}),n),i};function L(t){return(L="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function v(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,(s=i.key,r=void 0,r=function(t,e){if("object"!==L(t)||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var i=n.call(t,e||"default");if("object"!==L(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(s,"string"),"symbol"===L(r)?r:String(r)),i)}var s,r}function S(t,e){return(S=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function C(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,i=A(t);if(e){var s=A(this).constructor;n=Reflect.construct(i,arguments,s)}else n=i.apply(this,arguments);return P(this,n)}}function P(t,e){if(e&&("object"===L(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}function A(t){return(A=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var D=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&S(t,e)}(r,M.Control);var e,n,i,s=C(r);function r(t,e){var n;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,r),M.utils.isUndefined(E)&&M.exception(w("exception.impl"));var i=new E;return(n=s.call(this,i,"Attributions")).position=t,n.closePanel=e,n}return e=r,(n=[{key:"createView",value:function(t){var e=this;return this.map=t,console.warn(w("exception.attribution_obsolete")),new Promise((function(t,n){var i=M.template.compileSync(x.a,{vars:{icon:"BR"===e.position||"TR"===e.position?"g-cartografia-flecha-derecha":"g-cartografia-flecha-izquierda"}});i.querySelector("#close-button").addEventListener("click",(function(){return e.closePanel()})),e.html_=i,t(i)}))}},{key:"equals",value:function(t){return t instanceof r}},{key:"destroy",value:function(){this.getImpl().destroy()}}])&&v(e.prototype,n),i&&v(e,i),Object.defineProperty(e,"prototype",{writable:!1}),r}(),F=function(t,e){return t.interfaces_&&t.interfaces_.indexOf(e)>-1};class Y{constructor(t,e){this.low=e||0,this.high=t||0}static toBinaryString(t){let e,n="";for(e=2147483648;e>0;e>>>=1)n+=(t.high&e)===e?"1":"0";for(e=2147483648;e>0;e>>>=1)n+=(t.low&e)===e?"1":"0";return n}}function G(){}function q(){}G.NaN=NaN,G.isNaN=t=>Number.isNaN(t),G.isInfinite=t=>!Number.isFinite(t),G.MAX_VALUE=Number.MAX_VALUE,G.POSITIVE_INFINITY=Number.POSITIVE_INFINITY,G.NEGATIVE_INFINITY=Number.NEGATIVE_INFINITY,"function"==typeof Float64Array&&"function"==typeof Int32Array?function(){const t=new Float64Array(1),e=new Int32Array(t.buffer);G.doubleToLongBits=function(n){t[0]=n;let i=0|e[0],s=0|e[1];return 2146435072==(2146435072&s)&&0!=(1048575&s)&&0!==i&&(i=0,s=2146959360),new Y(s,i)},G.longBitsToDouble=function(n){return e[0]=n.low,e[1]=n.high,t[0]}}():function(){const t=Math.log2,e=Math.floor,n=Math.pow,i=function(){for(let i=53;i>0;i--){const s=n(2,i)-1;if(e(t(s))+1===i)return s}return 0}();G.doubleToLongBits=function(s){let r,o,l,a,c,h,u,g,f;if(s<0||1/s===Number.NEGATIVE_INFINITY?(h=1<<31,s=-s):h=0,0===s)return f=0,g=h,new Y(g,f);if(s===1/0)return f=0,g=2146435072|h,new Y(g,f);if(s!=s)return f=0,g=2146959360,new Y(g,f);if(a=0,f=0,r=e(s),r>1)if(r<=i)a=e(t(r)),a<=20?(f=0,g=r<<20-a&1048575):(l=a-20,o=n(2,l),f=r%o<<32-l,g=r/o&1048575);else for(l=r,f=0;o=l/2,l=e(o),0!==l;)a++,f>>>=1,f|=(1&g)<<31,g>>>=1,o!==l&&(g|=524288);if(u=a+1023,c=0===r,r=s-r,a<52&&0!==r)for(l=0;;){if(o=2*r,o>=1?(r=o-1,c?(u--,c=!1):(l<<=1,l|=1,a++)):(r=o,c?0==--u&&(a++,c=!1):(l<<=1,a++)),20===a)g|=l,l=0;else if(52===a){f|=l;break}if(1===o){a<20?g|=l<<20-a:a<52&&(f|=l<<52-a);break}}return g|=u<<20,g|=h,new Y(g,f)},G.longBitsToDouble=function(t){let e,i,s,r;const o=t.high,l=t.low,a=o&1<<31?-1:1;for(s=((2146435072&o)>>20)-1023,r=0,i=1<<19,e=1;e<=20;e++)o&i&&(r+=n(2,-e)),i>>>=1;for(i=1<<31,e=21;e<=52;e++)l&i&&(r+=n(2,-e)),i>>>=1;if(-1023===s){if(0===r)return 0*a;s=-1022}else{if(1024===s)return 0===r?a/0:NaN;r+=1}return a*r*n(2,s)}}();class B{getM(t){if(this.hasM()){const e=this.getDimension()-this.getMeasures();return this.getOrdinate(t,e)}return G.NaN}setOrdinate(t,e,n){}getZ(t){return this.hasZ()?this.getOrdinate(t,2):G.NaN}size(){}getOrdinate(t,e){}getCoordinate(){if(1===arguments.length){}else if(2===arguments.length){}}getCoordinateCopy(t){}createCoordinate(){}getDimension(){}hasM(){return this.getMeasures()>0}getX(t){}hasZ(){return this.getDimension()-this.getMeasures()>2}getMeasures(){return 0}expandEnvelope(t){}copy(){}getY(t){}toCoordinateArray(){}get interfaces_(){return[q]}}B.X=0,B.Y=1,B.Z=2,B.M=3;class U{create(){if(1===arguments.length){if(arguments[0]instanceof Array){}else if(F(arguments[0],B)){}}else if(2===arguments.length){}else if(3===arguments.length){const t=arguments[0],e=arguments[1];return this.create(t,e)}}}class X extends Error{constructor(t){super(t),this.name=Object.keys({Exception:X})[0]}toString(){return this.message}}class z extends X{constructor(t){super(t),this.name=Object.keys({IllegalArgumentException:z})[0]}}class k{filter(t){}}function j(){}function V(){}class Z{static equalsWithTolerance(t,e,n){return Math.abs(t-e)<=n}}function W(){}class H extends X{constructor(t){super(t),this.name=Object.keys({RuntimeException:H})[0]}}class K extends H{constructor(){super(),K.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)H.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];H.constructor_.call(this,t)}}}class J{static shouldNeverReachHere(){if(0===arguments.length)J.shouldNeverReachHere(null);else if(1===arguments.length){const t=arguments[0];throw new K("Should never reach here"+(null!==t?": "+t:""))}}static isTrue(){if(1===arguments.length){const t=arguments[0];J.isTrue(t,null)}else if(2===arguments.length){const t=arguments[1];if(!arguments[0])throw null===t?new K:new K(t)}}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];J.equals(t,e,null)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(!e.equals(t))throw new K("Expected "+t+" but encountered "+e+(null!==n?": "+n:""))}}}const Q=new ArrayBuffer(8),$=new Float64Array(Q),tt=new Int32Array(Q);class et{constructor(){et.constructor_.apply(this,arguments)}static constructor_(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)et.constructor_.call(this,0,0);else if(1===arguments.length){const t=arguments[0];et.constructor_.call(this,t.x,t.y,t.getZ())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];et.constructor_.call(this,t,e,et.NULL_ORDINATE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.z=n}}static hashCode(t){return $[0]=t,tt[0]^tt[1]}getM(){return G.NaN}setOrdinate(t,e){switch(t){case et.X:this.x=e;break;case et.Y:this.y=e;break;case et.Z:this.setZ(e);break;default:throw new z("Invalid ordinate index: "+t)}}equals2D(){if(1===arguments.length){const t=arguments[0];return this.x===t.x&&this.y===t.y}if(2===arguments.length){const t=arguments[0],e=arguments[1];return!!Z.equalsWithTolerance(this.x,t.x,e)&&!!Z.equalsWithTolerance(this.y,t.y,e)}}setM(t){throw new z("Invalid ordinate index: "+et.M)}getZ(){return this.z}getOrdinate(t){switch(t){case et.X:return this.x;case et.Y:return this.y;case et.Z:return this.getZ()}throw new z("Invalid ordinate index: "+t)}equals3D(t){return this.x===t.x&&this.y===t.y&&(this.getZ()===t.getZ()||G.isNaN(this.getZ())&&G.isNaN(t.getZ()))}equals(t){return t instanceof et&&this.equals2D(t)}equalInZ(t,e){return Z.equalsWithTolerance(this.getZ(),t.getZ(),e)}setX(t){this.x=t}compareTo(t){const e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0}getX(){return this.x}setZ(t){this.z=t}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return J.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}}copy(){return new et(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+")"}distance3D(t){const e=this.x-t.x,n=this.y-t.y,i=this.getZ()-t.getZ();return Math.sqrt(e*e+n*n+i*i)}getY(){return this.y}setY(t){this.y=t}distance(t){const e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+et.hashCode(this.x),t=37*t+et.hashCode(this.y),t}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}get interfaces_(){return[j,q,V]}}class nt{constructor(){nt.constructor_.apply(this,arguments)}static constructor_(){if(this._dimensionsToTest=2,0===arguments.length)nt.constructor_.call(this,2);else if(1===arguments.length){const t=arguments[0];if(2!==t&&3!==t)throw new z("only 2 or 3 dimensions may be specified");this._dimensionsToTest=t}}static compare(t,e){return t<e?-1:t>e?1:G.isNaN(t)?G.isNaN(e)?0:-1:G.isNaN(e)?1:0}compare(t,e){const n=nt.compare(t.x,e.x);if(0!==n)return n;const i=nt.compare(t.y,e.y);if(0!==i)return i;if(this._dimensionsToTest<=2)return 0;return nt.compare(t.getZ(),e.getZ())}get interfaces_(){return[W]}}et.DimensionalComparator=nt,et.NULL_ORDINATE=G.NaN,et.X=0,et.Y=1,et.Z=2,et.M=3;class it{constructor(){it.constructor_.apply(this,arguments)}static constructor_(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof et){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof it){const t=arguments[0];this.init(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.init(t,e,n,i)}}static intersects(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];let s=Math.min(n.x,i.x),r=Math.max(n.x,i.x),o=Math.min(t.x,e.x),l=Math.max(t.x,e.x);return!(o>r)&&(!(l<s)&&(s=Math.min(n.y,i.y),r=Math.max(n.y,i.y),o=Math.min(t.y,e.y),l=Math.max(t.y,e.y),!(o>r)&&!(l<s)))}}getArea(){return this.getWidth()*this.getHeight()}equals(t){if(!(t instanceof it))return!1;const e=t;return this.isNull()?e.isNull():this._maxx===e.getMaxX()&&this._maxy===e.getMaxY()&&this._minx===e.getMinX()&&this._miny===e.getMinY()}intersection(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new it;const e=this._minx>t._minx?this._minx:t._minx,n=this._miny>t._miny?this._miny:t._miny,i=this._maxx<t._maxx?this._maxx:t._maxx,s=this._maxy<t._maxy?this._maxy:t._maxy;return new it(e,i,n,s)}isNull(){return this._maxx<this._minx}getMaxX(){return this._maxx}covers(){if(1===arguments.length){if(arguments[0]instanceof et){const t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof it){const t=arguments[0];return!this.isNull()&&!t.isNull()&&(t.getMinX()>=this._minx&&t.getMaxX()<=this._maxx&&t.getMinY()>=this._miny&&t.getMaxY()<=this._maxy)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return!this.isNull()&&(t>=this._minx&&t<=this._maxx&&e>=this._miny&&e<=this._maxy)}}intersects(){if(1===arguments.length){if(arguments[0]instanceof it){const t=arguments[0];return!this.isNull()&&!t.isNull()&&!(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}if(arguments[0]instanceof et){const t=arguments[0];return this.intersects(t.x,t.y)}}else if(2===arguments.length){if(arguments[0]instanceof et&&arguments[1]instanceof et){const t=arguments[0],e=arguments[1];if(this.isNull())return!1;if((t.x<e.x?t.x:e.x)>this._maxx)return!1;if((t.x>e.x?t.x:e.x)<this._minx)return!1;if((t.y<e.y?t.y:e.y)>this._maxy)return!1;return!((t.y>e.y?t.y:e.y)<this._miny)}if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return!this.isNull()&&!(t>this._maxx||t<this._minx||e>this._maxy||e<this._miny)}}}getMinY(){return this._miny}getDiameter(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return Math.sqrt(t*t+e*e)}getMinX(){return this._minx}expandToInclude(){if(1===arguments.length){if(arguments[0]instanceof et){const t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof it){const t=arguments[0];if(t.isNull())return null;this.isNull()?(this._minx=t.getMinX(),this._maxx=t.getMaxX(),this._miny=t.getMinY(),this._maxy=t.getMaxY()):(t._minx<this._minx&&(this._minx=t._minx),t._maxx>this._maxx&&(this._maxx=t._maxx),t._miny<this._miny&&(this._miny=t._miny),t._maxy>this._maxy&&(this._maxy=t._maxy))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.isNull()?(this._minx=t,this._maxx=t,this._miny=e,this._maxy=e):(t<this._minx&&(this._minx=t),t>this._maxx&&(this._maxx=t),e<this._miny&&(this._miny=e),e>this._maxy&&(this._maxy=e))}}minExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t<e?t:e}getWidth(){return this.isNull()?0:this._maxx-this._minx}compareTo(t){const e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this._minx<e._minx?-1:this._minx>e._minx?1:this._miny<e._miny?-1:this._miny>e._miny?1:this._maxx<e._maxx?-1:this._maxx>e._maxx?1:this._maxy<e._maxy?-1:this._maxy>e._maxy?1:0}translate(t,e){if(this.isNull())return null;this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)}copy(){return new it(this)}toString(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"}setToNull(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1}disjoint(t){return!(!this.isNull()&&!t.isNull())||(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}getHeight(){return this.isNull()?0:this._maxy-this._miny}maxExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t>e?t:e}expandBy(){if(1===arguments.length){const t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.isNull())return null;this._minx-=t,this._maxx+=t,this._miny-=e,this._maxy+=e,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}}contains(){if(1===arguments.length){if(arguments[0]instanceof it){const t=arguments[0];return this.covers(t)}if(arguments[0]instanceof et){const t=arguments[0];return this.covers(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.covers(t,e)}}centre(){return this.isNull()?null:new et((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)}init(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof et){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof it){const t=arguments[0];this._minx=t._minx,this._maxx=t._maxx,this._miny=t._miny,this._maxy=t._maxy}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];t<e?(this._minx=t,this._maxx=e):(this._minx=e,this._maxx=t),n<i?(this._miny=n,this._maxy=i):(this._miny=i,this._maxy=n)}}getMaxY(){return this._maxy}distance(t){if(this.intersects(t))return 0;let e=0;this._maxx<t._minx?e=t._minx-this._maxx:this._minx>t._maxx&&(e=this._minx-t._maxx);let n=0;return this._maxy<t._miny?n=t._miny-this._maxy:this._miny>t._maxy&&(n=this._miny-t._maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+et.hashCode(this._minx),t=37*t+et.hashCode(this._maxx),t=37*t+et.hashCode(this._miny),t=37*t+et.hashCode(this._maxy),t}get interfaces_(){return[j,V]}}class st{constructor(){st.constructor_.apply(this,arguments)}isGeometryCollection(){return this.getTypeCode()===st.TYPECODE_GEOMETRYCOLLECTION}getFactory(){return this._factory}getGeometryN(t){return this}getArea(){return 0}isRectangle(){return!1}equalsExact(t){return this===t||this.equalsExact(t,0)}geometryChanged(){this.apply(st.geometryChangedFilter)}geometryChangedAction(){this._envelope=null}equalsNorm(t){return null!==t&&this.norm().equalsExact(t.norm())}getLength(){return 0}getNumGeometries(){return 1}compareTo(){let t;if(1===arguments.length){const e=arguments[0];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e)}if(2===arguments.length){const e=arguments[0],n=arguments[1];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e,n)}}getUserData(){return this._userData}getSRID(){return this._SRID}getEnvelope(){return this.getFactory().toGeometry(this.getEnvelopeInternal())}static checkNotGeometryCollection(t){if(t.getTypeCode()===st.TYPECODE_GEOMETRYCOLLECTION)throw new z("This method does not support GeometryCollection arguments")}equal(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n}norm(){const t=this.copy();return t.normalize(),t}reverse(){const t=this.reverseInternal();return null!=this.envelope&&(t.envelope=this.envelope.copy()),t.setSRID(this.getSRID()),t}copy(){const t=this.copyInternal();return t.envelope=null==this._envelope?null:this._envelope.copy(),t._SRID=this._SRID,t._userData=this._userData,t}getPrecisionModel(){return this._factory.getPrecisionModel()}getEnvelopeInternal(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new it(this._envelope)}setSRID(t){this._SRID=t}setUserData(t){this._userData=t}compare(t,e){const n=t.iterator(),i=e.iterator();for(;n.hasNext()&&i.hasNext();){const t=n.next(),e=i.next(),s=t.compareTo(e);if(0!==s)return s}return n.hasNext()?1:i.hasNext()?-1:0}hashCode(){return this.getEnvelopeInternal().hashCode()}isEquivalentClass(t){return this.getTypeCode()==t.getTypeCode()}get interfaces_(){return[q,j,V]}getClass(){return st}static hasNonEmptyElements(t){for(let e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1}static hasNullElements(t){for(let e=0;e<t.length;e++)if(null===t[e])return!0;return!1}}st.constructor_=function(t){t&&(this._envelope=null,this._userData=null,this._factory=t,this._SRID=t.getSRID())},st.TYPECODE_POINT=0,st.TYPECODE_MULTIPOINT=1,st.TYPECODE_LINESTRING=2,st.TYPECODE_LINEARRING=3,st.TYPECODE_MULTILINESTRING=4,st.TYPECODE_POLYGON=5,st.TYPECODE_MULTIPOLYGON=6,st.TYPECODE_GEOMETRYCOLLECTION=7,st.TYPENAME_POINT="Point",st.TYPENAME_MULTIPOINT="MultiPoint",st.TYPENAME_LINESTRING="LineString",st.TYPENAME_LINEARRING="LinearRing",st.TYPENAME_MULTILINESTRING="MultiLineString",st.TYPENAME_POLYGON="Polygon",st.TYPENAME_MULTIPOLYGON="MultiPolygon",st.TYPENAME_GEOMETRYCOLLECTION="GeometryCollection",st.geometryChangedFilter={get interfaces_(){return[k]},filter(t){t.geometryChangedAction()}};class rt{filter(t){}}class ot{}class lt{static copyCoord(t,e,n,i){const s=Math.min(t.getDimension(),n.getDimension());for(let r=0;r<s;r++)n.setOrdinate(i,r,t.getOrdinate(e,r))}static isRing(t){const e=t.size();return 0===e||!(e<=3)&&(t.getOrdinate(0,B.X)===t.getOrdinate(e-1,B.X)&&t.getOrdinate(0,B.Y)===t.getOrdinate(e-1,B.Y))}static scroll(){if(2===arguments.length){if(F(arguments[0],B)&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];lt.scroll(t,e,lt.isRing(t))}else if(F(arguments[0],B)&&arguments[1]instanceof et){const t=arguments[0],e=arguments[1],n=lt.indexOf(e,t);if(n<=0)return null;lt.scroll(t,n)}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(e<=0)return null;const i=t.copy(),s=n?t.size()-1:t.size();for(let n=0;n<s;n++)for(let r=0;r<t.getDimension();r++)t.setOrdinate(n,r,i.getOrdinate((e+n)%s,r));if(n)for(let e=0;e<t.getDimension();e++)t.setOrdinate(s,e,t.getOrdinate(0,e))}}static isEqual(t,e){const n=t.size();if(n!==e.size())return!1;const i=Math.min(t.getDimension(),e.getDimension());for(let s=0;s<n;s++)for(let n=0;n<i;n++){const i=t.getOrdinate(s,n),r=e.getOrdinate(s,n);if(t.getOrdinate(s,n)!==e.getOrdinate(s,n)&&(!G.isNaN(i)||!G.isNaN(r)))return!1}return!0}static minCoordinateIndex(){if(1===arguments.length){const t=arguments[0];return lt.minCoordinateIndex(t,0,t.size()-1)}if(3===arguments.length){const t=arguments[0],e=arguments[2];let n=-1,i=null;for(let s=arguments[1];s<=e;s++){const e=t.getCoordinate(s);(null===i||i.compareTo(e)>0)&&(i=e,n=s)}return n}}static extend(t,e,n){const i=t.create(n,e.getDimension()),s=e.size();if(lt.copy(e,0,i,0,s),s>0)for(let t=s;t<n;t++)lt.copy(e,s-1,i,t,1);return i}static reverse(t){const e=t.size()-1,n=Math.trunc(e/2);for(let i=0;i<=n;i++)lt.swap(t,i,e-i)}static swap(t,e,n){if(e===n)return null;for(let i=0;i<t.getDimension();i++){const s=t.getOrdinate(e,i);t.setOrdinate(e,i,t.getOrdinate(n,i)),t.setOrdinate(n,i,s)}}static copy(t,e,n,i,s){for(let r=0;r<s;r++)lt.copyCoord(t,e+r,n,i+r)}static ensureValidRing(t,e){const n=e.size();if(0===n)return e;if(n<=3)return lt.createClosedRing(t,e,4);return e.getOrdinate(0,B.X)===e.getOrdinate(n-1,B.X)&&e.getOrdinate(0,B.Y)===e.getOrdinate(n-1,B.Y)?e:lt.createClosedRing(t,e,n+1)}static indexOf(t,e){for(let n=0;n<e.size();n++)if(t.x===e.getOrdinate(n,B.X)&&t.y===e.getOrdinate(n,B.Y))return n;return-1}static createClosedRing(t,e,n){const i=t.create(n,e.getDimension()),s=e.size();lt.copy(e,0,i,0,s);for(let t=s;t<n;t++)lt.copy(e,0,i,t,1);return i}static minCoordinate(t){let e=null;for(let n=0;n<t.size();n++){const i=t.getCoordinate(n);(null===e||e.compareTo(i)>0)&&(e=i)}return e}}class at extends X{constructor(t){super(t),this.name=Object.keys({UnsupportedOperationException:at})[0]}}class ct{static isWhitespace(t){return t<=32&&t>=0||127===t}static toUpperCase(t){return t.toUpperCase()}}class ht{static toDimensionSymbol(t){switch(t){case ht.FALSE:return ht.SYM_FALSE;case ht.TRUE:return ht.SYM_TRUE;case ht.DONTCARE:return ht.SYM_DONTCARE;case ht.P:return ht.SYM_P;case ht.L:return ht.SYM_L;case ht.A:return ht.SYM_A}throw new z("Unknown dimension value: "+t)}static toDimensionValue(t){switch(ct.toUpperCase(t)){case ht.SYM_FALSE:return ht.FALSE;case ht.SYM_TRUE:return ht.TRUE;case ht.SYM_DONTCARE:return ht.DONTCARE;case ht.SYM_P:return ht.P;case ht.SYM_L:return ht.L;case ht.SYM_A:return ht.A}throw new z("Unknown dimension symbol: "+t)}}ht.P=0,ht.L=1,ht.A=2,ht.FALSE=-1,ht.TRUE=-2,ht.DONTCARE=-3,ht.SYM_FALSE="F",ht.SYM_TRUE="T",ht.SYM_DONTCARE="*",ht.SYM_P="0",ht.SYM_L="1",ht.SYM_A="2";class ut{filter(t){}}class gt{filter(t,e){}isDone(){}isGeometryChanged(){}}class ft extends st{constructor(){super(),ft.constructor_.apply(this,arguments)}static constructor_(){if(this._points=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];st.constructor_.call(this,e),this.init(t)}}computeEnvelopeInternal(){return this.isEmpty()?new it:this._points.expandEnvelope(new it)}isRing(){return this.isClosed()&&this.isSimple()}getCoordinates(){return this._points.toCoordinateArray()}copyInternal(){return new ft(this._points.copy(),this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof st){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._points.size()!==n._points.size())return!1;for(let t=0;t<this._points.size();t++)if(!this.equal(this._points.getCoordinate(t),n._points.getCoordinate(t),e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<Math.trunc(this._points.size()/2);t++){const e=this._points.size()-1-t;if(!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))){if(this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e))>0){const t=this._points.copy();lt.reverse(t),this._points=t}return null}}}getCoordinate(){return this.isEmpty()?null:this._points.getCoordinate(0)}getBoundaryDimension(){return this.isClosed()?ht.FALSE:0}isClosed(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))}reverseInternal(){const t=this._points.copy();return lt.reverse(t),this.getFactory().createLineString(t)}getEndPoint(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)}getTypeCode(){return st.TYPECODE_LINESTRING}getDimension(){return 1}getLength(){return class{static ofLine(t){const e=t.size();if(e<=1)return 0;let n=0;const i=new et;t.getCoordinate(0,i);let s=i.x,r=i.y;for(let o=1;o<e;o++){t.getCoordinate(o,i);const e=i.x,l=i.y,a=e-s,c=l-r;n+=Math.sqrt(a*a+c*c),s=e,r=l}return n}}.ofLine(this._points)}getNumPoints(){return this._points.size()}compareToSameClass(){if(1===arguments.length){const t=arguments[0];let e=0,n=0;for(;e<this._points.size()&&n<t._points.size();){const i=this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));if(0!==i)return i;e++,n++}return e<this._points.size()?1:n<t._points.size()?-1:0}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._points,t._points)}}apply(){if(F(arguments[0],rt)){const t=arguments[0];for(let e=0;e<this._points.size();e++)t.filter(this._points.getCoordinate(e))}else if(F(arguments[0],gt)){const t=arguments[0];if(0===this._points.size())return null;for(let e=0;e<this._points.size()&&(t.filter(this._points,e),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(F(arguments[0],ut)){arguments[0].filter(this)}else if(F(arguments[0],k)){arguments[0].filter(this)}}getBoundary(){throw new at}isEquivalentClass(t){return t instanceof ft}getCoordinateN(t){return this._points.getCoordinate(t)}getGeometryType(){return st.TYPENAME_LINESTRING}getCoordinateSequence(){return this._points}isEmpty(){return 0===this._points.size()}init(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new z("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this._points=t}isCoordinate(t){for(let e=0;e<this._points.size();e++)if(this._points.getCoordinate(e).equals(t))return!0;return!1}getStartPoint(){return this.isEmpty()?null:this.getPointN(0)}getPointN(t){return this.getFactory().createPoint(this._points.getCoordinate(t))}get interfaces_(){return[ot]}}class pt{}class dt extends X{constructor(t){super(t),this.name=Object.keys({IllegalStateException:dt})[0]}}class _t extends st{constructor(){super(),_t.constructor_.apply(this,arguments)}static constructor_(){this._coordinates=null;const t=arguments[0],e=arguments[1];st.constructor_.call(this,e),this.init(t)}computeEnvelopeInternal(){if(this.isEmpty())return new it;const t=new it;return t.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),t}getCoordinates(){return this.isEmpty()?[]:[this.getCoordinate()]}copyInternal(){return new _t(this._coordinates.copy(),this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof st){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&(!(!this.isEmpty()||!t.isEmpty())||this.isEmpty()===t.isEmpty()&&this.equal(t.getCoordinate(),this.getCoordinate(),e))}return super.equalsExact.apply(this,arguments)}normalize(){}getCoordinate(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null}getBoundaryDimension(){return ht.FALSE}reverseInternal(){return this.getFactory().createPoint(this._coordinates.copy())}getTypeCode(){return st.TYPECODE_POINT}getDimension(){return 0}getNumPoints(){return this.isEmpty()?0:1}getX(){if(null===this.getCoordinate())throw new dt("getX called on empty Point");return this.getCoordinate().x}compareToSameClass(){if(1===arguments.length){const t=arguments[0];return this.getCoordinate().compareTo(t.getCoordinate())}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._coordinates,t._coordinates)}}apply(){if(F(arguments[0],rt)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(F(arguments[0],gt)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this._coordinates,0),t.isGeometryChanged()&&this.geometryChanged()}else if(F(arguments[0],ut)){arguments[0].filter(this)}else if(F(arguments[0],k)){arguments[0].filter(this)}}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return st.TYPENAME_POINT}getCoordinateSequence(){return this._coordinates}getY(){if(null===this.getCoordinate())throw new dt("getY called on empty Point");return this.getCoordinate().y}isEmpty(){return 0===this._coordinates.size()}init(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),J.isTrue(t.size()<=1),this._coordinates=t}isSimple(){return!0}get interfaces_(){return[pt]}}class yt{static ofRing(){if(arguments[0]instanceof Array){const t=arguments[0];return Math.abs(yt.ofRingSigned(t))}if(F(arguments[0],B)){const t=arguments[0];return Math.abs(yt.ofRingSigned(t))}}static ofRingSigned(){if(arguments[0]instanceof Array){const t=arguments[0];if(t.length<3)return 0;let e=0;const n=t[0].x;for(let i=1;i<t.length-1;i++){const s=t[i].x-n,r=t[i+1].y;e+=s*(t[i-1].y-r)}return e/2}if(F(arguments[0],B)){const t=arguments[0],e=t.size();if(e<3)return 0;const n=new et,i=new et,s=new et;t.getCoordinate(0,i),t.getCoordinate(1,s);const r=i.x;s.x-=r;let o=0;for(let l=1;l<e-1;l++)n.y=i.y,i.x=s.x,i.y=s.y,t.getCoordinate(l+1,s),s.x-=r,o+=i.x*(n.y-s.y);return o/2}}}class mt{add(){}addAll(){}isEmpty(){}iterator(){}size(){}toArray(){}remove(){}}class Et extends X{constructor(t){super(t),this.name=Object.keys({IndexOutOfBoundsException:Et})[0]}}class It extends mt{get(){}set(){}isEmpty(){}}class xt extends X{constructor(t){super(t),this.name=Object.keys({NoSuchElementException:xt})[0]}}class Nt extends It{constructor(t){super(),this.array=[],t instanceof mt&&this.addAll(t)}get interfaces_(){return[It,mt]}ensureCapacity(){}add(t){return 1===arguments.length?this.array.push(t):this.array.splice(arguments[0],0,arguments[1]),!0}clear(){this.array=[]}addAll(t){for(const e of t)this.array.push(e)}set(t,e){const n=this.array[t];return this.array[t]=e,n}iterator(){return new Tt(this)}get(t){if(t<0||t>=this.size())throw new Et;return this.array[t]}isEmpty(){return 0===this.array.length}sort(t){t?this.array.sort((e,n)=>t.compare(e,n)):this.array.sort()}size(){return this.array.length}toArray(){return this.array.slice()}remove(t){for(let e=0,n=this.array.length;e<n;e++)if(this.array[e]===t)return!!this.array.splice(e,1);return!1}[Symbol.iterator](){return this.array.values()}}class Tt{constructor(t){this.arrayList=t,this.position=0}next(){if(this.position===this.arrayList.size())throw new xt;return this.arrayList.get(this.position++)}hasNext(){return this.position<this.arrayList.size()}set(t){return this.arrayList.set(this.position-1,t)}remove(){this.arrayList.remove(this.arrayList.get(this.position))}}class Rt{static sort(){const t=arguments[0];if(1===arguments.length)t.sort((t,e)=>t.compareTo(e));else if(2===arguments.length)t.sort((t,e)=>arguments[1].compare(t,e));else if(3===arguments.length){const e=t.slice(arguments[1],arguments[2]);e.sort();const n=t.slice(0,arguments[1]).concat(e,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of n)t.push(e)}else if(4===arguments.length){const e=t.slice(arguments[1],arguments[2]);e.sort((t,e)=>arguments[3].compare(t,e));const n=t.slice(0,arguments[1]).concat(e,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of n)t.push(e)}}static asList(t){const e=new Nt;for(const n of t)e.add(n);return e}static copyOf(t,e){return t.slice(0,e)}}class Ot{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}toString(){return this.str}}class bt{constructor(t){this.value=t}intValue(){return this.value}compareTo(t){return this.value<t?-1:this.value>t?1:0}static compare(t,e){return t<e?-1:t>e?1:0}static isNan(t){return Number.isNaN(t)}static valueOf(t){return new bt(t)}}class wt{constructor(){wt.constructor_.apply(this,arguments)}static constructor_(){if(this._hi=0,this._lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this.init(t)}else if(arguments[0]instanceof wt){const t=arguments[0];this.init(t)}else if("string"==typeof arguments[0]){const t=arguments[0];wt.constructor_.call(this,wt.parse(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t,e)}}static determinant(){if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];return wt.determinant(wt.valueOf(t),wt.valueOf(e),wt.valueOf(n),wt.valueOf(i))}if(arguments[3]instanceof wt&&arguments[2]instanceof wt&&arguments[0]instanceof wt&&arguments[1]instanceof wt){const t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e))}}static sqr(t){return wt.valueOf(t).selfMultiply(t)}static valueOf(){if("string"==typeof arguments[0]){const t=arguments[0];return wt.parse(t)}if("number"==typeof arguments[0]){return new wt(arguments[0])}}static sqrt(t){return wt.valueOf(t).sqrt()}static parse(t){let e=0;const n=t.length;for(;ct.isWhitespace(t.charAt(e));)e++;let i=!1;if(e<n){const n=t.charAt(e);"-"!==n&&"+"!==n||(e++,"-"===n&&(i=!0))}const s=new wt;let r=0,o=0,l=0,a=!1;for(;!(e>=n);){const n=t.charAt(e);if(e++,ct.isDigit(n)){const t=n-"0";s.selfMultiply(wt.TEN),s.selfAdd(t),r++}else{if("."!==n){if("e"===n||"E"===n){const n=t.substring(e);try{l=bt.parseInt(n)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+n+" in string "+t):e}break}throw new NumberFormatException("Unexpected character '"+n+"' at position "+e+" in string "+t)}o=r,a=!0}}let c=s;a||(o=r);const h=r-o-l;if(0===h)c=s;else if(h>0){const t=wt.TEN.pow(h);c=s.divide(t)}else if(h<0){const t=wt.TEN.pow(-h);c=s.multiply(t)}return i?c.negate():c}static createNaN(){return new wt(G.NaN,G.NaN)}static copy(t){return new wt(t)}static magnitude(t){const e=Math.abs(t),n=Math.log(e)/Math.log(10);let i=Math.trunc(Math.floor(n));return 10*Math.pow(10,i)<=e&&(i+=1),i}static stringOfChar(t,e){const n=new Ot;for(let i=0;i<e;i++)n.append(t);return n.toString()}le(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<=t._lo}extractSignificantDigits(t,e){let n=this.abs(),i=wt.magnitude(n._hi);const s=wt.TEN.pow(i);n=n.divide(s),n.gt(wt.TEN)?(n=n.divide(wt.TEN),i+=1):n.lt(wt.ONE)&&(n=n.multiply(wt.TEN),i-=1);const r=i+1,o=new Ot,l=wt.MAX_PRINT_DIGITS-1;for(let e=0;e<=l;e++){t&&e===r&&o.append(".");const i=Math.trunc(n._hi);if(i<0)break;let s=!1,a=0;i>9?(s=!0,a="9"):a="0"+i,o.append(a),n=n.subtract(wt.valueOf(i)).multiply(wt.TEN),s&&n.selfAdd(wt.TEN);let c=!0;const h=wt.magnitude(n._hi);if(h<0&&Math.abs(h)>=l-e&&(c=!1),!c)break}return e[0]=i,o.toString()}sqr(){return this.multiply(this)}doubleValue(){return this._hi+this._lo}subtract(){if(arguments[0]instanceof wt){const t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){const t=arguments[0];return this.add(-t)}}equals(){if(1===arguments.length&&arguments[0]instanceof wt){const t=arguments[0];return this._hi===t._hi&&this._lo===t._lo}}isZero(){return 0===this._hi&&0===this._lo}selfSubtract(){if(arguments[0]instanceof wt){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t._hi,-t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t,0)}}getSpecialNumberString(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null}min(t){return this.le(t)?this:t}selfDivide(){if(1===arguments.length){if(arguments[0]instanceof wt){const t=arguments[0];return this.selfDivide(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfDivide(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,i=null,s=null,r=null,o=null,l=null,a=null,c=null;return o=this._hi/t,l=wt.SPLIT*o,n=l-o,c=wt.SPLIT*t,n=l-n,i=o-n,s=c-t,a=o*t,s=c-s,r=t-s,c=n*s-a+n*r+i*s+i*r,l=(this._hi-a-c+this._lo-o*e)/t,c=o+l,this._hi=c,this._lo=o-c+l,this}}dump(){return"DD<"+this._hi+", "+this._lo+">"}divide(){if(arguments[0]instanceof wt){const t=arguments[0];let e=null,n=null,i=null,s=null,r=null,o=null,l=null,a=null;r=this._hi/t._hi,o=wt.SPLIT*r,e=o-r,a=wt.SPLIT*t._hi,e=o-e,n=r-e,i=a-t._hi,l=r*t._hi,i=a-i,s=t._hi-i,a=e*i-l+e*s+n*i+n*s,o=(this._hi-l-a+this._lo-r*t._lo)/t._hi,a=r+o;return new wt(a,r-a+o)}if("number"==typeof arguments[0]){const t=arguments[0];return G.isNaN(t)?wt.createNaN():wt.copy(this).selfDivide(t,0)}}ge(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>=t._lo}pow(t){if(0===t)return wt.valueOf(1);let e=new wt(this),n=wt.valueOf(1),i=Math.abs(t);if(i>1)for(;i>0;)i%2==1&&n.selfMultiply(e),i/=2,i>0&&(e=e.sqr());else n=e;return t<0?n.reciprocal():n}ceil(){if(this.isNaN())return wt.NaN;const t=Math.ceil(this._hi);let e=0;return t===this._hi&&(e=Math.ceil(this._lo)),new wt(t,e)}compareTo(t){const e=t;return this._hi<e._hi?-1:this._hi>e._hi?1:this._lo<e._lo?-1:this._lo>e._lo?1:0}rint(){if(this.isNaN())return this;return this.add(.5).floor()}setValue(){if(arguments[0]instanceof wt){const t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){const t=arguments[0];return this.init(t),this}}max(t){return this.ge(t)?this:t}sqrt(){if(this.isZero())return wt.valueOf(0);if(this.isNegative())return wt.NaN;const t=1/Math.sqrt(this._hi),e=this._hi*t,n=wt.valueOf(e),i=this.subtract(n.sqr())._hi*(.5*t);return n.add(i)}selfAdd(){if(1===arguments.length){if(arguments[0]instanceof wt){const t=arguments[0];return this.selfAdd(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];let e=null,n=null,i=null,s=null,r=null,o=null;return i=this._hi+t,r=i-this._hi,s=i-r,s=t-r+(this._hi-s),o=s+this._lo,e=i+o,n=o+(i-e),this._hi=e+n,this._lo=n+(e-this._hi),this}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,i=null,s=null,r=null,o=null,l=null,a=null,c=null;o=this._hi+t,s=this._lo+e,a=o-this._hi,c=s-this._lo,l=o-a,r=s-c,l=t-a+(this._hi-l),r=e-c+(this._lo-r),a=l+s,n=o+a,i=a+(o-n),a=r+i;const h=n+a,u=a+(n-h);return this._hi=h,this._lo=u,this}}selfMultiply(){if(1===arguments.length){if(arguments[0]instanceof wt){const t=arguments[0];return this.selfMultiply(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfMultiply(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,i=null,s=null,r=null,o=null,l=null;o=wt.SPLIT*this._hi,n=o-this._hi,l=wt.SPLIT*t,n=o-n,i=this._hi-n,s=l-t,o=this._hi*t,s=l-s,r=t-s,l=n*s-o+n*r+i*s+i*r+(this._hi*e+this._lo*t);const a=o+l;n=o-a;const c=l+n;return this._hi=a,this._lo=c,this}}selfSqr(){return this.selfMultiply(this)}floor(){if(this.isNaN())return wt.NaN;const t=Math.floor(this._hi);let e=0;return t===this._hi&&(e=Math.floor(this._lo)),new wt(t,e)}negate(){return this.isNaN()?this:new wt(-this._hi,-this._lo)}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}}multiply(){if(arguments[0]instanceof wt){const t=arguments[0];return t.isNaN()?wt.createNaN():wt.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){const t=arguments[0];return G.isNaN(t)?wt.createNaN():wt.copy(this).selfMultiply(t,0)}}isNaN(){return G.isNaN(this._hi)}intValue(){return Math.trunc(this._hi)}toString(){const t=wt.magnitude(this._hi);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()}toStandardNotation(){const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),i=e[0]+1;let s=n;if("."===n.charAt(0))s="0"+n;else if(i<0)s="0."+wt.stringOfChar("0",-i)+n;else if(-1===n.indexOf(".")){const t=i-n.length;s=n+wt.stringOfChar("0",t)+".0"}return this.isNegative()?"-"+s:s}reciprocal(){let t=null,e=null,n=null,i=null,s=null,r=null,o=null,l=null;s=1/this._hi,r=wt.SPLIT*s,t=r-s,l=wt.SPLIT*this._hi,t=r-t,e=s-t,n=l-this._hi,o=s*this._hi,n=l-n,i=this._hi-n,l=t*n-o+t*i+e*n+e*i,r=(1-o-l-s*this._lo)/this._hi;const a=s+r;return new wt(a,s-a+r)}toSciNotation(){if(this.isZero())return wt.SCI_NOT_ZERO;const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),i=wt.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new dt("Found leading zero: "+n);let s="";n.length>1&&(s=n.substring(1));const r=n.charAt(0)+"."+s;return this.isNegative()?"-"+r+i:r+i}abs(){return this.isNaN()?wt.NaN:this.isNegative()?this.negate():new wt(this)}isPositive(){return this._hi>0||0===this._hi&&this._lo>0}lt(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<t._lo}add(){if(arguments[0]instanceof wt){const t=arguments[0];return wt.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){const t=arguments[0];return wt.copy(this).selfAdd(t)}}init(){if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this._hi=t,this._lo=0}else if(arguments[0]instanceof wt){const t=arguments[0];this._hi=t._hi,this._lo=t._lo}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._hi=t,this._lo=e}}gt(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>t._lo}isNegative(){return this._hi<0||0===this._hi&&this._lo<0}trunc(){return this.isNaN()?wt.NaN:this.isPositive()?this.floor():this.ceil()}signum(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0}get interfaces_(){return[V,j,q]}}wt.PI=new wt(3.141592653589793,12246467991473532e-32),wt.TWO_PI=new wt(6.283185307179586,24492935982947064e-32),wt.PI_2=new wt(1.5707963267948966,6123233995736766e-32),wt.E=new wt(2.718281828459045,14456468917292502e-32),wt.NaN=new wt(G.NaN,G.NaN),wt.EPS=123259516440783e-46,wt.SPLIT=134217729,wt.MAX_PRINT_DIGITS=32,wt.TEN=wt.valueOf(10),wt.ONE=wt.valueOf(1),wt.SCI_NOT_EXPONENT_CHAR="E",wt.SCI_NOT_ZERO="0.0E0";class Lt{static orientationIndex(t,e,n){const i=Lt.orientationIndexFilter(t,e,n);if(i<=1)return i;const s=wt.valueOf(e.x).selfAdd(-t.x),r=wt.valueOf(e.y).selfAdd(-t.y),o=wt.valueOf(n.x).selfAdd(-e.x),l=wt.valueOf(n.y).selfAdd(-e.y);return s.selfMultiply(l).selfSubtract(r.selfMultiply(o)).signum()}static signOfDet2x2(){if(arguments[3]instanceof wt&&arguments[2]instanceof wt&&arguments[0]instanceof wt&&arguments[1]instanceof wt){const t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e)).signum()}if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3],s=wt.valueOf(t),r=wt.valueOf(e),o=wt.valueOf(n),l=wt.valueOf(i);return s.multiply(l).selfSubtract(r.multiply(o)).signum()}}static intersection(t,e,n,i){const s=new wt(t.y).selfSubtract(e.y),r=new wt(e.x).selfSubtract(t.x),o=new wt(t.x).selfMultiply(e.y).selfSubtract(new wt(e.x).selfMultiply(t.y)),l=new wt(n.y).selfSubtract(i.y),a=new wt(i.x).selfSubtract(n.x),c=new wt(n.x).selfMultiply(i.y).selfSubtract(new wt(i.x).selfMultiply(n.y)),h=r.multiply(c).selfSubtract(a.multiply(o)),u=l.multiply(o).selfSubtract(s.multiply(c)),g=s.multiply(a).selfSubtract(l.multiply(r)),f=h.selfDivide(g).doubleValue(),p=u.selfDivide(g).doubleValue();return G.isNaN(f)||G.isInfinite(f)||G.isNaN(p)||G.isInfinite(p)?null:new et(f,p)}static orientationIndexFilter(t,e,n){let i=null;const s=(t.x-n.x)*(e.y-n.y),r=(t.y-n.y)*(e.x-n.x),o=s-r;if(s>0){if(r<=0)return Lt.signum(o);i=s+r}else{if(!(s<0))return Lt.signum(o);if(r>=0)return Lt.signum(o);i=-s-r}const l=Lt.DP_SAFE_EPSILON*i;return o>=l||-o>=l?Lt.signum(o):2}static signum(t){return t>0?1:t<0?-1:0}}Lt.DP_SAFE_EPSILON=1e-15;class vt{static index(t,e,n){return Lt.orientationIndex(t,e,n)}static isCCW(){if(arguments[0]instanceof Array){const t=arguments[0],e=t.length-1;if(e<3)throw new z("Ring has fewer than 4 points, so orientation cannot be determined");let n=t[0],i=0;for(let s=1;s<=e;s++){const e=t[s];e.y>n.y&&(n=e,i=s)}let s=i;do{s-=1,s<0&&(s=e)}while(t[s].equals2D(n)&&s!==i);let r=i;do{r=(r+1)%e}while(t[r].equals2D(n)&&r!==i);const o=t[s],l=t[r];if(o.equals2D(n)||l.equals2D(n)||o.equals2D(l))return!1;const a=vt.index(o,n,l);let c=null;return c=0===a?o.x>l.x:a>0,c}if(F(arguments[0],B)){const t=arguments[0],e=t.size()-1;if(e<3)throw new z("Ring has fewer than 4 points, so orientation cannot be determined");let n=t.getCoordinate(0),i=0;for(let s=1;s<=e;s++){const e=t.getCoordinate(s);e.y>n.y&&(n=e,i=s)}let s=null,r=i;do{r-=1,r<0&&(r=e),s=t.getCoordinate(r)}while(s.equals2D(n)&&r!==i);let o=null,l=i;do{l=(l+1)%e,o=t.getCoordinate(l)}while(o.equals2D(n)&&l!==i);if(s.equals2D(n)||o.equals2D(n)||s.equals2D(o))return!1;const a=vt.index(s,n,o);let c=null;return c=0===a?s.x>o.x:a>0,c}}}vt.CLOCKWISE=-1,vt.RIGHT=vt.CLOCKWISE,vt.COUNTERCLOCKWISE=1,vt.LEFT=vt.COUNTERCLOCKWISE,vt.COLLINEAR=0,vt.STRAIGHT=vt.COLLINEAR;class St{}class Ct extends st{constructor(){super(),Ct.constructor_.apply(this,arguments)}static constructor_(){this._shell=null,this._holes=null;let t=arguments[0],e=arguments[1],n=arguments[2];if(st.constructor_.call(this,n),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),st.hasNullElements(e))throw new z("holes must not contain null elements");if(t.isEmpty()&&st.hasNonEmptyElements(e))throw new z("shell is empty but holes are not");this._shell=t,this._holes=e}computeEnvelopeInternal(){return this._shell.getEnvelopeInternal()}getCoordinates(){if(this.isEmpty())return[];const t=new Array(this.getNumPoints()).fill(null);let e=-1;const n=this._shell.getCoordinates();for(let i=0;i<n.length;i++)e++,t[e]=n[i];for(let n=0;n<this._holes.length;n++){const i=this._holes[n].getCoordinates();for(let n=0;n<i.length;n++)e++,t[e]=i[n]}return t}getArea(){let t=0;t+=yt.ofRing(this._shell.getCoordinateSequence());for(let e=0;e<this._holes.length;e++)t-=yt.ofRing(this._holes[e].getCoordinateSequence());return t}copyInternal(){const t=this._shell.copy(),e=new Array(this._holes.length).fill(null);for(let t=0;t<this._holes.length;t++)e[t]=this._holes[t].copy();return new Ct(t,e,this._factory)}isRectangle(){if(0!==this.getNumInteriorRing())return!1;if(null===this._shell)return!1;if(5!==this._shell.getNumPoints())return!1;const t=this._shell.getCoordinateSequence(),e=this.getEnvelopeInternal();for(let n=0;n<5;n++){const i=t.getX(n);if(i!==e.getMinX()&&i!==e.getMaxX())return!1;const s=t.getY(n);if(s!==e.getMinY()&&s!==e.getMaxY())return!1}let n=t.getX(0),i=t.getY(0);for(let e=1;e<=4;e++){const s=t.getX(e),r=t.getY(e);if(s!==n===(r!==i))return!1;n=s,i=r}return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof st){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t,i=this._shell,s=n._shell;if(!i.equalsExact(s,e))return!1;if(this._holes.length!==n._holes.length)return!1;for(let t=0;t<this._holes.length;t++)if(!this._holes[t].equalsExact(n._holes[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){if(0===arguments.length){this._shell=this.normalized(this._shell,!0);for(let t=0;t<this._holes.length;t++)this._holes[t]=this.normalized(this._holes[t],!1);Rt.sort(this._holes)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t.isEmpty())return null;const n=t.getCoordinateSequence(),i=lt.minCoordinateIndex(n,0,n.size()-2);lt.scroll(n,i,!0),vt.isCCW(n)===e&&lt.reverse(n)}}getCoordinate(){return this._shell.getCoordinate()}getNumInteriorRing(){return this._holes.length}getBoundaryDimension(){return 1}reverseInternal(){const t=this.getExteriorRing().reverse(),e=new Array(this.getNumInteriorRing()).fill(null);for(let t=0;t<e.length;t++)e[t]=this.getInteriorRingN(t).reverse();return this.getFactory().createPolygon(t,e)}getTypeCode(){return st.TYPECODE_POLYGON}getDimension(){return 2}getLength(){let t=0;t+=this._shell.getLength();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getLength();return t}getNumPoints(){let t=this._shell.getNumPoints();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getNumPoints();return t}convexHull(){return this.getExteriorRing().convexHull()}normalized(t,e){const n=t.copy();return this.normalize(n,e),n}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=this._shell,n=t._shell;return e.compareToSameClass(n)}if(2===arguments.length){const t=arguments[1],e=arguments[0],n=this._shell,i=e._shell,s=n.compareToSameClass(i,t);if(0!==s)return s;const r=this.getNumInteriorRing(),o=e.getNumInteriorRing();let l=0;for(;l<r&&l<o;){const n=this.getInteriorRingN(l),i=e.getInteriorRingN(l),s=n.compareToSameClass(i,t);if(0!==s)return s;l++}return l<r?1:l<o?-1:0}}apply(){if(F(arguments[0],rt)){const t=arguments[0];this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}else if(F(arguments[0],gt)){const t=arguments[0];if(this._shell.apply(t),!t.isDone())for(let e=0;e<this._holes.length&&(this._holes[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(F(arguments[0],ut)){arguments[0].filter(this)}else if(F(arguments[0],k)){const t=arguments[0];t.filter(this),this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new Array(this._holes.length+1).fill(null);t[0]=this._shell;for(let e=0;e<this._holes.length;e++)t[e+1]=this._holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)}getGeometryType(){return st.TYPENAME_POLYGON}getExteriorRing(){return this._shell}isEmpty(){return this._shell.isEmpty()}getInteriorRingN(t){return this._holes[t]}get interfaces_(){return[St]}}class Pt extends mt{contains(){}}class Mt extends Pt{}class At extends Mt{constructor(t){super(),this.array=[],t instanceof mt&&this.addAll(t)}contains(t){for(const e of this.array)if(0===e.compareTo(t))return!0;return!1}add(t){if(this.contains(t))return!1;for(let e=0,n=this.array.length;e<n;e++){if(1===this.array[e].compareTo(t))return!!this.array.splice(e,0,t)}return this.array.push(t),!0}addAll(t){for(const e of t)this.add(e);return!0}remove(){throw new at}size(){return this.array.length}isEmpty(){return 0===this.array.length}toArray(){return this.array.slice()}iterator(){return new Dt(this.array)}}class Dt{constructor(t){this.array=t,this.position=0}next(){if(this.position===this.array.length)throw new xt;return this.array[this.position++]}hasNext(){return this.position<this.array.length}remove(){throw new at}}class Ft extends st{constructor(){super(),Ft.constructor_.apply(this,arguments)}static constructor_(){if(this._geometries=null,0===arguments.length);else if(2===arguments.length){let t=arguments[0],e=arguments[1];if(st.constructor_.call(this,e),null===t&&(t=[]),st.hasNullElements(t))throw new z("geometries must not contain null elements");this._geometries=t}}computeEnvelopeInternal(){const t=new it;for(let e=0;e<this._geometries.length;e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal());return t}getGeometryN(t){return this._geometries[t]}getCoordinates(){const t=new Array(this.getNumPoints()).fill(null);let e=-1;for(let n=0;n<this._geometries.length;n++){const i=this._geometries[n].getCoordinates();for(let n=0;n<i.length;n++)e++,t[e]=i[n]}return t}getArea(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getArea();return t}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new Ft(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof st){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._geometries.length!==n._geometries.length)return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].equalsExact(n._geometries[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<this._geometries.length;t++)this._geometries[t].normalize();Rt.sort(this._geometries)}getCoordinate(){return this.isEmpty()?null:this._geometries[0].getCoordinate()}getBoundaryDimension(){let t=ht.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getBoundaryDimension());return t}reverseInternal(){const t=this._geometries.length,e=new Nt(t);for(let n=0;n<t;n++)e.add(this._geometries[n].reverse());return this.getFactory().buildGeometry(e)}getTypeCode(){return st.TYPECODE_GEOMETRYCOLLECTION}getDimension(){let t=ht.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getDimension());return t}getLength(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getLength();return t}getNumPoints(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getNumPoints();return t}getNumGeometries(){return this._geometries.length}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=new At(Rt.asList(this._geometries)),n=new At(Rt.asList(t._geometries));return this.compare(e,n)}if(2===arguments.length){const t=arguments[1],e=arguments[0],n=this.getNumGeometries(),i=e.getNumGeometries();let s=0;for(;s<n&&s<i;){const n=this.getGeometryN(s),i=e.getGeometryN(s),r=n.compareToSameClass(i,t);if(0!==r)return r;s++}return s<n?1:s<i?-1:0}}apply(){if(F(arguments[0],rt)){const t=arguments[0];for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(F(arguments[0],gt)){const t=arguments[0];if(0===this._geometries.length)return null;for(let e=0;e<this._geometries.length&&(this._geometries[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(F(arguments[0],ut)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(F(arguments[0],k)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}}getBoundary(){return st.checkNotGeometryCollection(this),J.shouldNeverReachHere(),null}getGeometryType(){return st.TYPENAME_GEOMETRYCOLLECTION}isEmpty(){for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isEmpty())return!1;return!0}}class Yt extends Ft{constructor(){super(),Yt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];Ft.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new Yt(t,this._factory)}isValid(){return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof st){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getCoordinate(){if(1===arguments.length&&Number.isInteger(arguments[0])){const t=arguments[0];return this._geometries[t].getCoordinate()}return super.getCoordinate.apply(this,arguments)}getBoundaryDimension(){return ht.FALSE}getTypeCode(){return st.TYPECODE_MULTIPOINT}getDimension(){return 0}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return st.TYPENAME_MULTIPOINT}get interfaces_(){return[pt]}}class Gt extends ft{constructor(){super(),Gt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ft.constructor_.call(this,t,e),this.validateConstruction()}copyInternal(){return new Gt(this._points.copy(),this._factory)}getBoundaryDimension(){return ht.FALSE}isClosed(){return!!this.isEmpty()||super.isClosed.call(this)}reverseInternal(){const t=this._points.copy();return lt.reverse(t),this.getFactory().createLinearRing(t)}getTypeCode(){return st.TYPECODE_LINEARRING}validateConstruction(){if(!this.isEmpty()&&!super.isClosed.call(this))throw new z("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<Gt.MINIMUM_VALID_SIZE)throw new z("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")}getGeometryType(){return st.TYPENAME_LINEARRING}}Gt.MINIMUM_VALID_SIZE=4;class qt extends et{constructor(){super(),qt.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)et.constructor_.call(this);else if(1===arguments.length){if(arguments[0]instanceof qt){const t=arguments[0];et.constructor_.call(this,t.x,t.y)}else if(arguments[0]instanceof et){const t=arguments[0];et.constructor_.call(this,t.x,t.y)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];et.constructor_.call(this,t,e,et.NULL_ORDINATE)}}setOrdinate(t,e){switch(t){case qt.X:this.x=e;break;case qt.Y:this.y=e;break;default:throw new z("Invalid ordinate index: "+t)}}getZ(){return et.NULL_ORDINATE}getOrdinate(t){switch(t){case qt.X:return this.x;case qt.Y:return this.y}throw new z("Invalid ordinate index: "+t)}setZ(t){throw new z("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new qt(this)}toString(){return"("+this.x+", "+this.y+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}}qt.X=0,qt.Y=1,qt.Z=-1,qt.M=-1;class Bt extends et{constructor(){super(),Bt.constructor_.apply(this,arguments)}static constructor_(){if(this._m=null,0===arguments.length)et.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof Bt){const t=arguments[0];et.constructor_.call(this,t.x,t.y),this._m=t._m}else if(arguments[0]instanceof et){const t=arguments[0];et.constructor_.call(this,t.x,t.y),this._m=this.getM()}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];et.constructor_.call(this,t,e,et.NULL_ORDINATE),this._m=n}}getM(){return this._m}setOrdinate(t,e){switch(t){case Bt.X:this.x=e;break;case Bt.Y:this.y=e;break;case Bt.M:this._m=e;break;default:throw new z("Invalid ordinate index: "+t)}}setM(t){this._m=t}getZ(){return et.NULL_ORDINATE}getOrdinate(t){switch(t){case Bt.X:return this.x;case Bt.Y:return this.y;case Bt.M:return this._m}throw new z("Invalid ordinate index: "+t)}setZ(t){throw new z("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new Bt(this)}toString(){return"("+this.x+", "+this.y+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}}Bt.X=0,Bt.Y=1,Bt.Z=-1,Bt.M=2;class Ut extends et{constructor(){super(),Ut.constructor_.apply(this,arguments)}static constructor_(){if(this._m=null,0===arguments.length)et.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof Ut){const t=arguments[0];et.constructor_.call(this,t),this._m=t._m}else if(arguments[0]instanceof et){const t=arguments[0];et.constructor_.call(this,t),this._m=this.getM()}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];et.constructor_.call(this,t,e,n),this._m=i}}getM(){return this._m}setOrdinate(t,e){switch(t){case et.X:this.x=e;break;case et.Y:this.y=e;break;case et.Z:this.z=e;break;case et.M:this._m=e;break;default:throw new z("Invalid ordinate index: "+t)}}setM(t){this._m=t}getOrdinate(t){switch(t){case et.X:return this.x;case et.Y:return this.y;case et.Z:return this.getZ();case et.M:return this.getM()}throw new z("Invalid ordinate index: "+t)}copy(){return new Ut(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}}class Xt{static measures(t){return t instanceof qt?0:t instanceof Bt||t instanceof Ut?1:0}static dimension(t){return t instanceof qt?2:t instanceof Bt?3:t instanceof Ut?4:3}static create(){if(1===arguments.length){const t=arguments[0];return Xt.create(t,0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return 2===t?new qt:3===t&&0===e?new et:3===t&&1===e?new Bt:4===t&&1===e?new Ut:new et}}}class zt extends Nt{constructor(){super(),zt.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.ensureCapacity(t.length),this.add(t,e)}}getCoordinate(t){return this.get(t)}addAll(){if(2===arguments.length&&"boolean"==typeof arguments[1]&&F(arguments[0],mt)){const t=arguments[1];let e=!1;for(let n=arguments[0].iterator();n.hasNext();)this.add(n.next(),t),e=!0;return e}return super.addAll.apply(this,arguments)}clone(){const t=super.clone.call(this);for(let e=0;e<this.size();e++)t.add(e,this.get(e).clone());return t}toCoordinateArray(){if(0===arguments.length)return this.toArray(zt.coordArrayType);if(1===arguments.length){if(arguments[0])return this.toArray(zt.coordArrayType);const t=this.size(),e=new Array(t).fill(null);for(let n=0;n<t;n++)e[n]=this.get(t-n-1);return e}}add(){if(1===arguments.length){const t=arguments[0];return super.add.call(this,t)}if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e,!0),!0}if(arguments[0]instanceof et&&"boolean"==typeof arguments[1]){const t=arguments[0];if(!arguments[1]&&this.size()>=1){if(this.get(this.size()-1).equals2D(t))return null}super.add.call(this,t)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(arguments[2])for(let n=0;n<t.length;n++)this.add(t[n],e);else for(let n=t.length-1;n>=0;n--)this.add(t[n],e);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof et){const t=arguments[0],e=arguments[1];if(!arguments[2]){const n=this.size();if(n>0){if(t>0){if(this.get(t-1).equals2D(e))return null}if(t<n){if(this.get(t).equals2D(e))return null}}}super.add.call(this,t,e)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];let s=1;n>i&&(s=-1);for(let r=n;r!==i;r+=s)this.add(t[r],e);return!0}}closeRing(){if(this.size()>0){const t=this.get(0).copy();this.add(t,!1)}}}zt.coordArrayType=new Array(0).fill(null);class kt{static log10(t){const e=Math.log(t);return G.isInfinite(e)||G.isNaN(e)?e:e/kt.LOG_10}static min(t,e,n,i){let s=t;return e<s&&(s=e),n<s&&(s=n),i<s&&(s=i),s}static clamp(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}}static wrap(t,e){return t<0?e- -t%e:t%e}static max(){if(3===arguments.length){const t=arguments[1],e=arguments[2];let n=arguments[0];return t>n&&(n=t),e>n&&(n=e),n}if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3];let i=arguments[0];return t>i&&(i=t),e>i&&(i=e),n>i&&(i=n),i}}static average(t,e){return(t+e)/2}}kt.LOG_10=Math.log(10);class jt{static arraycopy(t,e,n,i,s){let r=0;for(let o=e;o<e+s;o++)n[i+r]=t[o],r++}static getProperty(t){return{"line.separator":"\n"}[t]}}class Vt{static isRing(t){return!(t.length<4)&&!!t[0].equals2D(t[t.length-1])}static ptNotInList(t,e){for(let n=0;n<t.length;n++){const i=t[n];if(Vt.indexOf(i,e)<0)return i}return null}static scroll(t,e){const n=Vt.indexOf(e,t);if(n<0)return null;const i=new Array(t.length).fill(null);jt.arraycopy(t,n,i,0,t.length-n),jt.arraycopy(t,0,i,t.length-n,n),jt.arraycopy(i,0,t,0,t.length)}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(0!==n.compare(t[i],e[i]))return!1;return!0}}static intersection(t,e){const n=new zt;for(let i=0;i<t.length;i++)e.intersects(t[i])&&n.add(t[i],!0);return n.toCoordinateArray()}static measures(t){if(null===t||0===t.length)return 0;let e=0;for(const n of t)e=Math.max(e,Xt.measures(n));return e}static hasRepeatedPoints(t){for(let e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1}static removeRepeatedPoints(t){if(!Vt.hasRepeatedPoints(t))return t;return new zt(t,!1).toCoordinateArray()}static reverse(t){const e=t.length-1,n=Math.trunc(e/2);for(let i=0;i<=n;i++){const n=t[i];t[i]=t[e-i],t[e-i]=n}}static removeNull(t){let e=0;for(let n=0;n<t.length;n++)null!==t[n]&&e++;const n=new Array(e).fill(null);if(0===e)return n;let i=0;for(let e=0;e<t.length;e++)null!==t[e]&&(n[i++]=t[e]);return n}static copyDeep(){if(1===arguments.length){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=t[n].copy();return e}if(5===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3],s=arguments[4];for(let r=0;r<s;r++)n[i+r]=t[e+r].copy()}}static isEqualReversed(t,e){for(let n=0;n<t.length;n++){const i=t[n],s=e[t.length-n-1];if(0!==i.compareTo(s))return!1}return!0}static envelope(t){const e=new it;for(let n=0;n<t.length;n++)e.expandToInclude(t[n]);return e}static toCoordinateArray(t){return t.toArray(Vt.coordArrayType)}static dimension(t){if(null===t||0===t.length)return 3;let e=0;for(const n of t)e=Math.max(e,Xt.dimension(n));return e}static atLeastNCoordinatesOrNothing(t,e){return e.length>=t?e:[]}static indexOf(t,e){for(let n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1}static increasingDirection(t){for(let e=0;e<Math.trunc(t.length/2);e++){const n=t.length-1-e,i=t[e].compareTo(t[n]);if(0!==i)return i}return 1}static compare(t,e){let n=0;for(;n<t.length&&n<e.length;){const i=t[n].compareTo(e[n]);if(0!==i)return i;n++}return n<e.length?-1:n<t.length?1:0}static minCoordinate(t){let e=null;for(let n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e}static extract(t,e,n){e=kt.clamp(e,0,t.length);let i=(n=kt.clamp(n,-1,t.length))-e+1;n<0&&(i=0),e>=t.length&&(i=0),n<e&&(i=0);const s=new Array(i).fill(null);if(0===i)return s;let r=0;for(let i=e;i<=n;i++)s[r++]=t[i];return s}}Vt.ForwardComparator=class{compare(t,e){const n=t,i=e;return Vt.compare(n,i)}get interfaces_(){return[W]}},Vt.BidirectionalComparator=class{compare(t,e){const n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;const s=Vt.compare(n,i);return Vt.isEqualReversed(n,i)?0:s}OLDcompare(t,e){const n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;const s=Vt.increasingDirection(n),r=Vt.increasingDirection(i);let o=s>0?0:n.length-1,l=r>0?0:n.length-1;for(let t=0;t<n.length;t++){const t=n[o].compareTo(i[l]);if(0!==t)return t;o+=s,l+=r}return 0}get interfaces_(){return[W]}},Vt.coordArrayType=new Array(0).fill(null);class Zt{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}toString(){return this.str}}class Wt{constructor(){Wt.constructor_.apply(this,arguments)}static constructor_(){if(this._dimension=3,this._measures=0,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];Wt.constructor_.call(this,t,Vt.dimension(t),Vt.measures(t))}else if(Number.isInteger(arguments[0])){const t=arguments[0];this._coordinates=new Array(t).fill(null);for(let e=0;e<t;e++)this._coordinates[e]=new et}else if(F(arguments[0],B)){const t=arguments[0];if(null===t)return this._coordinates=new Array(0).fill(null),null;this._dimension=t.getDimension(),this._measures=t.getMeasures(),this._coordinates=new Array(t.size()).fill(null);for(let e=0;e<this._coordinates.length;e++)this._coordinates[e]=t.getCoordinateCopy(e)}}else if(2===arguments.length){if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];Wt.constructor_.call(this,t,e,Vt.measures(t))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];this._coordinates=new Array(t).fill(null),this._dimension=e;for(let n=0;n<t;n++)this._coordinates[n]=Xt.create(e)}}else if(3===arguments.length)if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];this._dimension=e,this._measures=n,this._coordinates=null===t?new Array(0).fill(null):t}else if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];this._coordinates=new Array(t).fill(null),this._dimension=e,this._measures=n;for(let e=0;e<t;e++)this._coordinates[e]=this.createCoordinate()}}getM(t){return this.hasM()?this._coordinates[t].getM():G.NaN}setOrdinate(t,e,n){switch(e){case B.X:this._coordinates[t].x=n;break;case B.Y:this._coordinates[t].y=n;break;default:this._coordinates[t].setOrdinate(e,n)}}getZ(t){return this.hasZ()?this._coordinates[t].getZ():G.NaN}size(){return this._coordinates.length}getOrdinate(t,e){switch(e){case B.X:return this._coordinates[t].x;case B.Y:return this._coordinates[t].y;default:return this._coordinates[t].getOrdinate(e)}}getCoordinate(){if(1===arguments.length){const t=arguments[0];return this._coordinates[t]}if(2===arguments.length){const t=arguments[0];arguments[1].setCoordinate(this._coordinates[t])}}getCoordinateCopy(t){const e=this.createCoordinate();return e.setCoordinate(this._coordinates[t]),e}createCoordinate(){return Xt.create(this.getDimension(),this.getMeasures())}getDimension(){return this._dimension}getX(t){return this._coordinates[t].x}getMeasures(){return this._measures}expandEnvelope(t){for(let e=0;e<this._coordinates.length;e++)t.expandToInclude(this._coordinates[e]);return t}copy(){const t=new Array(this.size()).fill(null);for(let e=0;e<this._coordinates.length;e++){const n=this.createCoordinate();n.setCoordinate(this._coordinates[e]),t[e]=n}return new Wt(t,this._dimension,this._measures)}toString(){if(this._coordinates.length>0){const t=new Zt(17*this._coordinates.length);t.append("("),t.append(this._coordinates[0]);for(let e=1;e<this._coordinates.length;e++)t.append(", "),t.append(this._coordinates[e]);return t.append(")"),t.toString()}return"()"}getY(t){return this._coordinates[t].y}toCoordinateArray(){return this._coordinates}get interfaces_(){return[B,V]}}class Ht{static instance(){return Ht.instanceObject}readResolve(){return Ht.instance()}create(){if(1===arguments.length){if(arguments[0]instanceof Array){return new Wt(arguments[0])}if(F(arguments[0],B)){return new Wt(arguments[0])}}else{if(2===arguments.length){let t=arguments[1];return t>3&&(t=3),t<2&&(t=2),new Wt(arguments[0],t)}if(3===arguments.length){let t=arguments[2],e=arguments[1]-t;return t>1&&(t=1),e>3&&(e=3),e<2&&(e=2),new Wt(arguments[0],e+t,t)}}}get interfaces_(){return[U,V]}}Ht.instanceObject=new Ht;class Kt extends Ft{constructor(){super(),Kt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];Ft.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new Kt(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof st){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return 1}getTypeCode(){return st.TYPECODE_MULTIPOLYGON}getDimension(){return 2}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new Nt;for(let e=0;e<this._geometries.length;e++){const n=this._geometries[e].getBoundary();for(let e=0;e<n.getNumGeometries();e++)t.add(n.getGeometryN(e))}const e=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(e))}getGeometryType(){return st.TYPENAME_MULTIPOLYGON}get interfaces_(){return[St]}}class Jt{get(){}put(){}size(){}values(){}entrySet(){}}class Qt extends Pt{constructor(t){super(),this.map=new Map,t instanceof mt&&this.addAll(t)}contains(t){const e=t.hashCode?t.hashCode():t;return!!this.map.has(e)}add(t){const e=t.hashCode?t.hashCode():t;return!this.map.has(e)&&!!this.map.set(e,t)}addAll(t){for(const e of t)this.add(e);return!0}remove(){throw new at}size(){return this.map.size}isEmpty(){return 0===this.map.size}toArray(){return Array.from(this.map.values())}iterator(){return new $t(this.map)}[Symbol.iterator](){return this.map}}class $t{constructor(t){this.iterator=t.values();const{done:e,value:n}=this.iterator.next();this.done=e,this.value=n}next(){if(this.done)throw new xt;const t=this.value,{done:e,value:n}=this.iterator.next();return this.done=e,this.value=n,t}hasNext(){return!this.done}remove(){throw new at}}class te extends Jt{constructor(){super(),this.map=new Map}get(t){return this.map.get(t)||null}put(t,e){return this.map.set(t,e),e}values(){const t=new Nt,e=this.map.values();let n=e.next();for(;!n.done;)t.add(n.value),n=e.next();return t}entrySet(){const t=new Qt;return this.map.entries().forEach(e=>t.add(e)),t}size(){return this.map.size()}}class ee{constructor(){ee.constructor_.apply(this,arguments)}static constructor_(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=ee.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof ne){const t=arguments[0];this._modelType=t,t===ee.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){const t=arguments[0];this._modelType=ee.FIXED,this.setScale(t)}else if(arguments[0]instanceof ee){const t=arguments[0];this._modelType=t._modelType,this._scale=t._scale}}static mostPrecise(t,e){return t.compareTo(e)>=0?t:e}equals(t){if(!(t instanceof ee))return!1;const e=t;return this._modelType===e._modelType&&this._scale===e._scale}compareTo(t){const e=t,n=this.getMaximumSignificantDigits(),i=e.getMaximumSignificantDigits();return bt.compare(n,i)}getScale(){return this._scale}isFloating(){return this._modelType===ee.FLOATING||this._modelType===ee.FLOATING_SINGLE}getType(){return this._modelType}toString(){let t="UNKNOWN";return this._modelType===ee.FLOATING?t="Floating":this._modelType===ee.FLOATING_SINGLE?t="Floating-Single":this._modelType===ee.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t}makePrecise(){if("number"==typeof arguments[0]){const t=arguments[0];if(G.isNaN(t))return t;if(this._modelType===ee.FLOATING_SINGLE){return t}return this._modelType===ee.FIXED?Math.round(t*this._scale)/this._scale:t}if(arguments[0]instanceof et){const t=arguments[0];if(this._modelType===ee.FLOATING)return null;t.x=this.makePrecise(t.x),t.y=this.makePrecise(t.y)}}getMaximumSignificantDigits(){let t=16;return this._modelType===ee.FLOATING?t=16:this._modelType===ee.FLOATING_SINGLE?t=6:this._modelType===ee.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t}setScale(t){this._scale=Math.abs(t)}get interfaces_(){return[V,j]}}class ne{constructor(){ne.constructor_.apply(this,arguments)}static constructor_(){this._name=null;const t=arguments[0];this._name=t,ne.nameToTypeMap.put(t,this)}readResolve(){return ne.nameToTypeMap.get(this._name)}toString(){return this._name}get interfaces_(){return[V]}}ne.nameToTypeMap=new te,ee.Type=ne,ee.FIXED=new ne("FIXED"),ee.FLOATING=new ne("FLOATING"),ee.FLOATING_SINGLE=new ne("FLOATING SINGLE"),ee.maximumPreciseValue=9007199254740992;class ie extends Ft{constructor(){super(),ie.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];Ft.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ie(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof st){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return this.isClosed()?ht.FALSE:0}isClosed(){if(this.isEmpty())return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isClosed())return!1;return!0}getTypeCode(){return st.TYPECODE_MULTILINESTRING}getDimension(){return 1}getBoundary(){throw new at}getGeometryType(){return st.TYPENAME_MULTILINESTRING}get interfaces_(){return[ot]}}class se{constructor(){se.constructor_.apply(this,arguments)}static constructor_(){if(this._precisionModel=null,this._coordinateSequenceFactory=null,this._SRID=null,0===arguments.length)se.constructor_.call(this,new ee,0);else if(1===arguments.length){if(F(arguments[0],U)){const t=arguments[0];se.constructor_.call(this,new ee,0,t)}else if(arguments[0]instanceof ee){const t=arguments[0];se.constructor_.call(this,t,0,se.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];se.constructor_.call(this,t,e,se.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._coordinateSequenceFactory=n,this._SRID=e}}static toMultiPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toGeometryArray(t){if(null===t)return null;const e=new Array(t.size()).fill(null);return t.toArray(e)}static getDefaultCoordinateSequenceFactory(){return Ht.instance()}static toMultiLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toMultiPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLinearRingArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static createPointFromInternalCoord(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)}createEmpty(t){switch(t){case-1:return this.createGeometryCollection();case 0:return this.createPoint();case 1:return this.createLineString();case 2:return this.createPolygon();default:throw new z("Invalid dimension: "+t)}}toGeometry(t){return t.isNull()?this.createPoint():t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new et(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new et(t.getMinX(),t.getMinY()),new et(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new et(t.getMinX(),t.getMinY()),new et(t.getMinX(),t.getMaxY()),new et(t.getMaxX(),t.getMaxY()),new et(t.getMaxX(),t.getMinY()),new et(t.getMinX(),t.getMinY())]),null)}createLineString(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(F(arguments[0],B)){return new ft(arguments[0],this)}}}createMultiLineString(){if(0===arguments.length)return new ie(null,this);if(1===arguments.length){return new ie(arguments[0],this)}}buildGeometry(t){let e=null,n=!1,i=!1;for(let s=t.iterator();s.hasNext();){const t=s.next(),r=t.getTypeCode();null===e&&(e=r),r!==e&&(n=!0),t instanceof Ft&&(i=!0)}if(null===e)return this.createGeometryCollection();if(n||i)return this.createGeometryCollection(se.toGeometryArray(t));const s=t.iterator().next();if(t.size()>1){if(s instanceof Ct)return this.createMultiPolygon(se.toPolygonArray(t));if(s instanceof ft)return this.createMultiLineString(se.toLineStringArray(t));if(s instanceof _t)return this.createMultiPoint(se.toPointArray(t));J.shouldNeverReachHere("Unhandled geometry type: "+s.getGeometryType())}return s}createMultiPointFromCoords(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)}createPoint(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof et){const t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(F(arguments[0],B)){return new _t(arguments[0],this)}}}getCoordinateSequenceFactory(){return this._coordinateSequenceFactory}createPolygon(){if(0===arguments.length)return this.createPolygon(null,null);if(1===arguments.length){if(F(arguments[0],B)){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Gt){const t=arguments[0];return this.createPolygon(t,null)}}else if(2===arguments.length){return new Ct(arguments[0],arguments[1],this)}}getSRID(){return this._SRID}createGeometryCollection(){if(0===arguments.length)return new Ft(null,this);if(1===arguments.length){return new Ft(arguments[0],this)}}getPrecisionModel(){return this._precisionModel}createLinearRing(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(F(arguments[0],B)){return new Gt(arguments[0],this)}}}createMultiPolygon(){if(0===arguments.length)return new Kt(null,this);if(1===arguments.length){return new Kt(arguments[0],this)}}createMultiPoint(){if(0===arguments.length)return new Yt(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){return new Yt(arguments[0],this)}if(F(arguments[0],B)){const t=arguments[0];if(null===t)return this.createMultiPoint(new Array(0).fill(null));const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const i=this.getCoordinateSequenceFactory().create(1,t.getDimension(),t.getMeasures());lt.copy(t,n,i,0,1),e[n]=this.createPoint(i)}return this.createMultiPoint(e)}}}get interfaces_(){return[V]}}const re=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];class oe{constructor(t){this.geometryFactory=t||new se}read(t){let e;e="string"==typeof t?JSON.parse(t):t;const n=e.type;if(!le[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==re.indexOf(n)?le[n].call(this,e.coordinates):"GeometryCollection"===n?le[n].call(this,e.geometries):le[n].call(this,e)}write(t){const e=t.getGeometryType();if(!ae[e])throw new Error("Geometry is not supported");return ae[e].call(this,t)}}const le={Feature:function(t){const e={};for(const n in t)e[n]=t[n];if(t.geometry){const n=t.geometry.type;if(!le[n])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=le.bbox.call(this,t.bbox)),e},FeatureCollection:function(t){const e={};if(t.features){e.features=[];for(let n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.call(this,t.bbox)),e},coordinates:function(t){const e=[];for(let n=0;n<t.length;++n){const i=t[n];e.push(new et(...i))}return e},bbox:function(t){return this.geometryFactory.createLinearRing([new et(t[0],t[1]),new et(t[2],t[1]),new et(t[2],t[3]),new et(t[0],t[3]),new et(t[0],t[1])])},Point:function(t){const e=new et(...t);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(le.Point.call(this,t[n]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){const e=le.coordinates.call(this,t);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(le.LineString.call(this,t[n]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){const e=le.coordinates.call(this,t[0]),n=this.geometryFactory.createLinearRing(e),i=[];for(let e=1;e<t.length;++e){const n=t[e],s=le.coordinates.call(this,n),r=this.geometryFactory.createLinearRing(s);i.push(r)}return this.geometryFactory.createPolygon(n,i)},MultiPolygon:function(t){const e=[];for(let n=0;n<t.length;++n){const i=t[n];e.push(le.Polygon.call(this,i))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){const e=[];for(let n=0;n<t.length;++n){const i=t[n];e.push(this.read(i))}return this.geometryFactory.createGeometryCollection(e)}},ae={coordinate:function(t){const e=[t.x,t.y];return t.z&&e.push(t.z),t.m&&e.push(t.m),e},Point:function(t){return{type:"Point",coordinates:ae.coordinate.call(this,t.getCoordinate())}},MultiPoint:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const i=t._geometries[n],s=ae.Point.call(this,i);e.push(s.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){const e=[],n=t.getCoordinates();for(let t=0;t<n.length;++t){const i=n[t];e.push(ae.coordinate.call(this,i))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const i=t._geometries[n],s=ae.LineString.call(this,i);e.push(s.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){const e=[],n=ae.LineString.call(this,t._shell);e.push(n.coordinates);for(let n=0;n<t._holes.length;++n){const i=t._holes[n],s=ae.LineString.call(this,i);e.push(s.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const i=t._geometries[n],s=ae.Polygon.call(this,i);e.push(s.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const i=t._geometries[n],s=i.getGeometryType();e.push(ae[s].call(this,i))}return{type:"GeometryCollection",geometries:e}}};class ce{constructor(t){this.parser=new oe(t||new se)}read(t){return this.parser.read(t)}}const he="XY",ue="XYZ",ge="XYM",fe="XYZM",pe={POINT:"Point",LINE_STRING:"LineString",LINEAR_RING:"LinearRing",POLYGON:"Polygon",MULTI_POINT:"MultiPoint",MULTI_LINE_STRING:"MultiLineString",MULTI_POLYGON:"MultiPolygon",GEOMETRY_COLLECTION:"GeometryCollection",CIRCLE:"Circle"},de=1,_e=2,ye=3,me=4,Ee=5,Ie=6,xe={};for(const t in pe)xe[t]=pe[t].toUpperCase();class Ne{constructor(t){this.wkt=t,this.index_=-1}isAlpha_(t){return t>="a"&&t<="z"||t>="A"&&t<="Z"}isNumeric_(t,e){return t>="0"&&t<="9"||"."==t&&!(void 0!==e&&e)}isWhiteSpace_(t){return" "==t||"\t"==t||"\r"==t||"\n"==t}nextChar_(){return this.wkt.charAt(++this.index_)}nextToken(){const t=this.nextChar_(),e=this.index_;let n,i=t;if("("==t)n=_e;else if(","==t)n=Ee;else if(")"==t)n=ye;else if(this.isNumeric_(t)||"-"==t)n=me,i=this.readNumber_();else if(this.isAlpha_(t))n=de,i=this.readText_();else{if(this.isWhiteSpace_(t))return this.nextToken();if(""!==t)throw new Error("Unexpected character: "+t);n=Ie}return{position:e,value:i,type:n}}readNumber_(){let t;const e=this.index_;let n=!1,i=!1;do{"."==t?n=!0:"e"!=t&&"E"!=t||(i=!0),t=this.nextChar_()}while(this.isNumeric_(t,n)||!i&&("e"==t||"E"==t)||i&&("-"==t||"+"==t));return parseFloat(this.wkt.substring(e,this.index_--))}readText_(){let t;const e=this.index_;do{t=this.nextChar_()}while(this.isAlpha_(t));return this.wkt.substring(e,this.index_--).toUpperCase()}}class Te{constructor(t,e){this.lexer_=t,this.token_,this.layout_=he,this.factory=e}consume_(){this.token_=this.lexer_.nextToken()}isTokenType(t){return this.token_.type==t}match(t){const e=this.isTokenType(t);return e&&this.consume_(),e}parse(){this.consume_();return this.parseGeometry_()}parseGeometryLayout_(){let t=he;const e=this.token_;if(this.isTokenType(de)){const n=e.value;"Z"===n?t=ue:"M"===n?t=ge:"ZM"===n&&(t=fe),t!==he&&this.consume_()}return t}parseGeometryCollectionText_(){if(this.match(_e)){const t=[];do{t.push(this.parseGeometry_())}while(this.match(Ee));if(this.match(ye))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePointText_(){if(this.match(_e)){const t=this.parsePoint_();if(this.match(ye))return t}else if(this.isEmptyGeometry_())return null;throw new Error(this.formatErrorMessage_())}parseLineStringText_(){if(this.match(_e)){const t=this.parsePointList_();if(this.match(ye))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePolygonText_(){if(this.match(_e)){const t=this.parseLineStringTextList_();if(this.match(ye))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiPointText_(){if(this.match(_e)){let t;if(t=this.token_.type==_e?this.parsePointTextList_():this.parsePointList_(),this.match(ye))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiLineStringText_(){if(this.match(_e)){const t=this.parseLineStringTextList_();if(this.match(ye))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiPolygonText_(){if(this.match(_e)){const t=this.parsePolygonTextList_();if(this.match(ye))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePoint_(){const t=[],e=this.layout_.length;for(let n=0;n<e;++n){const e=this.token_;if(!this.match(me))break;t.push(e.value)}if(t.length==e)return t;throw new Error(this.formatErrorMessage_())}parsePointList_(){const t=[this.parsePoint_()];for(;this.match(Ee);)t.push(this.parsePoint_());return t}parsePointTextList_(){const t=[this.parsePointText_()];for(;this.match(Ee);)t.push(this.parsePointText_());return t}parseLineStringTextList_(){const t=[this.parseLineStringText_()];for(;this.match(Ee);)t.push(this.parseLineStringText_());return t}parsePolygonTextList_(){const t=[this.parsePolygonText_()];for(;this.match(Ee);)t.push(this.parsePolygonText_());return t}isEmptyGeometry_(){const t=this.isTokenType(de)&&"EMPTY"==this.token_.value;return t&&this.consume_(),t}formatErrorMessage_(){return"Unexpected `"+this.token_.value+"` at position "+this.token_.position+" in `"+this.lexer_.wkt+"`"}parseGeometry_(){const t=this.factory,e=t=>new et(...t),n=n=>{const i=n.map(n=>t.createLinearRing(n.map(e)));return i.length>1?t.createPolygon(i[0],i.slice(1)):t.createPolygon(i[0])},i=this.token_;if(this.match(de)){const s=i.value;if(this.layout_=this.parseGeometryLayout_(),"GEOMETRYCOLLECTION"==s){const e=this.parseGeometryCollectionText_();return t.createGeometryCollection(e)}switch(s){case"POINT":{const e=this.parsePointText_();return e?t.createPoint(new et(...e)):t.createPoint()}case"LINESTRING":{const n=this.parseLineStringText_().map(e);return t.createLineString(n)}case"LINEARRING":{const n=this.parseLineStringText_().map(e);return t.createLinearRing(n)}case"POLYGON":{const e=this.parsePolygonText_();return e&&0!==e.length?n(e):t.createPolygon()}case"MULTIPOINT":{const n=this.parseMultiPointText_();if(!n||0===n.length)return t.createMultiPoint();const i=n.map(e).map(e=>t.createPoint(e));return t.createMultiPoint(i)}case"MULTILINESTRING":{const n=this.parseMultiLineStringText_().map(n=>t.createLineString(n.map(e)));return t.createMultiLineString(n)}case"MULTIPOLYGON":{const e=this.parseMultiPolygonText_();if(!e||0===e.length)return t.createMultiPolygon();const i=e.map(n);return t.createMultiPolygon(i)}default:throw new Error("Invalid geometry type: "+s)}}throw new Error(this.formatErrorMessage_())}}function Re(t){if(t.isEmpty())return"";const e=t.getCoordinate(),n=[e.x,e.y];return void 0===e.z||Number.isNaN(e.z)||n.push(e.z),void 0===e.m||Number.isNaN(e.m)||n.push(e.m),n.join(" ")}function Oe(t){const e=t.getCoordinates().map(t=>{const e=[t.x,t.y];return void 0===t.z||Number.isNaN(t.z)||e.push(t.z),void 0===t.m||Number.isNaN(t.m)||e.push(t.m),e}),n=[];for(let t=0,i=e.length;t<i;++t)n.push(e[t].join(" "));return n.join(", ")}function be(t){const e=[];e.push("("+Oe(t.getExteriorRing())+")");for(let n=0,i=t.getNumInteriorRing();n<i;++n)e.push("("+Oe(t.getInteriorRingN(n))+")");return e.join(", ")}const we={Point:Re,LineString:Oe,LinearRing:Oe,Polygon:be,MultiPoint:function(t){const e=[];for(let n=0,i=t.getNumGeometries();n<i;++n)e.push("("+Re(t.getGeometryN(n))+")");return e.join(", ")},MultiLineString:function(t){const e=[];for(let n=0,i=t.getNumGeometries();n<i;++n)e.push("("+Oe(t.getGeometryN(n))+")");return e.join(", ")},MultiPolygon:function(t){const e=[];for(let n=0,i=t.getNumGeometries();n<i;++n)e.push("("+be(t.getGeometryN(n))+")");return e.join(", ")},GeometryCollection:function(t){const e=[];for(let n=0,i=t.getNumGeometries();n<i;++n)e.push(Le(t.getGeometryN(n)));return e.join(", ")}};function Le(t){let e=t.getGeometryType();const n=we[e];e=e.toUpperCase();const i=function(t){let e="";if(t.isEmpty())return e;const n=t.getCoordinate();return void 0===n.z||Number.isNaN(n.z)||(e+="Z"),void 0===n.m||Number.isNaN(n.m)||(e+="M"),e}(t);if(i.length>0&&(e+=" "+i),t.isEmpty())return e+" EMPTY";return e+" ("+n(t)+")"}class ve{constructor(t){this.geometryFactory=t||new se,this.precisionModel=this.geometryFactory.getPrecisionModel()}read(t){const e=new Ne(t);return new Te(e,this.geometryFactory).parse()}write(t){return Le(t)}}class Se{constructor(t){this.parser=new ve(t)}write(t){return this.parser.write(t)}static toLineString(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}class Ce{static toLocationSymbol(t){switch(t){case Ce.EXTERIOR:return"e";case Ce.BOUNDARY:return"b";case Ce.INTERIOR:return"i";case Ce.NONE:return"-"}throw new z("Unknown location value: "+t)}}Ce.INTERIOR=0,Ce.BOUNDARY=1,Ce.EXTERIOR=2,Ce.NONE=-1;class Pe{static intersection(t,e,n,i){const s=t.x<e.x?t.x:e.x,r=t.y<e.y?t.y:e.y,o=t.x>e.x?t.x:e.x,l=t.y>e.y?t.y:e.y,a=n.x<i.x?n.x:i.x,c=n.y<i.y?n.y:i.y,h=n.x>i.x?n.x:i.x,u=n.y>i.y?n.y:i.y,g=((s>a?s:a)+(o<h?o:h))/2,f=((r>c?r:c)+(l<u?l:u))/2,p=t.x-g,d=t.y-f,_=e.x-g,y=e.y-f,m=n.x-g,E=n.y-f,I=i.x-g,x=i.y-f,N=d-y,T=_-p,R=p*y-_*d,O=E-x,b=I-m,w=m*x-I*E,L=N*b-O*T,v=(T*w-b*R)/L,S=(O*R-N*w)/L;return G.isNaN(v)||G.isInfinite(v)||G.isNaN(S)||G.isInfinite(S)?null:new et(v+g,S+f)}}class Me{static segmentToSegment(t,e,n,i){if(t.equals(e))return Me.pointToSegment(t,n,i);if(n.equals(i))return Me.pointToSegment(i,t,e);let s=!1;if(it.intersects(t,e,n,i)){const r=(e.x-t.x)*(i.y-n.y)-(e.y-t.y)*(i.x-n.x);if(0===r)s=!0;else{const o=(t.y-n.y)*(i.x-n.x)-(t.x-n.x)*(i.y-n.y),l=((t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y))/r,a=o/r;(a<0||a>1||l<0||l>1)&&(s=!0)}}else s=!0;return s?kt.min(Me.pointToSegment(t,n,i),Me.pointToSegment(e,n,i),Me.pointToSegment(n,t,e),Me.pointToSegment(i,t,e)):0}static pointToSegment(t,e,n){if(e.x===n.x&&e.y===n.y)return t.distance(e);const i=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),s=((t.x-e.x)*(n.x-e.x)+(t.y-e.y)*(n.y-e.y))/i;if(s<=0)return t.distance(e);if(s>=1)return t.distance(n);const r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/i;return Math.abs(r)*Math.sqrt(i)}static pointToLinePerpendicular(t,e,n){const i=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),s=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/i;return Math.abs(s)*Math.sqrt(i)}static pointToSegmentString(t,e){if(0===e.length)throw new z("Line array must contain at least one vertex");let n=t.distance(e[0]);for(let i=0;i<e.length-1;i++){const s=Me.pointToSegment(t,e[i],e[i+1]);s<n&&(n=s)}return n}}class Ae{constructor(){Ae.constructor_.apply(this,arguments)}static constructor_(){this._result=null,this._inputLines=Array(2).fill().map(()=>Array(2)),this._intPt=new Array(2).fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new et,this._intPt[1]=new et,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0}static computeEdgeDistance(t,e,n){const i=Math.abs(n.x-e.x),s=Math.abs(n.y-e.y);let r=-1;if(t.equals(e))r=0;else if(t.equals(n))r=i>s?i:s;else{const n=Math.abs(t.x-e.x),o=Math.abs(t.y-e.y);r=i>s?n:o,0!==r||t.equals(e)||(r=Math.max(n,o))}return J.isTrue(!(0===r&&!t.equals(e)),"Bad distance calculation"),r}static nonRobustComputeEdgeDistance(t,e,n){const i=t.x-e.x,s=t.y-e.y,r=Math.sqrt(i*i+s*s);return J.isTrue(!(0===r&&!t.equals(e)),"Invalid distance calculation"),r}getIndexAlongSegment(t,e){return this.computeIntLineIndex(),this._intLineIndex[t][e]}getTopologySummary(){const t=new Zt;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()}computeIntersection(t,e,n,i){this._inputLines[0][0]=t,this._inputLines[0][1]=e,this._inputLines[1][0]=n,this._inputLines[1][1]=i,this._result=this.computeIntersect(t,e,n,i)}getIntersectionNum(){return this._result}computeIntLineIndex(){if(0===arguments.length)null===this._intLineIndex&&(this._intLineIndex=Array(2).fill().map(()=>Array(2)),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){const t=arguments[0];this.getEdgeDistance(t,0)>this.getEdgeDistance(t,1)?(this._intLineIndex[t][0]=0,this._intLineIndex[t][1]=1):(this._intLineIndex[t][0]=1,this._intLineIndex[t][1]=0)}}isProper(){return this.hasIntersection()&&this._isProper}setPrecisionModel(t){this._precisionModel=t}isInteriorIntersection(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){const t=arguments[0];for(let e=0;e<this._result;e++)if(!this._intPt[e].equals2D(this._inputLines[t][0])&&!this._intPt[e].equals2D(this._inputLines[t][1]))return!0;return!1}}getIntersection(t){return this._intPt[t]}isEndPoint(){return this.hasIntersection()&&!this._isProper}hasIntersection(){return this._result!==Ae.NO_INTERSECTION}getEdgeDistance(t,e){return Ae.computeEdgeDistance(this._intPt[e],this._inputLines[t][0],this._inputLines[t][1])}isCollinear(){return this._result===Ae.COLLINEAR_INTERSECTION}toString(){return Se.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+Se.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()}getEndpoint(t,e){return this._inputLines[t][e]}isIntersection(t){for(let e=0;e<this._result;e++)if(this._intPt[e].equals2D(t))return!0;return!1}getIntersectionAlongSegment(t,e){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[t][e]]}}Ae.DONT_INTERSECT=0,Ae.DO_INTERSECT=1,Ae.COLLINEAR=2,Ae.NO_INTERSECTION=0,Ae.POINT_INTERSECTION=1,Ae.COLLINEAR_INTERSECTION=2;class De extends Ae{constructor(){super()}static nearestEndpoint(t,e,n,i){let s=t,r=Me.pointToSegment(t,n,i),o=Me.pointToSegment(e,n,i);return o<r&&(r=o,s=e),o=Me.pointToSegment(n,t,e),o<r&&(r=o,s=n),o=Me.pointToSegment(i,t,e),o<r&&(r=o,s=i),s}isInSegmentEnvelopes(t){const e=new it(this._inputLines[0][0],this._inputLines[0][1]),n=new it(this._inputLines[1][0],this._inputLines[1][1]);return e.contains(t)&&n.contains(t)}computeIntersection(){if(3!==arguments.length)return super.computeIntersection.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isProper=!1,it.intersects(e,n,t)&&0===vt.index(e,n,t)&&0===vt.index(n,e,t))return this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this._result=Ae.POINT_INTERSECTION,null;this._result=Ae.NO_INTERSECTION}}intersection(t,e,n,i){let s=this.intersectionSafe(t,e,n,i);return this.isInSegmentEnvelopes(s)||(s=new et(De.nearestEndpoint(t,e,n,i))),null!==this._precisionModel&&this._precisionModel.makePrecise(s),s}checkDD(t,e,n,i,s){const r=Lt.intersection(t,e,n,i),o=this.isInSegmentEnvelopes(r);jt.out.println("DD in env = "+o+"  --------------------- "+r),s.distance(r)>1e-4&&jt.out.println("Distance = "+s.distance(r))}intersectionSafe(t,e,n,i){let s=Pe.intersection(t,e,n,i);return null===s&&(s=De.nearestEndpoint(t,e,n,i)),s}computeCollinearIntersection(t,e,n,i){const s=it.intersects(t,e,n),r=it.intersects(t,e,i),o=it.intersects(n,i,t),l=it.intersects(n,i,e);return s&&r?(this._intPt[0]=n,this._intPt[1]=i,Ae.COLLINEAR_INTERSECTION):o&&l?(this._intPt[0]=t,this._intPt[1]=e,Ae.COLLINEAR_INTERSECTION):s&&o?(this._intPt[0]=n,this._intPt[1]=t,!n.equals(t)||r||l?Ae.COLLINEAR_INTERSECTION:Ae.POINT_INTERSECTION):s&&l?(this._intPt[0]=n,this._intPt[1]=e,!n.equals(e)||r||o?Ae.COLLINEAR_INTERSECTION:Ae.POINT_INTERSECTION):r&&o?(this._intPt[0]=i,this._intPt[1]=t,!i.equals(t)||s||l?Ae.COLLINEAR_INTERSECTION:Ae.POINT_INTERSECTION):r&&l?(this._intPt[0]=i,this._intPt[1]=e,!i.equals(e)||s||o?Ae.COLLINEAR_INTERSECTION:Ae.POINT_INTERSECTION):Ae.NO_INTERSECTION}computeIntersect(t,e,n,i){if(this._isProper=!1,!it.intersects(t,e,n,i))return Ae.NO_INTERSECTION;const s=vt.index(t,e,n),r=vt.index(t,e,i);if(s>0&&r>0||s<0&&r<0)return Ae.NO_INTERSECTION;const o=vt.index(n,i,t),l=vt.index(n,i,e);if(o>0&&l>0||o<0&&l<0)return Ae.NO_INTERSECTION;return 0===s&&0===r&&0===o&&0===l?this.computeCollinearIntersection(t,e,n,i):(0===s||0===r||0===o||0===l?(this._isProper=!1,t.equals2D(n)||t.equals2D(i)?this._intPt[0]=t:e.equals2D(n)||e.equals2D(i)?this._intPt[0]=e:0===s?this._intPt[0]=new et(n):0===r?this._intPt[0]=new et(i):0===o?this._intPt[0]=new et(t):0===l&&(this._intPt[0]=new et(e))):(this._isProper=!0,this._intPt[0]=this.intersection(t,e,n,i)),Ae.POINT_INTERSECTION)}}class Fe{constructor(){Fe.constructor_.apply(this,arguments)}static constructor_(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1;const t=arguments[0];this._p=t}static locatePointInRing(){if(arguments[0]instanceof et&&F(arguments[1],B)){const t=arguments[1],e=new Fe(arguments[0]),n=new et,i=new et;for(let s=1;s<t.size();s++)if(t.getCoordinate(s,n),t.getCoordinate(s-1,i),e.countSegment(n,i),e.isOnSegment())return e.getLocation();return e.getLocation()}if(arguments[0]instanceof et&&arguments[1]instanceof Array){const t=arguments[1],e=new Fe(arguments[0]);for(let n=1;n<t.length;n++){const i=t[n],s=t[n-1];if(e.countSegment(i,s),e.isOnSegment())return e.getLocation()}return e.getLocation()}}countSegment(t,e){if(t.x<this._p.x&&e.x<this._p.x)return null;if(this._p.x===e.x&&this._p.y===e.y)return this._isPointOnSegment=!0,null;if(t.y===this._p.y&&e.y===this._p.y){let n=t.x,i=e.x;return n>i&&(n=e.x,i=t.x),this._p.x>=n&&this._p.x<=i&&(this._isPointOnSegment=!0),null}if(t.y>this._p.y&&e.y<=this._p.y||e.y>this._p.y&&t.y<=this._p.y){let n=vt.index(t,e,this._p);if(n===vt.COLLINEAR)return this._isPointOnSegment=!0,null;e.y<t.y&&(n=-n),n===vt.LEFT&&this._crossingCount++}}isPointInPolygon(){return this.getLocation()!==Ce.EXTERIOR}getLocation(){return this._isPointOnSegment?Ce.BOUNDARY:this._crossingCount%2==1?Ce.INTERIOR:Ce.EXTERIOR}isOnSegment(){return this._isPointOnSegment}}class Ye{static isOnLine(){if(arguments[0]instanceof et&&F(arguments[1],B)){const t=arguments[0],e=arguments[1],n=new De,i=new et,s=new et,r=e.size();for(let o=1;o<r;o++)if(e.getCoordinate(o-1,i),e.getCoordinate(o,s),n.computeIntersection(t,i,s),n.hasIntersection())return!0;return!1}if(arguments[0]instanceof et&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1],n=new De;for(let i=1;i<e.length;i++){const s=e[i-1],r=e[i];if(n.computeIntersection(t,s,r),n.hasIntersection())return!0}return!1}}static locateInRing(t,e){return Fe.locatePointInRing(t,e)}static isInRing(t,e){return Ye.locateInRing(t,e)!==Ce.EXTERIOR}}class Ge{isInBoundary(t){}}class qe{isInBoundary(t){return t%2==1}get interfaces_(){return[Ge]}}class Be{isInBoundary(t){return t>0}get interfaces_(){return[Ge]}}class Ue{isInBoundary(t){return t>1}get interfaces_(){return[Ge]}}class Xe{isInBoundary(t){return 1===t}get interfaces_(){return[Ge]}}Ge.Mod2BoundaryNodeRule=qe,Ge.EndPointBoundaryNodeRule=Be,Ge.MultiValentEndPointBoundaryNodeRule=Ue,Ge.MonoValentEndPointBoundaryNodeRule=Xe,Ge.MOD2_BOUNDARY_RULE=new qe,Ge.ENDPOINT_BOUNDARY_RULE=new Be,Ge.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new Ue,Ge.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new Xe,Ge.OGC_SFS_BOUNDARY_RULE=Ge.MOD2_BOUNDARY_RULE;class ze{hasNext(){}next(){}remove(){}}class ke{constructor(){ke.constructor_.apply(this,arguments)}static constructor_(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;const t=arguments[0];this._parent=t,this._atStart=!0,this._index=0,this._max=t.getNumGeometries()}static isAtomic(t){return!(t instanceof Ft)}next(){if(this._atStart)return this._atStart=!1,ke.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null}if(this._index>=this._max)throw new xt;const t=this._parent.getGeometryN(this._index++);return t instanceof Ft?(this._subcollectionIterator=new ke(t),this._subcollectionIterator.next()):t}remove(){throw new at(this.getClass().getName())}hasNext(){if(this._atStart)return!0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return!0;this._subcollectionIterator=null}return!(this._index>=this._max)}get interfaces_(){return[ze]}}class je{constructor(){je.constructor_.apply(this,arguments)}static constructor_(){if(this._boundaryRule=Ge.OGC_SFS_BOUNDARY_RULE,this._isIn=null,this._numBoundaries=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];if(null===t)throw new z("Rule must be non-null");this._boundaryRule=t}}locateInPolygonRing(t,e){return e.getEnvelopeInternal().intersects(t)?Ye.locateInRing(t,e.getCoordinates()):Ce.EXTERIOR}intersects(t,e){return this.locate(t,e)!==Ce.EXTERIOR}updateLocationInfo(t){t===Ce.INTERIOR&&(this._isIn=!0),t===Ce.BOUNDARY&&this._numBoundaries++}computeLocation(t,e){if(e instanceof _t&&this.updateLocationInfo(this.locateOnPoint(t,e)),e instanceof ft)this.updateLocationInfo(this.locateOnLineString(t,e));else if(e instanceof Ct)this.updateLocationInfo(this.locateInPolygon(t,e));else if(e instanceof ie){const n=e;for(let e=0;e<n.getNumGeometries();e++){const i=n.getGeometryN(e);this.updateLocationInfo(this.locateOnLineString(t,i))}}else if(e instanceof Kt){const n=e;for(let e=0;e<n.getNumGeometries();e++){const i=n.getGeometryN(e);this.updateLocationInfo(this.locateInPolygon(t,i))}}else if(e instanceof Ft){const n=new ke(e);for(;n.hasNext();){const i=n.next();i!==e&&this.computeLocation(t,i)}}}locateOnPoint(t,e){return e.getCoordinate().equals2D(t)?Ce.INTERIOR:Ce.EXTERIOR}locateOnLineString(t,e){if(!e.getEnvelopeInternal().intersects(t))return Ce.EXTERIOR;const n=e.getCoordinateSequence();return e.isClosed()||!t.equals(n.getCoordinate(0))&&!t.equals(n.getCoordinate(n.size()-1))?Ye.isOnLine(t,n)?Ce.INTERIOR:Ce.EXTERIOR:Ce.BOUNDARY}locateInPolygon(t,e){if(e.isEmpty())return Ce.EXTERIOR;const n=e.getExteriorRing(),i=this.locateInPolygonRing(t,n);if(i===Ce.EXTERIOR)return Ce.EXTERIOR;if(i===Ce.BOUNDARY)return Ce.BOUNDARY;for(let n=0;n<e.getNumInteriorRing();n++){const i=e.getInteriorRingN(n),s=this.locateInPolygonRing(t,i);if(s===Ce.INTERIOR)return Ce.EXTERIOR;if(s===Ce.BOUNDARY)return Ce.BOUNDARY}return Ce.INTERIOR}locate(t,e){return e.isEmpty()?Ce.EXTERIOR:e instanceof ft?this.locateOnLineString(t,e):e instanceof Ct?this.locateInPolygon(t,e):(this._isIn=!1,this._numBoundaries=0,this.computeLocation(t,e),this._boundaryRule.isInBoundary(this._numBoundaries)?Ce.BOUNDARY:this._numBoundaries>0||this._isIn?Ce.INTERIOR:Ce.EXTERIOR)}}class Ve{constructor(){Ve.constructor_.apply(this,arguments)}static constructor_(){if(this._matrix=null,0===arguments.length)this._matrix=Array(3).fill().map(()=>Array(3)),this.setAll(ht.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){const t=arguments[0];Ve.constructor_.call(this),this.set(t)}else if(arguments[0]instanceof Ve){const t=arguments[0];Ve.constructor_.call(this),this._matrix[Ce.INTERIOR][Ce.INTERIOR]=t._matrix[Ce.INTERIOR][Ce.INTERIOR],this._matrix[Ce.INTERIOR][Ce.BOUNDARY]=t._matrix[Ce.INTERIOR][Ce.BOUNDARY],this._matrix[Ce.INTERIOR][Ce.EXTERIOR]=t._matrix[Ce.INTERIOR][Ce.EXTERIOR],this._matrix[Ce.BOUNDARY][Ce.INTERIOR]=t._matrix[Ce.BOUNDARY][Ce.INTERIOR],this._matrix[Ce.BOUNDARY][Ce.BOUNDARY]=t._matrix[Ce.BOUNDARY][Ce.BOUNDARY],this._matrix[Ce.BOUNDARY][Ce.EXTERIOR]=t._matrix[Ce.BOUNDARY][Ce.EXTERIOR],this._matrix[Ce.EXTERIOR][Ce.INTERIOR]=t._matrix[Ce.EXTERIOR][Ce.INTERIOR],this._matrix[Ce.EXTERIOR][Ce.BOUNDARY]=t._matrix[Ce.EXTERIOR][Ce.BOUNDARY],this._matrix[Ce.EXTERIOR][Ce.EXTERIOR]=t._matrix[Ce.EXTERIOR][Ce.EXTERIOR]}}static matches(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return e===ht.SYM_DONTCARE||(e===ht.SYM_TRUE&&(t>=0||t===ht.TRUE)||(e===ht.SYM_FALSE&&t===ht.FALSE||(e===ht.SYM_P&&t===ht.P||(e===ht.SYM_L&&t===ht.L||e===ht.SYM_A&&t===ht.A))))}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){const t=arguments[1];return new Ve(arguments[0]).matches(t)}}static isTrue(t){return t>=0||t===ht.TRUE}isIntersects(){return!this.isDisjoint()}isCovers(){return(Ve.isTrue(this._matrix[Ce.INTERIOR][Ce.INTERIOR])||Ve.isTrue(this._matrix[Ce.INTERIOR][Ce.BOUNDARY])||Ve.isTrue(this._matrix[Ce.BOUNDARY][Ce.INTERIOR])||Ve.isTrue(this._matrix[Ce.BOUNDARY][Ce.BOUNDARY]))&&this._matrix[Ce.EXTERIOR][Ce.INTERIOR]===ht.FALSE&&this._matrix[Ce.EXTERIOR][Ce.BOUNDARY]===ht.FALSE}isCoveredBy(){return(Ve.isTrue(this._matrix[Ce.INTERIOR][Ce.INTERIOR])||Ve.isTrue(this._matrix[Ce.INTERIOR][Ce.BOUNDARY])||Ve.isTrue(this._matrix[Ce.BOUNDARY][Ce.INTERIOR])||Ve.isTrue(this._matrix[Ce.BOUNDARY][Ce.BOUNDARY]))&&this._matrix[Ce.INTERIOR][Ce.EXTERIOR]===ht.FALSE&&this._matrix[Ce.BOUNDARY][Ce.EXTERIOR]===ht.FALSE}set(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),i=e%3;this._matrix[n][i]=ht.toDimensionValue(t.charAt(e))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]=n}}isContains(){return Ve.isTrue(this._matrix[Ce.INTERIOR][Ce.INTERIOR])&&this._matrix[Ce.EXTERIOR][Ce.INTERIOR]===ht.FALSE&&this._matrix[Ce.EXTERIOR][Ce.BOUNDARY]===ht.FALSE}setAtLeast(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),i=e%3;this.setAtLeast(n,i,ht.toDimensionValue(t.charAt(e)))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]<n&&(this._matrix[t][e]=n)}}setAtLeastIfValid(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)}isWithin(){return Ve.isTrue(this._matrix[Ce.INTERIOR][Ce.INTERIOR])&&this._matrix[Ce.INTERIOR][Ce.EXTERIOR]===ht.FALSE&&this._matrix[Ce.BOUNDARY][Ce.EXTERIOR]===ht.FALSE}isTouches(t,e){return t>e?this.isTouches(e,t):(t===ht.A&&e===ht.A||t===ht.L&&e===ht.L||t===ht.L&&e===ht.A||t===ht.P&&e===ht.A||t===ht.P&&e===ht.L)&&(this._matrix[Ce.INTERIOR][Ce.INTERIOR]===ht.FALSE&&(Ve.isTrue(this._matrix[Ce.INTERIOR][Ce.BOUNDARY])||Ve.isTrue(this._matrix[Ce.BOUNDARY][Ce.INTERIOR])||Ve.isTrue(this._matrix[Ce.BOUNDARY][Ce.BOUNDARY])))}isOverlaps(t,e){return t===ht.P&&e===ht.P||t===ht.A&&e===ht.A?Ve.isTrue(this._matrix[Ce.INTERIOR][Ce.INTERIOR])&&Ve.isTrue(this._matrix[Ce.INTERIOR][Ce.EXTERIOR])&&Ve.isTrue(this._matrix[Ce.EXTERIOR][Ce.INTERIOR]):t===ht.L&&e===ht.L&&(1===this._matrix[Ce.INTERIOR][Ce.INTERIOR]&&Ve.isTrue(this._matrix[Ce.INTERIOR][Ce.EXTERIOR])&&Ve.isTrue(this._matrix[Ce.EXTERIOR][Ce.INTERIOR]))}isEquals(t,e){return t===e&&(Ve.isTrue(this._matrix[Ce.INTERIOR][Ce.INTERIOR])&&this._matrix[Ce.INTERIOR][Ce.EXTERIOR]===ht.FALSE&&this._matrix[Ce.BOUNDARY][Ce.EXTERIOR]===ht.FALSE&&this._matrix[Ce.EXTERIOR][Ce.INTERIOR]===ht.FALSE&&this._matrix[Ce.EXTERIOR][Ce.BOUNDARY]===ht.FALSE)}toString(){const t=new Zt("123456789");for(let e=0;e<3;e++)for(let n=0;n<3;n++)t.setCharAt(3*e+n,ht.toDimensionSymbol(this._matrix[e][n]));return t.toString()}setAll(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this._matrix[e][n]=t}get(t,e){return this._matrix[t][e]}transpose(){let t=this._matrix[1][0];return this._matrix[1][0]=this._matrix[0][1],this._matrix[0][1]=t,t=this._matrix[2][0],this._matrix[2][0]=this._matrix[0][2],this._matrix[0][2]=t,t=this._matrix[2][1],this._matrix[2][1]=this._matrix[1][2],this._matrix[1][2]=t,this}matches(t){if(9!==t.length)throw new z("Should be length 9: "+t);for(let e=0;e<3;e++)for(let n=0;n<3;n++)if(!Ve.matches(this._matrix[e][n],t.charAt(3*e+n)))return!1;return!0}add(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this.setAtLeast(e,n,t.get(e,n))}isDisjoint(){return this._matrix[Ce.INTERIOR][Ce.INTERIOR]===ht.FALSE&&this._matrix[Ce.INTERIOR][Ce.BOUNDARY]===ht.FALSE&&this._matrix[Ce.BOUNDARY][Ce.INTERIOR]===ht.FALSE&&this._matrix[Ce.BOUNDARY][Ce.BOUNDARY]===ht.FALSE}isCrosses(t,e){return t===ht.P&&e===ht.L||t===ht.P&&e===ht.A||t===ht.L&&e===ht.A?Ve.isTrue(this._matrix[Ce.INTERIOR][Ce.INTERIOR])&&Ve.isTrue(this._matrix[Ce.INTERIOR][Ce.EXTERIOR]):t===ht.L&&e===ht.P||t===ht.A&&e===ht.P||t===ht.A&&e===ht.L?Ve.isTrue(this._matrix[Ce.INTERIOR][Ce.INTERIOR])&&Ve.isTrue(this._matrix[Ce.EXTERIOR][Ce.INTERIOR]):t===ht.L&&e===ht.L&&0===this._matrix[Ce.INTERIOR][Ce.INTERIOR]}get interfaces_(){return[q]}}class Ze{static isNorthern(t){return t===Ze.NE||t===Ze.NW}static isOpposite(t,e){if(t===e)return!1;return 2===(t-e+4)%4}static commonHalfPlane(t,e){if(t===e)return t;if(2===(t-e+4)%4)return-1;const n=t<e?t:e;return 0===n&&3===(t>e?t:e)?3:n}static isInHalfPlane(t,e){return e===Ze.SE?t===Ze.SE||t===Ze.SW:t===e||t===e+1}static quadrant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new z("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?Ze.NE:Ze.SE:e>=0?Ze.NW:Ze.SW}if(arguments[0]instanceof et&&arguments[1]instanceof et){const t=arguments[0],e=arguments[1];if(e.x===t.x&&e.y===t.y)throw new z("Cannot compute the quadrant for two identical points "+t);return e.x>=t.x?e.y>=t.y?Ze.NE:Ze.SE:e.y>=t.y?Ze.NW:Ze.SW}}}Ze.NE=0,Ze.NW=1,Ze.SW=2,Ze.SE=3;class We{constructor(){We.constructor_.apply(this,arguments)}static constructor_(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1===arguments.length){const t=arguments[0];this._edge=t}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];We.constructor_.call(this,t,e,n,null)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];We.constructor_.call(this,t),this.init(e,n),this._label=i}}compareDirection(t){return this._dx===t._dx&&this._dy===t._dy?0:this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:vt.index(t._p0,t._p1,this._p1)}getDy(){return this._dy}getCoordinate(){return this._p0}setNode(t){this._node=t}print(t){const e=Math.atan2(this._dy,this._dx),n=this.getClass().getName(),i=n.lastIndexOf("."),s=n.substring(i+1);t.print("  "+s+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+e+"   "+this._label)}compareTo(t){const e=t;return this.compareDirection(e)}getDirectedCoordinate(){return this._p1}getDx(){return this._dx}getLabel(){return this._label}getEdge(){return this._edge}getQuadrant(){return this._quadrant}getNode(){return this._node}toString(){const t=Math.atan2(this._dy,this._dx),e=this.getClass().getName(),n=e.lastIndexOf(".");return"  "+e.substring(n+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+t+"   "+this._label}computeLabel(t){}init(t,e){this._p0=t,this._p1=e,this._dx=e.x-t.x,this._dy=e.y-t.y,this._quadrant=Ze.quadrant(this._dx,this._dy),J.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found")}get interfaces_(){return[j]}}class He{static opposite(t){return t===He.LEFT?He.RIGHT:t===He.RIGHT?He.LEFT:t}}He.ON=0,He.LEFT=1,He.RIGHT=2;class Ke{constructor(){Ke.constructor_.apply(this,arguments)}static constructor_(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){const t=arguments[0];this.init(1),this.location[He.ON]=t}else if(arguments[0]instanceof Ke){const t=arguments[0];if(this.init(t.location.length),null!==t)for(let e=0;e<this.location.length;e++)this.location[e]=t.location[e]}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.init(3),this.location[He.ON]=t,this.location[He.LEFT]=e,this.location[He.RIGHT]=n}}setAllLocations(t){for(let e=0;e<this.location.length;e++)this.location[e]=t}isNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]!==Ce.NONE)return!1;return!0}setAllLocationsIfNull(t){for(let e=0;e<this.location.length;e++)this.location[e]===Ce.NONE&&(this.location[e]=t)}isLine(){return 1===this.location.length}merge(t){if(t.location.length>this.location.length){const t=new Array(3).fill(null);t[He.ON]=this.location[He.ON],t[He.LEFT]=Ce.NONE,t[He.RIGHT]=Ce.NONE,this.location=t}for(let e=0;e<this.location.length;e++)this.location[e]===Ce.NONE&&e<t.location.length&&(this.location[e]=t.location[e])}getLocations(){return this.location}flip(){if(this.location.length<=1)return null;const t=this.location[He.LEFT];this.location[He.LEFT]=this.location[He.RIGHT],this.location[He.RIGHT]=t}toString(){const t=new Ot;return this.location.length>1&&t.append(Ce.toLocationSymbol(this.location[He.LEFT])),t.append(Ce.toLocationSymbol(this.location[He.ON])),this.location.length>1&&t.append(Ce.toLocationSymbol(this.location[He.RIGHT])),t.toString()}setLocations(t,e,n){this.location[He.ON]=t,this.location[He.LEFT]=e,this.location[He.RIGHT]=n}get(t){return t<this.location.length?this.location[t]:Ce.NONE}isArea(){return this.location.length>1}isAnyNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]===Ce.NONE)return!0;return!1}setLocation(){if(1===arguments.length){const t=arguments[0];this.setLocation(He.ON,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.location[t]=e}}init(t){this.location=new Array(t).fill(null),this.setAllLocations(Ce.NONE)}isEqualOnSide(t,e){return this.location[e]===t.location[e]}allPositionsEqual(t){for(let e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0}}class Je{constructor(){Je.constructor_.apply(this,arguments)}static constructor_(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){const t=arguments[0];this.elt[0]=new Ke(t),this.elt[1]=new Ke(t)}else if(arguments[0]instanceof Je){const t=arguments[0];this.elt[0]=new Ke(t.elt[0]),this.elt[1]=new Ke(t.elt[1])}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[0]=new Ke(Ce.NONE),this.elt[1]=new Ke(Ce.NONE),this.elt[t].setLocation(e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[0]=new Ke(t,e,n),this.elt[1]=new Ke(t,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.elt[0]=new Ke(Ce.NONE,Ce.NONE,Ce.NONE),this.elt[1]=new Ke(Ce.NONE,Ce.NONE,Ce.NONE),this.elt[t].setLocations(e,n,i)}}static toLineLabel(t){const e=new Je(Ce.NONE);for(let n=0;n<2;n++)e.setLocation(n,t.getLocation(n));return e}getGeometryCount(){let t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t}setAllLocations(t,e){this.elt[t].setAllLocations(e)}isNull(t){return this.elt[t].isNull()}setAllLocationsIfNull(){if(1===arguments.length){const t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setAllLocationsIfNull(e)}}isLine(t){return this.elt[t].isLine()}merge(t){for(let e=0;e<2;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new Ke(t.elt[e]):this.elt[e].merge(t.elt[e])}flip(){this.elt[0].flip(),this.elt[1].flip()}getLocation(){if(1===arguments.length){const t=arguments[0];return this.elt[t].get(He.ON)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.elt[t].get(e)}}toString(){const t=new Ot;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()}isArea(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){const t=arguments[0];return this.elt[t].isArea()}}isAnyNull(t){return this.elt[t].isAnyNull()}setLocation(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setLocation(He.ON,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[t].setLocation(e,n)}}isEqualOnSide(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)}allPositionsEqual(t,e){return this.elt[t].allPositionsEqual(e)}toLine(t){this.elt[t].isArea()&&(this.elt[t]=new Ke(this.elt[t].location[0]))}}class Qe{createEdgeEndForNext(t,e,n,i){const s=n.segmentIndex+1;if(s>=t.getNumPoints()&&null===i)return null;let r=t.getCoordinate(s);null!==i&&i.segmentIndex===n.segmentIndex&&(r=i.coord);const o=new We(t,n.coord,r,new Je(t.getLabel()));e.add(o)}createEdgeEndForPrev(t,e,n,i){let s=n.segmentIndex;if(0===n.dist){if(0===s)return null;s--}let r=t.getCoordinate(s);null!==i&&i.segmentIndex>=s&&(r=i.coord);const o=new Je(t.getLabel());o.flip();const l=new We(t,n.coord,r,o);e.add(l)}computeEdgeEnds(){if(1===arguments.length){const t=arguments[0],e=new Nt;for(let n=t;n.hasNext();){const t=n.next();this.computeEdgeEnds(t,e)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getEdgeIntersectionList();n.addEndpoints();const i=n.iterator();let s=null,r=null;if(!i.hasNext())return null;let o=i.next();do{s=r,r=o,o=null,i.hasNext()&&(o=i.next()),null!==r&&(this.createEdgeEndForPrev(t,e,r,s),this.createEdgeEndForNext(t,e,r,o))}while(null!==r)}}}class $e{constructor(){$e.constructor_.apply(this,arguments)}static constructor_(){if(this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._label=t}}setVisited(t){this._isVisited=t}setInResult(t){this._isInResult=t}isCovered(){return this._isCovered}isCoveredSet(){return this._isCoveredSet}setLabel(t){this._label=t}getLabel(){return this._label}setCovered(t){this._isCovered=t,this._isCoveredSet=!0}updateIM(t){J.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)}isInResult(){return this._isInResult}isVisited(){return this._isVisited}}class tn extends $e{constructor(){super(),tn.constructor_.apply(this,arguments)}static constructor_(){this._coord=null,this._edges=null;const t=arguments[0],e=arguments[1];this._coord=t,this._edges=e,this._label=new Je(0,Ce.NONE)}isIncidentEdgeInResult(){for(let t=this.getEdges().getEdges().iterator();t.hasNext();){if(t.next().getEdge().isInResult())return!0}return!1}isIsolated(){return 1===this._label.getGeometryCount()}getCoordinate(){return this._coord}print(t){t.println("node "+this._coord+" lbl: "+this._label)}computeIM(t){}computeMergedLocation(t,e){let n=Ce.NONE;if(n=this._label.getLocation(e),!t.isNull(e)){const i=t.getLocation(e);n!==Ce.BOUNDARY&&(n=i)}return n}setLabel(){if(2!==arguments.length||!Number.isInteger(arguments[1])||!Number.isInteger(arguments[0]))return super.setLabel.apply(this,arguments);{const t=arguments[0],e=arguments[1];null===this._label?this._label=new Je(t,e):this._label.setLocation(t,e)}}getEdges(){return this._edges}mergeLabel(){if(arguments[0]instanceof tn){const t=arguments[0];this.mergeLabel(t._label)}else if(arguments[0]instanceof Je){const t=arguments[0];for(let e=0;e<2;e++){const n=this.computeMergedLocation(t,e);this._label.getLocation(e)===Ce.NONE&&this._label.setLocation(e,n)}}}add(t){this._edges.insert(t),t.setNode(this)}setLabelBoundary(t){if(null===this._label)return null;let e=Ce.NONE;null!==this._label&&(e=this._label.getLocation(t));let n=null;switch(e){case Ce.BOUNDARY:n=Ce.INTERIOR;break;case Ce.INTERIOR:default:n=Ce.BOUNDARY}this._label.setLocation(t,n)}}class en extends Jt{}function nn(t){return null==t?0:t.color}function sn(t){return null==t?null:t.parent}function rn(t,e){null!==t&&(t.color=e)}function on(t){return null==t?null:t.left}function ln(t){return null==t?null:t.right}class an extends en{constructor(){super(),this.root_=null,this.size_=0}get(t){let e=this.root_;for(;null!==e;){const n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null}put(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:0,getValue(){return this.value},getKey(){return this.key}},this.size_=1,null;let n,i,s=this.root_;do{if(n=s,i=t.compareTo(s.key),i<0)s=s.left;else{if(!(i>0)){const t=s.value;return s.value=e,t}s=s.right}}while(null!==s);const r={key:t,left:null,right:null,value:e,parent:n,color:0,getValue(){return this.value},getKey(){return this.key}};return i<0?n.left=r:n.right=r,this.fixAfterInsertion(r),this.size_++,null}fixAfterInsertion(t){let e;for(t.color=1;null!=t&&t!==this.root_&&1===t.parent.color;)sn(t)===on(sn(sn(t)))?(e=ln(sn(sn(t))),1===nn(e)?(rn(sn(t),0),rn(e,0),rn(sn(sn(t)),1),t=sn(sn(t))):(t===ln(sn(t))&&(t=sn(t),this.rotateLeft(t)),rn(sn(t),0),rn(sn(sn(t)),1),this.rotateRight(sn(sn(t))))):(e=on(sn(sn(t))),1===nn(e)?(rn(sn(t),0),rn(e,0),rn(sn(sn(t)),1),t=sn(sn(t))):(t===on(sn(t))&&(t=sn(t),this.rotateRight(t)),rn(sn(t),0),rn(sn(sn(t)),1),this.rotateLeft(sn(sn(t)))));this.root_.color=0}values(){const t=new Nt;let e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=an.successor(e));)t.add(e.value);return t}entrySet(){const t=new Qt;let e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=an.successor(e));)t.add(e);return t}rotateLeft(t){if(null!=t){const e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left===t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}}rotateRight(t){if(null!=t){const e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right===t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}}getFirstEntry(){let t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t}static successor(t){let e;if(null===t)return null;if(null!==t.right){for(e=t.right;null!==e.left;)e=e.left;return e}{e=t.parent;let n=t;for(;null!==e&&n===e.right;)n=e,e=e.parent;return e}}size(){return this.size_}containsKey(t){let e=this.root_;for(;null!==e;){const n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return!0;e=e.right}}return!1}}class cn{constructor(){cn.constructor_.apply(this,arguments)}static constructor_(){this.nodeMap=new an,this.nodeFact=null;const t=arguments[0];this.nodeFact=t}find(t){return this.nodeMap.get(t)}addNode(){if(arguments[0]instanceof et){const t=arguments[0];let e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof tn){const t=arguments[0],e=this.nodeMap.get(t.getCoordinate());return null===e?(this.nodeMap.put(t.getCoordinate(),t),t):(e.mergeLabel(t),e)}}print(t){for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this.nodeMap.values().iterator()}values(){return this.nodeMap.values()}getBoundaryNodes(t){const e=new Nt;for(let n=this.iterator();n.hasNext();){const i=n.next();i.getLabel().getLocation(t)===Ce.BOUNDARY&&e.add(i)}return e}add(t){const e=t.getCoordinate();this.addNode(e).add(t)}}class hn extends H{constructor(t,e){super(e?t+" [ "+e+" ]":t),this.pt=e?new et(e):void 0,this.name=Object.keys({TopologyException:hn})[0]}getCoordinate(){return this.pt}}class un{locate(t){}}class gn{constructor(){gn.constructor_.apply(this,arguments)}static constructor_(){this._geom=null;const t=arguments[0];this._geom=t}static locatePointInPolygon(t,e){if(e.isEmpty())return Ce.EXTERIOR;const n=e.getExteriorRing(),i=gn.locatePointInRing(t,n);if(i!==Ce.INTERIOR)return i;for(let n=0;n<e.getNumInteriorRing();n++){const i=e.getInteriorRingN(n),s=gn.locatePointInRing(t,i);if(s===Ce.BOUNDARY)return Ce.BOUNDARY;if(s===Ce.INTERIOR)return Ce.EXTERIOR}return Ce.INTERIOR}static locatePointInRing(t,e){return e.getEnvelopeInternal().intersects(t)?Ye.locateInRing(t,e.getCoordinates()):Ce.EXTERIOR}static containsPointInPolygon(t,e){return Ce.EXTERIOR!==gn.locatePointInPolygon(t,e)}static locateInGeometry(t,e){if(e instanceof Ct)return gn.locatePointInPolygon(t,e);if(e instanceof Ft){const n=new ke(e);for(;n.hasNext();){const i=n.next();if(i!==e){const e=gn.locateInGeometry(t,i);if(e!==Ce.EXTERIOR)return e}}}return Ce.EXTERIOR}static isContained(t,e){return Ce.EXTERIOR!==gn.locate(t,e)}static locate(t,e){return e.isEmpty()?Ce.EXTERIOR:e.getEnvelopeInternal().intersects(t)?gn.locateInGeometry(t,e):Ce.EXTERIOR}locate(t){return gn.locate(t,this._geom)}get interfaces_(){return[un]}}class fn{constructor(){fn.constructor_.apply(this,arguments)}static constructor_(){this._edgeMap=new an,this._edgeList=null,this._ptInAreaLocation=[Ce.NONE,Ce.NONE]}getNextCW(t){this.getEdges();const e=this._edgeList.indexOf(t);let n=e-1;return 0===e&&(n=this._edgeList.size()-1),this._edgeList.get(n)}propagateSideLabels(t){let e=Ce.NONE;for(let n=this.iterator();n.hasNext();){const i=n.next().getLabel();i.isArea(t)&&i.getLocation(t,He.LEFT)!==Ce.NONE&&(e=i.getLocation(t,He.LEFT))}if(e===Ce.NONE)return null;let n=e;for(let e=this.iterator();e.hasNext();){const i=e.next(),s=i.getLabel();if(s.getLocation(t,He.ON)===Ce.NONE&&s.setLocation(t,He.ON,n),s.isArea(t)){const e=s.getLocation(t,He.LEFT),r=s.getLocation(t,He.RIGHT);if(r!==Ce.NONE){if(r!==n)throw new hn("side location conflict",i.getCoordinate());e===Ce.NONE&&J.shouldNeverReachHere("found single null side (at "+i.getCoordinate()+")"),n=e}else J.isTrue(s.getLocation(t,He.LEFT)===Ce.NONE,"found single null side"),s.setLocation(t,He.RIGHT,n),s.setLocation(t,He.LEFT,n)}}}getCoordinate(){const t=this.iterator();if(!t.hasNext())return null;return t.next().getCoordinate()}print(t){jt.out.println("EdgeEndStar:   "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){e.next().print(t)}}isAreaLabelsConsistent(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)}checkAreaLabelsConsistent(t){const e=this.getEdges();if(e.size()<=0)return!0;const n=e.size()-1,i=e.get(n).getLabel().getLocation(t,He.LEFT);J.isTrue(i!==Ce.NONE,"Found unlabelled area edge");let s=i;for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();J.isTrue(n.isArea(t),"Found non-area edge");const i=n.getLocation(t,He.LEFT),r=n.getLocation(t,He.RIGHT);if(i===r)return!1;if(r!==s)return!1;s=i}return!0}findIndex(t){this.iterator();for(let e=0;e<this._edgeList.size();e++){if(this._edgeList.get(e)===t)return e}return-1}iterator(){return this.getEdges().iterator()}getEdges(){return null===this._edgeList&&(this._edgeList=new Nt(this._edgeMap.values())),this._edgeList}getLocation(t,e,n){return this._ptInAreaLocation[t]===Ce.NONE&&(this._ptInAreaLocation[t]=gn.locate(e,n[t].getGeometry())),this._ptInAreaLocation[t]}toString(){const t=new Ot;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(let e=this.iterator();e.hasNext();){const n=e.next();t.append(n),t.append("\n")}return t.toString()}computeEdgeEndLabels(t){for(let e=this.iterator();e.hasNext();){e.next().computeLabel(t)}}computeLabelling(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);const e=[!1,!1];for(let t=this.iterator();t.hasNext();){const n=t.next().getLabel();for(let t=0;t<2;t++)n.isLine(t)&&n.getLocation(t)===Ce.BOUNDARY&&(e[t]=!0)}for(let n=this.iterator();n.hasNext();){const i=n.next(),s=i.getLabel();for(let n=0;n<2;n++)if(s.isAnyNull(n)){let r=Ce.NONE;if(e[n])r=Ce.EXTERIOR;else{const e=i.getCoordinate();r=this.getLocation(n,e,t)}s.setAllLocationsIfNull(n,r)}}}getDegree(){return this._edgeMap.size()}insertEdgeEnd(t,e){this._edgeMap.put(t,e),this._edgeList=null}}class pn{constructor(){pn.constructor_.apply(this,arguments)}static constructor_(){this.mce=null,this.chainIndex=null;const t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e}computeIntersections(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)}}class dn{constructor(){dn.constructor_.apply(this,arguments)}static constructor_(){if(this._label=null,this._xValue=null,this._eventType=null,this._insertEvent=null,this._deleteEventIndex=null,this._obj=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._eventType=dn.DELETE,this._xValue=t,this._insertEvent=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._eventType=dn.INSERT,this._label=t,this._xValue=e,this._obj=n}}isDelete(){return this._eventType===dn.DELETE}setDeleteEventIndex(t){this._deleteEventIndex=t}getObject(){return this._obj}compareTo(t){const e=t;return this._xValue<e._xValue?-1:this._xValue>e._xValue?1:this._eventType<e._eventType?-1:this._eventType>e._eventType?1:0}getInsertEvent(){return this._insertEvent}isInsert(){return this._eventType===dn.INSERT}isSameLabel(t){return null!==this._label&&this._label===t._label}getDeleteEventIndex(){return this._deleteEventIndex}get interfaces_(){return[j]}}dn.INSERT=1,dn.DELETE=2;const _n={reverseOrder:function(){return{compare:(t,e)=>e.compareTo(t)}},min:function(t){return _n.sort(t),t.get(0)},sort:function(t,e){const n=t.toArray();e?Rt.sort(n,e):Rt.sort(n);const i=t.iterator();for(let t=0,e=n.length;t<e;t++)i.next(),i.set(n[t])},singletonList:function(t){const e=new Nt;return e.add(t),e}};var yn=_n;class mn{constructor(){mn.constructor_.apply(this,arguments)}static constructor_(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._properIntersectionPoint=null,this._li=null,this._includeProper=null,this._recordIsolated=null,this._isSelfIntersection=null,this._numIntersections=0,this.numTests=0,this._bdyNodes=null,this._isDone=!1,this._isDoneWhenProperInt=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._li=t,this._includeProper=e,this._recordIsolated=n}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,i){if(t===n&&1===this._li.getIntersectionNum()){if(mn.isAdjacentSegments(e,i))return!0;if(t.isClosed()){const n=t.getNumPoints()-1;if(0===e&&i===n||0===i&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}setIsDoneIfProperInt(t){this._isDoneWhenProperInt=t}hasProperInteriorIntersection(){return this._hasProperInterior}isBoundaryPointInternal(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next().getCoordinate();if(t.isIntersection(e))return!0}return!1}hasProperIntersection(){return this._hasProper}hasIntersection(){return this._hasIntersection}isDone(){return this._isDone}isBoundaryPoint(t,e){return null!==e&&(!!this.isBoundaryPointInternal(t,e[0])||!!this.isBoundaryPointInternal(t,e[1]))}setBoundaryNodes(t,e){this._bdyNodes=new Array(2).fill(null),this._bdyNodes[0]=t,this._bdyNodes[1]=e}addIntersections(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;const s=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[i],l=n.getCoordinates()[i+1];this._li.computeIntersection(s,r,o,l),this._li.hasIntersection()&&(this._recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this._numIntersections++,this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,!this._includeProper&&this._li.isProper()||(t.addIntersections(this._li,e,0),n.addIntersections(this._li,i,1)),this._li.isProper()&&(this._properIntersectionPoint=this._li.getIntersection(0).copy(),this._hasProper=!0,this._isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this._li,this._bdyNodes)||(this._hasProperInterior=!0))))}}class En extends class{}{constructor(){super(),En.constructor_.apply(this,arguments)}static constructor_(){this.events=new Nt,this.nOverlaps=null}prepareEvents(){yn.sort(this.events);for(let t=0;t<this.events.size();t++){const e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}}computeIntersections(){if(1===arguments.length){const t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(let e=0;e<this.events.size();e++){const n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof mn&&F(arguments[0],It)&&F(arguments[1],It)){const t=arguments[0],e=arguments[1],n=arguments[2];this.addEdges(t,t),this.addEdges(e,e),this.computeIntersections(n)}else if("boolean"==typeof arguments[2]&&F(arguments[0],It)&&arguments[1]instanceof mn){const t=arguments[0],e=arguments[1];arguments[2]?this.addEdges(t,null):this.addEdges(t),this.computeIntersections(e)}}addEdge(t,e){const n=t.getMonotoneChainEdge(),i=n.getStartIndexes();for(let t=0;t<i.length-1;t++){const i=new pn(n,t),s=new dn(e,n.getMinX(t),i);this.events.add(s),this.events.add(new dn(n.getMaxX(t),s))}}processOverlaps(t,e,n,i){const s=n.getObject();for(let r=t;r<e;r++){const t=this.events.get(r);if(t.isInsert()){const e=t.getObject();n.isSameLabel(t)||(s.computeIntersections(e,i),this.nOverlaps++)}}}addEdges(){if(1===arguments.length){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.addEdge(e,e)}}else if(2===arguments.length){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){const n=e.next();this.addEdge(n,t)}}}}class In{visitItem(t){}}class xn{constructor(){xn.constructor_.apply(this,arguments)}static constructor_(){this._min=G.POSITIVE_INFINITY,this._max=G.NEGATIVE_INFINITY}getMin(){return this._min}intersects(t,e){return!(this._min>e||this._max<t)}getMax(){return this._max}toString(){return Se.toLineString(new et(this._min,0),new et(this._max,0))}}xn.NodeComparator=class{compare(t,e){const n=t,i=e,s=(n._min+n._max)/2,r=(i._min+i._max)/2;return s<r?-1:s>r?1:0}get interfaces_(){return[W]}};class Nn extends xn{constructor(){super(),Nn.constructor_.apply(this,arguments)}static constructor_(){this._item=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._min=t,this._max=e,this._item=n}query(t,e,n){if(!this.intersects(t,e))return null;n.visitItem(this._item)}}class Tn extends xn{constructor(){super(),Tn.constructor_.apply(this,arguments)}static constructor_(){this._node1=null,this._node2=null;const t=arguments[0],e=arguments[1];this._node1=t,this._node2=e,this.buildExtent(this._node1,this._node2)}buildExtent(t,e){this._min=Math.min(t._min,e._min),this._max=Math.max(t._max,e._max)}query(t,e,n){if(!this.intersects(t,e))return null;null!==this._node1&&this._node1.query(t,e,n),null!==this._node2&&this._node2.query(t,e,n)}}class Rn{constructor(){Rn.constructor_.apply(this,arguments)}static constructor_(){this._leaves=new Nt,this._root=null,this._level=0}buildTree(){yn.sort(this._leaves,new xn.NodeComparator);let t=this._leaves,e=null,n=new Nt;for(;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}}insert(t,e,n){if(null!==this._root)throw new dt("Index cannot be added to once it has been queried");this._leaves.add(new Nn(t,e,n))}query(t,e,n){if(this.init(),null===this._root)return null;this._root.query(t,e,n)}buildRoot(){if(null!==this._root)return null;this._root=this.buildTree()}printNode(t){jt.out.println(Se.toLineString(new et(t._min,this._level),new et(t._max,this._level)))}init(){return null!==this._root||0===this._leaves.size()?null:void this.buildRoot()}buildLevel(t,e){this._level++,e.clear();for(let n=0;n<t.size();n+=2){const i=t.get(n);if(null===(n+1<t.size()?t.get(n):null))e.add(i);else{const i=new Tn(t.get(n),t.get(n+1));e.add(i)}}}}class On{constructor(){On.constructor_.apply(this,arguments)}static constructor_(){if(this.p0=null,this.p1=null,0===arguments.length)On.constructor_.call(this,new et,new et);else if(1===arguments.length){const t=arguments[0];On.constructor_.call(this,t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0=t,this.p1=e}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];On.constructor_.call(this,new et(t,e),new et(n,i))}}static midPoint(t,e){return new et((t.x+e.x)/2,(t.y+e.y)/2)}minX(){return Math.min(this.p0.x,this.p1.x)}orientationIndex(){if(arguments[0]instanceof On){const t=arguments[0],e=vt.index(this.p0,this.p1,t.p0),n=vt.index(this.p0,this.p1,t.p1);return e>=0&&n>=0||e<=0&&n<=0?Math.max(e,n):0}if(arguments[0]instanceof et){const t=arguments[0];return vt.index(this.p0,this.p1,t)}}toGeometry(t){return t.createLineString([this.p0,this.p1])}isVertical(){return this.p0.x===this.p1.x}equals(t){if(!(t instanceof On))return!1;const e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)}intersection(t){const e=new De;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null}project(){if(arguments[0]instanceof et){const t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new et(t);const e=this.projectionFactor(t),n=new et;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof On){const t=arguments[0],e=this.projectionFactor(t.p0),n=this.projectionFactor(t.p1);if(e>=1&&n>=1)return null;if(e<=0&&n<=0)return null;let i=this.project(t.p0);e<0&&(i=this.p0),e>1&&(i=this.p1);let s=this.project(t.p1);return n<0&&(s=this.p0),n>1&&(s=this.p1),new On(i,s)}}normalize(){this.p1.compareTo(this.p0)<0&&this.reverse()}angle(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)}getCoordinate(t){return 0===t?this.p0:this.p1}distancePerpendicular(t){return Me.pointToLinePerpendicular(t,this.p0,this.p1)}minY(){return Math.min(this.p0.y,this.p1.y)}midPoint(){return On.midPoint(this.p0,this.p1)}projectionFactor(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;const e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,i=e*e+n*n;if(i<=0)return G.NaN;return((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/i}closestPoints(t){const e=this.intersection(t);if(null!==e)return[e,e];const n=new Array(2).fill(null);let i=G.MAX_VALUE,s=null;const r=this.closestPoint(t.p0);i=r.distance(t.p0),n[0]=r,n[1]=t.p0;const o=this.closestPoint(t.p1);s=o.distance(t.p1),s<i&&(i=s,n[0]=o,n[1]=t.p1);const l=t.closestPoint(this.p0);s=l.distance(this.p0),s<i&&(i=s,n[0]=this.p0,n[1]=l);const a=t.closestPoint(this.p1);return s=a.distance(this.p1),s<i&&(i=s,n[0]=this.p1,n[1]=a),n}closestPoint(t){const e=this.projectionFactor(t);if(e>0&&e<1)return this.project(t);return this.p0.distance(t)<this.p1.distance(t)?this.p0:this.p1}maxX(){return Math.max(this.p0.x,this.p1.x)}getLength(){return this.p0.distance(this.p1)}compareTo(t){const e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)}reverse(){const t=this.p0;this.p0=this.p1,this.p1=t}equalsTopo(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)}lineIntersection(t){return Pe.intersection(this.p0,this.p1,t.p0,t.p1)}maxY(){return Math.max(this.p0.y,this.p1.y)}pointAlongOffset(t,e){const n=this.p0.x+t*(this.p1.x-this.p0.x),i=this.p0.y+t*(this.p1.y-this.p0.y),s=this.p1.x-this.p0.x,r=this.p1.y-this.p0.y,o=Math.sqrt(s*s+r*r);let l=0,a=0;if(0!==e){if(o<=0)throw new dt("Cannot compute offset from zero-length line segment");l=e*s/o,a=e*r/o}return new et(n-a,i+l)}setCoordinates(){if(1===arguments.length){const t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0.x=t.x,this.p0.y=t.y,this.p1.x=e.x,this.p1.y=e.y}}segmentFraction(t){let e=this.projectionFactor(t);return e<0?e=0:(e>1||G.isNaN(e))&&(e=1),e}toString(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"}isHorizontal(){return this.p0.y===this.p1.y}reflect(t){const e=this.p1.getY()-this.p0.getY(),n=this.p0.getX()-this.p1.getX(),i=this.p0.getY()*(this.p1.getX()-this.p0.getX())-this.p0.getX()*(this.p1.getY()-this.p0.getY()),s=e*e+n*n,r=e*e-n*n,o=t.getX(),l=t.getY();return new et((-r*o-2*e*n*l-2*e*i)/s,(r*l-2*e*n*o-2*n*i)/s)}distance(){if(arguments[0]instanceof On){const t=arguments[0];return Me.segmentToSegment(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof et){const t=arguments[0];return Me.pointToSegment(t,this.p0,this.p1)}}pointAlong(t){const e=new et;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e}hashCode(){let t=G.doubleToLongBits(this.p0.x);t^=31*G.doubleToLongBits(this.p0.y);const e=Math.trunc(t)^Math.trunc(t>>32);let n=G.doubleToLongBits(this.p1.x);n^=31*G.doubleToLongBits(this.p1.y);return e^(Math.trunc(n)^Math.trunc(n>>32))}get interfaces_(){return[j,V]}}class bn{constructor(){bn.constructor_.apply(this,arguments)}static constructor_(){if(this._lines=null,this._isForcedToLineString=!1,1===arguments.length){const t=arguments[0];this._lines=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._lines=t,this._isForcedToLineString=e}}static getGeometry(){if(1===arguments.length){const t=arguments[0];return t.getFactory().buildGeometry(bn.getLines(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().buildGeometry(bn.getLines(t,e))}}static getLines(){if(1===arguments.length){const t=arguments[0];return bn.getLines(t,!1)}if(2===arguments.length){if(F(arguments[0],mt)&&F(arguments[1],mt)){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){const n=e.next();bn.getLines(n,t)}return t}if(arguments[0]instanceof st&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=new Nt;return t.apply(new bn(n,e)),n}if(arguments[0]instanceof st&&F(arguments[1],mt)){const t=arguments[0],e=arguments[1];return t instanceof ft?e.add(t):t.apply(new bn(e)),e}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&F(arguments[0],mt)&&F(arguments[1],mt)){const t=arguments[1],e=arguments[2];for(let n=arguments[0].iterator();n.hasNext();){const i=n.next();bn.getLines(i,t,e)}return t}if("boolean"==typeof arguments[2]&&arguments[0]instanceof st&&F(arguments[1],mt)){const t=arguments[1],e=arguments[2];return arguments[0].apply(new bn(t,e)),t}}}filter(t){if(this._isForcedToLineString&&t instanceof Gt){const e=t.getFactory().createLineString(t.getCoordinateSequence());return this._lines.add(e),null}t instanceof ft&&this._lines.add(t)}setForceToLineString(t){this._isForcedToLineString=t}get interfaces_(){return[k]}}class wn{constructor(){wn.constructor_.apply(this,arguments)}static constructor_(){this._items=new Nt}visitItem(t){this._items.add(t)}getItems(){return this._items}get interfaces_(){return[In]}}class Ln{constructor(){Ln.constructor_.apply(this,arguments)}static constructor_(){this._geom=null,this._index=null;const t=arguments[0];if(!(F(t,St)||t instanceof Gt))throw new z("Argument must be Polygonal or LinearRing");this._geom=t}locate(t){null===this._index&&(this._index=new Sn(this._geom),this._geom=null);const e=new Fe(t),n=new vn(e);return this._index.query(t.y,t.y,n),e.getLocation()}get interfaces_(){return[un]}}class vn{constructor(){vn.constructor_.apply(this,arguments)}static constructor_(){this._counter=null;const t=arguments[0];this._counter=t}visitItem(t){const e=t;this._counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))}get interfaces_(){return[In]}}class Sn{constructor(){Sn.constructor_.apply(this,arguments)}static constructor_(){this._isEmpty=!1,this._index=new Rn;const t=arguments[0];t.isEmpty()?this._isEmpty=!0:this.init(t)}init(t){for(let e=bn.getLines(t).iterator();e.hasNext();){const t=e.next().getCoordinates();this.addLine(t)}}addLine(t){for(let e=1;e<t.length;e++){const n=new On(t[e-1],t[e]),i=Math.min(n.p0.y,n.p1.y),s=Math.max(n.p0.y,n.p1.y);this._index.insert(i,s,n)}}query(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isEmpty)return new Nt;const n=new wn;return this._index.query(t,e,n),n.getItems()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isEmpty)return null;this._index.query(t,e,n)}}}Ln.SegmentVisitor=vn,Ln.IntervalIndexedGeometry=Sn;class Cn{constructor(){Cn.constructor_.apply(this,arguments)}static constructor_(){this.coord=null,this.segmentIndex=null,this.dist=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new et(t),this.segmentIndex=e,this.dist=n}getSegmentIndex(){return this.segmentIndex}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)}compareTo(t){const e=t;return this.compare(e.segmentIndex,e.dist)}isEndPoint(t){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===t}toString(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist}getDistance(){return this.dist}compare(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0}get interfaces_(){return[j]}}class Pn{constructor(){Pn.constructor_.apply(this,arguments)}static constructor_(){this._nodeMap=new an,this.edge=null;const t=arguments[0];this.edge=t}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const i=e.next(),s=this.createSplitEdge(n,i);t.add(s),n=i}}addEndpoints(){const t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)}createSplitEdge(t,e){let n=e.segmentIndex-t.segmentIndex+2;const i=this.edge.pts[e.segmentIndex],s=e.dist>0||!e.coord.equals2D(i);s||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new et(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this.edge.pts[n];return s&&(r[o]=e.coord),new Yn(r,new Je(this.edge._label))}add(t,e,n){const i=new Cn(t,e,n),s=this._nodeMap.get(i);return null!==s?s:(this._nodeMap.put(i,i),i)}isIntersection(t){for(let e=this.iterator();e.hasNext();){if(e.next().coord.equals(t))return!0}return!1}}class Mn{constructor(){Mn.constructor_.apply(this,arguments)}static constructor_(){if(this._data=null,this._size=0,0===arguments.length)Mn.constructor_.call(this,10);else if(1===arguments.length){const t=arguments[0];this._data=new Array(t).fill(null)}}size(){return this._size}addAll(t){return null===t||0===t.length?null:(this.ensureCapacity(this._size+t.length),jt.arraycopy(t,0,this._data,this._size,t.length),void(this._size+=t.length))}ensureCapacity(t){if(t<=this._data.length)return null;const e=Math.max(t,2*this._data.length);this._data=Rt.copyOf(this._data,e)}toArray(){const t=new Array(this._size).fill(null);return jt.arraycopy(this._data,0,t,0,this._size),t}add(t){this.ensureCapacity(this._size+1),this._data[this._size]=t,++this._size}}class An{static toIntArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e}getChainStartIndices(t){let e=0;const n=new Mn(Math.trunc(t.length/2));n.add(e);do{const i=this.findChainEnd(t,e);n.add(i),e=i}while(e<t.length-1);return n.toArray()}findChainEnd(t,e){const n=Ze.quadrant(t[e],t[e+1]);let i=e+1;for(;i<t.length;){if(Ze.quadrant(t[i-1],t[i])!==n)break;i++}return i-1}OLDgetChainStartIndices(t){let e=0;const n=new Nt;n.add(e);do{const i=this.findChainEnd(t,e);n.add(i),e=i}while(e<t.length-1);return An.toIntArray(n)}}class Dn{constructor(){Dn.constructor_.apply(this,arguments)}static constructor_(){this.e=null,this.pts=null,this.startIndex=null;const t=arguments[0];this.e=t,this.pts=t.getCoordinates();const e=new An;this.startIndex=e.getChainStartIndices(this.pts)}getCoordinates(){return this.pts}getMaxX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n}getMinX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e<n?e:n}computeIntersectsForChain(){if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],i)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3],s=arguments[4],r=arguments[5];if(e-t==1&&s-i==1)return r.addIntersections(this.e,t,n.e,i),null;if(!this.overlaps(t,e,n,i,s))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((i+s)/2);t<o&&(i<l&&this.computeIntersectsForChain(t,o,n,i,l,r),l<s&&this.computeIntersectsForChain(t,o,n,l,s,r)),o<e&&(i<l&&this.computeIntersectsForChain(o,e,n,i,l,r),l<s&&this.computeIntersectsForChain(o,e,n,l,s,r))}}overlaps(t,e,n,i,s){return it.intersects(this.pts[t],this.pts[e],n.pts[i],n.pts[s])}getStartIndexes(){return this.startIndex}computeIntersects(t,e){for(let n=0;n<this.startIndex.length-1;n++)for(let i=0;i<t.startIndex.length-1;i++)this.computeIntersectsForChain(n,t,i,e)}}class Fn{constructor(){Fn.constructor_.apply(this,arguments)}static constructor_(){this._depth=Array(2).fill().map(()=>Array(3));for(let t=0;t<2;t++)for(let e=0;e<3;e++)this._depth[t][e]=Fn.NULL_VALUE}static depthAtLocation(t){return t===Ce.EXTERIOR?0:t===Ce.INTERIOR?1:Fn.NULL_VALUE}getDepth(t,e){return this._depth[t][e]}setDepth(t,e,n){this._depth[t][e]=n}isNull(){if(0===arguments.length){for(let t=0;t<2;t++)for(let e=0;e<3;e++)if(this._depth[t][e]!==Fn.NULL_VALUE)return!1;return!0}if(1===arguments.length){const t=arguments[0];return this._depth[t][1]===Fn.NULL_VALUE}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._depth[t][e]===Fn.NULL_VALUE}}normalize(){for(let t=0;t<2;t++)if(!this.isNull(t)){let e=this._depth[t][1];this._depth[t][2]<e&&(e=this._depth[t][2]),e<0&&(e=0);for(let n=1;n<3;n++){let i=0;this._depth[t][n]>e&&(i=1),this._depth[t][n]=i}}}getDelta(t){return this._depth[t][He.RIGHT]-this._depth[t][He.LEFT]}getLocation(t,e){return this._depth[t][e]<=0?Ce.EXTERIOR:Ce.INTERIOR}toString(){return"A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]}add(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<2;e++)for(let n=1;n<3;n++){const i=t.getLocation(e,n);i!==Ce.EXTERIOR&&i!==Ce.INTERIOR||(this.isNull(e,n)?this._depth[e][n]=Fn.depthAtLocation(i):this._depth[e][n]+=Fn.depthAtLocation(i))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1];arguments[2]===Ce.INTERIOR&&this._depth[t][e]++}}}Fn.NULL_VALUE=-1;class Yn extends $e{constructor(){super(),Yn.constructor_.apply(this,arguments)}static constructor_(){if(this.pts=null,this._env=null,this.eiList=new Pn(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new Fn,this._depthDelta=0,1===arguments.length){const t=arguments[0];Yn.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.pts=t,this._label=e}}static updateIM(){if(!(2===arguments.length&&arguments[1]instanceof Ve&&arguments[0]instanceof Je))return super.updateIM.apply(this,arguments);{const t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,He.ON),t.getLocation(1,He.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,He.LEFT),t.getLocation(1,He.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,He.RIGHT),t.getLocation(1,He.RIGHT),2))}}getDepth(){return this._depth}getCollapsedEdge(){const t=new Array(2).fill(null);t[0]=this.pts[0],t[1]=this.pts[1];return new Yn(t,Je.toLineLabel(this._label))}isIsolated(){return this._isIsolated}getCoordinates(){return this.pts}setIsolated(t){this._isIsolated=t}setName(t){this._name=t}equals(t){if(!(t instanceof Yn))return!1;const e=t;if(this.pts.length!==e.pts.length)return!1;let n=!0,i=!0,s=this.pts.length;for(let t=0;t<this.pts.length;t++)if(this.pts[t].equals2D(e.pts[t])||(n=!1),this.pts[t].equals2D(e.pts[--s])||(i=!1),!n&&!i)return!1;return!0}getCoordinate(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){const t=arguments[0];return this.pts[t]}}print(t){t.print("edge "+this._name+": "),t.print("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this._label+" "+this._depthDelta)}computeIM(t){Yn.updateIM(this._label,t)}isCollapsed(){return!!this._label.isArea()&&(3===this.pts.length&&!!this.pts[0].equals(this.pts[2]))}isClosed(){return this.pts[0].equals(this.pts[this.pts.length-1])}getMaximumSegmentIndex(){return this.pts.length-1}getDepthDelta(){return this._depthDelta}getNumPoints(){return this.pts.length}printReverse(t){t.print("edge "+this._name+": ");for(let e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")}getMonotoneChainEdge(){return null===this._mce&&(this._mce=new Dn(this)),this._mce}getEnvelope(){if(null===this._env){this._env=new it;for(let t=0;t<this.pts.length;t++)this._env.expandToInclude(this.pts[t])}return this._env}addIntersection(t,e,n,i){const s=new et(t.getIntersection(i));let r=e,o=t.getEdgeDistance(n,i);const l=r+1;if(l<this.pts.length){const t=this.pts[l];s.equals2D(t)&&(r=l,o=0)}this.eiList.add(s,r,o)}toString(){const t=new Zt;t.append("edge "+this._name+": "),t.append("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this._label+" "+this._depthDelta),t.toString()}isPointwiseEqual(t){if(this.pts.length!==t.pts.length)return!1;for(let e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0}setDepthDelta(t){this._depthDelta=t}getEdgeIntersectionList(){return this.eiList}addIntersections(t,e,n){for(let i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i)}}class Gn extends We{constructor(){super(),Gn.constructor_.apply(this,arguments)}static constructor_(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999];const t=arguments[0],e=arguments[1];if(We.constructor_.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{const e=t.getNumPoints()-1;this.init(t.getCoordinate(e),t.getCoordinate(e-1))}this.computeDirectedLabel()}static depthFactor(t,e){return t===Ce.EXTERIOR&&e===Ce.INTERIOR?1:t===Ce.INTERIOR&&e===Ce.EXTERIOR?-1:0}getNextMin(){return this._nextMin}getDepth(t){return this._depth[t]}setVisited(t){this._isVisited=t}computeDirectedLabel(){this._label=new Je(this._edge.getLabel()),this._isForward||this._label.flip()}getNext(){return this._next}setDepth(t,e){if(-999!==this._depth[t]&&this._depth[t]!==e)throw new hn("assigned depths do not match",this.getCoordinate());this._depth[t]=e}isInteriorAreaEdge(){let t=!0;for(let e=0;e<2;e++)this._label.isArea(e)&&this._label.getLocation(e,He.LEFT)===Ce.INTERIOR&&this._label.getLocation(e,He.RIGHT)===Ce.INTERIOR||(t=!1);return t}setNextMin(t){this._nextMin=t}print(t){super.print.call(this,t),t.print(" "+this._depth[He.LEFT]+"/"+this._depth[He.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")}setMinEdgeRing(t){this._minEdgeRing=t}isLineEdge(){const t=this._label.isLine(0)||this._label.isLine(1),e=!this._label.isArea(0)||this._label.allPositionsEqual(0,Ce.EXTERIOR),n=!this._label.isArea(1)||this._label.allPositionsEqual(1,Ce.EXTERIOR);return t&&e&&n}setEdgeRing(t){this._edgeRing=t}getMinEdgeRing(){return this._minEdgeRing}getDepthDelta(){let t=this._edge.getDepthDelta();return this._isForward||(t=-t),t}setInResult(t){this._isInResult=t}getSym(){return this._sym}isForward(){return this._isForward}getEdge(){return this._edge}printEdge(t){this.print(t),t.print(" "),this._isForward?this._edge.print(t):this._edge.printReverse(t)}setSym(t){this._sym=t}setVisitedEdge(t){this.setVisited(t),this._sym.setVisited(t)}setEdgeDepths(t,e){let n=this.getEdge().getDepthDelta();this._isForward||(n=-n);let i=1;t===He.LEFT&&(i=-1);const s=He.opposite(t),r=e+n*i;this.setDepth(t,e),this.setDepth(s,r)}getEdgeRing(){return this._edgeRing}isInResult(){return this._isInResult}setNext(t){this._next=t}isVisited(){return this._isVisited}}class qn{createNode(t){return new tn(t,null)}}class Bn{constructor(){Bn.constructor_.apply(this,arguments)}static constructor_(){if(this._edges=new Nt,this._nodes=null,this._edgeEndList=new Nt,0===arguments.length)this._nodes=new cn(new qn);else if(1===arguments.length){const t=arguments[0];this._nodes=new cn(t)}}static linkResultDirectedEdges(t){for(let e=t.iterator();e.hasNext();){e.next().getEdges().linkResultDirectedEdges()}}printEdges(t){t.println("Edges:");for(let e=0;e<this._edges.size();e++){t.println("edge "+e+":");const n=this._edges.get(e);n.print(t),n.eiList.print(t)}}find(t){return this._nodes.find(t)}addNode(){if(arguments[0]instanceof tn){const t=arguments[0];return this._nodes.addNode(t)}if(arguments[0]instanceof et){const t=arguments[0];return this._nodes.addNode(t)}}getNodeIterator(){return this._nodes.iterator()}linkResultDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkResultDirectedEdges()}}debugPrintln(t){jt.out.println(t)}isBoundaryNode(t,e){const n=this._nodes.find(e);if(null===n)return!1;const i=n.getLabel();return null!==i&&i.getLocation(t)===Ce.BOUNDARY}linkAllDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkAllDirectedEdges()}}matchInSameDirection(t,e,n,i){return!!t.equals(n)&&(vt.index(t,e,i)===vt.COLLINEAR&&Ze.quadrant(t,e)===Ze.quadrant(n,i))}getEdgeEnds(){return this._edgeEndList}debugPrint(t){jt.out.print(t)}getEdgeIterator(){return this._edges.iterator()}findEdgeInSameDirection(t,e){for(let n=0;n<this._edges.size();n++){const i=this._edges.get(n),s=i.getCoordinates();if(this.matchInSameDirection(t,e,s[0],s[1]))return i;if(this.matchInSameDirection(t,e,s[s.length-1],s[s.length-2]))return i}return null}insertEdge(t){this._edges.add(t)}findEdgeEnd(t){for(let e=this.getEdgeEnds().iterator();e.hasNext();){const n=e.next();if(n.getEdge()===t)return n}return null}addEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._edges.add(t);const n=new Gn(t,!0),i=new Gn(t,!1);n.setSym(i),i.setSym(n),this.add(n),this.add(i)}}add(t){this._nodes.add(t),this._edgeEndList.add(t)}getNodes(){return this._nodes.values()}findEdge(t,e){for(let n=0;n<this._edges.size();n++){const i=this._edges.get(n),s=i.getCoordinates();if(t.equals(s[0])&&e.equals(s[1]))return i}return null}}class Un extends Bn{constructor(){super(),Un.constructor_.apply(this,arguments)}static constructor_(){if(this._parentGeom=null,this._lineEdgeMap=new te,this._boundaryNodeRule=null,this._useBoundaryDeterminationRule=!0,this._argIndex=null,this._boundaryNodes=null,this._hasTooFewPoints=!1,this._invalidPoint=null,this._areaPtLocator=null,this._ptLocator=new je,2===arguments.length){const t=arguments[0],e=arguments[1];Un.constructor_.call(this,t,e,Ge.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._argIndex=t,this._parentGeom=e,this._boundaryNodeRule=n,null!==e&&this.add(e)}}static determineBoundary(t,e){return t.isInBoundary(e)?Ce.BOUNDARY:Ce.INTERIOR}insertBoundaryPoint(t,e){const n=this._nodes.addNode(e).getLabel();let i=1,s=Ce.NONE;s=n.getLocation(t,He.ON),s===Ce.BOUNDARY&&i++;const r=Un.determineBoundary(this._boundaryNodeRule,i);n.setLocation(t,r)}computeSelfNodes(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){const t=arguments[1],e=arguments[2],n=new mn(arguments[0],!0,!1);n.setIsDoneIfProperInt(e);const i=this.createEdgeSetIntersector(),s=this._parentGeom instanceof Gt||this._parentGeom instanceof Ct||this._parentGeom instanceof Kt,r=t||!s;return i.computeIntersections(this._edges,n,r),this.addSelfIntersectionNodes(this._argIndex),n}}computeSplitEdges(t){for(let e=this._edges.iterator();e.hasNext();){e.next().eiList.addSplitEdges(t)}}computeEdgeIntersections(t,e,n){const i=new mn(e,n,!0);i.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes());return this.createEdgeSetIntersector().computeIntersections(this._edges,t._edges,i),i}getGeometry(){return this._parentGeom}getBoundaryNodeRule(){return this._boundaryNodeRule}hasTooFewPoints(){return this._hasTooFewPoints}addPoint(){if(arguments[0]instanceof _t){const t=arguments[0].getCoordinate();this.insertPoint(this._argIndex,t,Ce.INTERIOR)}else if(arguments[0]instanceof et){const t=arguments[0];this.insertPoint(this._argIndex,t,Ce.INTERIOR)}}addPolygon(t){this.addPolygonRing(t.getExteriorRing(),Ce.EXTERIOR,Ce.INTERIOR);for(let e=0;e<t.getNumInteriorRing();e++){const n=t.getInteriorRingN(e);this.addPolygonRing(n,Ce.INTERIOR,Ce.EXTERIOR)}}addEdge(t){this.insertEdge(t);const e=t.getCoordinates();this.insertPoint(this._argIndex,e[0],Ce.BOUNDARY),this.insertPoint(this._argIndex,e[e.length-1],Ce.BOUNDARY)}addLineString(t){const e=Vt.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this._invalidPoint=e[0],null;const n=new Yn(e,new Je(this._argIndex,Ce.INTERIOR));this._lineEdgeMap.put(t,n),this.insertEdge(n),J.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this._argIndex,e[0]),this.insertBoundaryPoint(this._argIndex,e[e.length-1])}getInvalidPoint(){return this._invalidPoint}getBoundaryPoints(){const t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null);let n=0;for(let i=t.iterator();i.hasNext();){const t=i.next();e[n++]=t.getCoordinate().copy()}return e}getBoundaryNodes(){return null===this._boundaryNodes&&(this._boundaryNodes=this._nodes.getBoundaryNodes(this._argIndex)),this._boundaryNodes}addSelfIntersectionNode(t,e,n){if(this.isBoundaryNode(t,e))return null;n===Ce.BOUNDARY&&this._useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n)}addPolygonRing(t,e,n){if(t.isEmpty())return null;const i=Vt.removeRepeatedPoints(t.getCoordinates());if(i.length<4)return this._hasTooFewPoints=!0,this._invalidPoint=i[0],null;let s=e,r=n;vt.isCCW(i)&&(s=n,r=e);const o=new Yn(i,new Je(this._argIndex,Ce.BOUNDARY,s,r));this._lineEdgeMap.put(t,o),this.insertEdge(o),this.insertPoint(this._argIndex,i[0],Ce.BOUNDARY)}insertPoint(t,e,n){const i=this._nodes.addNode(e),s=i.getLabel();null===s?i._label=new Je(t,n):s.setLocation(t,n)}createEdgeSetIntersector(){return new En}addSelfIntersectionNodes(t){for(let e=this._edges.iterator();e.hasNext();){const n=e.next(),i=n.getLabel().getLocation(t);for(let e=n.eiList.iterator();e.hasNext();){const n=e.next();this.addSelfIntersectionNode(t,n.coord,i)}}}add(){if(!(1===arguments.length&&arguments[0]instanceof st))return super.add.apply(this,arguments);{const t=arguments[0];if(t.isEmpty())return null;if(t instanceof Kt&&(this._useBoundaryDeterminationRule=!1),t instanceof Ct)this.addPolygon(t);else if(t instanceof ft)this.addLineString(t);else if(t instanceof _t)this.addPoint(t);else if(t instanceof Yt)this.addCollection(t);else if(t instanceof ie)this.addCollection(t);else if(t instanceof Kt)this.addCollection(t);else{if(!(t instanceof Ft))throw new at(t.getGeometryType());this.addCollection(t)}}}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}locate(t){return F(this._parentGeom,St)&&this._parentGeom.getNumGeometries()>50?(null===this._areaPtLocator&&(this._areaPtLocator=new Ln(this._parentGeom)),this._areaPtLocator.locate(t)):this._ptLocator.locate(t,this._parentGeom)}findEdge(){if(1===arguments.length&&arguments[0]instanceof ft){const t=arguments[0];return this._lineEdgeMap.get(t)}return super.findEdge.apply(this,arguments)}}class Xn extends We{constructor(){super(),Xn.constructor_.apply(this,arguments)}static constructor_(){if(this._edgeEnds=new Nt,1===arguments.length){const t=arguments[0];Xn.constructor_.call(this,null,t)}else if(2===arguments.length){const t=arguments[1];We.constructor_.call(this,t.getEdge(),t.getCoordinate(),t.getDirectedCoordinate(),new Je(t.getLabel())),this.insert(t)}}insert(t){this._edgeEnds.add(t)}print(t){t.println("EdgeEndBundle--\x3e Label: "+this._label);for(let e=this.iterator();e.hasNext();){e.next().print(t),t.println()}}iterator(){return this._edgeEnds.iterator()}getEdgeEnds(){return this._edgeEnds}computeLabelOn(t,e){let n=0,i=!1;for(let e=this.iterator();e.hasNext();){const s=e.next().getLabel().getLocation(t);s===Ce.BOUNDARY&&n++,s===Ce.INTERIOR&&(i=!0)}let s=Ce.NONE;i&&(s=Ce.INTERIOR),n>0&&(s=Un.determineBoundary(e,n)),this._label.setLocation(t,s)}computeLabelSide(t,e){for(let n=this.iterator();n.hasNext();){const i=n.next();if(i.getLabel().isArea()){const n=i.getLabel().getLocation(t,e);if(n===Ce.INTERIOR)return this._label.setLocation(t,e,Ce.INTERIOR),null;n===Ce.EXTERIOR&&this._label.setLocation(t,e,Ce.EXTERIOR)}}}getLabel(){return this._label}computeLabelSides(t){this.computeLabelSide(t,He.LEFT),this.computeLabelSide(t,He.RIGHT)}updateIM(t){Yn.updateIM(this._label,t)}computeLabel(t){let e=!1;for(let t=this.iterator();t.hasNext();){t.next().getLabel().isArea()&&(e=!0)}this._label=e?new Je(Ce.NONE,Ce.NONE,Ce.NONE):new Je(Ce.NONE);for(let n=0;n<2;n++)this.computeLabelOn(n,t),e&&this.computeLabelSides(n)}}class zn extends fn{constructor(){super()}updateIM(t){for(let e=this.iterator();e.hasNext();){e.next().updateIM(t)}}insert(t){let e=this._edgeMap.get(t);null===e?(e=new Xn(t),this.insertEdgeEnd(t,e)):e.insert(t)}}class kn extends tn{constructor(){super(),kn.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];tn.constructor_.call(this,t,e)}updateIMFromEdges(t){this._edges.updateIM(t)}computeIM(t){t.setAtLeastIfValid(this._label.getLocation(0),this._label.getLocation(1),0)}}class jn extends qn{constructor(){super()}createNode(t){return new kn(t,new zn)}}class Vn{constructor(){Vn.constructor_.apply(this,arguments)}static constructor_(){this._li=new De,this._ptLocator=new je,this._arg=null,this._nodes=new cn(new jn),this._im=null,this._isolatedEdges=new Nt,this._invalidPoint=null;const t=arguments[0];this._arg=t}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}computeProperIntersectionIM(t,e){const n=this._arg[0].getGeometry().getDimension(),i=this._arg[1].getGeometry().getDimension(),s=t.hasProperIntersection(),r=t.hasProperInteriorIntersection();2===n&&2===i?s&&e.setAtLeast("212101212"):2===n&&1===i?(s&&e.setAtLeast("FFF0FFFF2"),r&&e.setAtLeast("1FFFFF1FF")):1===n&&2===i?(s&&e.setAtLeast("F0FFFFFF2"),r&&e.setAtLeast("1F1FFFFFF")):1===n&&1===i&&r&&e.setAtLeast("0FFFFFFFF")}labelIsolatedEdges(t,e){for(let n=this._arg[t].getEdgeIterator();n.hasNext();){const t=n.next();t.isIsolated()&&(this.labelIsolatedEdge(t,e,this._arg[e].getGeometry()),this._isolatedEdges.add(t))}}labelIsolatedEdge(t,e,n){if(n.getDimension()>0){const i=this._ptLocator.locate(t.getCoordinate(),n);t.getLabel().setAllLocations(e,i)}else t.getLabel().setAllLocations(e,Ce.EXTERIOR)}computeIM(){const t=new Ve;if(t.set(Ce.EXTERIOR,Ce.EXTERIOR,2),!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1);const e=this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(e,t);const n=new Qe,i=n.computeEdgeEnds(this._arg[0].getEdgeIterator());this.insertEdgeEnds(i);const s=n.computeEdgeEnds(this._arg[1].getEdgeIterator());return this.insertEdgeEnds(s),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t}labelNodeEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}}copyNodesAndLabels(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._nodes.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}labelIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),i=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),s=this._nodes.find(n.coord);s.getLabel().isNull(t)&&(i===Ce.BOUNDARY?s.setLabelBoundary(t):s.setLabel(t,Ce.INTERIOR))}}}labelIsolatedNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setAllLocations(e,n)}computeIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),i=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),s=this._nodes.addNode(n.coord);i===Ce.BOUNDARY?s.setLabelBoundary(t):s.getLabel().isNull(t)&&s.setLabel(t,Ce.INTERIOR)}}}labelIsolatedNodes(){for(let t=this._nodes.iterator();t.hasNext();){const e=t.next(),n=e.getLabel();J.isTrue(n.getGeometryCount()>0,"node with empty label found"),e.isIsolated()&&(n.isNull(0)?this.labelIsolatedNode(e,0):this.labelIsolatedNode(e,1))}}updateIM(t){for(let e=this._isolatedEdges.iterator();e.hasNext();){e.next().updateIM(t)}for(let e=this._nodes.iterator();e.hasNext();){const n=e.next();n.updateIM(t),n.updateIMFromEdges(t)}}computeDisjointIM(t){const e=this._arg[0].getGeometry();e.isEmpty()||(t.set(Ce.INTERIOR,Ce.EXTERIOR,e.getDimension()),t.set(Ce.BOUNDARY,Ce.EXTERIOR,e.getBoundaryDimension()));const n=this._arg[1].getGeometry();n.isEmpty()||(t.set(Ce.EXTERIOR,Ce.INTERIOR,n.getDimension()),t.set(Ce.EXTERIOR,Ce.BOUNDARY,n.getBoundaryDimension()))}}class Zn{constructor(){Zn.constructor_.apply(this,arguments)}static constructor_(){if(this._li=new De,this._resultPrecisionModel=null,this._arg=null,1===arguments.length){const t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this._arg=new Array(1).fill(null),this._arg[0]=new Un(0,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Zn.constructor_.call(this,t,e,Ge.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];t.getPrecisionModel().compareTo(e.getPrecisionModel())>=0?this.setComputationPrecision(t.getPrecisionModel()):this.setComputationPrecision(e.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new Un(0,t,n),this._arg[1]=new Un(1,e,n)}}getArgGeometry(t){return this._arg[t].getGeometry()}setComputationPrecision(t){this._resultPrecisionModel=t,this._li.setPrecisionModel(this._resultPrecisionModel)}}class Wn{constructor(){Wn.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal()}static contains(t,e){return new Wn(t).contains(e)}isContainedInBoundary(t){if(t instanceof Ct)return!1;if(t instanceof _t)return this.isPointContainedInBoundary(t);if(t instanceof ft)return this.isLineStringContainedInBoundary(t);for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.isContainedInBoundary(n))return!1}return!0}isLineSegmentContainedInBoundary(t,e){if(t.equals(e))return this.isPointContainedInBoundary(t);if(t.x===e.x){if(t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX())return!0}else if(t.y===e.y&&(t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()))return!0;return!1}isLineStringContainedInBoundary(t){const e=t.getCoordinateSequence(),n=new et,i=new et;for(let t=0;t<e.size()-1;t++)if(e.getCoordinate(t,n),e.getCoordinate(t+1,i),!this.isLineSegmentContainedInBoundary(n,i))return!1;return!0}isPointContainedInBoundary(){if(arguments[0]instanceof _t){const t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof et){const t=arguments[0];return t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX()||t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()}}contains(t){return!!this._rectEnv.contains(t.getEnvelopeInternal())&&!this.isContainedInBoundary(t)}}class Hn{constructor(){Hn.constructor_.apply(this,arguments)}static constructor_(){this._li=new De,this._rectEnv=null,this._diagUp0=null,this._diagUp1=null,this._diagDown0=null,this._diagDown1=null;const t=arguments[0];this._rectEnv=t,this._diagUp0=new et(t.getMinX(),t.getMinY()),this._diagUp1=new et(t.getMaxX(),t.getMaxY()),this._diagDown0=new et(t.getMinX(),t.getMaxY()),this._diagDown1=new et(t.getMaxX(),t.getMinY())}intersects(t,e){const n=new it(t,e);if(!this._rectEnv.intersects(n))return!1;if(this._rectEnv.intersects(t))return!0;if(this._rectEnv.intersects(e))return!0;if(t.compareTo(e)>0){const n=t;t=e,e=n}let i=!1;return e.y>t.y&&(i=!0),i?this._li.computeIntersection(t,e,this._diagDown0,this._diagDown1):this._li.computeIntersection(t,e,this._diagUp0,this._diagUp1),!!this._li.hasIntersection()}}class Kn{constructor(){Kn.constructor_.apply(this,arguments)}static constructor_(){this._isDone=!1}applyTo(t){for(let e=0;e<t.getNumGeometries()&&!this._isDone;e++){const n=t.getGeometryN(e);if(n instanceof Ft)this.applyTo(n);else if(this.visit(n),this.isDone())return this._isDone=!0,null}}}class Jn{constructor(){Jn.constructor_.apply(this,arguments)}static constructor_(){this._rectangle=null,this._rectEnv=null;const t=arguments[0];this._rectangle=t,this._rectEnv=t.getEnvelopeInternal()}static intersects(t,e){return new Jn(t).intersects(e)}intersects(t){if(!this._rectEnv.intersects(t.getEnvelopeInternal()))return!1;const e=new Qn(this._rectEnv);if(e.applyTo(t),e.intersects())return!0;const n=new $n(this._rectangle);if(n.applyTo(t),n.containsPoint())return!0;const i=new ti(this._rectangle);return i.applyTo(t),!!i.intersects()}}class Qn extends Kn{constructor(){super(),Qn.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null,this._intersects=!1;const t=arguments[0];this._rectEnv=t}isDone(){return!0===this._intersects}visit(t){const e=t.getEnvelopeInternal();return this._rectEnv.intersects(e)?this._rectEnv.contains(e)||e.getMinX()>=this._rectEnv.getMinX()&&e.getMaxX()<=this._rectEnv.getMaxX()||e.getMinY()>=this._rectEnv.getMinY()&&e.getMaxY()<=this._rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null}intersects(){return this._intersects}}class $n extends Kn{constructor(){super(),$n.constructor_.apply(this,arguments)}static constructor_(){this._rectSeq=null,this._rectEnv=null,this._containsPoint=!1;const t=arguments[0];this._rectSeq=t.getExteriorRing().getCoordinateSequence(),this._rectEnv=t.getEnvelopeInternal()}isDone(){return!0===this._containsPoint}visit(t){if(!(t instanceof Ct))return null;const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=new et;for(let i=0;i<4;i++)if(this._rectSeq.getCoordinate(i,n),e.contains(n)&&gn.containsPointInPolygon(n,t))return this._containsPoint=!0,null}containsPoint(){return this._containsPoint}}class ti extends Kn{constructor(){super(),ti.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null,this._rectIntersector=null,this._hasIntersection=!1,this._p0=new et,this._p1=new et;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal(),this._rectIntersector=new Hn(this._rectEnv)}intersects(){return this._hasIntersection}isDone(){return!0===this._hasIntersection}visit(t){const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=bn.getLines(t);this.checkIntersectionWithLineStrings(n)}checkIntersectionWithLineStrings(t){for(let e=t.iterator();e.hasNext();){const t=e.next();if(this.checkIntersectionWithSegments(t),this._hasIntersection)return null}}checkIntersectionWithSegments(t){const e=t.getCoordinateSequence();for(let t=1;t<e.size();t++)if(e.getCoordinate(t-1,this._p0),e.getCoordinate(t,this._p1),this._rectIntersector.intersects(this._p0,this._p1))return this._hasIntersection=!0,null}}class ei extends Zn{constructor(){super(),ei.constructor_.apply(this,arguments)}static constructor_(){if(this._relate=null,2===arguments.length){const t=arguments[0],e=arguments[1];Zn.constructor_.call(this,t,e),this._relate=new Vn(this._arg)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];Zn.constructor_.call(this,t,e,n),this._relate=new Vn(this._arg)}}static covers(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().covers(e.getEnvelopeInternal())&&(!!t.isRectangle()||new ei(t,e).getIntersectionMatrix().isCovers())))}static intersects(t,e){if(!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()))return!1;if(t.isRectangle())return Jn.intersects(t,e);if(e.isRectangle())return Jn.intersects(e,t);if(t.isGeometryCollection()||e.isGeometryCollection()){for(let n=0;n<t.getNumGeometries();n++)for(let i=0;i<e.getNumGeometries();i++)if(t.getGeometryN(n).intersects(e.getGeometryN(i)))return!0;return!1}return new ei(t,e).getIntersectionMatrix().isIntersects()}static touches(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new ei(t,e).getIntersectionMatrix().isTouches(t.getDimension(),e.getDimension())}static equalsTopo(t,e){return!!t.getEnvelopeInternal().equals(e.getEnvelopeInternal())&&ei.relate(t,e).isEquals(t.getDimension(),e.getDimension())}static relate(){if(2===arguments.length){return new ei(arguments[0],arguments[1]).getIntersectionMatrix()}if(3===arguments.length){return new ei(arguments[0],arguments[1],arguments[2]).getIntersectionMatrix()}}static overlaps(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new ei(t,e).getIntersectionMatrix().isOverlaps(t.getDimension(),e.getDimension())}static crosses(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new ei(t,e).getIntersectionMatrix().isCrosses(t.getDimension(),e.getDimension())}static contains(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().contains(e.getEnvelopeInternal())&&(t.isRectangle()?Wn.contains(t,e):new ei(t,e).getIntersectionMatrix().isContains())))}getIntersectionMatrix(){return this._relate.computeIM()}}function ni(t){return function(t){if(Array.isArray(t))return ii(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||function(t,e){if(!t)return;if("string"==typeof t)return ii(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return Array.from(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return ii(t,e)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function ii(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,i=new Array(e);n<e;n++)i[n]=t[n];return i}function si(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&ri(t,e)}function ri(t,e){return(ri=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function oi(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,i=ai(t);if(e){var s=ai(this).constructor;n=Reflect.construct(i,arguments,s)}else n=i.apply(this,arguments);return li(this,n)}}function li(t,e){if(e&&("object"===ci(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}function ai(t){return(ai=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function ci(t){return(ci="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function hi(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function ui(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,(s=i.key,r=void 0,r=function(t,e){if("object"!==ci(t)||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var i=n.call(t,e||"default");if("object"!==ci(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(s,"string"),"symbol"===ci(r)?r:String(r)),i)}var s,r}function gi(t,e,n){return e&&ui(t.prototype,e),n&&ui(t,n),Object.defineProperty(t,"prototype",{writable:!1}),t}var fi=function(t){si(n,t);var e=oi(n);function n(t,i){hi(this,n);return e.call(this,(function(e,n){var i=null;return M.utils.isNullOrEmpty(e)||(i=e.getGeometry()),t(i,n)}),i)}return gi(n)}(function(t){si(n,t);var e=oi(n);function n(t){var i,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return hi(this,n),(i=e.call(this)).filterFunction_=t,i.cqlFilter_="",M.utils.isNullOrEmpty(s.cqlFilter)||(i.cqlFilter_=s.cqlFilter),i}return gi(n,[{key:"setFunction",value:function(t){this.filterFunction_=t}},{key:"getFunctionFilter",value:function(){return this.filterFunction_}},{key:"execute",value:function(t){return t.filter(this.filterFunction_)}},{key:"toCQL",value:function(){return this.cqlFilter_}}]),n}(function(){function t(){hi(this,t)}return gi(t,[{key:"getFunctionFilter",value:function(){}},{key:"execute",value:function(t){}},{key:"toCQL",value:function(){}}]),t}())),pi=function(t,e){var n="",i=new M.format.WKT;return e.forEach((function(e,s){0!==s&&(n+=" OR ");var r=new M.Feature("filtered_geom",{type:"Feature",geometry:e}),o=i.write(r);n+="".concat(t,"({{geometryName}}, ").concat(o,")")})),n},di=function(t){var e=function(t){var e=t,n=[];return e instanceof M.layer.Vector?n=ni(e.getFeatures().map((function(t){return t.getGeometry()}))):(M.utils.isArray(e)||(e=[e]),n=e.map((function(t){var e;return t instanceof M.Feature?e=t.getGeometry():M.isObject(t)&&(e=t),e}))),n}(t);return new fi((function(t,n){var i=new ce,s=i.read(t);return e.some((function(t){var e=i.read(t);return ei.intersects(s,e)}))}),{cqlFilter:pi("INTERSECTS",e)})};function _i(t){return(_i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function yi(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function mi(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,(s=i.key,r=void 0,r=function(t,e){if("object"!==_i(t)||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var i=n.call(t,e||"default");if("object"!==_i(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(s,"string"),"symbol"===_i(r)?r:String(r)),i)}var s,r}function Ei(t,e){return(Ei=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function Ii(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,i=Ni(t);if(e){var s=Ni(this).constructor;n=Reflect.construct(i,arguments,s)}else n=i.apply(this,arguments);return xi(this,n)}}function xi(t,e){if(e&&("object"===_i(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}function Ni(t){return(Ni=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Ti=1,Ri=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Ei(t,e)}(r,M.Plugin);var e,n,i,s=Ii(r);function r(){var t,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return yi(this,r),t=s.call(this),e.mode!==Ti||M.utils.isNullOrEmpty(e.url)||M.utils.isNullOrEmpty(e.type)&&console.warn(w("exception.type")),e.mode!==Ti||M.utils.isNullOrEmpty(e.layerName)||M.utils.isNullOrEmpty(e.type)&&console.warn(w("exception.layerName")),t.map_=null,t.controls_=[],t.mode_=Number.parseInt(e.mode,10)||1,t.url_=e.url||"https://componentes.cnig.es/api-core/files/attributions/WMTS_PNOA_20170220/atribucionPNOA_Url.kml",t.type_=e.type||"kml",t.layerName_=e.layerName||"attributions",t.layer_=e.layer,t.scale_=Number.parseInt(e.scale,10)||1e4,t.attributionParam_=e.attributionParam||"atribucion",t.urlParam_=e.urlParam||"url",t.minWidth_=e.minWidth||"100px",t.maxWidth_=e.maxWidth||"200px",t.position_=e.position||"BL",t.defaultAttribution_=e.defaultAttribution||"Instituto Geogr&aacute;fico Nacional",t.defaultURL_=e.defaultURL||"https://www.ign.es/",t.tooltip_=e.tooltip||w("tooltip"),t.urlAttribute=e.urlAttribute||"Gobierno de España",window.addEventListener("resize",(function(e){return t.setCollapsiblePanel(e)})),t.order=e.order>=-1?e.order:null,t.options=e,t}return e=r,i=[{key:"getJSONTranslations",value:function(t){return"en"===t||"es"===t?"en"===t?N:T:M.language.getTranslation(t).attributions}}],(n=[{key:"addTo",value:function(t){var e=this;this.map_=t,this.impl_=new c(t),this.control_=new D(this.position_,this.closePanel),this.controls_.push(this.control_),this.panel_=new M.ui.Panel("Attributions",{collapsible:window.innerWidth<769,position:M.ui.position[this.position_],className:"m-panel-attributions",collapsedButtonClass:"g-cartografia-info",tooltip:this.tooltip_,order:this.order}),this.panel_.addControls(this.control_),this.map_.addPanels(this.panel_),this.initMode(),this.onMoveEnd((function(){e.changeAttributions()}))}},{key:"destroy",value:function(){this.map_.removeControls([this.control_]),this.panel_=null}},{key:"initMode",value:function(){if(this.mode_===Ti){if(!(this.layer_ instanceof M.layer.Vector)){var t={name:this.layerName_,url:this.url_};"geojson"===this.type_?this.layer_=new M.layer.GeoJSON(t,{displayInLayerSwitcher:!1}):"kml"===this.type_?this.layer_=new M.layer.KML(t,{displayInLayerSwitcher:!1}):this.type}this.map_.getLayers({name:this.layer_}).length<1&&(this.map_.addLayers(this.layer_),this.layer_.displayInLayerSwitcher=!1,this.layer_.setVisible(!1))}}},{key:"changeAttributions",value:function(){if(this.clearContent(),this.map_.getScale()<=this.scale_){this.setVisible(!0);var t=[];if(this.mode_===Ti){t=this.getMapAttributions();var e=this.map_.getZoom(),n=this.map_.getBaseLayers()[0],i=this.map_.getLayers().filter((function(t){return"WMTS"===t.type&&!t.displayInLayerSwitcher&&"OI.OrthoimageCoverage"===t.name})).length>0;t=void 0!==n&&"OI.OrthoimageCoverage"===n.name||i?e<14?[{attribution:"Copernicus Sentinel 2019",url:"https://sentinel.esa.int/web/sentinel/home"}].concat(t):[{attribution:"Sistema Cartográfico Nacional",url:"http://www.scne.es/"}].concat(t):void 0===n||"IGNBaseTodo"!==n.name&&"EL.GridCoverageDSM"!==n.name?void 0!==n&&"LC.LandCoverSurfaces"===n.name?e<14?[{attribution:"CORINE-Land Cover. Instituto Geográfico Nacional",url:this.defaultURL_}].concat(t):[{attribution:"Sistema Cartográfico Nacional",url:"http://www.scne.es/"}].concat(t):[{attribution:this.defaultAttribution_,url:this.defaultURL_}].concat(t):[{attribution:"Sistema Cartográfico Nacional",url:"http://www.scne.es/"}].concat(t)}this.addContent(t)}else{var s=this.map_.getZoom(),r=this.map_.getBaseLayers()[0],o=[{attribution:this.defaultAttribution_,url:this.defaultURL_}],l=this.map_.getLayers().filter((function(t){return"WMTS"===t.type&&!t.displayInLayerSwitcher&&"OI.OrthoimageCoverage"===t.name})).length>0;void 0!==r&&"OI.OrthoimageCoverage"===r.name||l?o=s<14?[{attribution:"Copernicus Sentinel 2019",url:"https://sentinel.esa.int/web/sentinel/home"}]:[{attribution:"Sistema Cartográfico Nacional",url:"http://www.scne.es/"}]:void 0===r||"IGNBaseTodo"!==r.name&&"EL.GridCoverageDSM"!==r.name?void 0!==r&&"LC.LandCoverSurfaces"===r.name&&(o=s<14?[{attribution:"CORINE-Land Cover. Instituto Geográfico Nacional",url:this.defaultURL_}]:[{attribution:"Sistema Cartográfico Nacional",url:"http://www.scne.es/"}]):o=[{attribution:"Sistema Cartográfico Nacional",url:"http://www.scne.es/"}],this.addContent(o)}}},{key:"addContent",value:function(t){var e=this,n=this.control_.getElement(),i=t.map((function(t,n,i){var s=document.createElement("a");s.target="_blank",s.href=t.url,s.setAttribute("rol","link"),s.setAttribute("tabindex",e.order),s.innerHTML=t.attribution;var r=e.map_.getScale()>e.scale_?"":", ".concat(e.urlAttribute);return s.innerHTML+=i.length-1===n?r:",",s})),s=document.createElement("div");i.forEach((function(t){s.append(t)})),n.append(s)}},{key:"clearContent",value:function(){if(!M.utils.isNullOrEmpty(this.control_)){var t=this.control_.getElement();t.querySelectorAll("div").forEach((function(e){return t.removeChild(e)}))}}},{key:"setVisible",value:function(t){this.control_.getElement().style.display=!1===t?"none":""}},{key:"getMapAttributions",value:function(){var t=this;this.updateBBoxFeature();var e=this.map_.getLayers().filter((function(t){return t.name.includes("attributions")}))[0].getFeatures();return di(this.bboxFeature_).execute(e).map((function(e){return{attribution:e.getAttribute(t.attributionParam_)||"",url:e.getAttribute(t.urlParam_)||t.defaultURL_}})).filter((function(t,e,n){return n.map((function(t){return t.attribution})).indexOf(t.attribution)===e}))}},{key:"getLayerAttributions",value:function(){}},{key:"closePanel",value:function(){this.getPanel().collapse()}},{key:"changeContentAttribution",value:function(t){this.control_.changeContent(t)}},{key:"updateBBoxFeature",value:function(){var t=this.map_.getBbox(),e=t.x,n=t.y;this.bboxFeature_=new M.Feature("bbox_feature",{type:"Feature",properties:{},geometry:{type:"Polygon",coordinates:[[[e.min,n.min],[e.min,n.max],[e.max,n.max],[e.max,n.min],[e.min,n.min]]]}})}},{key:"setCollapsiblePanel",value:function(t){this.getPanel()&&this.getPanel().getTemplatePanel()&&(t.target.innerWidth<769?(this.getPanel().getTemplatePanel().classList.remove("no-collapsible"),this.closePanel()):(this.getPanel().getTemplatePanel().classList.add("no-collapsible"),this.getPanel().getTemplatePanel().classList.remove("collapsed")))}},{key:"onMoveEnd",value:function(t){this.impl_.registerEvent("moveend",(function(e){return t(e)}))}},{key:"getPanel",value:function(){return this.panel_}},{key:"name",get:function(){return"attributions"}},{key:"mode",get:function(){return this.mode_}},{key:"position",get:function(){return this.position_}},{key:"scale",get:function(){return this.scale_}},{key:"defaultAttribution",get:function(){return this.defaultAttribution_}},{key:"defaultURL",get:function(){return this.defaultURL_}},{key:"url",get:function(){return this.url_}},{key:"type",get:function(){return this.type_}},{key:"layerName",get:function(){return this.layerName_}},{key:"attributionParam",get:function(){return this.attributionParam_}},{key:"urlParam",get:function(){return this.urlParam_}},{key:"getAPIRest",value:function(){return"".concat(this.name,"=").concat(this.position,"*").concat(this.tooltip_,"*").concat(this.mode,"*").concat(this.scale,"*").concat(this.defaultAttribution,"*").concat(this.defaultURL,"*").concat(this.url,"*").concat(this.type,"*").concat(this.layerName,"*").concat(this.attributionParam_,"*").concat(this.urlParam,"*").concat(this.minWidth_,"*").concat(this.maxWidth_,"*").concat(this.urlAttribute)}},{key:"getAPIRestBase64",value:function(){return"".concat(this.name,"=base64=").concat(M.utils.encodeBase64(this.options))}}])&&mi(e.prototype,n),i&&mi(e,i),Object.defineProperty(e,"prototype",{writable:!1}),r}();window.M.plugin||(window.M.plugin={}),window.M.control||(window.M.control={}),window.M.impl||(window.M.impl={}),window.M.impl.control||(window.M.impl.control={}),window.M.plugin.Attributions=Ri,window.M.control.AttributionsControl=D,window.M.impl.control.AttributionsControl=E}]);
//# sourceMappingURL=attributions-1.1.0.ol.min.js.map