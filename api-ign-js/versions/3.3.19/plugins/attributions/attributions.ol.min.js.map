{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/templates/attributions.html","webpack:///./src/impl/ol/js/attributions.js","webpack:///./src/impl/ol/js/attributionscontrol.js","webpack:///./src/facade/js/i18n/language.js","webpack:///./node_modules/jsts/java/lang/Double.js","webpack:///./src/facade/js/attributionscontrol.js","webpack:///./node_modules/jsts/hasInterface.js","webpack:///./node_modules/jsts/java/lang/Cloneable.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequence.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequenceFactory.js","webpack:///./node_modules/jsts/java/lang/IllegalArgumentException.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryComponentFilter.js","webpack:///./node_modules/jsts/java/lang/Comparable.js","webpack:///./node_modules/jsts/java/io/Serializable.js","webpack:///./node_modules/jsts/org/locationtech/jts/util/NumberUtil.js","webpack:///./node_modules/jsts/java/lang/Long.js","webpack:///./node_modules/jsts/java/util/Comparator.js","webpack:///./node_modules/jsts/java/lang/RuntimeException.js","webpack:///./node_modules/jsts/org/locationtech/jts/util/AssertionFailedException.js","webpack:///./node_modules/jsts/org/locationtech/jts/util/Assert.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Coordinate.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Envelope.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Geometry.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateFilter.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/BoundaryNodeRule.js","webpack:///./node_modules/jsts/java/util/Iterator.js","webpack:///./node_modules/jsts/java/util/Collection.js","webpack:///./node_modules/jsts/java/util/IndexOutOfBoundsException.js","webpack:///./node_modules/jsts/java/util/List.js","webpack:///./node_modules/jsts/java/util/NoSuchElementException.js","webpack:///./node_modules/jsts/java/util/OperationNotSupported.js","webpack:///./node_modules/jsts/java/util/ArrayList.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateList.js","webpack:///./node_modules/jsts/org/locationtech/jts/math/MathUtil.js","webpack:///./node_modules/jsts/java/lang/System.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateArrays.js","webpack:///./node_modules/jsts/java/util/Map.js","webpack:///./node_modules/jsts/java/util/SortedMap.js","webpack:///./node_modules/jsts/java/util/Set.js","webpack:///./node_modules/jsts/java/util/HashSet.js","webpack:///./node_modules/jsts/java/util/TreeMap.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Lineal.js","webpack:///./node_modules/jsts/java/util/SortedSet.js","webpack:///./node_modules/jsts/java/util/TreeSet.js","webpack:///./node_modules/jsts/Map.js","webpack:///./node_modules/jsts/java/util/Arrays.js","webpack:///./node_modules/jsts/java/lang/Character.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Dimension.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryFilter.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequenceFilter.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryCollection.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/MultiLineString.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/BoundaryOp.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/Length.js","webpack:///./node_modules/jsts/java/io/PrintStream.js","webpack:///./node_modules/jsts/java/io/StringReader.js","webpack:///./node_modules/jsts/java/io/ByteArrayOutputStream.js","webpack:///./node_modules/jsts/java/io/IOException.js","webpack:///./node_modules/jsts/java/io/LineNumberReader.js","webpack:///./node_modules/jsts/org/locationtech/jts/util/StringUtil.js","webpack:///./node_modules/jsts/java/lang/StringBuilder.js","webpack:///./node_modules/jsts/java/text/DecimalFormat.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequences.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/LineString.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Puntal.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Point.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/Area.js","webpack:///./node_modules/jsts/java/lang/StringBuffer.js","webpack:///./node_modules/jsts/java/lang/Integer.js","webpack:///./node_modules/jsts/org/locationtech/jts/math/DD.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/CGAlgorithmsDD.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/Orientation.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Polygonal.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Polygon.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/MultiPoint.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/LinearRing.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/MultiPolygon.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/util/GeometryEditor.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/impl/CoordinateArraySequence.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/impl/CoordinateArraySequenceFactory.js","webpack:///./node_modules/jsts/java/util/HashMap.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/PrecisionModel.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryFactory.js","webpack:///./node_modules/jsts/org/locationtech/jts/io/GeoJSONParser.js","webpack:///./node_modules/jsts/org/locationtech/jts/io/GeoJSONReader.js","webpack:///./node_modules/jsts/org/locationtech/jts/io/WKTParser.js","webpack:///./node_modules/jsts/org/locationtech/jts/io/WKTWriter.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Location.js","webpack:///./node_modules/jsts/java/lang/Exception.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/NotRepresentableException.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/HCoordinate.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/Distance.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/LineIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/RobustLineIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/RayCrossingCounter.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/PointLocation.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryCollectionIterator.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/PointLocator.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/IntersectionMatrix.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Quadrant.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeEnd.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Position.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/TopologyLocation.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Label.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/EdgeEndBuilder.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/GraphComponent.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Node.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/NodeMap.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/TopologyException.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/locate/PointOnGeometryLocator.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/locate/SimplePointInAreaLocator.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeEndStar.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChain.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/SweepLineEvent.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/EdgeSetIntersector.js","webpack:///./node_modules/jsts/java/util/Collections.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/SegmentIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/SimpleMCSweepLineIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/ItemVisitor.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/intervalrtree/IntervalRTreeNode.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/intervalrtree/IntervalRTreeLeafNode.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/intervalrtree/IntervalRTreeBranchNode.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/intervalrtree/SortedPackedIntervalRTree.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/LineSegment.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/util/LinearComponentExtracter.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/ArrayListVisitor.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/locate/IndexedPointInAreaLocator.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeIntersection.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeIntersectionList.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChainIndexer.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChainEdge.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Depth.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Edge.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/DirectedEdge.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/NodeFactory.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/PlanarGraph.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/GeometryGraph.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/EdgeEndBundle.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/EdgeEndBundleStar.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/RelateNode.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/RelateNodeFactory.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/RelateComputer.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/GeometryGraphOperation.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/predicate/RectangleContains.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/RectangleLineIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/util/ShortCircuitedGeometryVisitor.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/predicate/RectangleIntersects.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/RelateOp.js","webpack:///./src/facade/js/filter.js","webpack:///./src/facade/js/attributions.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Attributions","map","_this","_classCallCheck","this","_possibleConstructorReturn","_getPrototypeOf","map_","M","type","callback","getMapImpl","on","AttributionsControl","impl","Control","html","getInteractions","forEach","interaction","ol","DoubleClickZoom","dblClickInteraction_","_get","attributionscontrol_getPrototypeOf","facadeMap_","removeControl","translations","en","es","getValue","keyPath","res","lang","arguments","length","undefined","language","getLang","translation","getTranslation","utils","isNullOrEmpty","console","warn","concat","split","reduce","prev","current","log2","floor","pow","MAX_REL_BITS_INTEGER","f64buf","i32buf","position","closePanel","js_attributionscontrol_classCallCheck","isUndefined","AttributionsImplControl","exception","js_attributionscontrol_possibleConstructorReturn","js_attributionscontrol_getPrototypeOf","_this2","Promise","success","fail","template","compileSync","vars","icon","querySelector","addEventListener","html_","control","getImpl","destroy","hasInterface","interfaces_","indexOf","Clonable","CoordinateSequence_CoordinateSequence","[object Object]","constructor_","apply","index","ordinateIndex","env","X","Y","Z","CoordinateSequenceFactory_CoordinateSequenceFactory","Array","IllegalArgumentException","message","GeometryComponentFilter","geom","Comparable","Serializable","NumberUtil","x1","x2","tolerance","Math","abs","Long","high","low","Double","Comparator","RuntimeException","stack","Error","toBinaryString","result","mask","isNaN","Number","isInfinite","isFinite","MAX_VALUE","Float64Array","Int32Array","buffer","doubleToLongBits","longBitsToDouble","bits","x","y","f","skip","sign","exp","NEGATIVE_INFINITY","Infinity","fract","BIAS","NaN","constructor","AssertionFailedException_AssertionFailedException","super","Assert_Assert","shouldNeverReachHere","assertion","isTrue","expectedValue","actualValue","equals","Coordinate_Coordinate","trunc","z","other","equalsWithTolerance","equals2D","e","CloneNotSupportedException","dx","dy","dz","sqrt","hashCode","Coordinate_DimensionalComparator","a","b","o1","o2","c1","c2","compX","compare","compY","_dimensionsToTest","dimensionsToTest","DimensionalComparator","NULL_ORDINATE","serialVersionUID","Envelope_Envelope","p1","p2","q","q1","q2","minq","min","maxq","max","minp","maxp","getWidth","getHeight","otherEnvelope","isNull","_maxx","getMaxX","_maxy","getMaxY","_minx","getMinX","_miny","getMinY","intersects","intMinX","intMinY","intMaxX","intMaxY","covers","expandToInclude","w","h","transX","transY","init","distance","expandBy","deltaX","deltaY","setToNull","y1","y2","Geometry_Geometry","getTypeCode","TYPECODE_GEOMETRYCOLLECTION","_factory","g","equalsTopo","equalsExact","geometryChangedFilter","_envelope","norm","isEmpty","compareToSameClass","comp","_userData","_SRID","getFactory","toGeometry","getEnvelopeInternal","copy","normalize","getPrecisionModel","computeEnvelopeInternal","SRID","userData","iterator","j","hasNext","aElement","next","bElement","comparison","compareTo","TYPECODE_MULTIPOINT","TYPECODE_MULTILINESTRING","TYPECODE_MULTIPOLYGON","geometries","array","factory","getSRID","TYPECODE_POINT","TYPECODE_LINESTRING","TYPECODE_LINEARRING","TYPECODE_POLYGON","TYPENAME_POINT","TYPENAME_MULTIPOINT","TYPENAME_LINESTRING","TYPENAME_LINEARRING","TYPENAME_MULTILINESTRING","TYPENAME_POLYGON","TYPENAME_MULTIPOLYGON","TYPENAME_GEOMETRYCOLLECTION","geometryChangedAction","CoordinateFilter","coord","BoundaryNodeRule","boundaryCount","Mod2BoundaryNodeRule","EndPointBoundaryNodeRule","MultiValentEndPointBoundaryNodeRule","MonoValentEndPointBoundaryNodeRule","Iterator","Collection","IndexOutOfBoundsException","List","NoSuchElementException","OperationNotSupported","ArrayList","array_","addAll","MOD2_BOUNDARY_RULE","ENDPOINT_BOUNDARY_RULE","MULTIVALENT_ENDPOINT_BOUNDARY_RULE","MONOVALENT_ENDPOINT_BOUNDARY_RULE","OGC_SFS_BOUNDARY_RULE","remove","add","size","toArray","set","ensureCapacity","push","splice","clear","element","oldElement","Iterator_","len","found","removeAll","arrayList","arrayList_","position_","CoordinateList_CoordinateList","coll","allowRepeated","isChanged","clone","coordArrayType","obj","isInteger","start","end","inc","fill","MathUtil_MathUtil","ln","log","LOG_10","v1","v2","v3","v4","System","arraycopy","src","srcPos","dest","destPos","getProperty","line.separator","CoordinateArrays_CoordinateArrays","pts","testPts","testPt","coordinates","firstCoordinate","newCoordinates","coord1","coord2","coordinateComparator","coordList","toCoordinateArray","hasRepeatedPoints","last","mid","tmp","nonNull","newCoord","srcStart","destStart","pts1","pts2","coordinate","minCoord","clamp","npts","extractPts","iPts","CoordinateArrays_ForwardComparator","CoordinateArrays_BidirectionalComparator","forwardComp","isEqualReversed","dir1","increasingDirection","dir2","i1","i2","comparePt","Map_Map","SortedMap","Set","HashSet","ForwardComparator","BidirectionalComparator","put","values","entrySet","contains","javascript","util","HashSet_Iterator_","hashSet","hashSet_","BLACK","colorOf","color","parentOf","parent","setColor","leftOf","left","rightOf","right","TreeMap","root_","size_","cmp","oldValue","fixAfterInsertion","rotateLeft","rotateRight","getFirstEntry","successor","ch","containsKey","Lineal","SortedSet","TreeSet","TreeSet_Iterator_","Map_i","treeSet","treeSet_","Arrays","Character","sort","comparator","slice","asList","isWhitespace","toUpperCase","Dimension_Dimension","dimensionValue","FALSE","SYM_FALSE","TRUE","SYM_TRUE","DONTCARE","SYM_DONTCARE","P","SYM_P","L","SYM_L","A","SYM_A","dimensionSymbol","GeometryFilter","CoordinateSequenceFilter","seq","GeometryCollection_GeometryCollection","envelope","_geometries","getNumPoints","k","childCoordinates","getCoordinates","area","getArea","isEquivalentClass","otherCollection","getCoordinate","dimension","getBoundaryDimension","getDimension","sum","getLength","numPoints","revGeoms","reverse","createGeometryCollection","theseElements","otherElements","gc","n1","getNumGeometries","n2","thisGeom","getGeometryN","otherGeom","holeComp","filter","isDone","isGeometryChanged","geometryChanged","checkNotGeometryCollection","hasNullElements","MultiLineString_MultiLineString","isClosed","nLines","revLines","createMultiLineString","BoundaryOp_BoundaryOp","getBoundary","lineStrings","bnRule","mLine","_geom","getEmptyMultiPoint","bdyPts","computeBoundaryCoordinates","_geomFact","createPoint","createMultiPointFromCoords","LineString_LineString","boundaryLineString","boundaryMultiLineString","line","_bnRule","isInBoundary","getStartPoint","createMultiPoint","getEndPoint","_endpointMap","addEndpoint","getCoordinateN","it","entry","valence","count","getKey","pt","counter","Counter","Length_Length","x0","y0","PrintStream","StringReader","ByteArrayOutputStream","IOException","LineNumberReader","StringUtil_StringUtil","String","os","ps","printStackTrace","toString","depth","stackTrace","lineNumberReader","getStackTrace","readLine","NEWLINE","separator","separatorlen","tokenList","tmpString","pos","token","substring","SIMPLE_ORDINATE_FORMAT","format","chars","StringBuilder","str","append","setCharAt","substr","CoordinateSequences_CoordinateSequences","minDim","dim","setOrdinate","getOrdinate","cs1","cs2","cs1Size","fact","newseq","swap","copyCoord","cs","builder","createClosedRing","_points","expandEnvelope","isSimple","otherLineString","equal","getPointN","ofLine","createLineString","points","getCoordinateSequenceFactory","Puntal","Point_Point","_coordinates","getX","getY","IllegalStateException","point","Area_Area","ring","ofRingSigned","p0","StringBuffer","Integer","intValue","DD_DD","valueOf","selfMultiply","parse","strlen","charAt","isNegative","signCh","val","numDigits","numBeforeDec","isDigit","TEN","selfAdd","expStr","parseInt","ex","NumberFormatException","val2","numDecPlaces","scale","divide","multiply","negate","dd","xAbs","xLog10","xMag","buf","_hi","_lo","insertDecimalPoint","magnitude","mag","gt","lt","ONE","decimalPointPos","MAX_PRINT_DIGITS","digit","rebiasBy10","digitChar","subtract","continueExtractingDigits","remMag","isZero","le","selfDivide","yhi","ylo","tc","ty","C","U","hc","hy","u","SPLIT","createNaN","sqr","reciprocal","fhi","ceil","flo","ge","ax","axdd","d2","H","S","T","zhi","zlo","tx","hx","toStandardNotation","toSciNotation","specialStr","getSpecialNumberString","sigDigits","extractSignificantDigits","num","stringOfChar","numZeroes","SCI_NOT_ZERO","digits","SCI_NOT_EXPONENT_CHAR","trailingDigits","digitsWithDecimal","hi","lo","isPositive","PI","TWO_PI","PI_2","E","EPS","CGAlgorithmsDD_CGAlgorithmsDD","orientationIndexFilter","dx1","dy1","dx2","dy2","selfSubtract","signum","denom1","denom2","denom","numx1","numx2","fracP","doubleValue","numy1","numy2","fracQ","pa","pb","pc","detsum","detleft","detright","det","errbound","DP_SAFE_EPSILON","Orientation_Orientation","orientationIndex","nPts","hiPt","hiIndex","iPrev","iNext","disc","CLOCKWISE","RIGHT","COUNTERCLOCKWISE","LEFT","COLLINEAR","STRAIGHT","Polygonal","Polygon_Polygon","_shell","shellCoordinates","_holes","ofRing","getCoordinateSequence","getNumInteriorRing","prevX","prevY","otherPolygon","thisShell","otherPolygonShell","clockwise","uniqueCoordinates","minCoordinate","scroll","isCCW","poly","getExteriorRing","convexHull","otherShell","shellComp","nHole1","nHole2","thisHole","getInteriorRingN","otherHole","rings","createLinearRing","shellCopy","holeCopies","shell","holes","hasNonEmptyElements","MultiPoint_MultiPoint","LinearRing_LinearRing","MINIMUM_VALID_SIZE","GeometryFactory_GeometryFactory","validateConstruction","MultiPolygon_MultiPolygon","createMultiPolygon","allRings","allRingsArray","polygons","GeometryEditor_GeometryEditor","isUserDataCopied","_isUserDataCopied","geometry","operation","editInternal","setUserData","getUserData","editGeometryCollection","editPolygon","edit","getClass","getName","collection","collectionForType","polygon","newPolygon","createPolygon","hole","GeometryEditorOperation","NoOpGeometryOperation","GeometryEditor_CoordinateOperation","GeometryEditor_CoordinateSequenceOperation","CoordinateOperation","CoordinateSequenceOperation","CoordinateArraySequence_CoordinateArraySequence","_dimension","cloneCoordinates","strBuilder","coordSeq","getCoordinateCopy","CoordinateArraySequenceFactory_CoordinateArraySequenceFactory","instanceObject","instance","jsts_Map","proto","objectOnly","_keys","_values","_itp","sharedSize","delete","has","list","TypeError","keys","sharedIterator","entries","context","done","itp","array2","v","MapImpl","Map","HashMap","PrecisionModel_PrecisionModel","pm1","pm2","otherPrecisionModel","_modelType","_scale","getMaximumSignificantDigits","otherSigDigits","FLOATING","FLOATING_SINGLE","description","FIXED","getScale","round","makePrecise","maxSigDigits","PrecisionModel_Type","nameToTypeMap","_name","Type","modelType","setScale","pm","maximumPreciseValue","multiPolygons","multiPolygonArray","geometryArray","multiLineStrings","multiLineStringArray","lineStringArray","multiPoints","multiPointArray","linearRings","linearRingArray","pointArray","polygonArray","exemplar","geomList","geomClass","isHeterogeneous","hasGeometryCollection","partClass","toGeometryArray","geom0","toPolygonArray","toLineStringArray","toPointArray","_coordinateSequenceFactory","GeometryFactory_CloneOp","_precisionModel","ptSeq","coordinateSequenceFactory","CloneOp","precisionModel","getDefaultCoordinateSequenceFactory","geometryTypes","GeoJSONParser_GeoJSONParser","geometryFactory","json","JSON","getGeometryType","extract","Feature","feature","read","bbox","FeatureCollection","featureCollection","features","sub","Point","MultiPoint","LineString","MultiLineString","Polygon","linearRing","MultiPolygon","GeometryCollection","multipoint","geoJson","linestring","multilinestring","shellGeoJson","holeGeoJson","multipolygon","GeoJSONReader_GeoJSONReader","parser","regExes","typeStr","emptyTypeStr","spaces","parenComma","doubleParenComma","trimParens","WKTParser_WKTParser","wkt","replace","matches","exec","search","toLowerCase","WKTParser_parse","extractGeometry","WKTParser_extract","wktType","join","linearring","coords","trim","parseFloat","components","lines","wktArray","WKTWriter_WKTWriter","write","Location_Location","locationValue","EXTERIOR","BOUNDARY","INTERIOR","NONE","Exception","NotRepresentableException_NotRepresentableException","HCoordinate_HCoordinate","px","py","pw","qx","qy","qw","xInt","yInt","_x","_y","_w","Distance_Distance","B","D","pointToSegment","noIntersection","r_num","len2","minDistance","dist","LineIntersector_LineIntersector","pdx","pdy","segmentIndex","intIndex","computeIntLineIndex","_intLineIndex","catBuilder","isEndPoint","_isProper","isCollinear","p3","p4","_inputLines","_result","computeIntersect","getEdgeDistance","hasIntersection","isInteriorIntersection","inputLineIndex","_intPt","NO_INTERSECTION","computeEdgeDistance","COLLINEAR_INTERSECTION","toLineString","getTopologySummary","ptIndex","_pa","_pb","DONT_INTERSECT","DO_INTERSECT","POINT_INTERSECTION","RobustLineIntersector_RobustLineIntersector","nearestPt","minDist","intPt","env0","env1","computeIntersection","n3","n4","normPt","smallestInAbsValue","intersection","nearestEndpoint","intersectionWithNormalization","isInSegmentEnvelopes","x3","x4","xabs","intPtDD","isIn","out","println","normalizeToEnvCentre","safeHCoordinateIntersection","p1q1p2","p1q2p2","q1p1q2","q1p2q2","n00","n01","n10","n11","minX0","minY0","maxX0","maxY0","minX1","minY1","maxX1","maxY1","intMidX","intMidY","Pq1","Pq2","Qp1","Qp2","computeCollinearIntersection","RayCrossingCounter_RayCrossingCounter","countSegment","isOnSegment","getLocation","_p","_isPointOnSegment","minx","maxx","orient","_crossingCount","PointLocation_PointLocation","lineIntersector","locatePointInRing","locateInRing","GeometryCollectionIterator_GeometryCollectionIterator","_atStart","isAtomic","_parent","_index","_subcollectionIterator","_max","UnsupportedOperationException","PointLocator_PointLocator","locate","loc","_isIn","_numBoundaries","updateLocationInfo","locateOnPoint","locateOnLineString","locateInPolygon","ml","mpoly","geomi","g2","computeLocation","isOnLine","shellLoc","locateInPolygonRing","holeLoc","_boundaryRule","boundaryRule","IntersectionMatrix_IntersectionMatrix","actualDimensionValue","requiredDimensionSymbol","actualDimensionSymbols","requiredDimensionSymbols","isDisjoint","_matrix","dimensionSymbols","row","col","toDimensionValue","column","minimumDimensionSymbols","setAtLeast","minimumDimensionValue","dimensionOfGeometryA","dimensionOfGeometryB","isTouches","ai","bi","toDimensionSymbol","temp","im","setAll","elements","Quadrant_Quadrant","quad","NE","NW","quad1","quad2","halfPlane","SE","SW","EdgeEnd_EdgeEnd","_dx","_dy","_quadrant","_p0","_p1","node","_node","angle","atan2","className","lastDotPos","lastIndexOf","print","_label","compareDirection","_edge","boundaryNodeRule","quadrant","edge","label","Position","ON","TopologyLocation_TopologyLocation","locValue","location","gl","newLoc","toLocationSymbol","posIndex","setLocation","locIndex","setAllLocations","Label_Label","lineLabel","elt","geomIndex","setAllLocationsIfNull","isLine","lbl","merge","flip","isArea","isAnyNull","side","isEqualOnSide","allPositionsEqual","onLoc","leftLoc","rightLoc","setLocations","EdgeEndBuilder_EdgeEndBuilder","eiCurr","eiNext","pNext","getLabel","eiPrev","pPrev","edges","computeEdgeEnds","eiList","getEdgeIntersectionList","addEndpoints","createEdgeEndForPrev","createEdgeEndForNext","GraphComponent_GraphComponent","isVisited","_isVisited","isInResult","_isInResult","_isCovered","_isCoveredSet","isCovered","getGeometryCount","computeIM","Node_Node","getEdges","getEdge","_coord","label2","eltIndex","nLoc","setLabel","argIndex","onLocation","_edges","mergeLabel","computeMergedLocation","insert","setNode","NodeMap_NodeMap","nodeMap","nodeFact","createNode","bdyNodes","addNode","TopologyException_TopologyException","msg","msgWithCoord","PointOnGeometryLocator","SimplePointInAreaLocator_SimplePointInAreaLocator","locatePointInPolygon","locateInGeometry","EdgeEndStar_EdgeEndStar","ee","_edgeList","iNextCW","startLoc","currLoc","geomGraph","computeEdgeEndLabels","getBoundaryNodeRule","checkAreaLabelsConsistent","lastEdgeIndex","eSearch","_edgeMap","_ptInAreaLocation","getGeometry","computeLabel","propagateSideLabels","hasDimensionalCollapseEdge","MonotoneChain","mc","si","mce","computeIntersectsForChain","chainIndex","SweepLineEvent_SweepLineEvent","_eventType","DELETE","deleteEventIndex","_deleteEventIndex","_obj","pe","_xValue","_insertEvent","INSERT","ev","insertEvent","EdgeSetIntersector","Collections","reverseOrder","alen","singletonList","util_Collections","SegmentIntersector","e0","segIndex0","e1","segIndex1","_li","getIntersectionNum","isAdjacentSegments","maxSegIndex","_properIntersectionPoint","isDoneWhenProperInt","_isDoneWhenProperInt","_hasProperInterior","li","isIntersection","_hasProper","_hasIntersection","_isDone","isBoundaryPointInternal","bdyNodes0","bdyNodes1","_bdyNodes","numTests","p00","p01","p10","p11","_recordIsolated","setIsolated","_numIntersections","isTrivialIntersection","_includeProper","isProper","addIntersections","getIntersection","isBoundaryPoint","_isSelfIntersection","includeProper","recordIsolated","SimpleMCSweepLineIntersector_SimpleMCSweepLineIntersector","events","isDelete","getInsertEvent","setDeleteEventIndex","nOverlaps","prepareEvents","isInsert","processOverlaps","getDeleteEventIndex","edges0","edges1","addEdges","computeIntersections","edgeSet","getMonotoneChainEdge","startIndex","getStartIndexes","ev0","mc0","getObject","ev1","mc1","isSameLabel","addEdge","ItemVisitor","item","IntervalRTreeNode_IntervalRTreeNode","_min","queryMin","queryMax","IntervalRTreeNode_NodeComparator","mid1","mid2","NodeComparator","POSITIVE_INFINITY","IntervalRTreeLeafNode_IntervalRTreeLeafNode","visitor","visitItem","_item","IntervalRTreeBranchNode_IntervalRTreeBranchNode","_node1","query","_node2","buildExtent","SortedPackedIntervalRTree_SortedPackedIntervalRTree","_leaves","buildLevel","_root","buildTree","_level","buildRoot","LineSegment_LineSegment","seg","orient0","orient1","geomFactory","projectionFactor","pf0","pf1","newp0","project","newp1","pointToLinePerpendicular","midPoint","closestPt","close00","closestPoint","close01","close10","close11","factor","comp0","segmentLengthFraction","offsetDistance","segx","segy","ux","uy","ls","setCoordinates","inputPt","segFrac","segmentToSegment","bits0","java","hash0","bits1","LinearComponentExtracter_LinearComponentExtracter","buildGeometry","getLines","forceToLineString","geoms","_isForcedToLineString","_lines","isForcedToLineString","ArrayListVisitor_ArrayListVisitor","_items","IndexedPointInAreaLocator_IndexedPointInAreaLocator","rcc","IndexedPointInAreaLocator_SegmentVisitor","_counter","IndexedPointInAreaLocator_IntervalIndexedGeometry","addLine","getItems","SegmentVisitor","IntervalIndexedGeometry","EdgeIntersection_EdgeIntersection","maxSegmentIndex","EdgeIntersectionList_EdgeIntersectionList","_nodeMap","edgeList","ei","newEdge","createSplitEdge","ei0","ei1","lastSegStartPt","useIntPt1","ipt","Edge_Edge","eiNew","MonotoneChainIndexer_MonotoneChainIndexer","startIndexList","findChainEnd","toIntArray","chainQuad","MonotoneChainEdge_MonotoneChainEdge","chainIndex0","chainIndex1","start0","end0","start1","end1","overlaps","mid0","mcb","getChainStartIndices","Depth_Depth","NULL_VALUE","_depth","depthValue","minDepth","newValue","depthAtLocation","updateIM","setAtLeastIfValid","newPts","toLineLabel","_isIsolated","isIsolated","isEqualForward","isEqualReverse","iRev","_depthDelta","_mce","_env","normalizedSegmentIndex","nextSegIndex","nextPt","depthDelta","addIntersection","DirectedEdge_DirectedEdge","currLocation","nextLocation","_nextMin","_isForward","_next","depthVal","isInteriorAreaEdge","nextMin","getDepthDelta","minEdgeRing","_minEdgeRing","isExteriorIfArea0","isExteriorIfArea1","edgeRing","_edgeRing","_sym","printReverse","de","setVisited","directionFactor","oppositePos","opposite","oppositeDepth","setDepth","isForward","computeDirectedLabel","NodeFactory_NodeFactory","PlanarGraph_PlanarGraph","nodes","nodeit","linkResultDirectedEdges","_nodes","find","linkAllDirectedEdges","ep0","ep1","_edgeEndList","eCoord","matchInSameDirection","getEdgeEnds","edgesToAdd","de1","de2","setSym","GeometryGraph_GeometryGraph","determineBoundary","_boundaryNodeRule","computeRingSelfNodes","computeSelfNodes","isDoneIfProperInt","setIsDoneIfProperInt","esi","createEdgeSetIntersector","isRings","_parentGeom","computeAllSegments","addSelfIntersectionNodes","_argIndex","edgelist","addSplitEdges","setBoundaryNodes","getBoundaryNodes","_hasTooFewPoints","insertPoint","addPolygonRing","insertEdge","removeRepeatedPoints","_invalidPoint","_lineEdgeMap","insertBoundaryPoint","_boundaryNodes","isBoundaryNode","_useBoundaryDeterminationRule","lr","cwLeft","cwRight","eLoc","eiIt","addSelfIntersectionNode","addPolygon","addLineString","addPoint","addCollection","_areaPtLocator","_ptLocator","findEdge","parentGeom","EdgeEndBundle_EdgeEndBundle","_edgeEnds","foundInterior","computeLabelSide","computeLabelOn","computeLabelSides","getDirectedCoordinate","EdgeEndBundleStar_EdgeEndBundleStar","eb","insertEdgeEnd","RelateNode_RelateNode","RelateNodeFactory_RelateNodeFactory","RelateComputer_RelateComputer","intersector","dimA","_arg","dimB","hasProper","hasProperIntersection","hasProperInterior","hasProperInteriorIntersection","thisIndex","targetIndex","getEdgeIterator","labelIsolatedEdge","_isolatedEdges","target","computeDisjointIM","computeEdgeIntersections","computeIntersectionNodes","copyNodesAndLabels","labelIsolatedNodes","computeProperIntersectionIM","eeBuilder","ee0","insertEdgeEnds","ee1","labelNodeEdges","labelIsolatedEdges","ni","computeLabelling","getNodeIterator","graphNode","setLabelBoundary","labelIsolatedNode","updateIMFromEdges","ga","gb","_im","arg","GeometryGraphOperation","_resultPrecisionModel","setPrecisionModel","g0","setComputationPrecision","g1","RectangleContains_RectangleContains","rectangle","isPointContainedInBoundary","isLineStringContainedInBoundary","isContainedInBoundary","_rectEnv","isLineSegmentContainedInBoundary","RectangleLineIntersector_RectangleLineIntersector","segEnv","isSegUpwards","_diagDown0","_diagDown1","_diagUp0","_diagUp1","rectEnv","ShortCircuitedGeometryVisitor_ShortCircuitedGeometryVisitor","applyTo","visit","RectangleIntersects","RectangleIntersects_EnvelopeIntersectsVisitor","ecpVisitor","RectangleIntersects_GeometryContainsPointVisitor","_rectangle","containsPoint","riVisitor","RectangleIntersects_RectangleIntersectsSegmentVisitor","_intersects","elementEnv","_containsPoint","rectPt","_rectSeq","containsPointInPolygon","checkIntersectionWithLineStrings","testLine","checkIntersectionWithSegments","seq1","_rectIntersector","RelateOp_RelateOp","isRectangle","getIntersectionMatrix","isCovers","isGeometryCollection","isIntersects","isOverlaps","isCrosses","isContains","_relate","Base","Function","filterFunction","options","filter_classCallCheck","filter_possibleConstructorReturn","filter_getPrototypeOf","filterFunction_","cqlFilter_","cqlFilter","Spatial","FunctionParam","toCQLFilter","wktFormat","WKT","formatedGeometry","intersect","param","paramParameter","layer","Vector","_toConsumableArray","getFeatures","isArray","isObject","parseParamToGeometries","geometryToFilter","geojsonParser","GeoJSONReader","jtsGeomToFilter","some","jtsGeom","RelateOp","MODES","mapAttributions","layerAttributions","mixed","attributions_classCallCheck","attributions_possibleConstructorReturn","attributions_getPrototypeOf","includes","url","layerName","controls_","mode_","url_","config","attributions","type_","layerName_","layer_","scale_","attributionParam_","attributionParam","urlParam_","urlParam","minWidth_","minWidth","maxWidth_","maxWidth","defaultAttribution_","defaultAttribution","defaultURL_","defaultURL","tooltip_","tooltip","urlAttribute","window","setCollapsiblePanel","Plugin","impl_","AttributionsImpl","control_","panel_","ui","Panel","collapsible","innerWidth","collapsedButtonClass","addControls","addPanels","initMode","onMoveEnd","changeAttributions","removeControls","optionsLayer","GeoJSON","displayInLayerSwitcher","KML","getLayers","addLayers","setVisible","clearContent","getMapAttributions","zoom","getZoom","baseLayer","getBaseLayers","isHybrid","attribution","addContent","_this3","getElement","links","attrOpt","arr","link","document","createElement","href","innerHTML","attributeURL","div","querySelectorAll","child","removeChild","visibility","style","display","_this4","updateBBoxFeature","featuresAttributions","bboxFeature_","execute","getAttribute","getPanel","collapse","content","changeContent","_this$map_$getBbox","getBbox","properties","getTemplatePanel","classList","registerEvent","plugin","M$plugin$Attributions","M$control$AttributionsControl","M$impl$control$AttributionsControl"],"mappings":"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","file":"attributions.ol.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = \"<div id=\\\"m-attributions-container\\\" class=\\\"m-control m-container m-attributions\\\">\\n    <button id='close-button' class=\\\"{{icon}}\\\"></button>\\n</div>\";","/**\n * @classdesc\n */\nclass Attributions extends M.Object {\n  /**\n   * @constructor\n   */\n  constructor(map) {\n    super();\n\n    /**\n     * Map of the plugin\n     * @private\n     * @type {M.Map}\n     */\n    this.map_ = map;\n  }\n\n  /**\n   * Register events in ol.Map of M.Map\n   * @public\n   * @function\n   */\n  registerEvent(type, callback) {\n    const olMap = this.map_.getMapImpl();\n\n    olMap.on(type, callback);\n  }\n}\n\nexport default Attributions;\n","/**\n * @module M/impl/control/AttributionsControl\n */\nexport default class AttributionsControl extends M.impl.Control {\n  /**\n   * This function adds the control to the specified map\n   *\n   * @public\n   * @function\n   * @param {M.Map} map to add the plugin\n   * @param {HTMLElement} html of the plugin\n   * @api stable\n   */\n  addTo(map, html) {\n    const olMap = map.getMapImpl();\n    olMap.getInteractions().forEach((interaction) => {\n      if (interaction instanceof ol.interaction.DoubleClickZoom) {\n        this.dblClickInteraction_ = interaction;\n      }\n    });\n    // super addTo - don't delete\n    super.addTo(map, html);\n  }\n\n  /**\n   * This function destroys this control, cleaning the HTML\n   * and unregistering all events\n   *\n   * @public\n   * @function\n   * @api\n   * @export\n   */\n  destroy() {\n    this.facadeMap_.getMapImpl().removeControl(this);\n    this.facadeMap_ = null;\n  }\n}\n","import en from './en';\nimport es from './es';\n\n/**\n * Default object with es and en translate.\n *\n * @const\n * @type {object}\n */\nconst translations = {\n  en,\n  es,\n};\n\nconst getLang = () => {\n  let res = 'es';\n  if (typeof M.language.getLang === 'function') {\n    res = M.language.getLang();\n  }\n\n  return res;\n};\n\n/**\n * This function sets a new language translate.\n * @param {string} lang\n * @param {JSON} json\n * @public\n * @api\n */\nexport const addTranslation = (lang, json) => {\n  translations[lang] = json;\n};\n\n/**\n * This function gets a language translate.\n *\n * @param {string} lang\n * @return {JSON}\n * @public\n * @api\n */\nexport const getTranslation = (lang) => {\n  return translations[lang];\n};\n\n/**\n * This function gets a language value from key\n *\n * @public\n * @param {string}\n * @param {string}\n * @return {string}\n * @public\n * @api\n */\nexport const getValue = (keyPath, lang = getLang()) => {\n  const translation = getTranslation(lang);\n  let value = '';\n  if (M.utils.isNullOrEmpty(translation)) {\n    console.warn(`The translation '${lang}' has not been defined.`);\n  } else {\n    value = keyPath.split('.').reduce((prev, current) => prev[current], translation);\n  }\n  return value;\n};\n","import Long from './Long';\n\nexport default function Double () {}\n\nDouble.isNaN = n => Number.isNaN(n)\nDouble.isInfinite = n => !Number.isFinite(n)\nDouble.MAX_VALUE = Number.MAX_VALUE\n\nif (typeof Float64Array == 'function' &&\n\t  typeof Int32Array == 'function') {\n\t// Simple and fast conversion between double and long bits\n\t// using TypedArrays and ArrayViewBuffers.\n\t(function() {\n\t\tvar EXP_BIT_MASK = 0x7ff00000;\n\t\tvar SIGNIF_BIT_MASK = 0xFFFFF;\n\t\tvar f64buf = new Float64Array(1);\n\t\tvar i32buf = new Int32Array(f64buf.buffer);\n\t\tDouble.doubleToLongBits = function (value) {\n\t\t\tf64buf[0] = value;\n\t\t\tvar low = i32buf[0] | 0;\n\t\t\tvar high = i32buf[1] | 0;\n\t\t\t// Check for NaN based on values of bit fields, maximum\n\t\t\t// exponent and nonzero significand.\n\t\t\tif (((high & EXP_BIT_MASK) === EXP_BIT_MASK) &&\n\t\t\t\t((high & SIGNIF_BIT_MASK) !== 0) &&\n\t\t\t\t(low !== 0)) {\n\t\t\t\tlow = 0 | 0;\n\t\t\t\thigh = 0x7ff80000 | 0;\n\t\t\t}\n\t\t\treturn new Long(high, low);\n\t\t};\n\t\tDouble.longBitsToDouble = function (bits) {\n\t\t\ti32buf[0] = bits.low;\n\t\t\ti32buf[1] = bits.high;\n\t\t\treturn f64buf[0];\n\t\t};\n\t})();\n} else {\n\t// More complex and slower fallback implementation using \n\t// math and the divide-by-two and multiply-by-two algorithms.\n\t(function() {\n\t\tvar BIAS = 1023;\n\t\tvar log2 = Math.log2;\n\t\tvar floor = Math.floor;\n\t\tvar pow = Math.pow;\n\t\tvar MAX_REL_BITS_INTEGER = (function () {\n\t\t\tfor (var i = 53; i > 0; i--) {\n\t\t\t\tvar bits = pow(2, i) - 1;\n\t\t\t\tif (floor(log2(bits)) + 1 === i) {\n\t\t\t\t\treturn bits;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t})();\n\t\tDouble.doubleToLongBits = function (value) {\n\t\t\tvar x, y, f, bits, skip;\n\t\t\tvar sign, exp, high, low;\n\t\n\t\t\t// Get the sign bit and absolute value.\n\t\t\tif (value < 0 || 1 / value === Number.NEGATIVE_INFINITY) {\n\t\t\t\tsign = (1 << 31);\n\t\t\t\tvalue = (-value);\n\t\t\t} else {\n\t\t\t\tsign = 0;\n\t\t\t}\n\t\n\t\t\t// Handle some special values.\n\t\t\tif (value === 0) {\n\t\t\t\t// Handle zeros (+/-0).\n\t\t\t\tlow = 0 | 0;\n\t\t\t\thigh = sign; // exponent: 00..00, significand: 00..00\n\t\t\t\treturn new Long(high, low);\n\t\t\t}\n\t\n\t\t\tif (value === Infinity) {\n\t\t\t\t// Handle infinity (only positive values for value possible).\n\t\t\t\tlow = 0 | 0;\n\t\t\t\thigh = sign | 0x7ff00000; // exponent: 11..11, significand: 00..00\n\t\t\t\treturn new Long(high, low);\n\t\t\t}\n\t\n\t\t\tif (value !== value) {\n\t\t\t\t// Handle NaNs (boiled down to only one distinct NaN).\n\t\t\t\tlow = 0 | 0;\n\t\t\t\thigh = 0x7ff80000; // exponent: 11..11, significand: 10..00\n\t\t\t\treturn new Long(high, low);\n\t\t\t}\n\t\n\t\t\t// Preinitialize variables, that are not neccessarily set by\n\t\t\t// the algorithm.\n\t\t\tbits = 0;\n\t\t\tlow = 0 | 0;\n\t\n\t\t\t// Get the (always positive) integer part of value.\n\t\t\tx = floor(value);\n\t\n\t\t\t// Process the integer part if it's greater than 1. Zero requires\n\t\t\t// no bits at all, 1 represents the implicit (hidden) leading bit,\n\t\t\t// which must not be written as well.\n\t\t\tif (x > 1) {\n\t\t\t\t// If we can reliably determine the number of bits required for\n\t\t\t\t// the integer part,\n\t\t\t\tif (x <= MAX_REL_BITS_INTEGER) {\n\t\t\t\t\t// get the number of bits required to represent it minus 1\n\t\t\t\t\tbits = floor(log2(x)) /* + 1 - 1*/ ;\n\t\t\t\t\t// and simply copy/shift the integer bits into low and high.\n\t\t\t\t\t// That's much faster than the divide-by-two algorithm (saves\n\t\t\t\t\t// up to ~60%).\n\t\t\t\t\t// We always need to mask out the most significant bit, which\n\t\t\t\t\t// is the implicit (aka hidden) bit.\n\t\t\t\t\tif (bits <= 20) {\n\t\t\t\t\t\t// The simple case in which the integer fits into the\n\t\t\t\t\t\t// lower 20 bits of the high word is worth to be handled\n\t\t\t\t\t\t// separately (saves ~25%).\n\t\t\t\t\t\tlow = 0 | 0;\n\t\t\t\t\t\thigh = (x << (20 - bits)) & 0xfffff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Here, the integer part is split into low and high.\n\t\t\t\t\t\t// Since its value may require more than 32 bits, we\n\t\t\t\t\t\t// cannot use bitwise operators (which implicitly cast\n\t\t\t\t\t\t// to Int32), but use arithmetic operators % and / to\n\t\t\t\t\t\t// get low and high parts. The uppper 20 bits go to high,\n\t\t\t\t\t\t// the remaining bits (in f) to low.\n\t\t\t\t\t\tf = bits - 20;\n\t\t\t\t\t\t// Like (1 << f) but safe with even more than 32 bits.\n\t\t\t\t\t\ty = pow(2, f);\n\t\t\t\t\t\tlow = (x % y) << (32 - f);\n\t\t\t\t\t\thigh = (x / y) & 0xfffff;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// For greater values, we must use the much slower divide-by-two\n\t\t\t\t\t// algorithm. Bits are generated from right to left, that is from\n\t\t\t\t\t// least to most significant bit. For each bit, we left-shift both\n\t\t\t\t\t// low and high by one and carry bit #0 from high to #31 in low.\n\t\t\t\t\t// The next bit is then copied into bit #19 in high, the leftmost\n\t\t\t\t\t// bit of the double's significand.\n\t\n\t\t\t\t\t// Preserve x for later user, so work with f.\n\t\t\t\t\tf = x;\n\t\t\t\t\tlow = 0 | 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\ty = f / 2;\n\t\t\t\t\t\tf = floor(y);\n\t\t\t\t\t\tif (f === 0) {\n\t\t\t\t\t\t\t// We just found the most signigicant (1-)bit, which\n\t\t\t\t\t\t\t// is the implicit bit and so, not stored in the double\n\t\t\t\t\t\t\t// value. So, it's time to leave the loop.\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Count this bit, shift low and carry bit #0 from high.\n\t\t\t\t\t\tbits++;\n\t\t\t\t\t\tlow >>>= 1;\n\t\t\t\t\t\tlow |= (high & 0x1) << 31;\n\t\t\t\t\t\t// Shift high.\n\t\t\t\t\t\thigh >>>= 1;\n\t\t\t\t\t\tif (y !== f) {\n\t\t\t\t\t\t\t// Copy the new bit into bit #19 in high (only required if 1).\n\t\t\t\t\t\t\thigh |= 0x80000;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Bias the exponent.\n\t\t\texp = bits + BIAS;\n\t\n\t\t\t// If the integer part is zero, we've not yet seen the implicit\n\t\t\t// leading bit. Variable skip is later used while processing the \n\t\t\t// fractional part (if any).\n\t\t\tskip = (x === 0);\n\t\n\t\t\t// Get fraction only into x.\n\t\t\tx = value - x;\n\t\n\t\t\t// If some significand bits are still left to be filled and\n\t\t\t// the fractional part is not zero, convert the fraction using\n\t\t\t// the multiply-by-2 algorithm.\n\t\t\tif (bits < 52 && x !== 0) {\n\t\n\t\t\t\t// Initialize 'buffer' f, into which newly created bits get\n\t\t\t\t// shifted from right to left.\n\t\t\t\tf = 0;\n\t\n\t\t\t\twhile (true) {\n\t\t\t\t\ty = x * 2;\n\t\t\t\t\tif (y >= 1) {\n\t\t\t\t\t\t// This is a new 1-bit. Add and count this bit, if not\n\t\t\t\t\t\t// prohibited by skip.\n\t\t\t\t\t\tx = y - 1;\n\t\t\t\t\t\tif (!skip) {\n\t\t\t\t\t\t\tf <<= 1;\n\t\t\t\t\t\t\tf |= 1;\n\t\t\t\t\t\t\tbits++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Otherwise, decrement the exponent and unset\n\t\t\t\t\t\t\t// skip, so that all following bits get written.\n\t\t\t\t\t\t\texp--;\n\t\t\t\t\t\t\tskip = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// This is a new 0-bit. Add and count this bit, if not\n\t\t\t\t\t\t// prohibited by skip.\n\t\t\t\t\t\tx = y;\n\t\t\t\t\t\tif (!skip) {\n\t\t\t\t\t\t\tf <<= 1;\n\t\t\t\t\t\t\tbits++;\n\t\t\t\t\t\t} else if (--exp === 0) {\n\t\t\t\t\t\t\t// Otherwise we've just decremented the exponent. If the\n\t\t\t\t\t\t\t// biased exponent is zero now (-1023), we process a\n\t\t\t\t\t\t\t// subnormal number, which has no impled leading 1-bit.\n\t\t\t\t\t\t\t// So, count this 0-bit and unset skip to write out\n\t\t\t\t\t\t\t// all the following bits.\n\t\t\t\t\t\t\tbits++;\n\t\t\t\t\t\t\tskip = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (bits === 20) {\n\t\t\t\t\t\t// When 20 bits have been created in total, we're done with\n\t\t\t\t\t\t// the high word. Copy the bits from 'buffer' f into high\n\t\t\t\t\t\t// and reset 'buffer' f. Following bits will end up in the\n\t\t\t\t\t\t// low word.\n\t\t\t\t\t\thigh |= f;\n\t\t\t\t\t\tf = 0;\n\t\t\t\t\t} else if (bits === 52) {\n\t\t\t\t\t\t// When 52 bits have been created in total, we're done with\n\t\t\t\t\t\t// low word as well. Copy the bits from 'buffer' f into low\n\t\t\t\t\t\t// and exit the loop.\n\t\t\t\t\t\tlow |= f;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (y === 1) {\n\t\t\t\t\t\t// When y is exactly 1, there is no remainder and the process\n\t\t\t\t\t\t// is complete (the number is finite). Copy the bits from\n\t\t\t\t\t\t// 'buffer' f into either low or high and exit the loop.\n\t\t\t\t\t\tif (bits < 20) {\n\t\t\t\t\t\t\thigh |= (f << (20 - bits));\n\t\t\t\t\t\t} else if (bits < 52) {\n\t\t\t\t\t\t\tlow |= (f << (52 - bits));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Copy/shift the exponent and sign bits into the high word.\n\t\t\thigh |= (exp << 20);\n\t\t\thigh |= sign;\n\t\n\t\t\treturn new Long(high, low);\n\t\t};\n\t\tDouble.longBitsToDouble = function (bits) {\n\t\t\tvar x, sign, exp, fract;\n\t\t\tvar high = bits.high;\n\t\t\tvar low = bits.low;\n\t\n\t\t\t// Extract the sign.\n\t\t\tsign = (high & (1 << 31)) ? -1 : 1;\n\t\n\t\t\t// Extract the unbiased exponent.\n\t\t\texp = ((high & 0x7ff00000) >> 20) - BIAS;\n\t\n\t\t\t// Calculate the fraction from left to right. Start\n\t\t\t// off with the 20 lower bits from the high word.\n\t\t\tfract = 0;\n\t\t\tx = (1 << 19);\n\t\t\tfor (var i = 1; i <= 20; i++) {\n\t\t\t\tif (high & x) {\n\t\t\t\t\tfract += pow(2, -i);\n\t\t\t\t}\n\t\t\t\tx >>>= 1;\n\t\t\t}\n\t\t\t// Continue with all 32 bits from the low word.\n\t\t\tx = (1 << 31);\n\t\t\tfor (var i = 21; i <= 52; i++) {\n\t\t\t\tif (low & x) {\n\t\t\t\t\tfract += pow(2, -i);\n\t\t\t\t}\n\t\t\t\tx >>>= 1;\n\t\t\t}\n\t\n\t\t\t// Handle special values.\n\t\t\t// Check for zero and subnormal values.\n\t\t\tif (exp === -BIAS) {\n\t\t\t\tif (fract === 0) {\n\t\t\t\t\t// +/-1.0 * 0.0 => +/-0.0\n\t\t\t\t\treturn sign * 0;\n\t\t\t\t}\n\t\t\t\texp = -1022;\n\t\t\t}\n\t\t\t// Check for +/-Infinity or NaN.\n\t\t\telse if (exp === BIAS + 1) {\n\t\t\t\tif (fract === 0) {\n\t\t\t\t\t// +/-1.0 / 0.0 => +/-Infinity\n\t\t\t\t\treturn sign / 0;\n\t\t\t\t}\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// Nothing special? Seems to be a normal number.\n\t\t\telse {\n\t\t\t\t// Add the implicit leading bit (1*2^0).\n\t\t\t\tfract += 1;\n\t\t\t}\n\t\n\t\t\treturn sign * fract * pow(2, exp);\n\t\t};\n\t})();\n}","/**\n * @module M/control/AttributionsControl\n */\nimport AttributionsImplControl from '../../impl/ol/js/attributionscontrol';\nimport template from '../../templates/attributions';\nimport { getValue } from './i18n/language';\n\n/**\n * @classdesc\n * Main constructor of the class. Creates a PluginControl\n * control\n */\nexport default class AttributionsControl extends M.Control {\n  /**\n   * @constructor\n   * @extends {M.Control}\n   * @api\n   */\n  constructor(position, closePanel) {\n    if (M.utils.isUndefined(AttributionsImplControl)) {\n      M.exception(getValue('exception.impl'));\n    }\n    const impl = new AttributionsImplControl();\n    super(impl, 'Attributions');\n    this.position = position;\n    this.closePanel = closePanel;\n  }\n\n  /**\n   * This function creates the view\n   *\n   * @public\n   * @function\n   * @param {M.Map} map to add the control\n   * @api\n   */\n  createView(map) {\n    this.map = map;\n    return new Promise((success, fail) => {\n      const html = M.template.compileSync(template, {\n        vars: {\n          icon: this.position === 'BR' || this.position === 'TR' ?\n            'g-cartografia-flecha-derecha' : 'g-cartografia-flecha-izquierda',\n        },\n      });\n      html.querySelector('#close-button').addEventListener('click', () => this.closePanel());\n      this.html_ = html;\n\n      success(html);\n    });\n  }\n\n  /**\n   * This function compares controls\n   *\n   * @public\n   * @function\n   * @param {M.Control} control to compare\n   * @api\n   */\n  equals(control) {\n    return control instanceof AttributionsControl;\n  }\n\n  destroy() {\n    this.getImpl().destroy();\n  }\n}\n","export default function (o, i) {\n  return o.interfaces_ && o.interfaces_.indexOf(i) > -1\n}\n","export default function Clonable () {}\n","import Cloneable from '../../../../java/lang/Cloneable';\nexport default class CoordinateSequence {\n\tconstructor() {\n\t\tCoordinateSequence.constructor_.apply(this, arguments);\n\t}\n\tsetOrdinate(index, ordinateIndex, value) {}\n\tsize() {}\n\tgetOrdinate(index, ordinateIndex) {}\n\tgetCoordinate() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet i = arguments[0];\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet index = arguments[0], coord = arguments[1];\n\t\t}\n\t}\n\tgetCoordinateCopy(i) {}\n\tgetDimension() {}\n\tgetX(index) {}\n\texpandEnvelope(env) {}\n\tcopy() {}\n\tgetY(index) {}\n\ttoCoordinateArray() {}\n\tgetClass() {\n\t\treturn CoordinateSequence;\n\t}\n\tget interfaces_() {\n\t\treturn [Cloneable];\n\t}\n}\nCoordinateSequence.constructor_ = function () {};\nCoordinateSequence.X = 0;\nCoordinateSequence.Y = 1;\nCoordinateSequence.Z = 2;\nCoordinateSequence.M = 3;\n","import hasInterface from '../../../../hasInterface';\nimport CoordinateSequence from './CoordinateSequence';\nexport default class CoordinateSequenceFactory {\n\tconstructor() {\n\t\tCoordinateSequenceFactory.constructor_.apply(this, arguments);\n\t}\n\tcreate() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordSeq = arguments[0];\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet size = arguments[0], dimension = arguments[1];\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn CoordinateSequenceFactory;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCoordinateSequenceFactory.constructor_ = function () {};\n","export default function IllegalArgumentException (message) {\n  this.message = message\n}\n","export default class GeometryComponentFilter {\n\tconstructor() {\n\t\tGeometryComponentFilter.constructor_.apply(this, arguments);\n\t}\n\tfilter(geom) {}\n\tgetClass() {\n\t\treturn GeometryComponentFilter;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGeometryComponentFilter.constructor_ = function () {};\n","export default function Comparable () {}\n","export default function Serializable () {}\n","export default class NumberUtil {\n\tconstructor() {\n\t\tNumberUtil.constructor_.apply(this, arguments);\n\t}\n\tstatic equalsWithTolerance(x1, x2, tolerance) {\n\t\treturn Math.abs(x1 - x2) <= tolerance;\n\t}\n\tgetClass() {\n\t\treturn NumberUtil;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nNumberUtil.constructor_ = function () {};\n","export default function Long(high, low) {\n  this.low = low | 0\n  this.high = high | 0\n}\n\nLong.toBinaryString = function (i) {\n  var result = ''\n  for (var mask = 0x80000000; mask > 0; mask >>>= 1)\n    result += (i.high & mask) === mask ? '1' : '0'\n  for (var mask = 0x80000000; mask > 0; mask >>>= 1)\n    result += (i.low & mask) === mask ? '1' : '0'\n  return result\n}","export default function Comparator () {}\n","export default function RuntimeException (message) {\n  this.name = 'RuntimeException'\n  this.message = message\n  this.stack = (new Error()).stack\n  Error.call(this, message)\n}\n\nRuntimeException.prototype = Object.create(Error.prototype)\nRuntimeException.prototype.constructor = Error\n","import RuntimeException from '../../../../java/lang/RuntimeException';\nexport default class AssertionFailedException extends RuntimeException {\n\tconstructor() {\n\t\tsuper();\n\t\tAssertionFailedException.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn AssertionFailedException;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nAssertionFailedException.constructor_ = function () {\n\tif (arguments.length === 0) {\n\t\tRuntimeException.constructor_.call(this);\n\t} else if (arguments.length === 1) {\n\t\tlet message = arguments[0];\n\t\tRuntimeException.constructor_.call(this, message);\n\t}\n};\n","import AssertionFailedException from './AssertionFailedException';\nexport default class Assert {\n\tconstructor() {\n\t\tAssert.constructor_.apply(this, arguments);\n\t}\n\tstatic shouldNeverReachHere() {\n\t\tif (arguments.length === 0) {\n\t\t\tAssert.shouldNeverReachHere(null);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet message = arguments[0];\n\t\t\tthrow new AssertionFailedException(\"Should never reach here\" + (message !== null ? \": \" + message : \"\"));\n\t\t}\n\t}\n\tstatic isTrue() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet assertion = arguments[0];\n\t\t\tAssert.isTrue(assertion, null);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet assertion = arguments[0], message = arguments[1];\n\t\t\tif (!assertion) {\n\t\t\t\tif (message === null) {\n\t\t\t\t\tthrow new AssertionFailedException();\n\t\t\t\t} else {\n\t\t\t\t\tthrow new AssertionFailedException(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic equals() {\n\t\tif (arguments.length === 2) {\n\t\t\tlet expectedValue = arguments[0], actualValue = arguments[1];\n\t\t\tAssert.equals(expectedValue, actualValue, null);\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet expectedValue = arguments[0], actualValue = arguments[1], message = arguments[2];\n\t\t\tif (!actualValue.equals(expectedValue)) {\n\t\t\t\tthrow new AssertionFailedException(\"Expected \" + expectedValue + \" but encountered \" + actualValue + (message !== null ? \": \" + message : \"\"));\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn Assert;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nAssert.constructor_ = function () {};\n","import NumberUtil from '../util/NumberUtil';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Double from '../../../../java/lang/Double';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport Comparator from '../../../../java/util/Comparator';\nimport Serializable from '../../../../java/io/Serializable';\nimport Assert from '../util/Assert';\nexport default class Coordinate {\n\tconstructor() {\n\t\tCoordinate.constructor_.apply(this, arguments);\n\t}\n\tstatic hashCode() {\n\t\tif (arguments.length === 1 && typeof arguments[0] === \"number\") {\n\t\t\tlet x = arguments[0];\n\t\t\tvar f = Double.doubleToLongBits(x);\n\t\t\treturn Math.trunc(f ^ f >>> 32);\n\t\t}\n\t}\n\tsetOrdinate(ordinateIndex, value) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase Coordinate.X:\n\t\t\t\tthis.x = value;\n\t\t\t\tbreak;\n\t\t\tcase Coordinate.Y:\n\t\t\t\tthis.y = value;\n\t\t\t\tbreak;\n\t\t\tcase Coordinate.Z:\n\t\t\t\tthis.z = value;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n\t\t}\n\t}\n\tequals2D() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet other = arguments[0];\n\t\t\tif (this.x !== other.x) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.y !== other.y) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet c = arguments[0], tolerance = arguments[1];\n\t\t\tif (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tgetOrdinate(ordinateIndex) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase Coordinate.X:\n\t\t\t\treturn this.x;\n\t\t\tcase Coordinate.Y:\n\t\t\t\treturn this.y;\n\t\t\tcase Coordinate.Z:\n\t\t\t\treturn this.z;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n\t}\n\tequals3D(other) {\n\t\treturn this.x === other.x && this.y === other.y && (this.z === other.z || Double.isNaN(this.z) && Double.isNaN(other.z));\n\t}\n\tequals(other) {\n\t\tif (!(other instanceof Coordinate)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.equals2D(other);\n\t}\n\tequalInZ(c, tolerance) {\n\t\treturn NumberUtil.equalsWithTolerance(this.z, c.z, tolerance);\n\t}\n\tcompareTo(o) {\n\t\tvar other = o;\n\t\tif (this.x < other.x) return -1;\n\t\tif (this.x > other.x) return 1;\n\t\tif (this.y < other.y) return -1;\n\t\tif (this.y > other.y) return 1;\n\t\treturn 0;\n\t}\n\tclone() {\n\t\ttry {\n\t\t\tvar coord = null;\n\t\t\treturn coord;\n\t\t} catch (e) {\n\t\t\tif (e instanceof CloneNotSupportedException) {\n\t\t\t\tAssert.shouldNeverReachHere(\"this shouldn't happen because this class is Cloneable\");\n\t\t\t\treturn null;\n\t\t\t} else throw e;\n\t\t} finally {}\n\t}\n\tcopy() {\n\t\treturn new Coordinate(this);\n\t}\n\ttoString() {\n\t\treturn \"(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\n\t}\n\tdistance3D(c) {\n\t\tvar dx = this.x - c.x;\n\t\tvar dy = this.y - c.y;\n\t\tvar dz = this.z - c.z;\n\t\treturn Math.sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n\tdistance(c) {\n\t\tvar dx = this.x - c.x;\n\t\tvar dy = this.y - c.y;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\thashCode() {\n\t\tvar result = 17;\n\t\tresult = 37 * result + Coordinate.hashCode(this.x);\n\t\tresult = 37 * result + Coordinate.hashCode(this.y);\n\t\treturn result;\n\t}\n\tsetCoordinate(other) {\n\t\tthis.x = other.x;\n\t\tthis.y = other.y;\n\t\tthis.z = other.z;\n\t}\n\tgetClass() {\n\t\treturn Coordinate;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparable, Cloneable, Serializable];\n\t}\n}\nclass DimensionalComparator {\n\tconstructor() {\n\t\tDimensionalComparator.constructor_.apply(this, arguments);\n\t}\n\tstatic compare(a, b) {\n\t\tif (a < b) return -1;\n\t\tif (a > b) return 1;\n\t\tif (Double.isNaN(a)) {\n\t\t\tif (Double.isNaN(b)) return 0;\n\t\t\treturn -1;\n\t\t}\n\t\tif (Double.isNaN(b)) return 1;\n\t\treturn 0;\n\t}\n\tcompare(o1, o2) {\n\t\tvar c1 = o1;\n\t\tvar c2 = o2;\n\t\tvar compX = DimensionalComparator.compare(c1.x, c2.x);\n\t\tif (compX !== 0) return compX;\n\t\tvar compY = DimensionalComparator.compare(c1.y, c2.y);\n\t\tif (compY !== 0) return compY;\n\t\tif (this._dimensionsToTest <= 2) return 0;\n\t\tvar compZ = DimensionalComparator.compare(c1.z, c2.z);\n\t\treturn compZ;\n\t}\n\tgetClass() {\n\t\treturn DimensionalComparator;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparator];\n\t}\n}\nDimensionalComparator.constructor_ = function () {\n\tthis._dimensionsToTest = 2;\n\tif (arguments.length === 0) {\n\t\tDimensionalComparator.constructor_.call(this, 2);\n\t} else if (arguments.length === 1) {\n\t\tlet dimensionsToTest = arguments[0];\n\t\tif (dimensionsToTest !== 2 && dimensionsToTest !== 3) throw new IllegalArgumentException(\"only 2 or 3 dimensions may be specified\");\n\t\tthis._dimensionsToTest = dimensionsToTest;\n\t}\n};\nCoordinate.DimensionalComparator = DimensionalComparator;\nCoordinate.constructor_ = function () {\n\tthis.x = null;\n\tthis.y = null;\n\tthis.z = null;\n\tif (arguments.length === 0) {\n\t\tCoordinate.constructor_.call(this, 0.0, 0.0);\n\t} else if (arguments.length === 1) {\n\t\tlet c = arguments[0];\n\t\tCoordinate.constructor_.call(this, c.x, c.y, c.z);\n\t} else if (arguments.length === 2) {\n\t\tlet x = arguments[0], y = arguments[1];\n\t\tCoordinate.constructor_.call(this, x, y, Coordinate.NULL_ORDINATE);\n\t} else if (arguments.length === 3) {\n\t\tlet x = arguments[0], y = arguments[1], z = arguments[2];\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t}\n};\nCoordinate.serialVersionUID = 6683108902428366910;\nCoordinate.NULL_ORDINATE = Double.NaN;\nCoordinate.X = 0;\nCoordinate.Y = 1;\nCoordinate.Z = 2;\n","import Coordinate from './Coordinate';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Serializable from '../../../../java/io/Serializable';\nexport default class Envelope {\n\tconstructor() {\n\t\tEnvelope.constructor_.apply(this, arguments);\n\t}\n\tstatic intersects() {\n\t\tif (arguments.length === 3) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1], q = arguments[2];\n\t\t\tif (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && (q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3];\n\t\t\tvar minq = Math.min(q1.x, q2.x);\n\t\t\tvar maxq = Math.max(q1.x, q2.x);\n\t\t\tvar minp = Math.min(p1.x, p2.x);\n\t\t\tvar maxp = Math.max(p1.x, p2.x);\n\t\t\tif (minp > maxq) return false;\n\t\t\tif (maxp < minq) return false;\n\t\t\tminq = Math.min(q1.y, q2.y);\n\t\t\tmaxq = Math.max(q1.y, q2.y);\n\t\t\tminp = Math.min(p1.y, p2.y);\n\t\t\tmaxp = Math.max(p1.y, p2.y);\n\t\t\tif (minp > maxq) return false;\n\t\t\tif (maxp < minq) return false;\n\t\t\treturn true;\n\t\t}\n\t}\n\tgetArea() {\n\t\treturn this.getWidth() * this.getHeight();\n\t}\n\tequals(other) {\n\t\tif (!(other instanceof Envelope)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar otherEnvelope = other;\n\t\tif (this.isNull()) {\n\t\t\treturn otherEnvelope.isNull();\n\t\t}\n\t\treturn this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY();\n\t}\n\tintersection(env) {\n\t\tif (this.isNull() || env.isNull() || !this.intersects(env)) return new Envelope();\n\t\tvar intMinX = this._minx > env._minx ? this._minx : env._minx;\n\t\tvar intMinY = this._miny > env._miny ? this._miny : env._miny;\n\t\tvar intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;\n\t\tvar intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;\n\t\treturn new Envelope(intMinX, intMaxX, intMinY, intMaxY);\n\t}\n\tisNull() {\n\t\treturn this._maxx < this._minx;\n\t}\n\tgetMaxX() {\n\t\treturn this._maxx;\n\t}\n\tcovers() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\treturn this.covers(p.x, p.y);\n\t\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\tif (this.isNull() || other.isNull()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\tif (this.isNull()) return false;\n\t\t\treturn x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy;\n\t\t}\n\t}\n\tintersects() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\tif (this.isNull() || other.isNull()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny);\n\t\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\treturn this.intersects(p.x, p.y);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tif (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\t\t\tlet a = arguments[0], b = arguments[1];\n\t\t\t\tif (this.isNull()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tvar envminx = a.x < b.x ? a.x : b.x;\n\t\t\t\tif (envminx > this._maxx) return false;\n\t\t\t\tvar envmaxx = a.x > b.x ? a.x : b.x;\n\t\t\t\tif (envmaxx < this._minx) return false;\n\t\t\t\tvar envminy = a.y < b.y ? a.y : b.y;\n\t\t\t\tif (envminy > this._maxy) return false;\n\t\t\t\tvar envmaxy = a.y > b.y ? a.y : b.y;\n\t\t\t\tif (envmaxy < this._miny) return false;\n\t\t\t\treturn true;\n\t\t\t} else if (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\t\tif (this.isNull()) return false;\n\t\t\t\treturn !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny);\n\t\t\t}\n\t\t}\n\t}\n\tgetMinY() {\n\t\treturn this._miny;\n\t}\n\tgetMinX() {\n\t\treturn this._minx;\n\t}\n\texpandToInclude() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\tthis.expandToInclude(p.x, p.y);\n\t\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\tif (other.isNull()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (this.isNull()) {\n\t\t\t\t\tthis._minx = other.getMinX();\n\t\t\t\t\tthis._maxx = other.getMaxX();\n\t\t\t\t\tthis._miny = other.getMinY();\n\t\t\t\t\tthis._maxy = other.getMaxY();\n\t\t\t\t} else {\n\t\t\t\t\tif (other._minx < this._minx) {\n\t\t\t\t\t\tthis._minx = other._minx;\n\t\t\t\t\t}\n\t\t\t\t\tif (other._maxx > this._maxx) {\n\t\t\t\t\t\tthis._maxx = other._maxx;\n\t\t\t\t\t}\n\t\t\t\t\tif (other._miny < this._miny) {\n\t\t\t\t\t\tthis._miny = other._miny;\n\t\t\t\t\t}\n\t\t\t\t\tif (other._maxy > this._maxy) {\n\t\t\t\t\t\tthis._maxy = other._maxy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\tif (this.isNull()) {\n\t\t\t\tthis._minx = x;\n\t\t\t\tthis._maxx = x;\n\t\t\t\tthis._miny = y;\n\t\t\t\tthis._maxy = y;\n\t\t\t} else {\n\t\t\t\tif (x < this._minx) {\n\t\t\t\t\tthis._minx = x;\n\t\t\t\t}\n\t\t\t\tif (x > this._maxx) {\n\t\t\t\t\tthis._maxx = x;\n\t\t\t\t}\n\t\t\t\tif (y < this._miny) {\n\t\t\t\t\tthis._miny = y;\n\t\t\t\t}\n\t\t\t\tif (y > this._maxy) {\n\t\t\t\t\tthis._maxy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tminExtent() {\n\t\tif (this.isNull()) return 0.0;\n\t\tvar w = this.getWidth();\n\t\tvar h = this.getHeight();\n\t\tif (w < h) return w;\n\t\treturn h;\n\t}\n\tgetWidth() {\n\t\tif (this.isNull()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._maxx - this._minx;\n\t}\n\tcompareTo(o) {\n\t\tvar env = o;\n\t\tif (this.isNull()) {\n\t\t\tif (env.isNull()) return 0;\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tif (env.isNull()) return 1;\n\t\t}\n\t\tif (this._minx < env._minx) return -1;\n\t\tif (this._minx > env._minx) return 1;\n\t\tif (this._miny < env._miny) return -1;\n\t\tif (this._miny > env._miny) return 1;\n\t\tif (this._maxx < env._maxx) return -1;\n\t\tif (this._maxx > env._maxx) return 1;\n\t\tif (this._maxy < env._maxy) return -1;\n\t\tif (this._maxy > env._maxy) return 1;\n\t\treturn 0;\n\t}\n\ttranslate(transX, transY) {\n\t\tif (this.isNull()) {\n\t\t\treturn null;\n\t\t}\n\t\tthis.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);\n\t}\n\ttoString() {\n\t\treturn \"Env[\" + this._minx + \" : \" + this._maxx + \", \" + this._miny + \" : \" + this._maxy + \"]\";\n\t}\n\tsetToNull() {\n\t\tthis._minx = 0;\n\t\tthis._maxx = -1;\n\t\tthis._miny = 0;\n\t\tthis._maxy = -1;\n\t}\n\tgetHeight() {\n\t\tif (this.isNull()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._maxy - this._miny;\n\t}\n\tmaxExtent() {\n\t\tif (this.isNull()) return 0.0;\n\t\tvar w = this.getWidth();\n\t\tvar h = this.getHeight();\n\t\tif (w > h) return w;\n\t\treturn h;\n\t}\n\texpandBy() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet distance = arguments[0];\n\t\t\tthis.expandBy(distance, distance);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet deltaX = arguments[0], deltaY = arguments[1];\n\t\t\tif (this.isNull()) return null;\n\t\t\tthis._minx -= deltaX;\n\t\t\tthis._maxx += deltaX;\n\t\t\tthis._miny -= deltaY;\n\t\t\tthis._maxy += deltaY;\n\t\t\tif (this._minx > this._maxx || this._miny > this._maxy) this.setToNull();\n\t\t}\n\t}\n\tcontains() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\treturn this.covers(other);\n\t\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\treturn this.covers(p);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\treturn this.covers(x, y);\n\t\t}\n\t}\n\tcentre() {\n\t\tif (this.isNull()) return null;\n\t\treturn new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0);\n\t}\n\tinit() {\n\t\tif (arguments.length === 0) {\n\t\t\tthis.setToNull();\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\tthis.init(p.x, p.x, p.y, p.y);\n\t\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\t\tlet env = arguments[0];\n\t\t\t\tthis._minx = env._minx;\n\t\t\t\tthis._maxx = env._maxx;\n\t\t\t\tthis._miny = env._miny;\n\t\t\t\tthis._maxy = env._maxy;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\t\tthis.init(p1.x, p2.x, p1.y, p2.y);\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet x1 = arguments[0], x2 = arguments[1], y1 = arguments[2], y2 = arguments[3];\n\t\t\tif (x1 < x2) {\n\t\t\t\tthis._minx = x1;\n\t\t\t\tthis._maxx = x2;\n\t\t\t} else {\n\t\t\t\tthis._minx = x2;\n\t\t\t\tthis._maxx = x1;\n\t\t\t}\n\t\t\tif (y1 < y2) {\n\t\t\t\tthis._miny = y1;\n\t\t\t\tthis._maxy = y2;\n\t\t\t} else {\n\t\t\t\tthis._miny = y2;\n\t\t\t\tthis._maxy = y1;\n\t\t\t}\n\t\t}\n\t}\n\tgetMaxY() {\n\t\treturn this._maxy;\n\t}\n\tdistance(env) {\n\t\tif (this.intersects(env)) return 0;\n\t\tvar dx = 0.0;\n\t\tif (this._maxx < env._minx) dx = env._minx - this._maxx; else if (this._minx > env._maxx) dx = this._minx - env._maxx;\n\t\tvar dy = 0.0;\n\t\tif (this._maxy < env._miny) dy = env._miny - this._maxy; else if (this._miny > env._maxy) dy = this._miny - env._maxy;\n\t\tif (dx === 0.0) return dy;\n\t\tif (dy === 0.0) return dx;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\thashCode() {\n\t\tvar result = 17;\n\t\tresult = 37 * result + Coordinate.hashCode(this._minx);\n\t\tresult = 37 * result + Coordinate.hashCode(this._maxx);\n\t\tresult = 37 * result + Coordinate.hashCode(this._miny);\n\t\tresult = 37 * result + Coordinate.hashCode(this._maxy);\n\t\treturn result;\n\t}\n\tgetClass() {\n\t\treturn Envelope;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparable, Serializable];\n\t}\n}\nEnvelope.constructor_ = function () {\n\tthis._minx = null;\n\tthis._maxx = null;\n\tthis._miny = null;\n\tthis._maxy = null;\n\tif (arguments.length === 0) {\n\t\tthis.init();\n\t} else if (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\tthis.init(p.x, p.x, p.y, p.y);\n\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\tlet env = arguments[0];\n\t\t\tthis.init(env);\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\tthis.init(p1.x, p2.x, p1.y, p2.y);\n\t} else if (arguments.length === 4) {\n\t\tlet x1 = arguments[0], x2 = arguments[1], y1 = arguments[2], y2 = arguments[3];\n\t\tthis.init(x1, x2, y1, y2);\n\t}\n};\nEnvelope.serialVersionUID = 5873921885273102420;\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport Serializable from '../../../../java/io/Serializable';\nimport Envelope from './Envelope';\nexport default class Geometry {\n\tconstructor() {\n\t\tGeometry.constructor_.apply(this, arguments);\n\t}\n\tisGeometryCollection() {\n\t\treturn this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION;\n\t}\n\tgetFactory() {\n\t\treturn this._factory;\n\t}\n\tgetGeometryN(n) {\n\t\treturn this;\n\t}\n\tgetArea() {\n\t\treturn 0.0;\n\t}\n\tisRectangle() {\n\t\treturn false;\n\t}\n\tequals() {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tlet g = arguments[0];\n\t\t\tif (g === null) return false;\n\t\t\treturn this.equalsTopo(g);\n\t\t} else if (arguments[0] instanceof Object) {\n\t\t\tlet o = arguments[0];\n\t\t\tif (!(o instanceof Geometry)) return false;\n\t\t\tvar g = o;\n\t\t\treturn this.equalsExact(g);\n\t\t}\n\t}\n\tequalsExact(other) {\n\t\treturn this === other || this.equalsExact(other, 0);\n\t}\n\tgeometryChanged() {\n\t\tthis.apply(Geometry.geometryChangedFilter);\n\t}\n\tgeometryChangedAction() {\n\t\tthis._envelope = null;\n\t}\n\tequalsNorm(g) {\n\t\tif (g === null) return false;\n\t\treturn this.norm().equalsExact(g.norm());\n\t}\n\tgetLength() {\n\t\treturn 0.0;\n\t}\n\tgetNumGeometries() {\n\t\treturn 1;\n\t}\n\tcompareTo() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar other = o;\n\t\t\tif (this.getTypeCode() !== other.getTypeCode()) {\n\t\t\t\treturn this.getTypeCode() - other.getTypeCode();\n\t\t\t}\n\t\t\tif (this.isEmpty() && other.isEmpty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (other.isEmpty()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn this.compareToSameClass(o);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar other = o;\n\t\t\tif (this.getTypeCode() !== other.getTypeCode()) {\n\t\t\t\treturn this.getTypeCode() - other.getTypeCode();\n\t\t\t}\n\t\t\tif (this.isEmpty() && other.isEmpty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (other.isEmpty()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn this.compareToSameClass(o, comp);\n\t\t}\n\t}\n\tgetUserData() {\n\t\treturn this._userData;\n\t}\n\tgetSRID() {\n\t\treturn this._SRID;\n\t}\n\tgetEnvelope() {\n\t\treturn this.getFactory().toGeometry(this.getEnvelopeInternal());\n\t}\n\tcheckNotGeometryCollection(g) {\n\t\tif (g.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION) {\n\t\t\tthrow new IllegalArgumentException(\"This method does not support GeometryCollection arguments\");\n\t\t}\n\t}\n\tequal(a, b, tolerance) {\n\t\tif (tolerance === 0) {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\treturn a.distance(b) <= tolerance;\n\t}\n\tnorm() {\n\t\tvar copy = this.copy();\n\t\tcopy.normalize();\n\t\treturn copy;\n\t}\n\tgetPrecisionModel() {\n\t\treturn this._factory.getPrecisionModel();\n\t}\n\tgetEnvelopeInternal() {\n\t\tif (this._envelope === null) {\n\t\t\tthis._envelope = this.computeEnvelopeInternal();\n\t\t}\n\t\treturn new Envelope(this._envelope);\n\t}\n\tsetSRID(SRID) {\n\t\tthis._SRID = SRID;\n\t}\n\tsetUserData(userData) {\n\t\tthis._userData = userData;\n\t}\n\tcompare(a, b) {\n\t\tvar i = a.iterator();\n\t\tvar j = b.iterator();\n\t\twhile (i.hasNext() && j.hasNext()) {\n\t\t\tvar aElement = i.next();\n\t\t\tvar bElement = j.next();\n\t\t\tvar comparison = aElement.compareTo(bElement);\n\t\t\tif (comparison !== 0) {\n\t\t\t\treturn comparison;\n\t\t\t}\n\t\t}\n\t\tif (i.hasNext()) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (j.hasNext()) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\thashCode() {\n\t\treturn this.getEnvelopeInternal().hashCode();\n\t}\n\tisGeometryCollectionOrDerived() {\n\t\tif (this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === Geometry.TYPECODE_MULTIPOINT || this.getTypeCode() === Geometry.TYPECODE_MULTILINESTRING || this.getTypeCode() === Geometry.TYPECODE_MULTIPOLYGON) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tget interfaces_() {\n\t\treturn [Cloneable, Comparable, Serializable];\n\t}\n\tgetClass() {\n\t\treturn Geometry;\n\t}\n\tstatic hasNonEmptyElements(geometries) {\n\t\tfor (var i = 0; i < geometries.length; i++) {\n\t\t\tif (!geometries[i].isEmpty()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tstatic hasNullElements(array) {\n\t\tfor (var i = 0; i < array.length; i++) {\n\t\t\tif (array[i] === null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\nGeometry.constructor_ = function (factory) {\n\tif (!factory)\n\t\treturn;\n\tthis._envelope = null;\n\tthis._userData = null;\n\tthis._factory = factory;\n\tthis._SRID = factory.getSRID();\n};\nGeometry.serialVersionUID = 8763622679187376702;\nGeometry.TYPECODE_POINT = 0;\nGeometry.TYPECODE_MULTIPOINT = 1;\nGeometry.TYPECODE_LINESTRING = 2;\nGeometry.TYPECODE_LINEARRING = 3;\nGeometry.TYPECODE_MULTILINESTRING = 4;\nGeometry.TYPECODE_POLYGON = 5;\nGeometry.TYPECODE_MULTIPOLYGON = 6;\nGeometry.TYPECODE_GEOMETRYCOLLECTION = 7;\nGeometry.TYPENAME_POINT = \"Point\";\nGeometry.TYPENAME_MULTIPOINT = \"MultiPoint\";\nGeometry.TYPENAME_LINESTRING = \"LineString\";\nGeometry.TYPENAME_LINEARRING = \"LinearRing\";\nGeometry.TYPENAME_MULTILINESTRING = \"MultiLineString\";\nGeometry.TYPENAME_POLYGON = \"Polygon\";\nGeometry.TYPENAME_MULTIPOLYGON = \"MultiPolygon\";\nGeometry.TYPENAME_GEOMETRYCOLLECTION = \"GeometryCollection\";\nGeometry.geometryChangedFilter = {\n\tget interfaces_() {\n\t\treturn [GeometryComponentFilter];\n\t},\n\tfilter(geom) {\n\t\tgeom.geometryChangedAction();\n\t}\n};\n","export default class CoordinateFilter {\n\tconstructor() {\n\t\tCoordinateFilter.constructor_.apply(this, arguments);\n\t}\n\tfilter(coord) {}\n\tgetClass() {\n\t\treturn CoordinateFilter;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCoordinateFilter.constructor_ = function () {};\n","export default class BoundaryNodeRule {\n\tconstructor() {\n\t\tBoundaryNodeRule.constructor_.apply(this, arguments);\n\t}\n\tisInBoundary(boundaryCount) {}\n\tgetClass() {\n\t\treturn BoundaryNodeRule;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nclass Mod2BoundaryNodeRule {\n\tconstructor() {\n\t\tMod2BoundaryNodeRule.constructor_.apply(this, arguments);\n\t}\n\tisInBoundary(boundaryCount) {\n\t\treturn boundaryCount % 2 === 1;\n\t}\n\tgetClass() {\n\t\treturn Mod2BoundaryNodeRule;\n\t}\n\tget interfaces_() {\n\t\treturn [BoundaryNodeRule];\n\t}\n}\nMod2BoundaryNodeRule.constructor_ = function () {};\nclass EndPointBoundaryNodeRule {\n\tconstructor() {\n\t\tEndPointBoundaryNodeRule.constructor_.apply(this, arguments);\n\t}\n\tisInBoundary(boundaryCount) {\n\t\treturn boundaryCount > 0;\n\t}\n\tgetClass() {\n\t\treturn EndPointBoundaryNodeRule;\n\t}\n\tget interfaces_() {\n\t\treturn [BoundaryNodeRule];\n\t}\n}\nEndPointBoundaryNodeRule.constructor_ = function () {};\nclass MultiValentEndPointBoundaryNodeRule {\n\tconstructor() {\n\t\tMultiValentEndPointBoundaryNodeRule.constructor_.apply(this, arguments);\n\t}\n\tisInBoundary(boundaryCount) {\n\t\treturn boundaryCount > 1;\n\t}\n\tgetClass() {\n\t\treturn MultiValentEndPointBoundaryNodeRule;\n\t}\n\tget interfaces_() {\n\t\treturn [BoundaryNodeRule];\n\t}\n}\nMultiValentEndPointBoundaryNodeRule.constructor_ = function () {};\nclass MonoValentEndPointBoundaryNodeRule {\n\tconstructor() {\n\t\tMonoValentEndPointBoundaryNodeRule.constructor_.apply(this, arguments);\n\t}\n\tisInBoundary(boundaryCount) {\n\t\treturn boundaryCount === 1;\n\t}\n\tgetClass() {\n\t\treturn MonoValentEndPointBoundaryNodeRule;\n\t}\n\tget interfaces_() {\n\t\treturn [BoundaryNodeRule];\n\t}\n}\nMonoValentEndPointBoundaryNodeRule.constructor_ = function () {};\nBoundaryNodeRule.Mod2BoundaryNodeRule = Mod2BoundaryNodeRule;\nBoundaryNodeRule.EndPointBoundaryNodeRule = EndPointBoundaryNodeRule;\nBoundaryNodeRule.MultiValentEndPointBoundaryNodeRule = MultiValentEndPointBoundaryNodeRule;\nBoundaryNodeRule.MonoValentEndPointBoundaryNodeRule = MonoValentEndPointBoundaryNodeRule;\nBoundaryNodeRule.constructor_ = function () {};\nBoundaryNodeRule.MOD2_BOUNDARY_RULE = new Mod2BoundaryNodeRule();\nBoundaryNodeRule.ENDPOINT_BOUNDARY_RULE = new EndPointBoundaryNodeRule();\nBoundaryNodeRule.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new MultiValentEndPointBoundaryNodeRule();\nBoundaryNodeRule.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new MonoValentEndPointBoundaryNodeRule();\nBoundaryNodeRule.OGC_SFS_BOUNDARY_RULE = BoundaryNodeRule.MOD2_BOUNDARY_RULE;\n","/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html\n * @constructor\n * @private\n */\nexport default function Iterator() {};\n\n/**\n * Returns true if the iteration has more elements.\n * @return {boolean}\n */\nIterator.prototype.hasNext = function() {};\n\n/**\n * Returns the next element in the iteration.\n * @return {Object}\n */\nIterator.prototype.next = function() {};\n\n/**\n * Removes from the underlying collection the last element returned by the\n * iterator (optional operation).\n */\nIterator.prototype.remove = function() {};\n","import Iterator from './Iterator'\n\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html\n *\n * @constructor\n * @private\n */\nexport default function Collection() {};\n\n/**\n * Ensures that this collection contains the specified element (optional\n * operation).\n * @param {Object} e\n * @return {boolean}\n */\nCollection.prototype.add = function() {};\n\n\n/**\n * Appends all of the elements in the specified collection to the end of this\n * list, in the order that they are returned by the specified collection's\n * iterator (optional operation).\n * @param {javascript.util.Collection} c\n * @return {boolean}\n */\nCollection.prototype.addAll = function() {};\n\n\n/**\n * Returns true if this collection contains no elements.\n * @return {boolean}\n */\nCollection.prototype.isEmpty = function() {};\n\n\n/**\n * Returns an iterator over the elements in this collection.\n * @return {javascript.util.Iterator}\n */\nCollection.prototype.iterator = function() {};\n\n\n/**\n * Returns an iterator over the elements in this collection.\n * @return {number}\n */\nCollection.prototype.size = function() {};\n\n\n/**\n * Returns an array containing all of the elements in this collection.\n * @return {Array}\n */\nCollection.prototype.toArray = function() {};\n\n\n/**\n * Removes a single instance of the specified element from this collection if it\n * is present. (optional)\n * @param {Object} e\n * @return {boolean}\n */\nCollection.prototype.remove = function() {};\n","/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nexport default function IndexOutOfBoundsException(message) {\n  this.message = message || '';\n};\nIndexOutOfBoundsException.prototype = new Error();\n\n/**\n * @type {string}\n */\nIndexOutOfBoundsException.prototype.name = 'IndexOutOfBoundsException';\n","import Collection from './Collection'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html\n *\n * @extends {javascript.util.Collection}\n * @constructor\n * @private\n */\nexport default function List() { };\nList.prototype = Object.create(Collection.prototype);\nList.prototype.constructor = List\n\n/**\n * Returns the element at the specified position in this list.\n * @param {number} index\n * @return {Object}\n */\nList.prototype.get = function() { };\n\n\n/**\n * Replaces the element at the specified position in this list with the\n * specified element (optional operation).\n * @param {number} index\n * @param {Object} e\n * @return {Object}\n */\nList.prototype.set = function() { };\n\n\n/**\n * Returns true if this collection contains no elements.\n * @return {boolean}\n */\nList.prototype.isEmpty = function() { };\n","/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nexport default function NoSuchElementException(message) {\n  this.message = message || '';\n};\nNoSuchElementException.prototype = new Error();\n\n\n/**\n * @type {string}\n */\nNoSuchElementException.prototype.name = 'NoSuchElementException';\n","/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nexport default function OperationNotSupported(message) {\n  this.message = message || '';\n};\nOperationNotSupported.prototype = new Error();\n\n\n/**\n * @type {string}\n */\nOperationNotSupported.prototype.name = 'OperationNotSupported';\n","import Collection from './Collection'\nimport IndexOutOfBoundsException from './IndexOutOfBoundsException'\nimport Iterator from './Iterator'\nimport List from './List'\nimport NoSuchElementException from './NoSuchElementException'\nimport OperationNotSupported from './OperationNotSupported'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html\n *\n * @extends List\n * @private\n */\nexport default function ArrayList () {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n};\nArrayList.prototype = Object.create(List.prototype)\nArrayList.prototype.constructor = ArrayList;\n\nArrayList.prototype.ensureCapacity = function () {}\nArrayList.prototype.interfaces_ = [List, Collection]\n\n/**\n * @override\n */\nArrayList.prototype.add = function(e) {\n  if (arguments.length === 1) {\n    this.array_.push(e)\n  } else {\n    this.array_.splice(arguments[0], 0, arguments[1])\n  }\n  return true\n};\n\nArrayList.prototype.clear = function() {\n  this.array_ = []\n}\n\n/**\n * @override\n */\nArrayList.prototype.addAll = function(c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.add(i.next());\n  }\n  return true;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.set = function(index, element) {\n  var oldElement = this.array_[index];\n  this.array_[index] = element;\n  return oldElement;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.iterator = function() {\n  return new Iterator_(this);\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.get = function(index) {\n  if (index < 0 || index >= this.size()) {\n    throw new IndexOutOfBoundsException();\n  }\n\n  return this.array_[index];\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.isEmpty = function() {\n  return this.array_.length === 0;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.size = function() {\n  return this.array_.length;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.toArray = function() {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.remove = function(o) {\n  var found = false;\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    if (this.array_[i] === o) {\n      this.array_.splice(i, 1);\n      found = true;\n      break;\n    }\n  }\n\n  return found;\n};\n\n\nArrayList.prototype.removeAll = function(c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.remove(i.next());\n  }\n  return true;\n};\n\n\n\n/**\n * @extends {Iterator}\n * @param {ArrayList} arrayList\n * @constructor\n * @private\n */\nvar Iterator_ = function(arrayList) {\n  /**\n   * @type {ArrayList}\n   * @private\n  */\n  this.arrayList_ = arrayList;\n  /**\n   * @type {number}\n   * @private\n  */\n  this.position_ = 0;\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.next = function() {\n  if (this.position_ === this.arrayList_.size()) {\n    throw new NoSuchElementException();\n  }\n  return this.arrayList_.get(this.position_++);\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.hasNext = function() {\n  if (this.position_ < this.arrayList_.size()) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * TODO: should be in ListIterator\n * @override\n */\nIterator_.prototype.set = function(element) {\n  return this.arrayList_.set(this.position_ - 1, element);\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.remove = function() {\n  this.arrayList_.remove(this.arrayList_.get(this.position_));\n};\n","import hasInterface from '../../../../hasInterface';\nimport Collection from '../../../../java/util/Collection';\nimport Coordinate from './Coordinate';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default class CoordinateList extends ArrayList {\n\tconstructor() {\n\t\tsuper();\n\t\tCoordinateList.constructor_.apply(this, arguments);\n\t}\n\tgetCoordinate(i) {\n\t\treturn this.get(i);\n\t}\n\taddAll() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"boolean\" && hasInterface(arguments[0], Collection))) {\n\t\t\tlet coll = arguments[0], allowRepeated = arguments[1];\n\t\t\tvar isChanged = false;\n\t\t\tfor (var i = coll.iterator(); i.hasNext(); ) {\n\t\t\t\tthis.add(i.next(), allowRepeated);\n\t\t\t\tisChanged = true;\n\t\t\t}\n\t\t\treturn isChanged;\n\t\t} else return super.addAll.apply(this, arguments);\n\t}\n\tclone() {\n\t\tvar clone = super.clone.call(this);\n\t\tfor (var i = 0; i < this.size(); i++) {\n\t\t\tclone.add(i, this.get(i).clone());\n\t\t}\n\t\treturn clone;\n\t}\n\ttoCoordinateArray() {\n\t\treturn this.toArray(CoordinateList.coordArrayType);\n\t}\n\tadd() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet coord = arguments[0];\n\t\t\tsuper.add.call(this, coord);\n\t\t} else if (arguments.length === 2) {\n\t\t\tif (arguments[0] instanceof Array && typeof arguments[1] === \"boolean\") {\n\t\t\t\tlet coord = arguments[0], allowRepeated = arguments[1];\n\t\t\t\tthis.add(coord, allowRepeated, true);\n\t\t\t\treturn true;\n\t\t\t} else if (arguments[0] instanceof Coordinate && typeof arguments[1] === \"boolean\") {\n\t\t\t\tlet coord = arguments[0], allowRepeated = arguments[1];\n\t\t\t\tif (!allowRepeated) {\n\t\t\t\t\tif (this.size() >= 1) {\n\t\t\t\t\t\tvar last = this.get(this.size() - 1);\n\t\t\t\t\t\tif (last.equals2D(coord)) return null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsuper.add.call(this, coord);\n\t\t\t} else if (arguments[0] instanceof Object && typeof arguments[1] === \"boolean\") {\n\t\t\t\tlet obj = arguments[0], allowRepeated = arguments[1];\n\t\t\t\tthis.add(obj, allowRepeated);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (typeof arguments[2] === \"boolean\" && (arguments[0] instanceof Array && typeof arguments[1] === \"boolean\")) {\n\t\t\t\tlet coord = arguments[0], allowRepeated = arguments[1], direction = arguments[2];\n\t\t\t\tif (direction) {\n\t\t\t\t\tfor (var i = 0; i < coord.length; i++) {\n\t\t\t\t\t\tthis.add(coord[i], allowRepeated);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i = coord.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tthis.add(coord[i], allowRepeated);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else if (typeof arguments[2] === \"boolean\" && (Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate)) {\n\t\t\t\tlet i = arguments[0], coord = arguments[1], allowRepeated = arguments[2];\n\t\t\t\tif (!allowRepeated) {\n\t\t\t\t\tvar size = this.size();\n\t\t\t\t\tif (size > 0) {\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\tvar prev = this.get(i - 1);\n\t\t\t\t\t\t\tif (prev.equals2D(coord)) return null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i < size) {\n\t\t\t\t\t\t\tvar next = this.get(i);\n\t\t\t\t\t\t\tif (next.equals2D(coord)) return null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsuper.add.call(this, i, coord);\n\t\t\t}\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet coord = arguments[0], allowRepeated = arguments[1], start = arguments[2], end = arguments[3];\n\t\t\tvar inc = 1;\n\t\t\tif (start > end) inc = -1;\n\t\t\tfor (var i = start; i !== end; i += inc) {\n\t\t\t\tthis.add(coord[i], allowRepeated);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tcloseRing() {\n\t\tif (this.size() > 0) this.add(new Coordinate(this.get(0)), false);\n\t}\n\tgetClass() {\n\t\treturn CoordinateList;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCoordinateList.constructor_ = function () {\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet coord = arguments[0];\n\t\tthis.ensureCapacity(coord.length);\n\t\tthis.add(coord, true);\n\t} else if (arguments.length === 2) {\n\t\tlet coord = arguments[0], allowRepeated = arguments[1];\n\t\tthis.ensureCapacity(coord.length);\n\t\tthis.add(coord, allowRepeated);\n\t}\n};\nCoordinateList.coordArrayType = new Array(0).fill(null);\n","import Double from '../../../../java/lang/Double';\nexport default class MathUtil {\n\tconstructor() {\n\t\tMathUtil.constructor_.apply(this, arguments);\n\t}\n\tstatic log10(x) {\n\t\tvar ln = Math.log(x);\n\t\tif (Double.isInfinite(ln)) return ln;\n\t\tif (Double.isNaN(ln)) return ln;\n\t\treturn ln / MathUtil.LOG_10;\n\t}\n\tstatic min(v1, v2, v3, v4) {\n\t\tvar min = v1;\n\t\tif (v2 < min) min = v2;\n\t\tif (v3 < min) min = v3;\n\t\tif (v4 < min) min = v4;\n\t\treturn min;\n\t}\n\tstatic clamp() {\n\t\tif (typeof arguments[2] === \"number\" && (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\")) {\n\t\t\tlet x = arguments[0], min = arguments[1], max = arguments[2];\n\t\t\tif (x < min) return min;\n\t\t\tif (x > max) return max;\n\t\t\treturn x;\n\t\t} else if (Number.isInteger(arguments[2]) && (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))) {\n\t\t\tlet x = arguments[0], min = arguments[1], max = arguments[2];\n\t\t\tif (x < min) return min;\n\t\t\tif (x > max) return max;\n\t\t\treturn x;\n\t\t}\n\t}\n\tstatic wrap(index, max) {\n\t\tif (index < 0) {\n\t\t\treturn max - -index % max;\n\t\t}\n\t\treturn index % max;\n\t}\n\tstatic max() {\n\t\tif (arguments.length === 3) {\n\t\t\tlet v1 = arguments[0], v2 = arguments[1], v3 = arguments[2];\n\t\t\tvar max = v1;\n\t\t\tif (v2 > max) max = v2;\n\t\t\tif (v3 > max) max = v3;\n\t\t\treturn max;\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet v1 = arguments[0], v2 = arguments[1], v3 = arguments[2], v4 = arguments[3];\n\t\t\tvar max = v1;\n\t\t\tif (v2 > max) max = v2;\n\t\t\tif (v3 > max) max = v3;\n\t\t\tif (v4 > max) max = v4;\n\t\t\treturn max;\n\t\t}\n\t}\n\tstatic average(x1, x2) {\n\t\treturn (x1 + x2) / 2.0;\n\t}\n\tgetClass() {\n\t\treturn MathUtil;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nMathUtil.constructor_ = function () {};\nMathUtil.LOG_10 = Math.log(10);\n","export default function System () { }\n\nSystem.arraycopy = (src, srcPos, dest, destPos, len) => {\n  let c = 0\n  for (let i = srcPos; i < srcPos + len; i++) {\n    dest[destPos + c] = src[i]\n    c++\n  }\n}\n\nSystem.getProperty = (name) => {\n  return {\n    'line.separator': '\\n'\n  }[name]\n}\n","import CoordinateList from './CoordinateList';\nimport Coordinate from './Coordinate';\nimport MathUtil from '../math/MathUtil';\nimport System from '../../../../java/lang/System';\nimport Comparator from '../../../../java/util/Comparator';\nimport Envelope from './Envelope';\nexport default class CoordinateArrays {\n\tconstructor() {\n\t\tCoordinateArrays.constructor_.apply(this, arguments);\n\t}\n\tstatic isRing(pts) {\n\t\tif (pts.length < 4) return false;\n\t\tif (!pts[0].equals2D(pts[pts.length - 1])) return false;\n\t\treturn true;\n\t}\n\tstatic ptNotInList(testPts, pts) {\n\t\tfor (var i = 0; i < testPts.length; i++) {\n\t\t\tvar testPt = testPts[i];\n\t\t\tif (CoordinateArrays.indexOf(testPt, pts) < 0) return testPt;\n\t\t}\n\t\treturn null;\n\t}\n\tstatic scroll(coordinates, firstCoordinate) {\n\t\tvar i = CoordinateArrays.indexOf(firstCoordinate, coordinates);\n\t\tif (i < 0) return null;\n\t\tvar newCoordinates = new Array(coordinates.length).fill(null);\n\t\tSystem.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);\n\t\tSystem.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);\n\t\tSystem.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);\n\t}\n\tstatic equals() {\n\t\tif (arguments.length === 2) {\n\t\t\tlet coord1 = arguments[0], coord2 = arguments[1];\n\t\t\tif (coord1 === coord2) return true;\n\t\t\tif (coord1 === null || coord2 === null) return false;\n\t\t\tif (coord1.length !== coord2.length) return false;\n\t\t\tfor (var i = 0; i < coord1.length; i++) {\n\t\t\t\tif (!coord1[i].equals(coord2[i])) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet coord1 = arguments[0], coord2 = arguments[1], coordinateComparator = arguments[2];\n\t\t\tif (coord1 === coord2) return true;\n\t\t\tif (coord1 === null || coord2 === null) return false;\n\t\t\tif (coord1.length !== coord2.length) return false;\n\t\t\tfor (var i = 0; i < coord1.length; i++) {\n\t\t\t\tif (coordinateComparator.compare(coord1[i], coord2[i]) !== 0) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tstatic intersection(coordinates, env) {\n\t\tvar coordList = new CoordinateList();\n\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\tif (env.intersects(coordinates[i])) coordList.add(coordinates[i], true);\n\t\t}\n\t\treturn coordList.toCoordinateArray();\n\t}\n\tstatic hasRepeatedPoints(coord) {\n\t\tfor (var i = 1; i < coord.length; i++) {\n\t\t\tif (coord[i - 1].equals(coord[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tstatic removeRepeatedPoints(coord) {\n\t\tif (!CoordinateArrays.hasRepeatedPoints(coord)) return coord;\n\t\tvar coordList = new CoordinateList(coord, false);\n\t\treturn coordList.toCoordinateArray();\n\t}\n\tstatic reverse(coord) {\n\t\tvar last = coord.length - 1;\n\t\tvar mid = Math.trunc(last / 2);\n\t\tfor (var i = 0; i <= mid; i++) {\n\t\t\tvar tmp = coord[i];\n\t\t\tcoord[i] = coord[last - i];\n\t\t\tcoord[last - i] = tmp;\n\t\t}\n\t}\n\tstatic removeNull(coord) {\n\t\tvar nonNull = 0;\n\t\tfor (var i = 0; i < coord.length; i++) {\n\t\t\tif (coord[i] !== null) nonNull++;\n\t\t}\n\t\tvar newCoord = new Array(nonNull).fill(null);\n\t\tif (nonNull === 0) return newCoord;\n\t\tvar j = 0;\n\t\tfor (var i = 0; i < coord.length; i++) {\n\t\t\tif (coord[i] !== null) newCoord[j++] = coord[i];\n\t\t}\n\t\treturn newCoord;\n\t}\n\tstatic copyDeep() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet coordinates = arguments[0];\n\t\t\tvar copy = new Array(coordinates.length).fill(null);\n\t\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\t\tcopy[i] = new Coordinate(coordinates[i]);\n\t\t\t}\n\t\t\treturn copy;\n\t\t} else if (arguments.length === 5) {\n\t\t\tlet src = arguments[0], srcStart = arguments[1], dest = arguments[2], destStart = arguments[3], length = arguments[4];\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tdest[destStart + i] = new Coordinate(src[srcStart + i]);\n\t\t\t}\n\t\t}\n\t}\n\tstatic isEqualReversed(pts1, pts2) {\n\t\tfor (var i = 0; i < pts1.length; i++) {\n\t\t\tvar p1 = pts1[i];\n\t\t\tvar p2 = pts2[pts1.length - i - 1];\n\t\t\tif (p1.compareTo(p2) !== 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic envelope(coordinates) {\n\t\tvar env = new Envelope();\n\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\tenv.expandToInclude(coordinates[i]);\n\t\t}\n\t\treturn env;\n\t}\n\tstatic toCoordinateArray(coordList) {\n\t\treturn coordList.toArray(CoordinateArrays.coordArrayType);\n\t}\n\tstatic atLeastNCoordinatesOrNothing(n, c) {\n\t\treturn c.length >= n ? c : [];\n\t}\n\tstatic indexOf(coordinate, coordinates) {\n\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\tif (coordinate.equals(coordinates[i])) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tstatic increasingDirection(pts) {\n\t\tfor (var i = 0; i < Math.trunc(pts.length / 2); i++) {\n\t\t\tvar j = pts.length - 1 - i;\n\t\t\tvar comp = pts[i].compareTo(pts[j]);\n\t\t\tif (comp !== 0) return comp;\n\t\t}\n\t\treturn 1;\n\t}\n\tstatic compare(pts1, pts2) {\n\t\tvar i = 0;\n\t\twhile (i < pts1.length && i < pts2.length) {\n\t\t\tvar compare = pts1[i].compareTo(pts2[i]);\n\t\t\tif (compare !== 0) return compare;\n\t\t\ti++;\n\t\t}\n\t\tif (i < pts2.length) return -1;\n\t\tif (i < pts1.length) return 1;\n\t\treturn 0;\n\t}\n\tstatic minCoordinate(coordinates) {\n\t\tvar minCoord = null;\n\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\tif (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {\n\t\t\t\tminCoord = coordinates[i];\n\t\t\t}\n\t\t}\n\t\treturn minCoord;\n\t}\n\tstatic extract(pts, start, end) {\n\t\tstart = MathUtil.clamp(start, 0, pts.length);\n\t\tend = MathUtil.clamp(end, -1, pts.length);\n\t\tvar npts = end - start + 1;\n\t\tif (end < 0) npts = 0;\n\t\tif (start >= pts.length) npts = 0;\n\t\tif (end < start) npts = 0;\n\t\tvar extractPts = new Array(npts).fill(null);\n\t\tif (npts === 0) return extractPts;\n\t\tvar iPts = 0;\n\t\tfor (var i = start; i <= end; i++) {\n\t\t\textractPts[iPts++] = pts[i];\n\t\t}\n\t\treturn extractPts;\n\t}\n\tgetClass() {\n\t\treturn CoordinateArrays;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nclass ForwardComparator {\n\tconstructor() {\n\t\tForwardComparator.constructor_.apply(this, arguments);\n\t}\n\tcompare(o1, o2) {\n\t\tvar pts1 = o1;\n\t\tvar pts2 = o2;\n\t\treturn CoordinateArrays.compare(pts1, pts2);\n\t}\n\tgetClass() {\n\t\treturn ForwardComparator;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparator];\n\t}\n}\nForwardComparator.constructor_ = function () {};\nclass BidirectionalComparator {\n\tconstructor() {\n\t\tBidirectionalComparator.constructor_.apply(this, arguments);\n\t}\n\tcompare(o1, o2) {\n\t\tvar pts1 = o1;\n\t\tvar pts2 = o2;\n\t\tif (pts1.length < pts2.length) return -1;\n\t\tif (pts1.length > pts2.length) return 1;\n\t\tif (pts1.length === 0) return 0;\n\t\tvar forwardComp = CoordinateArrays.compare(pts1, pts2);\n\t\tvar isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);\n\t\tif (isEqualRev) return 0;\n\t\treturn forwardComp;\n\t}\n\tOLDcompare(o1, o2) {\n\t\tvar pts1 = o1;\n\t\tvar pts2 = o2;\n\t\tif (pts1.length < pts2.length) return -1;\n\t\tif (pts1.length > pts2.length) return 1;\n\t\tif (pts1.length === 0) return 0;\n\t\tvar dir1 = CoordinateArrays.increasingDirection(pts1);\n\t\tvar dir2 = CoordinateArrays.increasingDirection(pts2);\n\t\tvar i1 = dir1 > 0 ? 0 : pts1.length - 1;\n\t\tvar i2 = dir2 > 0 ? 0 : pts1.length - 1;\n\t\tfor (var i = 0; i < pts1.length; i++) {\n\t\t\tvar comparePt = pts1[i1].compareTo(pts2[i2]);\n\t\t\tif (comparePt !== 0) return comparePt;\n\t\t\ti1 += dir1;\n\t\t\ti2 += dir2;\n\t\t}\n\t\treturn 0;\n\t}\n\tgetClass() {\n\t\treturn BidirectionalComparator;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparator];\n\t}\n}\nBidirectionalComparator.constructor_ = function () {};\nCoordinateArrays.ForwardComparator = ForwardComparator;\nCoordinateArrays.BidirectionalComparator = BidirectionalComparator;\nCoordinateArrays.constructor_ = function () {};\nCoordinateArrays.coordArrayType = new Array(0).fill(null);\n","/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html\n *\n * @constructor\n * @private\n */\nexport default function Map() {};\n\n\n/**\n * Returns the value to which the specified key is mapped, or null if this map\n * contains no mapping for the key.\n * @param {Object} key\n * @return {Object}\n */\nMap.prototype.get = function() {};\n\n\n/**\n * Associates the specified value with the specified key in this map (optional\n * operation).\n * @param {Object} key\n * @param {Object} value\n * @return {Object}\n */\nMap.prototype.put = function() {};\n\n\n/**\n * Returns the number of key-value mappings in this map.\n * @return {number}\n */\nMap.prototype.size = function() {};\n\n\n/**\n * Returns a Collection view of the values contained in this map.\n * @return {javascript.util.Collection}\n */\nMap.prototype.values = function() {};\n\n/**\n * Returns a {@link Set} view of the mappings contained in this map.\n * The set is backed by the map, so changes to the map are\n * reflected in the set, and vice-versa.  If the map is modified\n * while an iteration over the set is in progress (except through\n * the iterator's own <tt>remove</tt> operation, or through the\n * <tt>setValue</tt> operation on a map entry returned by the\n * iterator) the results of the iteration are undefined.  The set\n * supports element removal, which removes the corresponding\n * mapping from the map, via the <tt>Iterator.remove</tt>,\n * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and\n * <tt>clear</tt> operations.  It does not support the\n * <tt>add</tt> or <tt>addAll</tt> operations.\n *\n * @return {Set} a set view of the mappings contained in this map\n */\nMap.prototype.entrySet = function() {};\n","import Map from './Map'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html\n *\n * @extends {Map}\n * @constructor\n * @private\n */\nexport default function SortedMap() {};\nSortedMap.prototype = new Map();\n","import Collection from './Collection'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html\n *\n * @extends {Collection}\n * @constructor\n * @private\n */\nexport default function Set() {};\nSet.prototype = new Collection();\n\n\n/**\n * Returns true if this set contains the specified element. More formally,\n * returns true if and only if this set contains an element e such that (o==null ?\n * e==null : o.equals(e)).\n * @param {Object} e\n * @return {boolean}\n */\nSet.prototype.contains = function() {};\n","import Collection from './Collection'\nimport Iterator from './Iterator'\nimport NoSuchElementException from './NoSuchElementException'\nimport OperationNotSupported from './OperationNotSupported'\nimport Set from './Set'\n\n/**\n * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html\n *\n * @extends {javascript.util.Set}\n * @constructor\n * @private\n */\nexport default function HashSet() {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n};\nHashSet.prototype = new Set();\n\n\n/**\n * @override\n */\nHashSet.prototype.contains = function(o) {\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this.array_[i];\n    if (e === o) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.add = function(o) {\n  if (this.contains(o)) {\n    return false;\n  }\n\n  this.array_.push(o);\n\n  return true;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.addAll = function(c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.add(i.next());\n  }\n  return true;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.remove = function(o) {\n  throw new javascript.util.OperationNotSupported();\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.size = function() {\n  return this.array_.length;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.isEmpty = function() {\n  return this.array_.length === 0;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.toArray = function() {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.iterator = function() {\n  return new Iterator_(this);\n};\n\n\n\n/**\n * @extends {Iterator}\n * @param {HashSet} hashSet\n * @constructor\n * @private\n */\nvar Iterator_ = function(hashSet) {\n  /**\n   * @type {HashSet}\n   * @private\n   */\n  this.hashSet_ = hashSet;\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.next = function() {\n  if (this.position_ === this.hashSet_.size()) {\n    throw new NoSuchElementException();\n  }\n  return this.hashSet_.array_[this.position_++];\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.hasNext = function() {\n  if (this.position_ < this.hashSet_.size()) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.remove = function() {\n  throw new OperationNotSupported();\n};\n","import ArrayList from './ArrayList'\nimport SortedMap from './SortedMap'\nimport HashSet from './HashSet'\n\nconst BLACK = 0\nconst RED = 1\nfunction colorOf (p) { return (p == null ? BLACK : p.color) }\nfunction parentOf (p) { return (p == null ? null : p.parent) }\nfunction setColor (p, c) { if (p !== null) p.color = c }\nfunction leftOf (p) { return (p == null ? null : p.left) }\nfunction rightOf (p) { return (p == null ? null : p.right) }\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html\n *\n * @extends {SortedMap}\n * @constructor\n * @private\n */\nexport default function TreeMap() {\n  /**\n   * @type {Object}\n   * @private\n   */\n  this.root_ = null;\n  /**\n   * @type {number}\n   * @private\n  */\n  this.size_ = 0;\n};\nTreeMap.prototype = new SortedMap();\n\n\n/**\n * @override\n */\nTreeMap.prototype.get = function(key) {\n  var p = this.root_;\n  while (p !== null) {\n    var cmp = key['compareTo'](p.key);\n    if (cmp < 0) {\n      p = p.left;\n    } else if (cmp > 0) {\n      p = p.right;\n    } else {\n      return p.value;\n    }\n  }\n  return null;\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.put = function(key, value) {\n  if (this.root_ === null) {\n    this.root_ = {\n      key: key,\n      value: value,\n      left: null,\n      right: null,\n      parent: null,\n      color: BLACK,\n      getValue() { return this.value },\n      getKey() { return this.key }\n    };\n    this.size_ = 1;\n    return null;\n  }\n  var t = this.root_, parent, cmp;\n  do {\n    parent = t;\n    cmp = key['compareTo'](t.key);\n    if (cmp < 0) {\n      t = t.left;\n    } else if (cmp > 0) {\n      t = t.right;\n    } else {\n      var oldValue = t.value;\n      t.value = value;\n      return oldValue;\n    }\n  } while (t !== null);\n  var e = {\n    key: key,\n    left: null,\n    right: null,\n    value: value,\n    parent: parent,\n    color: BLACK,\n    getValue() { return this.value },\n    getKey() { return this.key }\n  };\n  if (cmp < 0) {\n    parent.left = e;\n  } else {\n    parent.right = e;\n  }\n  this.fixAfterInsertion(e);\n  this.size_++;\n  return null;\n};\n\n\n/**\n * @param {Object} x\n */\nTreeMap.prototype.fixAfterInsertion = function(x) {\n  x.color = RED;\n  while (x != null && x != this.root_ && x.parent.color == RED) {\n    if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n      var y = rightOf(parentOf(parentOf(x)));\n      if (colorOf(y) == RED) {\n        setColor(parentOf(x), BLACK);\n        setColor(y, BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        x = parentOf(parentOf(x));\n      } else {\n        if (x == rightOf(parentOf(x))) {\n          x = parentOf(x);\n          this.rotateLeft(x);\n        }\n        setColor(parentOf(x), BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        this.rotateRight(parentOf(parentOf(x)));\n      }\n    } else {\n      var y = leftOf(parentOf(parentOf(x)));\n      if (colorOf(y) == RED) {\n        setColor(parentOf(x), BLACK);\n        setColor(y, BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        x = parentOf(parentOf(x));\n      } else {\n        if (x == leftOf(parentOf(x))) {\n          x = parentOf(x);\n          this.rotateRight(x);\n        }\n        setColor(parentOf(x), BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        this.rotateLeft(parentOf(parentOf(x)));\n      }\n    }\n  }\n  this.root_.color = BLACK;\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.values = function() {\n  var arrayList = new ArrayList();\n  var p = this.getFirstEntry();\n  if (p !== null) {\n    arrayList.add(p.value);\n    while ((p = TreeMap.successor(p)) !== null) {\n      arrayList.add(p.value);\n    }\n  }\n  return arrayList;\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.entrySet = function() {\n  var hashSet = new HashSet();\n  var p = this.getFirstEntry();\n  if (p !== null) {\n    hashSet.add(p);\n    while ((p = TreeMap.successor(p)) !== null) {\n      hashSet.add(p);\n    }\n  }\n  return hashSet;\n};\n\n\n/**\n * @param {Object} p\n */\nTreeMap.prototype.rotateLeft = function(p) {\n  if (p != null) {\n    var r = p.right;\n    p.right = r.left;\n    if (r.left != null)\n      r.left.parent = p;\n    r.parent = p.parent;\n    if (p.parent == null)\n      this.root_ = r;\n    else if (p.parent.left == p)\n      p.parent.left = r;\n    else\n      p.parent.right = r;\n    r.left = p;\n    p.parent = r;\n  }\n};\n\n\n/**\n * @param {Object} p\n */\nTreeMap.prototype.rotateRight = function(p) {\n  if (p != null) {\n    var l = p.left;\n    p.left = l.right;\n    if (l.right != null) l.right.parent = p;\n    l.parent = p.parent;\n    if (p.parent == null)\n      this.root_ = l;\n    else if (p.parent.right == p)\n      p.parent.right = l;\n    else p.parent.left = l;\n    l.right = p;\n    p.parent = l;\n  }\n};\n\n\n/**\n * @return {Object}\n */\nTreeMap.prototype.getFirstEntry = function() {\n  var p = this.root_;\n  if (p != null) {\n    while (p.left != null) {\n      p = p.left;\n    }\n  }\n  return p;\n};\n\n\n/**\n * @param {Object} t\n * @return {Object}\n * @private\n */\nTreeMap.successor = function(t) {\n  if (t === null)\n    return null;\n  else if (t.right !== null) {\n    var p = t.right;\n    while (p.left !== null) {\n      p = p.left;\n    }\n    return p;\n  } else {\n    var p = t.parent;\n    var ch = t;\n    while (p !== null && ch === p.right) {\n      ch = p;\n      p = p.parent;\n    }\n    return p;\n  }\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.size = function() {\n  return this.size_;\n};\n\n\nTreeMap.prototype.containsKey = function(key) {\n  var p = this.root_;\n  while (p !== null) {\n    var cmp = key['compareTo'](p.key);\n    if (cmp < 0) {\n      p = p.left;\n    } else if (cmp > 0) {\n      p = p.right;\n    } else {\n      return true;\n    }\n  }\n  return false;\n};\n","export default class Lineal {\n\tconstructor() {\n\t\tLineal.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn Lineal;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nLineal.constructor_ = function () {};\n","import Set from './Set'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html\n *\n * @extends {Set}\n * @constructor\n * @private\n */\nexport default function SortedSet() {};\nSortedSet.prototype = new Set();\n","import Collection from './Collection'\nimport Iterator from './Iterator'\nimport NoSuchElementException from './NoSuchElementException'\nimport OperationNotSupported from './OperationNotSupported'\nimport SortedSet from './SortedSet'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html\n *\n * @extends {SortedSet}\n * @constructor\n * @private\n */\nexport default function TreeSet() {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n};\nTreeSet.prototype = new SortedSet();\n\n\n/**\n * @override\n */\nTreeSet.prototype.contains = function(o) {\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this.array_[i];\n    if (e['compareTo'](o) === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.add = function(o) {\n  if (this.contains(o)) {\n    return false;\n  }\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this.array_[i];\n    if (e['compareTo'](o) === 1) {\n      this.array_.splice(i, 0, o);\n      return true;\n    }\n  }\n\n  this.array_.push(o);\n\n  return true;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.addAll = function(c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.add(i.next());\n  }\n  return true;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.remove = function(e) {\n  throw new OperationNotSupported();\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.size = function() {\n  return this.array_.length;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.isEmpty = function() {\n  return this.array_.length === 0;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.toArray = function() {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.iterator = function() {\n  return new Iterator_(this);\n};\n\n\n\n/**\n * @extends {javascript.util.Iterator}\n * @param {javascript.util.TreeSet} treeSet\n * @constructor\n * @private\n */\nvar Iterator_ = function(treeSet) {\n  /**\n   * @type {javascript.util.TreeSet}\n   * @private\n   */\n  this.treeSet_ = treeSet;\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.next = function() {\n  if (this.position_ === this.treeSet_.size()) {\n    throw new NoSuchElementException();\n  }\n  return this.treeSet_.array_[this.position_++];\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.hasNext = function() {\n  if (this.position_ < this.treeSet_.size()) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.remove = function() {\n  throw new OperationNotSupported();\n};\n","// shared pointer\nvar i\n// shortcuts\nvar defineProperty = Object.defineProperty\nfunction is (a, b) { return (a === b) || (a !== a && b !== b) } // eslint-disable-line\n\nexport default createCollection({\n  // WeakMap#delete(key:void*):boolean\n  'delete': sharedDelete,\n  // :was Map#get(key:void*[, d3fault:void*]):void*\n  // Map#has(key:void*):boolean\n  has: mapHas,\n  // Map#get(key:void*):boolean\n  get: sharedGet,\n  // Map#set(key:void*, value:void*):void\n  set: sharedSet,\n  // Map#keys(void):Iterator\n  keys: sharedKeys,\n  // Map#values(void):Iterator\n  values: sharedValues,\n  // Map#entries(void):Iterator\n  entries: mapEntries,\n  // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`\n  forEach: sharedForEach,\n  // Map#clear():\n  clear: sharedClear\n})\n\nfunction createCollection (proto, objectOnly) {\n  function Collection (a) {\n    if (!this || this.constructor !== Collection) return new Collection(a)\n    this._keys = []\n    this._values = []\n    this._itp = [] // iteration pointers\n    this.objectOnly = objectOnly\n\n    // parse initial iterable argument passed\n    if (a) init.call(this, a)\n  }\n\n  // define size for non object-only collections\n  if (!objectOnly) {\n    defineProperty(proto, 'size', {\n      get: sharedSize\n    })\n  }\n\n  // set prototype\n  proto.constructor = Collection\n  Collection.prototype = proto\n\n  return Collection\n}\n\nfunction init (a) {\n  // init Set argument, like `[1,2,3,{}]`\n  if (this.add) a.forEach(this.add, this)\n  // init Map argument like `[[1,2], [{}, 4]]`\n  else a.forEach(function (a) { this.set(a[0], a[1]) }, this)\n}\n\nfunction sharedDelete (key) {\n  if (this.has(key)) {\n    this._keys.splice(i, 1)\n    this._values.splice(i, 1)\n    // update iteration pointers\n    this._itp.forEach(function (p) { if (i < p[0]) p[0]-- })\n  }\n  // Aurora here does it while Canary doesn't\n  return i > -1\n}\n\nfunction sharedGet (key) {\n  return this.has(key) ? this._values[i] : undefined\n}\n\nfunction has (list, key) {\n  if (this.objectOnly && key !== Object(key)) throw new TypeError('Invalid value used as weak collection key')\n  // NaN or 0 passed\n  if (key !== key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} // eslint-disable-line\n  else i = list.indexOf(key)\n  return i > -1\n}\n\nfunction mapHas (value) {\n  return has.call(this, this._keys, value)\n}\n\nfunction sharedSet (key, value) {\n  this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value\n  return this\n}\n\nfunction sharedClear () {\n  (this._keys || 0).length =\n    this._values.length = 0\n}\n\nfunction sharedKeys () {\n  return sharedIterator(this._itp, this._keys)\n}\n\nfunction sharedValues () {\n  return sharedIterator(this._itp, this._values)\n}\n\nfunction mapEntries () {\n  return sharedIterator(this._itp, this._keys, this._values)\n}\n\nfunction sharedIterator (itp, array, array2) {\n  var p = [0]\n  var done = false\n  itp.push(p)\n  return {\n    next: function () {\n      var v\n      var k = p[0]\n      if (!done && k < array.length) {\n        v = array2 ? [array[k], array2[k]] : array[k]\n        p[0]++\n      } else {\n        done = true\n        itp.splice(itp.indexOf(p), 1)\n      }\n      return { done: done, value: v }\n    }\n  }\n}\n\nfunction sharedSize () {\n  return this._values.length\n}\n\nfunction sharedForEach (callback, context) {\n  var it = this.entries()\n  for (;;) {\n    var r = it.next()\n    if (r.done) break\n    callback.call(context, r.value[1], r.value[0], this)\n  }\n}\n","import ArrayList from './ArrayList'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html\n *\n * @constructor\n * @private\n */\nexport default function Arrays() {};\n\n/**\n */\nArrays.sort = function() {\n  var a = arguments[0], i, t, comparator, compare;\n  if (arguments.length === 1) {\n    compare = function(a, b) {\n      return a.compareTo(b);\n    }\n    a.sort(compare);\n    return;\n  } else if (arguments.length === 2) {\n    comparator = arguments[1];\n    compare = function(a, b) {\n      return comparator['compare'](a, b);\n    };\n    a.sort(compare);\n  } else if (arguments.length === 3) {\n    t = a.slice(arguments[1], arguments[2]);\n    t.sort();\n    var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n    a.splice(0, a.length);\n    for (i = 0; i < r.length; i++) {\n      a.push(r[i]);\n    }\n    return;\n  } else if (arguments.length === 4) {\n    t = a.slice(arguments[1], arguments[2]);\n    comparator = arguments[3];\n    compare = function(a, b) {\n      return comparator['compare'](a, b);\n    };\n    t.sort(compare);\n    r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n    a.splice(0, a.length);\n    for (i = 0; i < r.length; i++) {\n      a.push(r[i]);\n    }\n    return;\n  }\n};\n\n\n/**\n * @param {Array} array\n * @return {ArrayList}\n */\nArrays.asList = function(array) {\n  var arrayList = new ArrayList();\n  for (var i = 0, len = array.length; i < len; i++) {\n    arrayList.add(array[i]);\n  }\n  return arrayList;\n};\n","export default function Character () {}\nCharacter.isWhitespace = c => ((c <= 32 && c >= 0) || c == 127)\nCharacter.toUpperCase = c => c.toUpperCase()\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Character from '../../../../java/lang/Character';\nexport default class Dimension {\n\tconstructor() {\n\t\tDimension.constructor_.apply(this, arguments);\n\t}\n\tstatic toDimensionSymbol(dimensionValue) {\n\t\tswitch (dimensionValue) {\n\t\t\tcase Dimension.FALSE:\n\t\t\t\treturn Dimension.SYM_FALSE;\n\t\t\tcase Dimension.TRUE:\n\t\t\t\treturn Dimension.SYM_TRUE;\n\t\t\tcase Dimension.DONTCARE:\n\t\t\t\treturn Dimension.SYM_DONTCARE;\n\t\t\tcase Dimension.P:\n\t\t\t\treturn Dimension.SYM_P;\n\t\t\tcase Dimension.L:\n\t\t\t\treturn Dimension.SYM_L;\n\t\t\tcase Dimension.A:\n\t\t\t\treturn Dimension.SYM_A;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Unknown dimension value: \" + dimensionValue);\n\t}\n\tstatic toDimensionValue(dimensionSymbol) {\n\t\tswitch (Character.toUpperCase(dimensionSymbol)) {\n\t\t\tcase Dimension.SYM_FALSE:\n\t\t\t\treturn Dimension.FALSE;\n\t\t\tcase Dimension.SYM_TRUE:\n\t\t\t\treturn Dimension.TRUE;\n\t\t\tcase Dimension.SYM_DONTCARE:\n\t\t\t\treturn Dimension.DONTCARE;\n\t\t\tcase Dimension.SYM_P:\n\t\t\t\treturn Dimension.P;\n\t\t\tcase Dimension.SYM_L:\n\t\t\t\treturn Dimension.L;\n\t\t\tcase Dimension.SYM_A:\n\t\t\t\treturn Dimension.A;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Unknown dimension symbol: \" + dimensionSymbol);\n\t}\n\tgetClass() {\n\t\treturn Dimension;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nDimension.constructor_ = function () {};\nDimension.P = 0;\nDimension.L = 1;\nDimension.A = 2;\nDimension.FALSE = -1;\nDimension.TRUE = -2;\nDimension.DONTCARE = -3;\nDimension.SYM_FALSE = 'F';\nDimension.SYM_TRUE = 'T';\nDimension.SYM_DONTCARE = '*';\nDimension.SYM_P = '0';\nDimension.SYM_L = '1';\nDimension.SYM_A = '2';\n","export default class GeometryFilter {\n\tconstructor() {\n\t\tGeometryFilter.constructor_.apply(this, arguments);\n\t}\n\tfilter(geom) {}\n\tgetClass() {\n\t\treturn GeometryFilter;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGeometryFilter.constructor_ = function () {};\n","export default class CoordinateSequenceFilter {\n\tconstructor() {\n\t\tCoordinateSequenceFilter.constructor_.apply(this, arguments);\n\t}\n\tfilter(seq, i) {}\n\tisDone() {}\n\tisGeometryChanged() {}\n\tgetClass() {\n\t\treturn CoordinateSequenceFilter;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCoordinateSequenceFilter.constructor_ = function () {};\n","import TreeSet from '../../../../java/util/TreeSet';\nimport Geometry from './Geometry';\nimport Arrays from '../../../../java/util/Arrays';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Dimension from './Dimension';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nimport Envelope from './Envelope';\nimport Assert from '../util/Assert';\nexport default class GeometryCollection extends Geometry {\n\tconstructor() {\n\t\tsuper();\n\t\tGeometryCollection.constructor_.apply(this, arguments);\n\t}\n\tcomputeEnvelopeInternal() {\n\t\tvar envelope = new Envelope();\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tenvelope.expandToInclude(this._geometries[i].getEnvelopeInternal());\n\t\t}\n\t\treturn envelope;\n\t}\n\tgetGeometryN(n) {\n\t\treturn this._geometries[n];\n\t}\n\tgetCoordinates() {\n\t\tvar coordinates = new Array(this.getNumPoints()).fill(null);\n\t\tvar k = -1;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tvar childCoordinates = this._geometries[i].getCoordinates();\n\t\t\tfor (var j = 0; j < childCoordinates.length; j++) {\n\t\t\t\tk++;\n\t\t\t\tcoordinates[k] = childCoordinates[j];\n\t\t\t}\n\t\t}\n\t\treturn coordinates;\n\t}\n\tgetArea() {\n\t\tvar area = 0.0;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tarea += this._geometries[i].getArea();\n\t\t}\n\t\treturn area;\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar otherCollection = other;\n\t\t\tif (this._geometries.length !== otherCollection._geometries.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tif (!this._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tnormalize() {\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tthis._geometries[i].normalize();\n\t\t}\n\t\tArrays.sort(this._geometries);\n\t}\n\tgetCoordinate() {\n\t\tif (this.isEmpty()) return null;\n\t\treturn this._geometries[0].getCoordinate();\n\t}\n\tgetBoundaryDimension() {\n\t\tvar dimension = Dimension.FALSE;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tdimension = Math.max(dimension, this._geometries[i].getBoundaryDimension());\n\t\t}\n\t\treturn dimension;\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_GEOMETRYCOLLECTION;\n\t}\n\tgetDimension() {\n\t\tvar dimension = Dimension.FALSE;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tdimension = Math.max(dimension, this._geometries[i].getDimension());\n\t\t}\n\t\treturn dimension;\n\t}\n\tgetLength() {\n\t\tvar sum = 0.0;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tsum += this._geometries[i].getLength();\n\t\t}\n\t\treturn sum;\n\t}\n\tgetNumPoints() {\n\t\tvar numPoints = 0;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tnumPoints += this._geometries[i].getNumPoints();\n\t\t}\n\t\treturn numPoints;\n\t}\n\tgetNumGeometries() {\n\t\treturn this._geometries.length;\n\t}\n\treverse() {\n\t\tvar n = this._geometries.length;\n\t\tvar revGeoms = new Array(n).fill(null);\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\trevGeoms[i] = this._geometries[i].reverse();\n\t\t}\n\t\treturn this.getFactory().createGeometryCollection(revGeoms);\n\t}\n\tcompareToSameClass() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar theseElements = new TreeSet(Arrays.asList(this._geometries));\n\t\t\tvar otherElements = new TreeSet(Arrays.asList(o._geometries));\n\t\t\treturn this.compare(theseElements, otherElements);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar gc = o;\n\t\t\tvar n1 = this.getNumGeometries();\n\t\t\tvar n2 = gc.getNumGeometries();\n\t\t\tvar i = 0;\n\t\t\twhile (i < n1 && i < n2) {\n\t\t\t\tvar thisGeom = this.getGeometryN(i);\n\t\t\t\tvar otherGeom = gc.getGeometryN(i);\n\t\t\t\tvar holeComp = thisGeom.compareToSameClass(otherGeom, comp);\n\t\t\t\tif (holeComp !== 0) return holeComp;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i < n1) return 1;\n\t\t\tif (i < n2) return -1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tapply() {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this._geometries.length === 0) return null;\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t\tif (filter.isDone()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t}\n\t\t}\n\t}\n\tgetBoundary() {\n\t\tthis.checkNotGeometryCollection(this);\n\t\tAssert.shouldNeverReachHere();\n\t\treturn null;\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_GEOMETRYCOLLECTION;\n\t}\n\tcopy() {\n\t\tvar geometries = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < geometries.length; i++) {\n\t\t\tgeometries[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new GeometryCollection(geometries, this._factory);\n\t}\n\tisEmpty() {\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tif (!this._geometries[i].isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tgetClass() {\n\t\treturn GeometryCollection;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGeometryCollection.constructor_ = function () {\n\tthis._geometries = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 2) {\n\t\tlet geometries = arguments[0], factory = arguments[1];\n\t\tGeometry.constructor_.call(this, factory);\n\t\tif (geometries === null) {\n\t\t\tgeometries = [];\n\t\t}\n\t\tif (Geometry.hasNullElements(geometries)) {\n\t\t\tthrow new IllegalArgumentException(\"geometries must not contain null elements\");\n\t\t}\n\t\tthis._geometries = geometries;\n\t}\n};\nGeometryCollection.serialVersionUID = -5694727726395021467;\n","import Geometry from './Geometry';\nimport BoundaryOp from '../operation/BoundaryOp';\nimport Lineal from './Lineal';\nimport GeometryCollection from './GeometryCollection';\nimport Dimension from './Dimension';\nexport default class MultiLineString extends GeometryCollection {\n\tconstructor() {\n\t\tsuper();\n\t\tMultiLineString.constructor_.apply(this, arguments);\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn super.equalsExact.call(this, other, tolerance);\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tgetBoundaryDimension() {\n\t\tif (this.isClosed()) {\n\t\t\treturn Dimension.FALSE;\n\t\t}\n\t\treturn 0;\n\t}\n\tisClosed() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tif (!this._geometries[i].isClosed()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_MULTILINESTRING;\n\t}\n\tgetDimension() {\n\t\treturn 1;\n\t}\n\treverse() {\n\t\tvar nLines = this._geometries.length;\n\t\tvar revLines = new Array(nLines).fill(null);\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\trevLines[nLines - 1 - i] = this._geometries[i].reverse();\n\t\t}\n\t\treturn this.getFactory().createMultiLineString(revLines);\n\t}\n\tgetBoundary() {\n\t\treturn new BoundaryOp(this).getBoundary();\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_MULTILINESTRING;\n\t}\n\tcopy() {\n\t\tvar lineStrings = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < lineStrings.length; i++) {\n\t\t\tlineStrings[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new MultiLineString(lineStrings, this._factory);\n\t}\n\tgetClass() {\n\t\treturn MultiLineString;\n\t}\n\tget interfaces_() {\n\t\treturn [Lineal];\n\t}\n}\nMultiLineString.constructor_ = function () {\n\tlet lineStrings = arguments[0], factory = arguments[1];\n\tGeometryCollection.constructor_.call(this, lineStrings, factory);\n};\nMultiLineString.serialVersionUID = 8166665132445433741;\n","import LineString from '../geom/LineString';\nimport BoundaryNodeRule from '../algorithm/BoundaryNodeRule';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport TreeMap from '../../../../java/util/TreeMap';\nimport MultiLineString from '../geom/MultiLineString';\nexport default class BoundaryOp {\n\tconstructor() {\n\t\tBoundaryOp.constructor_.apply(this, arguments);\n\t}\n\tstatic getBoundary() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet g = arguments[0];\n\t\t\tvar bop = new BoundaryOp(g);\n\t\t\treturn bop.getBoundary();\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet g = arguments[0], bnRule = arguments[1];\n\t\t\tvar bop = new BoundaryOp(g, bnRule);\n\t\t\treturn bop.getBoundary();\n\t\t}\n\t}\n\tboundaryMultiLineString(mLine) {\n\t\tif (this._geom.isEmpty()) {\n\t\t\treturn this.getEmptyMultiPoint();\n\t\t}\n\t\tvar bdyPts = this.computeBoundaryCoordinates(mLine);\n\t\tif (bdyPts.length === 1) {\n\t\t\treturn this._geomFact.createPoint(bdyPts[0]);\n\t\t}\n\t\treturn this._geomFact.createMultiPointFromCoords(bdyPts);\n\t}\n\tgetBoundary() {\n\t\tif (this._geom instanceof LineString) return this.boundaryLineString(this._geom);\n\t\tif (this._geom instanceof MultiLineString) return this.boundaryMultiLineString(this._geom);\n\t\treturn this._geom.getBoundary();\n\t}\n\tboundaryLineString(line) {\n\t\tif (this._geom.isEmpty()) {\n\t\t\treturn this.getEmptyMultiPoint();\n\t\t}\n\t\tif (line.isClosed()) {\n\t\t\tvar closedEndpointOnBoundary = this._bnRule.isInBoundary(2);\n\t\t\tif (closedEndpointOnBoundary) {\n\t\t\t\treturn line.getStartPoint();\n\t\t\t} else {\n\t\t\t\treturn this._geomFact.createMultiPoint();\n\t\t\t}\n\t\t}\n\t\treturn this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()]);\n\t}\n\tgetEmptyMultiPoint() {\n\t\treturn this._geomFact.createMultiPoint();\n\t}\n\tcomputeBoundaryCoordinates(mLine) {\n\t\tvar bdyPts = new ArrayList();\n\t\tthis._endpointMap = new TreeMap();\n\t\tfor (var i = 0; i < mLine.getNumGeometries(); i++) {\n\t\t\tvar line = mLine.getGeometryN(i);\n\t\t\tif (line.getNumPoints() === 0) continue;\n\t\t\tthis.addEndpoint(line.getCoordinateN(0));\n\t\t\tthis.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));\n\t\t}\n\t\tfor (var it = this._endpointMap.entrySet().iterator(); it.hasNext(); ) {\n\t\t\tvar entry = it.next();\n\t\t\tvar counter = entry.getValue();\n\t\t\tvar valence = counter.count;\n\t\t\tif (this._bnRule.isInBoundary(valence)) {\n\t\t\t\tbdyPts.add(entry.getKey());\n\t\t\t}\n\t\t}\n\t\treturn CoordinateArrays.toCoordinateArray(bdyPts);\n\t}\n\taddEndpoint(pt) {\n\t\tvar counter = this._endpointMap.get(pt);\n\t\tif (counter === null) {\n\t\t\tcounter = new Counter();\n\t\t\tthis._endpointMap.put(pt, counter);\n\t\t}\n\t\tcounter.count++;\n\t}\n\tgetClass() {\n\t\treturn BoundaryOp;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nBoundaryOp.constructor_ = function () {\n\tthis._geom = null;\n\tthis._geomFact = null;\n\tthis._bnRule = null;\n\tthis._endpointMap = null;\n\tif (arguments.length === 1) {\n\t\tlet geom = arguments[0];\n\t\tBoundaryOp.constructor_.call(this, geom, BoundaryNodeRule.MOD2_BOUNDARY_RULE);\n\t} else if (arguments.length === 2) {\n\t\tlet geom = arguments[0], bnRule = arguments[1];\n\t\tthis._geom = geom;\n\t\tthis._geomFact = geom.getFactory();\n\t\tthis._bnRule = bnRule;\n\t}\n};\nclass Counter {\n\tconstructor() {\n\t\tCounter.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn Counter;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCounter.constructor_ = function () {\n\tthis.count = null;\n};\n","import Coordinate from '../geom/Coordinate';\nexport default class Length {\n\tconstructor() {\n\t\tLength.constructor_.apply(this, arguments);\n\t}\n\tstatic ofLine(pts) {\n\t\tvar n = pts.size();\n\t\tif (n <= 1) return 0.0;\n\t\tvar len = 0.0;\n\t\tvar p = new Coordinate();\n\t\tpts.getCoordinate(0, p);\n\t\tvar x0 = p.x;\n\t\tvar y0 = p.y;\n\t\tfor (var i = 1; i < n; i++) {\n\t\t\tpts.getCoordinate(i, p);\n\t\t\tvar x1 = p.x;\n\t\t\tvar y1 = p.y;\n\t\t\tvar dx = x1 - x0;\n\t\t\tvar dy = y1 - y0;\n\t\t\tlen += Math.sqrt(dx * dx + dy * dy);\n\t\t\tx0 = x1;\n\t\t\ty0 = y1;\n\t\t}\n\t\treturn len;\n\t}\n\tgetClass() {\n\t\treturn Length;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nLength.constructor_ = function () {};\n","export default function PrintStream () {}\n","export default function StringReader () {}\n","export default function ByteArrayOutputStream () {}\n","export default function IOException () {}\n","export default function LineNumberReader () {}\n","import PrintStream from '../../../../java/io/PrintStream';\nimport StringReader from '../../../../java/io/StringReader';\nimport DecimalFormat from '../../../../java/text/DecimalFormat';\nimport System from '../../../../java/lang/System';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport ByteArrayOutputStream from '../../../../java/io/ByteArrayOutputStream';\nimport Assert from './Assert';\nimport IOException from '../../../../java/io/IOException';\nimport LineNumberReader from '../../../../java/io/LineNumberReader';\nexport default class StringUtil {\n\tconstructor() {\n\t\tStringUtil.constructor_.apply(this, arguments);\n\t}\n\tstatic chars(c, n) {\n\t\tvar ch = new Array(n).fill(null);\n\t\tfor (var i = 0; i < n; i++) {\n\t\t\tch[i] = c;\n\t\t}\n\t\treturn new String(ch);\n\t}\n\tstatic getStackTrace() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet t = arguments[0];\n\t\t\tvar os = new ByteArrayOutputStream();\n\t\t\tvar ps = new PrintStream(os);\n\t\t\tt.printStackTrace(ps);\n\t\t\treturn os.toString();\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet t = arguments[0], depth = arguments[1];\n\t\t\tvar stackTrace = \"\";\n\t\t\tvar stringReader = new StringReader(StringUtil.getStackTrace(t));\n\t\t\tvar lineNumberReader = new LineNumberReader(stringReader);\n\t\t\tfor (var i = 0; i < depth; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tstackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e instanceof IOException) {\n\t\t\t\t\t\tAssert.shouldNeverReachHere();\n\t\t\t\t\t} else throw e;\n\t\t\t\t} finally {}\n\t\t\t}\n\t\t\treturn stackTrace;\n\t\t}\n\t}\n\tstatic split(s, separator) {\n\t\tvar separatorlen = separator.length;\n\t\tvar tokenList = new ArrayList();\n\t\tvar tmpString = \"\" + s;\n\t\tvar pos = tmpString.indexOf(separator);\n\t\twhile (pos >= 0) {\n\t\t\tvar token = tmpString.substring(0, pos);\n\t\t\ttokenList.add(token);\n\t\t\ttmpString = tmpString.substring(pos + separatorlen);\n\t\t\tpos = tmpString.indexOf(separator);\n\t\t}\n\t\tif (tmpString.length > 0) tokenList.add(tmpString);\n\t\tvar res = new Array(tokenList.size()).fill(null);\n\t\tfor (var i = 0; i < res.length; i++) {\n\t\t\tres[i] = tokenList.get(i);\n\t\t}\n\t\treturn res;\n\t}\n\tstatic toString() {\n\t\tif (arguments.length === 1 && typeof arguments[0] === \"number\") {\n\t\t\tlet d = arguments[0];\n\t\t\treturn StringUtil.SIMPLE_ORDINATE_FORMAT.format(d);\n\t\t}\n\t}\n\tstatic spaces(n) {\n\t\treturn StringUtil.chars(' ', n);\n\t}\n\tgetClass() {\n\t\treturn StringUtil;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nStringUtil.constructor_ = function () {};\nStringUtil.NEWLINE = System.getProperty(\"line.separator\");\nStringUtil.SIMPLE_ORDINATE_FORMAT = new DecimalFormat(\"0.#\");\n","export default function StringBuilder (str) {\n    this.str = str\n  }\n  \n  StringBuilder.prototype.append = function (e) {\n    this.str += e\n  }\n  \n  StringBuilder.prototype.setCharAt = function (i, c) {\n    this.str = this.str.substr(0, i) + c + this.str.substr(i + 1)\n  }\n  \n  StringBuilder.prototype.toString = function (e) {\n    return this.str\n  }\n  ","export default function DecimalFormat () {}\n","import hasInterface from '../../../../hasInterface';\nimport StringUtil from '../util/StringUtil';\nimport Double from '../../../../java/lang/Double';\nimport CoordinateSequence from './CoordinateSequence';\nimport StringBuilder from '../../../../java/lang/StringBuilder';\nexport default class CoordinateSequences {\n\tconstructor() {\n\t\tCoordinateSequences.constructor_.apply(this, arguments);\n\t}\n\tstatic copyCoord(src, srcPos, dest, destPos) {\n\t\tvar minDim = Math.min(src.getDimension(), dest.getDimension());\n\t\tfor (var dim = 0; dim < minDim; dim++) {\n\t\t\tdest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));\n\t\t}\n\t}\n\tstatic isRing(seq) {\n\t\tvar n = seq.size();\n\t\tif (n === 0) return true;\n\t\tif (n <= 3) return false;\n\t\treturn seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n\t}\n\tstatic isEqual(cs1, cs2) {\n\t\tvar cs1Size = cs1.size();\n\t\tvar cs2Size = cs2.size();\n\t\tif (cs1Size !== cs2Size) return false;\n\t\tvar dim = Math.min(cs1.getDimension(), cs2.getDimension());\n\t\tfor (var i = 0; i < cs1Size; i++) {\n\t\t\tfor (var d = 0; d < dim; d++) {\n\t\t\t\tvar v1 = cs1.getOrdinate(i, d);\n\t\t\t\tvar v2 = cs2.getOrdinate(i, d);\n\t\t\t\tif (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) continue;\n\t\t\t\tif (Double.isNaN(v1) && Double.isNaN(v2)) continue;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tstatic extend(fact, seq, size) {\n\t\tvar newseq = fact.create(size, seq.getDimension());\n\t\tvar n = seq.size();\n\t\tCoordinateSequences.copy(seq, 0, newseq, 0, n);\n\t\tif (n > 0) {\n\t\t\tfor (var i = n; i < size; i++) CoordinateSequences.copy(seq, n - 1, newseq, i, 1);\n\t\t}\n\t\treturn newseq;\n\t}\n\tstatic reverse(seq) {\n\t\tvar last = seq.size() - 1;\n\t\tvar mid = Math.trunc(last / 2);\n\t\tfor (var i = 0; i <= mid; i++) {\n\t\t\tCoordinateSequences.swap(seq, i, last - i);\n\t\t}\n\t}\n\tstatic swap(seq, i, j) {\n\t\tif (i === j) return null;\n\t\tfor (var dim = 0; dim < seq.getDimension(); dim++) {\n\t\t\tvar tmp = seq.getOrdinate(i, dim);\n\t\t\tseq.setOrdinate(i, dim, seq.getOrdinate(j, dim));\n\t\t\tseq.setOrdinate(j, dim, tmp);\n\t\t}\n\t}\n\tstatic copy(src, srcPos, dest, destPos, length) {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tCoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);\n\t\t}\n\t}\n\tstatic toString() {\n\t\tif (arguments.length === 1 && hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\tlet cs = arguments[0];\n\t\t\tvar size = cs.size();\n\t\t\tif (size === 0) return \"()\";\n\t\t\tvar dim = cs.getDimension();\n\t\t\tvar builder = new StringBuilder();\n\t\t\tbuilder.append('(');\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tif (i > 0) builder.append(\" \");\n\t\t\t\tfor (var d = 0; d < dim; d++) {\n\t\t\t\t\tif (d > 0) builder.append(\",\");\n\t\t\t\t\tbuilder.append(StringUtil.toString(cs.getOrdinate(i, d)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuilder.append(')');\n\t\t\treturn builder.toString();\n\t\t}\n\t}\n\tstatic ensureValidRing(fact, seq) {\n\t\tvar n = seq.size();\n\t\tif (n === 0) return seq;\n\t\tif (n <= 3) return CoordinateSequences.createClosedRing(fact, seq, 4);\n\t\tvar isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n\t\tif (isClosed) return seq;\n\t\treturn CoordinateSequences.createClosedRing(fact, seq, n + 1);\n\t}\n\tstatic createClosedRing(fact, seq, size) {\n\t\tvar newseq = fact.create(size, seq.getDimension());\n\t\tvar n = seq.size();\n\t\tCoordinateSequences.copy(seq, 0, newseq, 0, n);\n\t\tfor (var i = n; i < size; i++) CoordinateSequences.copy(seq, 0, newseq, i, 1);\n\t\treturn newseq;\n\t}\n\tgetClass() {\n\t\treturn CoordinateSequences;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCoordinateSequences.constructor_ = function () {};\n","import Geometry from './Geometry';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport BoundaryOp from '../operation/BoundaryOp';\nimport Length from '../algorithm/Length';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Lineal from './Lineal';\nimport CoordinateSequences from './CoordinateSequences';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Dimension from './Dimension';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nimport Envelope from './Envelope';\nexport default class LineString extends Geometry {\n\tconstructor() {\n\t\tsuper();\n\t\tLineString.constructor_.apply(this, arguments);\n\t}\n\tcomputeEnvelopeInternal() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn new Envelope();\n\t\t}\n\t\treturn this._points.expandEnvelope(new Envelope());\n\t}\n\tisRing() {\n\t\treturn this.isClosed() && this.isSimple();\n\t}\n\tgetCoordinates() {\n\t\treturn this._points.toCoordinateArray();\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar otherLineString = other;\n\t\t\tif (this._points.size() !== otherLineString._points.size()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\t\tif (!this.equal(this._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tnormalize() {\n\t\tfor (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {\n\t\t\tvar j = this._points.size() - 1 - i;\n\t\t\tif (!this._points.getCoordinate(i).equals(this._points.getCoordinate(j))) {\n\t\t\t\tif (this._points.getCoordinate(i).compareTo(this._points.getCoordinate(j)) > 0) {\n\t\t\t\t\tvar copy = this._points.copy();\n\t\t\t\t\tCoordinateSequences.reverse(copy);\n\t\t\t\t\tthis._points = copy;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\tgetCoordinate() {\n\t\tif (this.isEmpty()) return null;\n\t\treturn this._points.getCoordinate(0);\n\t}\n\tgetBoundaryDimension() {\n\t\tif (this.isClosed()) {\n\t\t\treturn Dimension.FALSE;\n\t\t}\n\t\treturn 0;\n\t}\n\tisClosed() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));\n\t}\n\tgetEndPoint() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.getPointN(this.getNumPoints() - 1);\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_LINESTRING;\n\t}\n\tgetDimension() {\n\t\treturn 1;\n\t}\n\tgetLength() {\n\t\treturn Length.ofLine(this._points);\n\t}\n\tgetNumPoints() {\n\t\treturn this._points.size();\n\t}\n\treverse() {\n\t\tvar seq = this._points.copy();\n\t\tCoordinateSequences.reverse(seq);\n\t\tvar revLine = this.getFactory().createLineString(seq);\n\t\treturn revLine;\n\t}\n\tcompareToSameClass() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar line = o;\n\t\t\tvar i = 0;\n\t\t\tvar j = 0;\n\t\t\twhile (i < this._points.size() && j < line._points.size()) {\n\t\t\t\tvar comparison = this._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));\n\t\t\t\tif (comparison !== 0) {\n\t\t\t\t\treturn comparison;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (i < this._points.size()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (j < line._points.size()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar line = o;\n\t\t\treturn comp.compare(this._points, line._points);\n\t\t}\n\t}\n\tapply() {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\t\tfilter.filter(this._points.getCoordinate(i));\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this._points.size() === 0) return null;\n\t\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\t\tfilter.filter(this._points, i);\n\t\t\t\tif (filter.isDone()) break;\n\t\t\t}\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t}\n\t}\n\tgetBoundary() {\n\t\treturn new BoundaryOp(this).getBoundary();\n\t}\n\tisEquivalentClass(other) {\n\t\treturn other instanceof LineString;\n\t}\n\tgetCoordinateN(n) {\n\t\treturn this._points.getCoordinate(n);\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_LINESTRING;\n\t}\n\tcopy() {\n\t\treturn new LineString(this._points.copy(), this._factory);\n\t}\n\tgetCoordinateSequence() {\n\t\treturn this._points;\n\t}\n\tisEmpty() {\n\t\treturn this._points.size() === 0;\n\t}\n\tinit(points) {\n\t\tif (points === null) {\n\t\t\tpoints = this.getFactory().getCoordinateSequenceFactory().create([]);\n\t\t}\n\t\tif (points.size() === 1) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid number of points in LineString (found \" + points.size() + \" - must be 0 or >= 2)\");\n\t\t}\n\t\tthis._points = points;\n\t}\n\tisCoordinate(pt) {\n\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\tif (this._points.getCoordinate(i).equals(pt)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tgetStartPoint() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.getPointN(0);\n\t}\n\tgetPointN(n) {\n\t\treturn this.getFactory().createPoint(this._points.getCoordinate(n));\n\t}\n\tgetClass() {\n\t\treturn LineString;\n\t}\n\tget interfaces_() {\n\t\treturn [Lineal];\n\t}\n}\nLineString.constructor_ = function () {\n\tthis._points = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 2) {\n\t\tlet points = arguments[0], factory = arguments[1];\n\t\tGeometry.constructor_.call(this, factory);\n\t\tthis.init(points);\n\t}\n};\nLineString.serialVersionUID = 3110669828065365560;\n","export default class Puntal {\n\tconstructor() {\n\t\tPuntal.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn Puntal;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPuntal.constructor_ = function () {};\n","import Geometry from './Geometry';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Dimension from './Dimension';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nimport Puntal from './Puntal';\nimport Envelope from './Envelope';\nimport Assert from '../util/Assert';\nexport default class Point extends Geometry {\n\tconstructor() {\n\t\tsuper();\n\t\tPoint.constructor_.apply(this, arguments);\n\t}\n\tcomputeEnvelopeInternal() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn new Envelope();\n\t\t}\n\t\tvar env = new Envelope();\n\t\tenv.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));\n\t\treturn env;\n\t}\n\tgetCoordinates() {\n\t\treturn this.isEmpty() ? [] : [this.getCoordinate()];\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.isEmpty() && other.isEmpty()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (this.isEmpty() !== other.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tnormalize() {}\n\tgetCoordinate() {\n\t\treturn this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;\n\t}\n\tgetBoundaryDimension() {\n\t\treturn Dimension.FALSE;\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_POINT;\n\t}\n\tgetDimension() {\n\t\treturn 0;\n\t}\n\tgetNumPoints() {\n\t\treturn this.isEmpty() ? 0 : 1;\n\t}\n\treverse() {\n\t\treturn this.copy();\n\t}\n\tgetX() {\n\t\tif (this.getCoordinate() === null) {\n\t\t\tthrow new IllegalStateException(\"getX called on empty Point\");\n\t\t}\n\t\treturn this.getCoordinate().x;\n\t}\n\tcompareToSameClass() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet other = arguments[0];\n\t\t\tvar point = other;\n\t\t\treturn this.getCoordinate().compareTo(point.getCoordinate());\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet other = arguments[0], comp = arguments[1];\n\t\t\tvar point = other;\n\t\t\treturn comp.compare(this._coordinates, point._coordinates);\n\t\t}\n\t}\n\tapply() {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfilter.filter(this.getCoordinate());\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this.isEmpty()) return null;\n\t\t\tfilter.filter(this._coordinates, 0);\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t}\n\t}\n\tgetBoundary() {\n\t\treturn this.getFactory().createGeometryCollection();\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_POINT;\n\t}\n\tcopy() {\n\t\treturn new Point(this._coordinates.copy(), this._factory);\n\t}\n\tgetCoordinateSequence() {\n\t\treturn this._coordinates;\n\t}\n\tgetY() {\n\t\tif (this.getCoordinate() === null) {\n\t\t\tthrow new IllegalStateException(\"getY called on empty Point\");\n\t\t}\n\t\treturn this.getCoordinate().y;\n\t}\n\tisEmpty() {\n\t\treturn this._coordinates.size() === 0;\n\t}\n\tinit(coordinates) {\n\t\tif (coordinates === null) {\n\t\t\tcoordinates = this.getFactory().getCoordinateSequenceFactory().create([]);\n\t\t}\n\t\tAssert.isTrue(coordinates.size() <= 1);\n\t\tthis._coordinates = coordinates;\n\t}\n\tisSimple() {\n\t\treturn true;\n\t}\n\tgetClass() {\n\t\treturn Point;\n\t}\n\tget interfaces_() {\n\t\treturn [Puntal];\n\t}\n}\nPoint.constructor_ = function () {\n\tthis._coordinates = null;\n\tlet coordinates = arguments[0], factory = arguments[1];\n\tGeometry.constructor_.call(this, factory);\n\tthis.init(coordinates);\n};\nPoint.serialVersionUID = 4902022702746614570;\n","import hasInterface from '../../../../hasInterface';\nimport Coordinate from '../geom/Coordinate';\nimport CoordinateSequence from '../geom/CoordinateSequence';\nexport default class Area {\n\tconstructor() {\n\t\tArea.constructor_.apply(this, arguments);\n\t}\n\tstatic ofRing() {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tlet ring = arguments[0];\n\t\t\treturn Math.abs(Area.ofRingSigned(ring));\n\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\tlet ring = arguments[0];\n\t\t\treturn Math.abs(Area.ofRingSigned(ring));\n\t\t}\n\t}\n\tstatic ofRingSigned() {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tlet ring = arguments[0];\n\t\t\tif (ring.length < 3) return 0.0;\n\t\t\tvar sum = 0.0;\n\t\t\tvar x0 = ring[0].x;\n\t\t\tfor (var i = 1; i < ring.length - 1; i++) {\n\t\t\t\tvar x = ring[i].x - x0;\n\t\t\t\tvar y1 = ring[i + 1].y;\n\t\t\t\tvar y2 = ring[i - 1].y;\n\t\t\t\tsum += x * (y2 - y1);\n\t\t\t}\n\t\t\treturn sum / 2.0;\n\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\tlet ring = arguments[0];\n\t\t\tvar n = ring.size();\n\t\t\tif (n < 3) return 0.0;\n\t\t\tvar p0 = new Coordinate();\n\t\t\tvar p1 = new Coordinate();\n\t\t\tvar p2 = new Coordinate();\n\t\t\tring.getCoordinate(0, p1);\n\t\t\tring.getCoordinate(1, p2);\n\t\t\tvar x0 = p1.x;\n\t\t\tp2.x -= x0;\n\t\t\tvar sum = 0.0;\n\t\t\tfor (var i = 1; i < n - 1; i++) {\n\t\t\t\tp0.y = p1.y;\n\t\t\t\tp1.x = p2.x;\n\t\t\t\tp1.y = p2.y;\n\t\t\t\tring.getCoordinate(i + 1, p2);\n\t\t\t\tp2.x -= x0;\n\t\t\t\tsum += p1.x * (p0.y - p2.y);\n\t\t\t}\n\t\t\treturn sum / 2.0;\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn Area;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nArea.constructor_ = function () {};\n","export default function StringBuffer (str) {\n  this.str = str\n}\n\nStringBuffer.prototype.append = function (e) {\n  this.str += e\n}\n\nStringBuffer.prototype.setCharAt = function (i, c) {\n  this.str = this.str.substr(0, i) + c + this.str.substr(i + 1)\n}\n\nStringBuffer.prototype.toString = function (e) {\n  return this.str\n}\n","export default function Integer (value) {\n  this.value = value\n}\n\nInteger.prototype.intValue = function () {\n  return this.value\n}\nInteger.prototype.compareTo = function (o) {\n  if (this.value < o) return -1\n  if (this.value > o) return 1\n  return 0\n}\n\nInteger.isNaN = n => Number.isNaN(n)\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Double from '../../../../java/lang/Double';\nimport Integer from '../../../../java/lang/Integer';\nimport Character from '../../../../java/lang/Character';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport Serializable from '../../../../java/io/Serializable';\nexport default class DD {\n\tconstructor() {\n\t\tDD.constructor_.apply(this, arguments);\n\t}\n\tstatic sqr(x) {\n\t\treturn DD.valueOf(x).selfMultiply(x);\n\t}\n\tstatic valueOf() {\n\t\tif (typeof arguments[0] === \"string\") {\n\t\t\tlet str = arguments[0];\n\t\t\treturn DD.parse(str);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet x = arguments[0];\n\t\t\treturn new DD(x);\n\t\t}\n\t}\n\tstatic sqrt(x) {\n\t\treturn DD.valueOf(x).sqrt();\n\t}\n\tstatic parse(str) {\n\t\tvar i = 0;\n\t\tvar strlen = str.length;\n\t\twhile (Character.isWhitespace(str.charAt(i))) i++;\n\t\tvar isNegative = false;\n\t\tif (i < strlen) {\n\t\t\tvar signCh = str.charAt(i);\n\t\t\tif (signCh === '-' || signCh === '+') {\n\t\t\t\ti++;\n\t\t\t\tif (signCh === '-') isNegative = true;\n\t\t\t}\n\t\t}\n\t\tvar val = new DD();\n\t\tvar numDigits = 0;\n\t\tvar numBeforeDec = 0;\n\t\tvar exp = 0;\n\t\twhile (true) {\n\t\t\tif (i >= strlen) break;\n\t\t\tvar ch = str.charAt(i);\n\t\t\ti++;\n\t\t\tif (Character.isDigit(ch)) {\n\t\t\t\tvar d = ch - '0';\n\t\t\t\tval.selfMultiply(DD.TEN);\n\t\t\t\tval.selfAdd(d);\n\t\t\t\tnumDigits++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch === '.') {\n\t\t\t\tnumBeforeDec = numDigits;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch === 'e' || ch === 'E') {\n\t\t\t\tvar expStr = str.substring(i);\n\t\t\t\ttry {\n\t\t\t\t\texp = Integer.parseInt(expStr);\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tif (ex instanceof NumberFormatException) {\n\t\t\t\t\t\tthrow new NumberFormatException(\"Invalid exponent \" + expStr + \" in string \" + str);\n\t\t\t\t\t} else throw ex;\n\t\t\t\t} finally {}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthrow new NumberFormatException(\"Unexpected character '\" + ch + \"' at position \" + i + \" in string \" + str);\n\t\t}\n\t\tvar val2 = val;\n\t\tvar numDecPlaces = numDigits - numBeforeDec - exp;\n\t\tif (numDecPlaces === 0) {\n\t\t\tval2 = val;\n\t\t} else if (numDecPlaces > 0) {\n\t\t\tvar scale = DD.TEN.pow(numDecPlaces);\n\t\t\tval2 = val.divide(scale);\n\t\t} else if (numDecPlaces < 0) {\n\t\t\tvar scale = DD.TEN.pow(-numDecPlaces);\n\t\t\tval2 = val.multiply(scale);\n\t\t}\n\t\tif (isNegative) {\n\t\t\treturn val2.negate();\n\t\t}\n\t\treturn val2;\n\t}\n\tstatic createNaN() {\n\t\treturn new DD(Double.NaN, Double.NaN);\n\t}\n\tstatic copy(dd) {\n\t\treturn new DD(dd);\n\t}\n\tstatic magnitude(x) {\n\t\tvar xAbs = Math.abs(x);\n\t\tvar xLog10 = Math.log(xAbs) / Math.log(10);\n\t\tvar xMag = Math.trunc(Math.floor(xLog10));\n\t\tvar xApprox = Math.pow(10, xMag);\n\t\tif (xApprox * 10 <= xAbs) xMag += 1;\n\t\treturn xMag;\n\t}\n\tstatic stringOfChar(ch, len) {\n\t\tvar buf = new StringBuffer();\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tbuf.append(ch);\n\t\t}\n\t\treturn buf.toString();\n\t}\n\tle(y) {\n\t\treturn this._hi < y._hi || this._hi === y._hi && this._lo <= y._lo;\n\t}\n\textractSignificantDigits(insertDecimalPoint, magnitude) {\n\t\tvar y = this.abs();\n\t\tvar mag = DD.magnitude(y._hi);\n\t\tvar scale = DD.TEN.pow(mag);\n\t\ty = y.divide(scale);\n\t\tif (y.gt(DD.TEN)) {\n\t\t\ty = y.divide(DD.TEN);\n\t\t\tmag += 1;\n\t\t} else if (y.lt(DD.ONE)) {\n\t\t\ty = y.multiply(DD.TEN);\n\t\t\tmag -= 1;\n\t\t}\n\t\tvar decimalPointPos = mag + 1;\n\t\tvar buf = new StringBuffer();\n\t\tvar numDigits = DD.MAX_PRINT_DIGITS - 1;\n\t\tfor (var i = 0; i <= numDigits; i++) {\n\t\t\tif (insertDecimalPoint && i === decimalPointPos) {\n\t\t\t\tbuf.append('.');\n\t\t\t}\n\t\t\tvar digit = Math.trunc(y._hi);\n\t\t\tif (digit < 0 || digit > 9) {}\n\t\t\tif (digit < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar rebiasBy10 = false;\n\t\t\tvar digitChar = 0;\n\t\t\tif (digit > 9) {\n\t\t\t\trebiasBy10 = true;\n\t\t\t\tdigitChar = '9';\n\t\t\t} else {\n\t\t\t\tdigitChar = '0' + digit;\n\t\t\t}\n\t\t\tbuf.append(digitChar);\n\t\t\ty = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);\n\t\t\tif (rebiasBy10) y.selfAdd(DD.TEN);\n\t\t\tvar continueExtractingDigits = true;\n\t\t\tvar remMag = DD.magnitude(y._hi);\n\t\t\tif (remMag < 0 && Math.abs(remMag) >= numDigits - i) continueExtractingDigits = false;\n\t\t\tif (!continueExtractingDigits) break;\n\t\t}\n\t\tmagnitude[0] = mag;\n\t\treturn buf.toString();\n\t}\n\tsqr() {\n\t\treturn this.multiply(this);\n\t}\n\tdoubleValue() {\n\t\treturn this._hi + this._lo;\n\t}\n\tsubtract() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\treturn this.add(y.negate());\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\treturn this.add(-y);\n\t\t}\n\t}\n\tequals() {\n\t\tif (arguments.length === 1 && arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\treturn this._hi === y._hi && this._lo === y._lo;\n\t\t}\n\t}\n\tisZero() {\n\t\treturn this._hi === 0.0 && this._lo === 0.0;\n\t}\n\tselfSubtract() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\tif (this.isNaN()) return this;\n\t\t\treturn this.selfAdd(-y._hi, -y._lo);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\tif (this.isNaN()) return this;\n\t\t\treturn this.selfAdd(-y, 0.0);\n\t\t}\n\t}\n\tgetSpecialNumberString() {\n\t\tif (this.isZero()) return \"0.0\";\n\t\tif (this.isNaN()) return \"NaN \";\n\t\treturn null;\n\t}\n\tmin(x) {\n\t\tif (this.le(x)) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn x;\n\t\t}\n\t}\n\tselfDivide() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof DD) {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfDivide(y._hi, y._lo);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfDivide(y, 0.0);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet yhi = arguments[0], ylo = arguments[1];\n\t\t\tvar hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;\n\t\t\tC = this._hi / yhi;\n\t\t\tc = DD.SPLIT * C;\n\t\t\thc = c - C;\n\t\t\tu = DD.SPLIT * yhi;\n\t\t\thc = c - hc;\n\t\t\ttc = C - hc;\n\t\t\thy = u - yhi;\n\t\t\tU = C * yhi;\n\t\t\thy = u - hy;\n\t\t\tty = yhi - hy;\n\t\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n\t\t\tc = (this._hi - U - u + this._lo - C * ylo) / yhi;\n\t\t\tu = C + c;\n\t\t\tthis._hi = u;\n\t\t\tthis._lo = C - u + c;\n\t\t\treturn this;\n\t\t}\n\t}\n\tdump() {\n\t\treturn \"DD<\" + this._hi + \", \" + this._lo + \">\";\n\t}\n\tdivide() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\tvar hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;\n\t\t\tC = this._hi / y._hi;\n\t\t\tc = DD.SPLIT * C;\n\t\t\thc = c - C;\n\t\t\tu = DD.SPLIT * y._hi;\n\t\t\thc = c - hc;\n\t\t\ttc = C - hc;\n\t\t\thy = u - y._hi;\n\t\t\tU = C * y._hi;\n\t\t\thy = u - hy;\n\t\t\tty = y._hi - hy;\n\t\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n\t\t\tc = (this._hi - U - u + this._lo - C * y._lo) / y._hi;\n\t\t\tu = C + c;\n\t\t\tvar zhi = u;\n\t\t\tvar zlo = C - u + c;\n\t\t\treturn new DD(zhi, zlo);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\tif (Double.isNaN(y)) return DD.createNaN();\n\t\t\treturn DD.copy(this).selfDivide(y, 0.0);\n\t\t}\n\t}\n\tge(y) {\n\t\treturn this._hi > y._hi || this._hi === y._hi && this._lo >= y._lo;\n\t}\n\tpow(exp) {\n\t\tif (exp === 0.0) return DD.valueOf(1.0);\n\t\tvar r = new DD(this);\n\t\tvar s = DD.valueOf(1.0);\n\t\tvar n = Math.abs(exp);\n\t\tif (n > 1) {\n\t\t\twhile (n > 0) {\n\t\t\t\tif (n % 2 === 1) {\n\t\t\t\t\ts.selfMultiply(r);\n\t\t\t\t}\n\t\t\t\tn /= 2;\n\t\t\t\tif (n > 0) r = r.sqr();\n\t\t\t}\n\t\t} else {\n\t\t\ts = r;\n\t\t}\n\t\tif (exp < 0) return s.reciprocal();\n\t\treturn s;\n\t}\n\tceil() {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tvar fhi = Math.ceil(this._hi);\n\t\tvar flo = 0.0;\n\t\tif (fhi === this._hi) {\n\t\t\tflo = Math.ceil(this._lo);\n\t\t}\n\t\treturn new DD(fhi, flo);\n\t}\n\tcompareTo(o) {\n\t\tvar other = o;\n\t\tif (this._hi < other._hi) return -1;\n\t\tif (this._hi > other._hi) return 1;\n\t\tif (this._lo < other._lo) return -1;\n\t\tif (this._lo > other._lo) return 1;\n\t\treturn 0;\n\t}\n\trint() {\n\t\tif (this.isNaN()) return this;\n\t\tvar plus5 = this.add(0.5);\n\t\treturn plus5.floor();\n\t}\n\tsetValue() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet value = arguments[0];\n\t\t\tthis.init(value);\n\t\t\treturn this;\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet value = arguments[0];\n\t\t\tthis.init(value);\n\t\t\treturn this;\n\t\t}\n\t}\n\tmax(x) {\n\t\tif (this.ge(x)) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn x;\n\t\t}\n\t}\n\tsqrt() {\n\t\tif (this.isZero()) return DD.valueOf(0.0);\n\t\tif (this.isNegative()) {\n\t\t\treturn DD.NaN;\n\t\t}\n\t\tvar x = 1.0 / Math.sqrt(this._hi);\n\t\tvar ax = this._hi * x;\n\t\tvar axdd = DD.valueOf(ax);\n\t\tvar diffSq = this.subtract(axdd.sqr());\n\t\tvar d2 = diffSq._hi * (x * 0.5);\n\t\treturn axdd.add(d2);\n\t}\n\tselfAdd() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof DD) {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfAdd(y._hi, y._lo);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\tvar H = null, h = null, S = null, s = null, e = null, f = null;\n\t\t\t\tS = this._hi + y;\n\t\t\t\te = S - this._hi;\n\t\t\t\ts = S - e;\n\t\t\t\ts = y - e + (this._hi - s);\n\t\t\t\tf = s + this._lo;\n\t\t\t\tH = S + f;\n\t\t\t\th = f + (S - H);\n\t\t\t\tthis._hi = H + h;\n\t\t\t\tthis._lo = h + (H - this._hi);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet yhi = arguments[0], ylo = arguments[1];\n\t\t\tvar H = null, h = null, T = null, t = null, S = null, s = null, e = null, f = null;\n\t\t\tS = this._hi + yhi;\n\t\t\tT = this._lo + ylo;\n\t\t\te = S - this._hi;\n\t\t\tf = T - this._lo;\n\t\t\ts = S - e;\n\t\t\tt = T - f;\n\t\t\ts = yhi - e + (this._hi - s);\n\t\t\tt = ylo - f + (this._lo - t);\n\t\t\te = s + T;\n\t\t\tH = S + e;\n\t\t\th = e + (S - H);\n\t\t\te = t + h;\n\t\t\tvar zhi = H + e;\n\t\t\tvar zlo = e + (H - zhi);\n\t\t\tthis._hi = zhi;\n\t\t\tthis._lo = zlo;\n\t\t\treturn this;\n\t\t}\n\t}\n\tselfMultiply() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof DD) {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfMultiply(y._hi, y._lo);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfMultiply(y, 0.0);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet yhi = arguments[0], ylo = arguments[1];\n\t\t\tvar hx = null, tx = null, hy = null, ty = null, C = null, c = null;\n\t\t\tC = DD.SPLIT * this._hi;\n\t\t\thx = C - this._hi;\n\t\t\tc = DD.SPLIT * yhi;\n\t\t\thx = C - hx;\n\t\t\ttx = this._hi - hx;\n\t\t\thy = c - yhi;\n\t\t\tC = this._hi * yhi;\n\t\t\thy = c - hy;\n\t\t\tty = yhi - hy;\n\t\t\tc = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);\n\t\t\tvar zhi = C + c;\n\t\t\thx = C - zhi;\n\t\t\tvar zlo = c + hx;\n\t\t\tthis._hi = zhi;\n\t\t\tthis._lo = zlo;\n\t\t\treturn this;\n\t\t}\n\t}\n\tselfSqr() {\n\t\treturn this.selfMultiply(this);\n\t}\n\tfloor() {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tvar fhi = Math.floor(this._hi);\n\t\tvar flo = 0.0;\n\t\tif (fhi === this._hi) {\n\t\t\tflo = Math.floor(this._lo);\n\t\t}\n\t\treturn new DD(fhi, flo);\n\t}\n\tnegate() {\n\t\tif (this.isNaN()) return this;\n\t\treturn new DD(-this._hi, -this._lo);\n\t}\n\tclone() {\n\t\ttry {\n\t\t\treturn null;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof CloneNotSupportedException) {\n\t\t\t\treturn null;\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t}\n\tmultiply() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\tif (y.isNaN()) return DD.createNaN();\n\t\t\treturn DD.copy(this).selfMultiply(y);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\tif (Double.isNaN(y)) return DD.createNaN();\n\t\t\treturn DD.copy(this).selfMultiply(y, 0.0);\n\t\t}\n\t}\n\tisNaN() {\n\t\treturn Double.isNaN(this._hi);\n\t}\n\tintValue() {\n\t\treturn Math.trunc(this._hi);\n\t}\n\ttoString() {\n\t\tvar mag = DD.magnitude(this._hi);\n\t\tif (mag >= -3 && mag <= 20) return this.toStandardNotation();\n\t\treturn this.toSciNotation();\n\t}\n\ttoStandardNotation() {\n\t\tvar specialStr = this.getSpecialNumberString();\n\t\tif (specialStr !== null) return specialStr;\n\t\tvar magnitude = new Array(1).fill(null);\n\t\tvar sigDigits = this.extractSignificantDigits(true, magnitude);\n\t\tvar decimalPointPos = magnitude[0] + 1;\n\t\tvar num = sigDigits;\n\t\tif (sigDigits.charAt(0) === '.') {\n\t\t\tnum = \"0\" + sigDigits;\n\t\t} else if (decimalPointPos < 0) {\n\t\t\tnum = \"0.\" + DD.stringOfChar('0', -decimalPointPos) + sigDigits;\n\t\t} else if (sigDigits.indexOf('.') === -1) {\n\t\t\tvar numZeroes = decimalPointPos - sigDigits.length;\n\t\t\tvar zeroes = DD.stringOfChar('0', numZeroes);\n\t\t\tnum = sigDigits + zeroes + \".0\";\n\t\t}\n\t\tif (this.isNegative()) return \"-\" + num;\n\t\treturn num;\n\t}\n\treciprocal() {\n\t\tvar hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;\n\t\tC = 1.0 / this._hi;\n\t\tc = DD.SPLIT * C;\n\t\thc = c - C;\n\t\tu = DD.SPLIT * this._hi;\n\t\thc = c - hc;\n\t\ttc = C - hc;\n\t\thy = u - this._hi;\n\t\tU = C * this._hi;\n\t\thy = u - hy;\n\t\tty = this._hi - hy;\n\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n\t\tc = (1.0 - U - u - C * this._lo) / this._hi;\n\t\tvar zhi = C + c;\n\t\tvar zlo = C - zhi + c;\n\t\treturn new DD(zhi, zlo);\n\t}\n\ttoSciNotation() {\n\t\tif (this.isZero()) return DD.SCI_NOT_ZERO;\n\t\tvar specialStr = this.getSpecialNumberString();\n\t\tif (specialStr !== null) return specialStr;\n\t\tvar magnitude = new Array(1).fill(null);\n\t\tvar digits = this.extractSignificantDigits(false, magnitude);\n\t\tvar expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];\n\t\tif (digits.charAt(0) === '0') {\n\t\t\tthrow new IllegalStateException(\"Found leading zero: \" + digits);\n\t\t}\n\t\tvar trailingDigits = \"\";\n\t\tif (digits.length > 1) trailingDigits = digits.substring(1);\n\t\tvar digitsWithDecimal = digits.charAt(0) + \".\" + trailingDigits;\n\t\tif (this.isNegative()) return \"-\" + digitsWithDecimal + expStr;\n\t\treturn digitsWithDecimal + expStr;\n\t}\n\tabs() {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tif (this.isNegative()) return this.negate();\n\t\treturn new DD(this);\n\t}\n\tisPositive() {\n\t\treturn this._hi > 0.0 || this._hi === 0.0 && this._lo > 0.0;\n\t}\n\tlt(y) {\n\t\treturn this._hi < y._hi || this._hi === y._hi && this._lo < y._lo;\n\t}\n\tadd() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\treturn DD.copy(this).selfAdd(y);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\treturn DD.copy(this).selfAdd(y);\n\t\t}\n\t}\n\tinit() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (typeof arguments[0] === \"number\") {\n\t\t\t\tlet x = arguments[0];\n\t\t\t\tthis._hi = x;\n\t\t\t\tthis._lo = 0.0;\n\t\t\t} else if (arguments[0] instanceof DD) {\n\t\t\t\tlet dd = arguments[0];\n\t\t\t\tthis._hi = dd._hi;\n\t\t\t\tthis._lo = dd._lo;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet hi = arguments[0], lo = arguments[1];\n\t\t\tthis._hi = hi;\n\t\t\tthis._lo = lo;\n\t\t}\n\t}\n\tgt(y) {\n\t\treturn this._hi > y._hi || this._hi === y._hi && this._lo > y._lo;\n\t}\n\tisNegative() {\n\t\treturn this._hi < 0.0 || this._hi === 0.0 && this._lo < 0.0;\n\t}\n\ttrunc() {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tif (this.isPositive()) return this.floor(); else return this.ceil();\n\t}\n\tsignum() {\n\t\tif (this._hi > 0) return 1;\n\t\tif (this._hi < 0) return -1;\n\t\tif (this._lo > 0) return 1;\n\t\tif (this._lo < 0) return -1;\n\t\treturn 0;\n\t}\n\tgetClass() {\n\t\treturn DD;\n\t}\n\tget interfaces_() {\n\t\treturn [Serializable, Comparable, Cloneable];\n\t}\n}\nDD.constructor_ = function () {\n\tthis._hi = 0.0;\n\tthis._lo = 0.0;\n\tif (arguments.length === 0) {\n\t\tthis.init(0.0);\n\t} else if (arguments.length === 1) {\n\t\tif (typeof arguments[0] === \"number\") {\n\t\t\tlet x = arguments[0];\n\t\t\tthis.init(x);\n\t\t} else if (arguments[0] instanceof DD) {\n\t\t\tlet dd = arguments[0];\n\t\t\tthis.init(dd);\n\t\t} else if (typeof arguments[0] === \"string\") {\n\t\t\tlet str = arguments[0];\n\t\t\tDD.constructor_.call(this, DD.parse(str));\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet hi = arguments[0], lo = arguments[1];\n\t\tthis.init(hi, lo);\n\t}\n};\nDD.PI = new DD(3.141592653589793116e+00, 1.224646799147353207e-16);\nDD.TWO_PI = new DD(6.283185307179586232e+00, 2.449293598294706414e-16);\nDD.PI_2 = new DD(1.570796326794896558e+00, 6.123233995736766036e-17);\nDD.E = new DD(2.718281828459045091e+00, 1.445646891729250158e-16);\nDD.NaN = new DD(Double.NaN, Double.NaN);\nDD.EPS = 1.23259516440783e-32;\nDD.SPLIT = 134217729.0;\nDD.MAX_PRINT_DIGITS = 32;\nDD.TEN = DD.valueOf(10.0);\nDD.ONE = DD.valueOf(1.0);\nDD.SCI_NOT_EXPONENT_CHAR = \"E\";\nDD.SCI_NOT_ZERO = \"0.0E0\";\n","import Coordinate from '../geom/Coordinate';\nimport DD from '../math/DD';\nexport default class CGAlgorithmsDD {\n\tconstructor() {\n\t\tCGAlgorithmsDD.constructor_.apply(this, arguments);\n\t}\n\tstatic orientationIndex(p1, p2, q) {\n\t\tvar index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);\n\t\tif (index <= 1) return index;\n\t\tvar dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);\n\t\tvar dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);\n\t\tvar dx2 = DD.valueOf(q.x).selfAdd(-p2.x);\n\t\tvar dy2 = DD.valueOf(q.y).selfAdd(-p2.y);\n\t\treturn dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();\n\t}\n\tstatic signOfDet2x2() {\n\t\tif (arguments[3] instanceof DD && (arguments[2] instanceof DD && (arguments[0] instanceof DD && arguments[1] instanceof DD))) {\n\t\t\tlet x1 = arguments[0], y1 = arguments[1], x2 = arguments[2], y2 = arguments[3];\n\t\t\tvar det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n\t\t\treturn det.signum();\n\t\t} else if (typeof arguments[3] === \"number\" && (typeof arguments[2] === \"number\" && (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\"))) {\n\t\t\tlet dx1 = arguments[0], dy1 = arguments[1], dx2 = arguments[2], dy2 = arguments[3];\n\t\t\tvar x1 = DD.valueOf(dx1);\n\t\t\tvar y1 = DD.valueOf(dy1);\n\t\t\tvar x2 = DD.valueOf(dx2);\n\t\t\tvar y2 = DD.valueOf(dy2);\n\t\t\tvar det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n\t\t\treturn det.signum();\n\t\t}\n\t}\n\tstatic intersection(p1, p2, q1, q2) {\n\t\tvar denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));\n\t\tvar denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));\n\t\tvar denom = denom1.subtract(denom2);\n\t\tvar numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n\t\tvar numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n\t\tvar numx = numx1.subtract(numx2);\n\t\tvar fracP = numx.selfDivide(denom).doubleValue();\n\t\tvar x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();\n\t\tvar numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n\t\tvar numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n\t\tvar numy = numy1.subtract(numy2);\n\t\tvar fracQ = numy.selfDivide(denom).doubleValue();\n\t\tvar y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();\n\t\treturn new Coordinate(x, y);\n\t}\n\tstatic orientationIndexFilter(pa, pb, pc) {\n\t\tvar detsum = null;\n\t\tvar detleft = (pa.x - pc.x) * (pb.y - pc.y);\n\t\tvar detright = (pa.y - pc.y) * (pb.x - pc.x);\n\t\tvar det = detleft - detright;\n\t\tif (detleft > 0.0) {\n\t\t\tif (detright <= 0.0) {\n\t\t\t\treturn CGAlgorithmsDD.signum(det);\n\t\t\t} else {\n\t\t\t\tdetsum = detleft + detright;\n\t\t\t}\n\t\t} else if (detleft < 0.0) {\n\t\t\tif (detright >= 0.0) {\n\t\t\t\treturn CGAlgorithmsDD.signum(det);\n\t\t\t} else {\n\t\t\t\tdetsum = -detleft - detright;\n\t\t\t}\n\t\t} else {\n\t\t\treturn CGAlgorithmsDD.signum(det);\n\t\t}\n\t\tvar errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;\n\t\tif (det >= errbound || -det >= errbound) {\n\t\t\treturn CGAlgorithmsDD.signum(det);\n\t\t}\n\t\treturn 2;\n\t}\n\tstatic signum(x) {\n\t\tif (x > 0) return 1;\n\t\tif (x < 0) return -1;\n\t\treturn 0;\n\t}\n\tgetClass() {\n\t\treturn CGAlgorithmsDD;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCGAlgorithmsDD.constructor_ = function () {};\nCGAlgorithmsDD.DP_SAFE_EPSILON = 1e-15;\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport CGAlgorithmsDD from './CGAlgorithmsDD';\nexport default class Orientation {\n\tconstructor() {\n\t\tOrientation.constructor_.apply(this, arguments);\n\t}\n\tstatic index(p1, p2, q) {\n\t\treturn CGAlgorithmsDD.orientationIndex(p1, p2, q);\n\t}\n\tstatic isCCW(ring) {\n\t\tvar nPts = ring.length - 1;\n\t\tif (nPts < 3) throw new IllegalArgumentException(\"Ring has fewer than 4 points, so orientation cannot be determined\");\n\t\tvar hiPt = ring[0];\n\t\tvar hiIndex = 0;\n\t\tfor (var i = 1; i <= nPts; i++) {\n\t\t\tvar p = ring[i];\n\t\t\tif (p.y > hiPt.y) {\n\t\t\t\thiPt = p;\n\t\t\t\thiIndex = i;\n\t\t\t}\n\t\t}\n\t\tvar iPrev = hiIndex;\n\t\tdo {\n\t\t\tiPrev = iPrev - 1;\n\t\t\tif (iPrev < 0) iPrev = nPts;\n\t\t} while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);\n\t\tvar iNext = hiIndex;\n\t\tdo {\n\t\t\tiNext = (iNext + 1) % nPts;\n\t\t} while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);\n\t\tvar prev = ring[iPrev];\n\t\tvar next = ring[iNext];\n\t\tif (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;\n\t\tvar disc = Orientation.index(prev, hiPt, next);\n\t\tvar isCCW = null;\n\t\tif (disc === 0) {\n\t\t\tisCCW = prev.x > next.x;\n\t\t} else {\n\t\t\tisCCW = disc > 0;\n\t\t}\n\t\treturn isCCW;\n\t}\n\tgetClass() {\n\t\treturn Orientation;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nOrientation.constructor_ = function () {};\nOrientation.CLOCKWISE = -1;\nOrientation.RIGHT = Orientation.CLOCKWISE;\nOrientation.COUNTERCLOCKWISE = 1;\nOrientation.LEFT = Orientation.COUNTERCLOCKWISE;\nOrientation.COLLINEAR = 0;\nOrientation.STRAIGHT = Orientation.COLLINEAR;\n","export default class Polygonal {\n\tconstructor() {\n\t\tPolygonal.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn Polygonal;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPolygonal.constructor_ = function () {};\n","import Area from '../algorithm/Area';\nimport Geometry from './Geometry';\nimport Arrays from '../../../../java/util/Arrays';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Orientation from '../algorithm/Orientation';\nimport System from '../../../../java/lang/System';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport CoordinateArrays from './CoordinateArrays';\nimport Polygonal from './Polygonal';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nexport default class Polygon extends Geometry {\n\tconstructor() {\n\t\tsuper();\n\t\tPolygon.constructor_.apply(this, arguments);\n\t}\n\tcomputeEnvelopeInternal() {\n\t\treturn this._shell.getEnvelopeInternal();\n\t}\n\tgetCoordinates() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn [];\n\t\t}\n\t\tvar coordinates = new Array(this.getNumPoints()).fill(null);\n\t\tvar k = -1;\n\t\tvar shellCoordinates = this._shell.getCoordinates();\n\t\tfor (var x = 0; x < shellCoordinates.length; x++) {\n\t\t\tk++;\n\t\t\tcoordinates[k] = shellCoordinates[x];\n\t\t}\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tvar childCoordinates = this._holes[i].getCoordinates();\n\t\t\tfor (var j = 0; j < childCoordinates.length; j++) {\n\t\t\t\tk++;\n\t\t\t\tcoordinates[k] = childCoordinates[j];\n\t\t\t}\n\t\t}\n\t\treturn coordinates;\n\t}\n\tgetArea() {\n\t\tvar area = 0.0;\n\t\tarea += Area.ofRing(this._shell.getCoordinateSequence());\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tarea -= Area.ofRing(this._holes[i].getCoordinateSequence());\n\t\t}\n\t\treturn area;\n\t}\n\tisRectangle() {\n\t\tif (this.getNumInteriorRing() !== 0) return false;\n\t\tif (this._shell === null) return false;\n\t\tif (this._shell.getNumPoints() !== 5) return false;\n\t\tvar seq = this._shell.getCoordinateSequence();\n\t\tvar env = this.getEnvelopeInternal();\n\t\tfor (var i = 0; i < 5; i++) {\n\t\t\tvar x = seq.getX(i);\n\t\t\tif (!(x === env.getMinX() || x === env.getMaxX())) return false;\n\t\t\tvar y = seq.getY(i);\n\t\t\tif (!(y === env.getMinY() || y === env.getMaxY())) return false;\n\t\t}\n\t\tvar prevX = seq.getX(0);\n\t\tvar prevY = seq.getY(0);\n\t\tfor (var i = 1; i <= 4; i++) {\n\t\t\tvar x = seq.getX(i);\n\t\t\tvar y = seq.getY(i);\n\t\t\tvar xChanged = x !== prevX;\n\t\t\tvar yChanged = y !== prevY;\n\t\t\tif (xChanged === yChanged) return false;\n\t\t\tprevX = x;\n\t\t\tprevY = y;\n\t\t}\n\t\treturn true;\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar otherPolygon = other;\n\t\t\tvar thisShell = this._shell;\n\t\t\tvar otherPolygonShell = otherPolygon._shell;\n\t\t\tif (!thisShell.equalsExact(otherPolygonShell, tolerance)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this._holes.length !== otherPolygon._holes.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tif (!this._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tnormalize() {\n\t\tif (arguments.length === 0) {\n\t\t\tthis.normalize(this._shell, true);\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tthis.normalize(this._holes[i], false);\n\t\t\t}\n\t\t\tArrays.sort(this._holes);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet ring = arguments[0], clockwise = arguments[1];\n\t\t\tif (ring.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);\n\t\t\tSystem.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);\n\t\t\tvar minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());\n\t\t\tCoordinateArrays.scroll(uniqueCoordinates, minCoordinate);\n\t\t\tSystem.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);\n\t\t\tring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];\n\t\t\tif (Orientation.isCCW(ring.getCoordinates()) === clockwise) {\n\t\t\t\tCoordinateArrays.reverse(ring.getCoordinates());\n\t\t\t}\n\t\t}\n\t}\n\tgetCoordinate() {\n\t\treturn this._shell.getCoordinate();\n\t}\n\tgetNumInteriorRing() {\n\t\treturn this._holes.length;\n\t}\n\tgetBoundaryDimension() {\n\t\treturn 1;\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_POLYGON;\n\t}\n\tgetDimension() {\n\t\treturn 2;\n\t}\n\tgetLength() {\n\t\tvar len = 0.0;\n\t\tlen += this._shell.getLength();\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tlen += this._holes[i].getLength();\n\t\t}\n\t\treturn len;\n\t}\n\tgetNumPoints() {\n\t\tvar numPoints = this._shell.getNumPoints();\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tnumPoints += this._holes[i].getNumPoints();\n\t\t}\n\t\treturn numPoints;\n\t}\n\treverse() {\n\t\tvar poly = this.copy();\n\t\tpoly._shell = this._shell.copy().reverse();\n\t\tpoly._holes = new Array(this._holes.length).fill(null);\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tpoly._holes[i] = this._holes[i].copy().reverse();\n\t\t}\n\t\treturn poly;\n\t}\n\tconvexHull() {\n\t\treturn this.getExteriorRing().convexHull();\n\t}\n\tcompareToSameClass() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar thisShell = this._shell;\n\t\t\tvar otherShell = o._shell;\n\t\t\treturn thisShell.compareToSameClass(otherShell);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar poly = o;\n\t\t\tvar thisShell = this._shell;\n\t\t\tvar otherShell = poly._shell;\n\t\t\tvar shellComp = thisShell.compareToSameClass(otherShell, comp);\n\t\t\tif (shellComp !== 0) return shellComp;\n\t\t\tvar nHole1 = this.getNumInteriorRing();\n\t\t\tvar nHole2 = poly.getNumInteriorRing();\n\t\t\tvar i = 0;\n\t\t\twhile (i < nHole1 && i < nHole2) {\n\t\t\t\tvar thisHole = this.getInteriorRingN(i);\n\t\t\t\tvar otherHole = poly.getInteriorRingN(i);\n\t\t\t\tvar holeComp = thisHole.compareToSameClass(otherHole, comp);\n\t\t\t\tif (holeComp !== 0) return holeComp;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i < nHole1) return 1;\n\t\t\tif (i < nHole2) return -1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tapply() {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tthis._shell.apply(filter);\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tthis._holes[i].apply(filter);\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tthis._shell.apply(filter);\n\t\t\tif (!filter.isDone()) {\n\t\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\t\tthis._holes[i].apply(filter);\n\t\t\t\t\tif (filter.isDone()) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t\tthis._shell.apply(filter);\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tthis._holes[i].apply(filter);\n\t\t\t}\n\t\t}\n\t}\n\tgetBoundary() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn this.getFactory().createMultiLineString();\n\t\t}\n\t\tvar rings = new Array(this._holes.length + 1).fill(null);\n\t\trings[0] = this._shell;\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\trings[i + 1] = this._holes[i];\n\t\t}\n\t\tif (rings.length <= 1) return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());\n\t\treturn this.getFactory().createMultiLineString(rings);\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_POLYGON;\n\t}\n\tcopy() {\n\t\tvar shellCopy = this._shell.copy();\n\t\tvar holeCopies = new Array(this._holes.length).fill(null);\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tholeCopies[i] = this._holes[i].copy();\n\t\t}\n\t\treturn new Polygon(shellCopy, holeCopies, this._factory);\n\t}\n\tgetExteriorRing() {\n\t\treturn this._shell;\n\t}\n\tisEmpty() {\n\t\treturn this._shell.isEmpty();\n\t}\n\tgetInteriorRingN(n) {\n\t\treturn this._holes[n];\n\t}\n\tgetClass() {\n\t\treturn Polygon;\n\t}\n\tget interfaces_() {\n\t\treturn [Polygonal];\n\t}\n}\nPolygon.constructor_ = function () {\n\tthis._shell = null;\n\tthis._holes = null;\n\tlet shell = arguments[0], holes = arguments[1], factory = arguments[2];\n\tGeometry.constructor_.call(this, factory);\n\tif (shell === null) {\n\t\tshell = this.getFactory().createLinearRing();\n\t}\n\tif (holes === null) {\n\t\tholes = [];\n\t}\n\tif (Geometry.hasNullElements(holes)) {\n\t\tthrow new IllegalArgumentException(\"holes must not contain null elements\");\n\t}\n\tif (shell.isEmpty() && Geometry.hasNonEmptyElements(holes)) {\n\t\tthrow new IllegalArgumentException(\"shell is empty but holes are not\");\n\t}\n\tthis._shell = shell;\n\tthis._holes = holes;\n};\nPolygon.serialVersionUID = -3494792200821764533;\n","import Geometry from './Geometry';\nimport GeometryCollection from './GeometryCollection';\nimport Dimension from './Dimension';\nimport Puntal from './Puntal';\nexport default class MultiPoint extends GeometryCollection {\n\tconstructor() {\n\t\tsuper();\n\t\tMultiPoint.constructor_.apply(this, arguments);\n\t}\n\tisValid() {\n\t\treturn true;\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn super.equalsExact.call(this, other, tolerance);\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tgetCoordinate() {\n\t\tif (arguments.length === 1 && Number.isInteger(arguments[0])) {\n\t\t\tlet n = arguments[0];\n\t\t\treturn this._geometries[n].getCoordinate();\n\t\t} else return super.getCoordinate.apply(this, arguments);\n\t}\n\tgetBoundaryDimension() {\n\t\treturn Dimension.FALSE;\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_MULTIPOINT;\n\t}\n\tgetDimension() {\n\t\treturn 0;\n\t}\n\tgetBoundary() {\n\t\treturn this.getFactory().createGeometryCollection();\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_MULTIPOINT;\n\t}\n\tcopy() {\n\t\tvar points = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < points.length; i++) {\n\t\t\tpoints[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new MultiPoint(points, this._factory);\n\t}\n\tgetClass() {\n\t\treturn MultiPoint;\n\t}\n\tget interfaces_() {\n\t\treturn [Puntal];\n\t}\n}\nMultiPoint.constructor_ = function () {\n\tlet points = arguments[0], factory = arguments[1];\n\tGeometryCollection.constructor_.call(this, points, factory);\n};\nMultiPoint.serialVersionUID = -8048474874175355449;\n","import LineString from './LineString';\nimport Geometry from './Geometry';\nimport hasInterface from '../../../../hasInterface';\nimport GeometryFactory from './GeometryFactory';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport CoordinateSequences from './CoordinateSequences';\nimport CoordinateSequence from './CoordinateSequence';\nimport Dimension from './Dimension';\nexport default class LinearRing extends LineString {\n\tconstructor() {\n\t\tsuper();\n\t\tLinearRing.constructor_.apply(this, arguments);\n\t}\n\tgetBoundaryDimension() {\n\t\treturn Dimension.FALSE;\n\t}\n\tisClosed() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn super.isClosed.call(this);\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_LINEARRING;\n\t}\n\treverse() {\n\t\tvar seq = this._points.copy();\n\t\tCoordinateSequences.reverse(seq);\n\t\tvar rev = this.getFactory().createLinearRing(seq);\n\t\treturn rev;\n\t}\n\tvalidateConstruction() {\n\t\tif (!this.isEmpty() && !super.isClosed.call(this)) {\n\t\t\tthrow new IllegalArgumentException(\"Points of LinearRing do not form a closed linestring\");\n\t\t}\n\t\tif (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid number of points in LinearRing (found \" + this.getCoordinateSequence().size() + \" - must be 0 or >= 4)\");\n\t\t}\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_LINEARRING;\n\t}\n\tcopy() {\n\t\treturn new LinearRing(this._points.copy(), this._factory);\n\t}\n\tgetClass() {\n\t\treturn LinearRing;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nLinearRing.constructor_ = function () {\n\tif (arguments[0] instanceof Array && arguments[1] instanceof GeometryFactory) {\n\t\tlet points = arguments[0], factory = arguments[1];\n\t\tLinearRing.constructor_.call(this, factory.getCoordinateSequenceFactory().create(points), factory);\n\t} else if (hasInterface(arguments[0], CoordinateSequence) && arguments[1] instanceof GeometryFactory) {\n\t\tlet points = arguments[0], factory = arguments[1];\n\t\tLineString.constructor_.call(this, points, factory);\n\t\tthis.validateConstruction();\n\t}\n};\nLinearRing.MINIMUM_VALID_SIZE = 4;\nLinearRing.serialVersionUID = -4261142084085851829;\n","import Geometry from './Geometry';\nimport GeometryCollection from './GeometryCollection';\nimport Polygonal from './Polygonal';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default class MultiPolygon extends GeometryCollection {\n\tconstructor() {\n\t\tsuper();\n\t\tMultiPolygon.constructor_.apply(this, arguments);\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn super.equalsExact.call(this, other, tolerance);\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tgetBoundaryDimension() {\n\t\treturn 1;\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_MULTIPOLYGON;\n\t}\n\tgetDimension() {\n\t\treturn 2;\n\t}\n\treverse() {\n\t\tvar n = this._geometries.length;\n\t\tvar revGeoms = new Array(n).fill(null);\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\trevGeoms[i] = this._geometries[i].reverse();\n\t\t}\n\t\treturn this.getFactory().createMultiPolygon(revGeoms);\n\t}\n\tgetBoundary() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn this.getFactory().createMultiLineString();\n\t\t}\n\t\tvar allRings = new ArrayList();\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tvar polygon = this._geometries[i];\n\t\t\tvar rings = polygon.getBoundary();\n\t\t\tfor (var j = 0; j < rings.getNumGeometries(); j++) {\n\t\t\t\tallRings.add(rings.getGeometryN(j));\n\t\t\t}\n\t\t}\n\t\tvar allRingsArray = new Array(allRings.size()).fill(null);\n\t\treturn this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_MULTIPOLYGON;\n\t}\n\tcopy() {\n\t\tvar polygons = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < polygons.length; i++) {\n\t\t\tpolygons[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new MultiPolygon(polygons, this._factory);\n\t}\n\tgetClass() {\n\t\treturn MultiPolygon;\n\t}\n\tget interfaces_() {\n\t\treturn [Polygonal];\n\t}\n}\nMultiPolygon.constructor_ = function () {\n\tlet polygons = arguments[0], factory = arguments[1];\n\tGeometryCollection.constructor_.call(this, polygons, factory);\n};\nMultiPolygon.serialVersionUID = -551033529766975875;\n","import LineString from '../LineString';\nimport Point from '../Point';\nimport Polygon from '../Polygon';\nimport MultiPoint from '../MultiPoint';\nimport LinearRing from '../LinearRing';\nimport MultiPolygon from '../MultiPolygon';\nimport GeometryCollection from '../GeometryCollection';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Assert from '../../util/Assert';\nimport MultiLineString from '../MultiLineString';\nexport default class GeometryEditor {\n\tconstructor() {\n\t\tGeometryEditor.constructor_.apply(this, arguments);\n\t}\n\tsetCopyUserData(isUserDataCopied) {\n\t\tthis._isUserDataCopied = isUserDataCopied;\n\t}\n\tedit(geometry, operation) {\n\t\tif (geometry === null) return null;\n\t\tvar result = this.editInternal(geometry, operation);\n\t\tif (this._isUserDataCopied) {\n\t\t\tresult.setUserData(geometry.getUserData());\n\t\t}\n\t\treturn result;\n\t}\n\teditInternal(geometry, operation) {\n\t\tif (this._factory === null) this._factory = geometry.getFactory();\n\t\tif (geometry instanceof GeometryCollection) {\n\t\t\treturn this.editGeometryCollection(geometry, operation);\n\t\t}\n\t\tif (geometry instanceof Polygon) {\n\t\t\treturn this.editPolygon(geometry, operation);\n\t\t}\n\t\tif (geometry instanceof Point) {\n\t\t\treturn operation.edit(geometry, this._factory);\n\t\t}\n\t\tif (geometry instanceof LineString) {\n\t\t\treturn operation.edit(geometry, this._factory);\n\t\t}\n\t\tAssert.shouldNeverReachHere(\"Unsupported Geometry class: \" + geometry.getClass().getName());\n\t\treturn null;\n\t}\n\teditGeometryCollection(collection, operation) {\n\t\tvar collectionForType = operation.edit(collection, this._factory);\n\t\tvar geometries = new ArrayList();\n\t\tfor (var i = 0; i < collectionForType.getNumGeometries(); i++) {\n\t\t\tvar geometry = this.edit(collectionForType.getGeometryN(i), operation);\n\t\t\tif (geometry === null || geometry.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgeometries.add(geometry);\n\t\t}\n\t\tif (collectionForType.getClass() === MultiPoint) {\n\t\t\treturn this._factory.createMultiPoint(geometries.toArray([]));\n\t\t}\n\t\tif (collectionForType.getClass() === MultiLineString) {\n\t\t\treturn this._factory.createMultiLineString(geometries.toArray([]));\n\t\t}\n\t\tif (collectionForType.getClass() === MultiPolygon) {\n\t\t\treturn this._factory.createMultiPolygon(geometries.toArray([]));\n\t\t}\n\t\treturn this._factory.createGeometryCollection(geometries.toArray([]));\n\t}\n\teditPolygon(polygon, operation) {\n\t\tvar newPolygon = operation.edit(polygon, this._factory);\n\t\tif (newPolygon === null) newPolygon = this._factory.createPolygon();\n\t\tif (newPolygon.isEmpty()) {\n\t\t\treturn newPolygon;\n\t\t}\n\t\tvar shell = this.edit(newPolygon.getExteriorRing(), operation);\n\t\tif (shell === null || shell.isEmpty()) {\n\t\t\treturn this._factory.createPolygon();\n\t\t}\n\t\tvar holes = new ArrayList();\n\t\tfor (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {\n\t\t\tvar hole = this.edit(newPolygon.getInteriorRingN(i), operation);\n\t\t\tif (hole === null || hole.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tholes.add(hole);\n\t\t}\n\t\treturn this._factory.createPolygon(shell, holes.toArray([]));\n\t}\n\tgetClass() {\n\t\treturn GeometryEditor;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nfunction GeometryEditorOperation() {}\nGeometryEditor.GeometryEditorOperation = GeometryEditorOperation;\nclass NoOpGeometryOperation {\n\tconstructor() {\n\t\tNoOpGeometryOperation.constructor_.apply(this, arguments);\n\t}\n\tedit(geometry, factory) {\n\t\treturn geometry;\n\t}\n\tgetClass() {\n\t\treturn NoOpGeometryOperation;\n\t}\n\tget interfaces_() {\n\t\treturn [GeometryEditorOperation];\n\t}\n}\nNoOpGeometryOperation.constructor_ = function () {};\nclass CoordinateOperation {\n\tconstructor() {\n\t\tCoordinateOperation.constructor_.apply(this, arguments);\n\t}\n\tedit(geometry, factory) {\n\t\tvar coordinates = this.edit(geometry.getCoordinates(), geometry);\n\t\tif (geometry instanceof LinearRing) {\n\t\t\tif (coordinates === null) return factory.createLinearRing(); else return factory.createLinearRing(coordinates);\n\t\t}\n\t\tif (geometry instanceof LineString) {\n\t\t\tif (coordinates === null) return factory.createLineString(); else return factory.createLineString(coordinates);\n\t\t}\n\t\tif (geometry instanceof Point) {\n\t\t\tif (coordinates === null || coordinates.length === 0) return factory.createPoint(); else return factory.createPoint(coordinates[0]);\n\t\t}\n\t\treturn geometry;\n\t}\n\tgetClass() {\n\t\treturn CoordinateOperation;\n\t}\n\tget interfaces_() {\n\t\treturn [GeometryEditorOperation];\n\t}\n}\nCoordinateOperation.constructor_ = function () {};\nclass CoordinateSequenceOperation {\n\tconstructor() {\n\t\tCoordinateSequenceOperation.constructor_.apply(this, arguments);\n\t}\n\tedit(geometry, factory) {\n\t\tif (geometry instanceof LinearRing) {\n\t\t\treturn factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry));\n\t\t}\n\t\tif (geometry instanceof LineString) {\n\t\t\treturn factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry));\n\t\t}\n\t\tif (geometry instanceof Point) {\n\t\t\treturn factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry));\n\t\t}\n\t\treturn geometry;\n\t}\n\tgetClass() {\n\t\treturn CoordinateSequenceOperation;\n\t}\n\tget interfaces_() {\n\t\treturn [GeometryEditorOperation];\n\t}\n}\nCoordinateSequenceOperation.constructor_ = function () {};\nGeometryEditor.NoOpGeometryOperation = NoOpGeometryOperation;\nGeometryEditor.CoordinateOperation = CoordinateOperation;\nGeometryEditor.CoordinateSequenceOperation = CoordinateSequenceOperation;\nGeometryEditor.constructor_ = function () {\n\tthis._factory = null;\n\tthis._isUserDataCopied = false;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet factory = arguments[0];\n\t\tthis._factory = factory;\n\t}\n};\n","import hasInterface from '../../../../../hasInterface';\nimport Coordinate from '../Coordinate';\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport Double from '../../../../../java/lang/Double';\nimport CoordinateSequence from '../CoordinateSequence';\nimport Serializable from '../../../../../java/io/Serializable';\nimport StringBuilder from '../../../../../java/lang/StringBuilder';\nexport default class CoordinateArraySequence {\n\tconstructor() {\n\t\tCoordinateArraySequence.constructor_.apply(this, arguments);\n\t}\n\tsetOrdinate(index, ordinateIndex, value) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase CoordinateSequence.X:\n\t\t\t\tthis._coordinates[index].x = value;\n\t\t\t\tbreak;\n\t\t\tcase CoordinateSequence.Y:\n\t\t\t\tthis._coordinates[index].y = value;\n\t\t\t\tbreak;\n\t\t\tcase CoordinateSequence.Z:\n\t\t\t\tthis._coordinates[index].z = value;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"invalid ordinateIndex\");\n\t\t}\n\t}\n\tsize() {\n\t\treturn this._coordinates.length;\n\t}\n\tgetOrdinate(index, ordinateIndex) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase CoordinateSequence.X:\n\t\t\t\treturn this._coordinates[index].x;\n\t\t\tcase CoordinateSequence.Y:\n\t\t\t\treturn this._coordinates[index].y;\n\t\t\tcase CoordinateSequence.Z:\n\t\t\t\treturn this._coordinates[index].z;\n\t\t}\n\t\treturn Double.NaN;\n\t}\n\tgetCoordinate() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet i = arguments[0];\n\t\t\treturn this._coordinates[i];\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet index = arguments[0], coord = arguments[1];\n\t\t\tcoord.x = this._coordinates[index].x;\n\t\t\tcoord.y = this._coordinates[index].y;\n\t\t\tcoord.z = this._coordinates[index].z;\n\t\t}\n\t}\n\tgetCoordinateCopy(i) {\n\t\treturn new Coordinate(this._coordinates[i]);\n\t}\n\tgetDimension() {\n\t\treturn this._dimension;\n\t}\n\tgetX(index) {\n\t\treturn this._coordinates[index].x;\n\t}\n\texpandEnvelope(env) {\n\t\tfor (var i = 0; i < this._coordinates.length; i++) {\n\t\t\tenv.expandToInclude(this._coordinates[i]);\n\t\t}\n\t\treturn env;\n\t}\n\tcopy() {\n\t\tvar cloneCoordinates = new Array(this.size()).fill(null);\n\t\tfor (var i = 0; i < this._coordinates.length; i++) {\n\t\t\tcloneCoordinates[i] = this._coordinates[i].copy();\n\t\t}\n\t\treturn new CoordinateArraySequence(cloneCoordinates, this._dimension);\n\t}\n\ttoString() {\n\t\tif (this._coordinates.length > 0) {\n\t\t\tvar strBuilder = new StringBuilder(17 * this._coordinates.length);\n\t\t\tstrBuilder.append('(');\n\t\t\tstrBuilder.append(this._coordinates[0]);\n\t\t\tfor (var i = 1; i < this._coordinates.length; i++) {\n\t\t\t\tstrBuilder.append(\", \");\n\t\t\t\tstrBuilder.append(this._coordinates[i]);\n\t\t\t}\n\t\t\tstrBuilder.append(')');\n\t\t\treturn strBuilder.toString();\n\t\t} else {\n\t\t\treturn \"()\";\n\t\t}\n\t}\n\tgetY(index) {\n\t\treturn this._coordinates[index].y;\n\t}\n\ttoCoordinateArray() {\n\t\treturn this._coordinates;\n\t}\n\tgetClass() {\n\t\treturn CoordinateArraySequence;\n\t}\n\tget interfaces_() {\n\t\treturn [CoordinateSequence, Serializable];\n\t}\n}\nCoordinateArraySequence.constructor_ = function () {\n\tthis._dimension = 3;\n\tthis._coordinates = null;\n\tif (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tlet coordinates = arguments[0];\n\t\t\tCoordinateArraySequence.constructor_.call(this, coordinates, 3);\n\t\t} else if (Number.isInteger(arguments[0])) {\n\t\t\tlet size = arguments[0];\n\t\t\tthis._coordinates = new Array(size).fill(null);\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tthis._coordinates[i] = new Coordinate();\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\tlet coordSeq = arguments[0];\n\t\t\tif (coordSeq === null) {\n\t\t\t\tthis._coordinates = new Array(0).fill(null);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis._dimension = coordSeq.getDimension();\n\t\t\tthis._coordinates = new Array(coordSeq.size()).fill(null);\n\t\t\tfor (var i = 0; i < this._coordinates.length; i++) {\n\t\t\t\tthis._coordinates[i] = coordSeq.getCoordinateCopy(i);\n\t\t\t}\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tif (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n\t\t\tlet coordinates = arguments[0], dimension = arguments[1];\n\t\t\tthis._coordinates = coordinates;\n\t\t\tthis._dimension = dimension;\n\t\t\tif (coordinates === null) this._coordinates = new Array(0).fill(null);\n\t\t} else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n\t\t\tlet size = arguments[0], dimension = arguments[1];\n\t\t\tthis._coordinates = new Array(size).fill(null);\n\t\t\tthis._dimension = dimension;\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tthis._coordinates[i] = new Coordinate();\n\t\t\t}\n\t\t}\n\t}\n};\nCoordinateArraySequence.serialVersionUID = -915438501601840650;\n","import CoordinateSequenceFactory from '../CoordinateSequenceFactory';\nimport hasInterface from '../../../../../hasInterface';\nimport CoordinateArraySequence from './CoordinateArraySequence';\nimport CoordinateSequence from '../CoordinateSequence';\nimport Serializable from '../../../../../java/io/Serializable';\nexport default class CoordinateArraySequenceFactory {\n\tconstructor() {\n\t\tCoordinateArraySequenceFactory.constructor_.apply(this, arguments);\n\t}\n\tstatic instance() {\n\t\treturn CoordinateArraySequenceFactory.instanceObject;\n\t}\n\treadResolve() {\n\t\treturn CoordinateArraySequenceFactory.instance();\n\t}\n\tcreate() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new CoordinateArraySequence(coordinates);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordSeq = arguments[0];\n\t\t\t\treturn new CoordinateArraySequence(coordSeq);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet size = arguments[0], dimension = arguments[1];\n\t\t\tif (dimension > 3) dimension = 3;\n\t\t\tif (dimension < 2) return new CoordinateArraySequence(size);\n\t\t\treturn new CoordinateArraySequence(size, dimension);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn CoordinateArraySequenceFactory;\n\t}\n\tget interfaces_() {\n\t\treturn [CoordinateSequenceFactory, Serializable];\n\t}\n}\nCoordinateArraySequenceFactory.constructor_ = function () {};\nCoordinateArraySequenceFactory.serialVersionUID = -4099577099607551657;\nCoordinateArraySequenceFactory.instanceObject = new CoordinateArraySequenceFactory();\n","import ArrayList from './ArrayList'\nimport MapInterface from './Map'\nimport HashSet from './HashSet'\nimport MapPolyfill from '../../Map'\n\nlet MapImpl = typeof Map === 'undefined' || !Map.prototype.values ? MapPolyfill : Map\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html\n *\n * @extends {javascript.util.Map}\n * @constructor\n * @private\n */\nexport default function HashMap () {\n  /**\n   * @type {Object}\n   * @private\n  */\n  this.map_ = new MapImpl()\n}\nHashMap.prototype = new MapInterface()\n\n/**\n * @override\n */\nHashMap.prototype.get = function (key) {\n  return this.map_.get(key) || null\n}\n\n/**\n * @override\n */\nHashMap.prototype.put = function (key, value) {\n  this.map_.set(key, value)\n  return value\n}\n\n/**\n * @override\n */\nHashMap.prototype.values = function () {\n  const arrayList = new ArrayList()\n  const it = this.map_.values()\n  let o = it.next()\n  while (!o.done) {\n    arrayList.add(o.value)\n    o = it.next()\n  }\n  return arrayList\n}\n\n/**\n * @override\n */\nHashMap.prototype.entrySet = function () {\n  const hashSet = new HashSet()\n  this.map_.entries().forEach(entry => hashSet.add(entry))\n  return hashSet\n}\n\n/**\n * @override\n */\nHashMap.prototype.size = function () {\n  return this.map_.size()\n}\n","import HashMap from '../../../../java/util/HashMap';\nimport Coordinate from './Coordinate';\nimport Double from '../../../../java/lang/Double';\nimport Integer from '../../../../java/lang/Integer';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Serializable from '../../../../java/io/Serializable';\nexport default class PrecisionModel {\n\tconstructor() {\n\t\tPrecisionModel.constructor_.apply(this, arguments);\n\t}\n\tstatic mostPrecise(pm1, pm2) {\n\t\tif (pm1.compareTo(pm2) >= 0) return pm1;\n\t\treturn pm2;\n\t}\n\tequals(other) {\n\t\tif (!(other instanceof PrecisionModel)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar otherPrecisionModel = other;\n\t\treturn this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale;\n\t}\n\tcompareTo(o) {\n\t\tvar other = o;\n\t\tvar sigDigits = this.getMaximumSignificantDigits();\n\t\tvar otherSigDigits = other.getMaximumSignificantDigits();\n\t\treturn new Integer(sigDigits).compareTo(new Integer(otherSigDigits));\n\t}\n\tgetScale() {\n\t\treturn this._scale;\n\t}\n\tisFloating() {\n\t\treturn this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE;\n\t}\n\tgetType() {\n\t\treturn this._modelType;\n\t}\n\ttoString() {\n\t\tvar description = \"UNKNOWN\";\n\t\tif (this._modelType === PrecisionModel.FLOATING) {\n\t\t\tdescription = \"Floating\";\n\t\t} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n\t\t\tdescription = \"Floating-Single\";\n\t\t} else if (this._modelType === PrecisionModel.FIXED) {\n\t\t\tdescription = \"Fixed (Scale=\" + this.getScale() + \")\";\n\t\t}\n\t\treturn description;\n\t}\n\tmakePrecise() {\n\t\tif (typeof arguments[0] === \"number\") {\n\t\t\tlet val = arguments[0];\n\t\t\tif (Double.isNaN(val)) return val;\n\t\t\tif (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n\t\t\t\tvar floatSingleVal = val;\n\t\t\t\treturn floatSingleVal;\n\t\t\t}\n\t\t\tif (this._modelType === PrecisionModel.FIXED) {\n\t\t\t\treturn Math.round(val * this._scale) / this._scale;\n\t\t\t}\n\t\t\treturn val;\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet coord = arguments[0];\n\t\t\tif (this._modelType === PrecisionModel.FLOATING) return null;\n\t\t\tcoord.x = this.makePrecise(coord.x);\n\t\t\tcoord.y = this.makePrecise(coord.y);\n\t\t}\n\t}\n\tgetMaximumSignificantDigits() {\n\t\tvar maxSigDigits = 16;\n\t\tif (this._modelType === PrecisionModel.FLOATING) {\n\t\t\tmaxSigDigits = 16;\n\t\t} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n\t\t\tmaxSigDigits = 6;\n\t\t} else if (this._modelType === PrecisionModel.FIXED) {\n\t\t\tmaxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));\n\t\t}\n\t\treturn maxSigDigits;\n\t}\n\tsetScale(scale) {\n\t\tthis._scale = Math.abs(scale);\n\t}\n\tgetClass() {\n\t\treturn PrecisionModel;\n\t}\n\tget interfaces_() {\n\t\treturn [Serializable, Comparable];\n\t}\n}\nclass Type {\n\tconstructor() {\n\t\tType.constructor_.apply(this, arguments);\n\t}\n\treadResolve() {\n\t\treturn Type.nameToTypeMap.get(this._name);\n\t}\n\ttoString() {\n\t\treturn this._name;\n\t}\n\tgetClass() {\n\t\treturn Type;\n\t}\n\tget interfaces_() {\n\t\treturn [Serializable];\n\t}\n}\nType.constructor_ = function () {\n\tthis._name = null;\n\tlet name = arguments[0];\n\tthis._name = name;\n\tType.nameToTypeMap.put(name, this);\n};\nType.serialVersionUID = -5528602631731589822;\nType.nameToTypeMap = new HashMap();\nPrecisionModel.Type = Type;\nPrecisionModel.constructor_ = function () {\n\tthis._modelType = null;\n\tthis._scale = null;\n\tif (arguments.length === 0) {\n\t\tthis._modelType = PrecisionModel.FLOATING;\n\t} else if (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Type) {\n\t\t\tlet modelType = arguments[0];\n\t\t\tthis._modelType = modelType;\n\t\t\tif (modelType === PrecisionModel.FIXED) {\n\t\t\t\tthis.setScale(1.0);\n\t\t\t}\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet scale = arguments[0];\n\t\t\tthis._modelType = PrecisionModel.FIXED;\n\t\t\tthis.setScale(scale);\n\t\t} else if (arguments[0] instanceof PrecisionModel) {\n\t\t\tlet pm = arguments[0];\n\t\t\tthis._modelType = pm._modelType;\n\t\t\tthis._scale = pm._scale;\n\t\t}\n\t}\n};\nPrecisionModel.serialVersionUID = 7777263578777803835;\nPrecisionModel.FIXED = new Type(\"FIXED\");\nPrecisionModel.FLOATING = new Type(\"FLOATING\");\nPrecisionModel.FLOATING_SINGLE = new Type(\"FLOATING SINGLE\");\nPrecisionModel.maximumPreciseValue = 9007199254740992.0;\n","import CoordinateSequenceFactory from './CoordinateSequenceFactory';\nimport LineString from './LineString';\nimport Geometry from './Geometry';\nimport hasInterface from '../../../../hasInterface';\nimport Coordinate from './Coordinate';\nimport Point from './Point';\nimport Polygon from './Polygon';\nimport MultiPoint from './MultiPoint';\nimport GeometryEditor from './util/GeometryEditor';\nimport LinearRing from './LinearRing';\nimport CoordinateArraySequenceFactory from './impl/CoordinateArraySequenceFactory';\nimport MultiPolygon from './MultiPolygon';\nimport CoordinateSequences from './CoordinateSequences';\nimport CoordinateSequence from './CoordinateSequence';\nimport GeometryCollection from './GeometryCollection';\nimport PrecisionModel from './PrecisionModel';\nimport Serializable from '../../../../java/io/Serializable';\nimport Assert from '../util/Assert';\nimport MultiLineString from './MultiLineString';\nexport default class GeometryFactory {\n\tconstructor() {\n\t\tGeometryFactory.constructor_.apply(this, arguments);\n\t}\n\tstatic toMultiPolygonArray(multiPolygons) {\n\t\tvar multiPolygonArray = new Array(multiPolygons.size()).fill(null);\n\t\treturn multiPolygons.toArray(multiPolygonArray);\n\t}\n\tstatic toGeometryArray(geometries) {\n\t\tif (geometries === null) return null;\n\t\tvar geometryArray = new Array(geometries.size()).fill(null);\n\t\treturn geometries.toArray(geometryArray);\n\t}\n\tstatic getDefaultCoordinateSequenceFactory() {\n\t\treturn CoordinateArraySequenceFactory.instance();\n\t}\n\tstatic toMultiLineStringArray(multiLineStrings) {\n\t\tvar multiLineStringArray = new Array(multiLineStrings.size()).fill(null);\n\t\treturn multiLineStrings.toArray(multiLineStringArray);\n\t}\n\tstatic toLineStringArray(lineStrings) {\n\t\tvar lineStringArray = new Array(lineStrings.size()).fill(null);\n\t\treturn lineStrings.toArray(lineStringArray);\n\t}\n\tstatic toMultiPointArray(multiPoints) {\n\t\tvar multiPointArray = new Array(multiPoints.size()).fill(null);\n\t\treturn multiPoints.toArray(multiPointArray);\n\t}\n\tstatic toLinearRingArray(linearRings) {\n\t\tvar linearRingArray = new Array(linearRings.size()).fill(null);\n\t\treturn linearRings.toArray(linearRingArray);\n\t}\n\tstatic toPointArray(points) {\n\t\tvar pointArray = new Array(points.size()).fill(null);\n\t\treturn points.toArray(pointArray);\n\t}\n\tstatic toPolygonArray(polygons) {\n\t\tvar polygonArray = new Array(polygons.size()).fill(null);\n\t\treturn polygons.toArray(polygonArray);\n\t}\n\tstatic createPointFromInternalCoord(coord, exemplar) {\n\t\texemplar.getPrecisionModel().makePrecise(coord);\n\t\treturn exemplar.getFactory().createPoint(coord);\n\t}\n\ttoGeometry(envelope) {\n\t\tif (envelope.isNull()) {\n\t\t\treturn this.createPoint();\n\t\t}\n\t\tif (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {\n\t\t\treturn this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()));\n\t\t}\n\t\tif (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {\n\t\t\treturn this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())]);\n\t\t}\n\t\treturn this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null);\n\t}\n\tcreateLineString() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createLineString(this.getCoordinateSequenceFactory().create([]));\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn this.createLineString(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new LineString(coordinates, this);\n\t\t\t}\n\t\t}\n\t}\n\tcreateMultiLineString() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new MultiLineString(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet lineStrings = arguments[0];\n\t\t\treturn new MultiLineString(lineStrings, this);\n\t\t}\n\t}\n\tbuildGeometry(geomList) {\n\t\tvar geomClass = null;\n\t\tvar isHeterogeneous = false;\n\t\tvar hasGeometryCollection = false;\n\t\tfor (var i = geomList.iterator(); i.hasNext(); ) {\n\t\t\tvar geom = i.next();\n\t\t\tvar partClass = geom.getClass();\n\t\t\tif (geomClass === null) {\n\t\t\t\tgeomClass = partClass;\n\t\t\t}\n\t\t\tif (partClass !== geomClass) {\n\t\t\t\tisHeterogeneous = true;\n\t\t\t}\n\t\t\tif (geom instanceof GeometryCollection) hasGeometryCollection = true;\n\t\t}\n\t\tif (geomClass === null) {\n\t\t\treturn this.createGeometryCollection();\n\t\t}\n\t\tif (isHeterogeneous || hasGeometryCollection) {\n\t\t\treturn this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));\n\t\t}\n\t\tvar geom0 = geomList.iterator().next();\n\t\tvar isCollection = geomList.size() > 1;\n\t\tif (isCollection) {\n\t\t\tif (geom0 instanceof Polygon) {\n\t\t\t\treturn this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));\n\t\t\t} else if (geom0 instanceof LineString) {\n\t\t\t\treturn this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));\n\t\t\t} else if (geom0 instanceof Point) {\n\t\t\t\treturn this.createMultiPoint(GeometryFactory.toPointArray(geomList));\n\t\t\t}\n\t\t\tAssert.shouldNeverReachHere(\"Unhandled class: \" + geom0.getClass().getName());\n\t\t}\n\t\treturn geom0;\n\t}\n\tcreateMultiPointFromCoords(coordinates) {\n\t\treturn this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t}\n\tcreatePoint() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createPoint(this.getCoordinateSequenceFactory().create([]));\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet coordinate = arguments[0];\n\t\t\t\treturn this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new Point(coordinates, this);\n\t\t\t}\n\t\t}\n\t}\n\tgetCoordinateSequenceFactory() {\n\t\treturn this._coordinateSequenceFactory;\n\t}\n\tcreatePolygon() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createPolygon(null, null);\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet shell = arguments[0];\n\t\t\t\treturn this.createPolygon(this.createLinearRing(shell));\n\t\t\t} else if (arguments[0] instanceof Array) {\n\t\t\t\tlet shell = arguments[0];\n\t\t\t\treturn this.createPolygon(this.createLinearRing(shell));\n\t\t\t} else if (arguments[0] instanceof LinearRing) {\n\t\t\t\tlet shell = arguments[0];\n\t\t\t\treturn this.createPolygon(shell, null);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet shell = arguments[0], holes = arguments[1];\n\t\t\treturn new Polygon(shell, holes, this);\n\t\t}\n\t}\n\tgetSRID() {\n\t\treturn this._SRID;\n\t}\n\tcreateGeometryCollection() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new GeometryCollection(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet geometries = arguments[0];\n\t\t\treturn new GeometryCollection(geometries, this);\n\t\t}\n\t}\n\tcreateGeometry(g) {\n\t\tvar editor = new GeometryEditor(this);\n\t\treturn editor.edit(g, new CloneOp(this._coordinateSequenceFactory));\n\t}\n\tgetPrecisionModel() {\n\t\treturn this._precisionModel;\n\t}\n\tcreateLinearRing() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createLinearRing(this.getCoordinateSequenceFactory().create([]));\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new LinearRing(coordinates, this);\n\t\t\t}\n\t\t}\n\t}\n\tcreateMultiPolygon() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new MultiPolygon(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet polygons = arguments[0];\n\t\t\treturn new MultiPolygon(polygons, this);\n\t\t}\n\t}\n\tcreateMultiPoint() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new MultiPoint(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet point = arguments[0];\n\t\t\t\treturn new MultiPoint(point, this);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\tif (coordinates === null) {\n\t\t\t\t\treturn this.createMultiPoint(new Array(0).fill(null));\n\t\t\t\t}\n\t\t\t\tvar points = new Array(coordinates.size()).fill(null);\n\t\t\t\tfor (var i = 0; i < coordinates.size(); i++) {\n\t\t\t\t\tvar ptSeq = this.getCoordinateSequenceFactory().create(1, coordinates.getDimension());\n\t\t\t\t\tCoordinateSequences.copy(coordinates, i, ptSeq, 0, 1);\n\t\t\t\t\tpoints[i] = this.createPoint(ptSeq);\n\t\t\t\t}\n\t\t\t\treturn this.createMultiPoint(points);\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn GeometryFactory;\n\t}\n\tget interfaces_() {\n\t\treturn [Serializable];\n\t}\n}\nclass CloneOp extends GeometryEditor.CoordinateSequenceOperation {\n\tconstructor() {\n\t\tsuper();\n\t\tCloneOp.constructor_.apply(this, arguments);\n\t}\n\tedit() {\n\t\tif (arguments.length === 2 && (arguments[1] instanceof Geometry && hasInterface(arguments[0], CoordinateSequence))) {\n\t\t\tlet coordSeq = arguments[0], geometry = arguments[1];\n\t\t\treturn this.coordinateSequenceFactory.create(coordSeq);\n\t\t} else return super.edit.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn CloneOp;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCloneOp.constructor_ = function () {\n\tthis.coordinateSequenceFactory = null;\n\tlet coordinateSequenceFactory = arguments[0];\n\tthis.coordinateSequenceFactory = coordinateSequenceFactory;\n};\nGeometryFactory.CloneOp = CloneOp;\nGeometryFactory.constructor_ = function () {\n\tthis._precisionModel = null;\n\tthis._coordinateSequenceFactory = null;\n\tthis._SRID = null;\n\tif (arguments.length === 0) {\n\t\tGeometryFactory.constructor_.call(this, new PrecisionModel(), 0);\n\t} else if (arguments.length === 1) {\n\t\tif (hasInterface(arguments[0], CoordinateSequenceFactory)) {\n\t\t\tlet coordinateSequenceFactory = arguments[0];\n\t\t\tGeometryFactory.constructor_.call(this, new PrecisionModel(), 0, coordinateSequenceFactory);\n\t\t} else if (arguments[0] instanceof PrecisionModel) {\n\t\t\tlet precisionModel = arguments[0];\n\t\t\tGeometryFactory.constructor_.call(this, precisionModel, 0, GeometryFactory.getDefaultCoordinateSequenceFactory());\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet precisionModel = arguments[0], SRID = arguments[1];\n\t\tGeometryFactory.constructor_.call(this, precisionModel, SRID, GeometryFactory.getDefaultCoordinateSequenceFactory());\n\t} else if (arguments.length === 3) {\n\t\tlet precisionModel = arguments[0], SRID = arguments[1], coordinateSequenceFactory = arguments[2];\n\t\tthis._precisionModel = precisionModel;\n\t\tthis._coordinateSequenceFactory = coordinateSequenceFactory;\n\t\tthis._SRID = SRID;\n\t}\n};\nGeometryFactory.serialVersionUID = -6820524753094095635;\n","import Coordinate from '../geom/Coordinate'\nimport GeometryFactory from '../geom/GeometryFactory'\n\nconst geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon']\n\n/**\n * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */\n\n/**\n * Create a new parser for GeoJSON\n *\n * @param {GeometryFactory} geometryFactory\n * @return An instance of GeoJsonParser.\n * @constructor\n * @private\n */\nexport default class GeoJSONParser {\n  constructor(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory()\n  }\n\n  /**\n   * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries\n   *\n   * @param {}\n   *          A GeoJSON object.\n   * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.\n   * @private\n   */\n  read (json) {\n    let obj\n    if (typeof json === 'string')\n      obj = JSON.parse(json)\n    else\n      obj = json\n\n    const type = obj.type\n\n    if (!parse[type])\n      throw new Error('Unknown GeoJSON type: ' + obj.type)\n\n    if (geometryTypes.indexOf(type) !== -1)\n      return parse[type].call(this, obj.coordinates)\n    else if (type === 'GeometryCollection')\n      return parse[type].call(this, obj.geometries)\n\n    // feature or feature collection\n    return parse[type].call(this, obj)\n  }\n\n  /**\n   * Serialize a Geometry object into GeoJSON\n   *\n   * @param {Geometry}\n   *          geometry A Geometry or array of Geometries.\n   * @return {Object} A GeoJSON object represting the input Geometry/Geometries.\n   * @private\n   */\n  write (geometry) {\n    const type = geometry.getGeometryType()\n\n    if (!extract[type])\n      throw new Error('Geometry is not supported')\n\n    return extract[type].call(this, geometry)\n  }\n} \n\nconst parse = {\n  /**\n   * Parse a GeoJSON Feature object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.\n   */\n  Feature: function (obj) {\n    const feature = {}\n\n    for (let key in obj)\n      feature[key] = obj[key]\n\n    if (obj.geometry) {\n      const type = obj.geometry.type\n      if (!parse[type])\n        throw new Error('Unknown GeoJSON type: ' + obj.type)\n      feature.geometry = this.read(obj.geometry)\n    }\n\n    if (obj.bbox)\n      feature.bbox = parse.bbox.call(this, obj.bbox)\n\n    return feature\n  },\n\n  /**\n   * Parse a GeoJSON FeatureCollection object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.\n   */\n  FeatureCollection: function (obj) {\n    const featureCollection = {}\n\n    if (obj.features) {\n      featureCollection.features = []\n\n      for (let i = 0; i < obj.features.length; ++i)\n        featureCollection.features.push(this.read(obj.features[i]))\n    }\n\n    if (obj.bbox)\n      featureCollection.bbox = this.parse.bbox.call(this, obj.bbox)\n\n    return featureCollection\n  },\n\n  /**\n   * Convert the ordinates in an array to an array of Coordinates\n   *\n   * @param {Array}\n   *          array Array with {Number}s.\n   *\n   * @return {Array} Array with Coordinates.\n   */\n  coordinates: function (array) {\n    const coordinates = []\n    for (let i = 0; i < array.length; ++i) {\n      const sub = array[i]\n      coordinates.push(new Coordinate(sub[0], sub[1]))\n    }\n    return coordinates\n  },\n\n  /**\n   * Convert the bbox to a LinearRing\n   *\n   * @param {Array}\n   *          array Array with [xMin, yMin, xMax, yMax].\n   *\n   * @return {Array} Array with Coordinates.\n   */\n  bbox: function (array) {\n    return this.geometryFactory.createLinearRing([\n      new Coordinate(array[0], array[1]),\n      new Coordinate(array[2], array[1]),\n      new Coordinate(array[2], array[3]),\n      new Coordinate(array[0], array[3]),\n      new Coordinate(array[0], array[1])\n    ])\n  },\n\n  /**\n   * Convert an Array with ordinates to a Point\n   *\n   * @param {Array}\n   *          array Array with ordinates.\n   *\n   * @return {Point} Point.\n   */\n  Point: function (array) {\n    const coordinate = new Coordinate(array[0], array[1])\n    return this.geometryFactory.createPoint(coordinate)\n  },\n\n  /**\n   * Convert an Array with coordinates to a MultiPoint\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiPoint} MultiPoint.\n   */\n  MultiPoint: function (array) {\n    const points = []\n    for (let i = 0; i < array.length; ++i)\n      points.push(parse.Point.call(this, array[i]))\n    return this.geometryFactory.createMultiPoint(points)\n  },\n\n  /**\n   * Convert an Array with coordinates to a LineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {LineString} LineString.\n   */\n  LineString: function (array) {\n    const coordinates = parse.coordinates.call(this, array)\n    return this.geometryFactory.createLineString(coordinates)\n  },\n\n  /**\n   * Convert an Array with coordinates to a MultiLineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiLineString} MultiLineString.\n   */\n  MultiLineString: function (array) {\n    const lineStrings = []\n    for (let i = 0; i < array.length; ++i)\n      lineStrings.push(parse.LineString.call(this, array[i]))\n    return this.geometryFactory.createMultiLineString(lineStrings)\n  },\n\n  /**\n   * Convert an Array to a Polygon\n   *\n   * @param {Array}\n   *          array Array with shell and holes.\n   *\n   * @return {Polygon} Polygon.\n   */\n  Polygon: function (array) {\n    const shellCoordinates = parse.coordinates.call(this, array[0])\n    const shell = this.geometryFactory.createLinearRing(shellCoordinates)\n    const holes = []\n    for (let i = 1; i < array.length; ++i) {\n      var hole = array[i]\n      var coordinates = parse.coordinates.call(this, hole)\n      var linearRing = this.geometryFactory.createLinearRing(coordinates)\n      holes.push(linearRing)\n    }\n    return this.geometryFactory.createPolygon(shell, holes)\n  },\n\n  /**\n   * Convert an Array to a MultiPolygon\n   *\n   * @param {Array}\n   *          array Array of arrays with shell and rings.\n   *\n   * @return {MultiPolygon} MultiPolygon.\n   */\n  MultiPolygon: function (array) {\n    const polygons = []\n    for (let i = 0; i < array.length; ++i) {\n      const polygon = array[i]\n      polygons.push(parse.Polygon.call(this, polygon))\n    }\n    return this.geometryFactory.createMultiPolygon(polygons)\n  },\n\n  /**\n   * Convert an Array to a GeometryCollection\n   *\n   * @param {Array}\n   *          array Array of GeoJSON geometries.\n   *\n   * @return {GeometryCollection} GeometryCollection.\n   */\n  GeometryCollection: function (array) {\n    const geometries = []\n    for (let i = 0; i < array.length; ++i) {\n      const geometry = array[i]\n      geometries.push(this.read(geometry))\n    }\n    return this.geometryFactory.createGeometryCollection(geometries)\n  }\n}\n\nconst extract = {\n  /**\n   * Convert a Coordinate to an Array\n   *\n   * @param {Coordinate}\n   *          coordinate Coordinate to convert.\n   *\n   * @return {Array} Array of ordinates.\n   */\n  coordinate: function (coordinate) {\n    return [coordinate.x, coordinate.y]\n  },\n\n  /**\n   * Convert a Point to a GeoJSON object\n   *\n   * @param {Point}\n   *          point Point to convert.\n   *\n   * @return {Array} Array of 2 ordinates (paired to a coordinate).\n   */\n  Point: function (point) {\n    const array = extract.coordinate.call(this, point.getCoordinate())\n    return {\n      type: 'Point',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiPoint to a GeoJSON object\n   *\n   * @param {MultiPoint}\n   *          multipoint MultiPoint to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */\n  MultiPoint: function (multipoint) {\n    const array = []\n    for (let i = 0; i < multipoint._geometries.length; ++i) {\n      const point = multipoint._geometries[i]\n      const geoJson = extract.Point.call(this, point)\n      array.push(geoJson.coordinates)\n    }\n    return {\n      type: 'MultiPoint',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a LineString to a GeoJSON object\n   *\n   * @param {LineString}\n   *          linestring LineString to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */\n  LineString: function (linestring) {\n    const array = []\n    const coordinates = linestring.getCoordinates()\n    for (let i = 0; i < coordinates.length; ++i) {\n      const coordinate = coordinates[i]\n      array.push(extract.coordinate.call(this, coordinate))\n    }\n    return {\n      type: 'LineString',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiLineString to a GeoJSON object\n   *\n   * @param {MultiLineString}\n   *          multilinestring MultiLineString to convert.\n   *\n   * @return {Array} Array of Array of coordinates.\n   */\n  MultiLineString: function (multilinestring) {\n    const array = []\n    for (let i = 0; i < multilinestring._geometries.length; ++i) {\n      const linestring = multilinestring._geometries[i]\n      const geoJson = extract.LineString.call(this, linestring)\n      array.push(geoJson.coordinates)\n    }\n    return {\n      type: 'MultiLineString',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a Polygon to a GeoJSON object\n   *\n   * @param {Polygon}\n   *          polygon Polygon to convert.\n   *\n   * @return {Array} Array with shell, holes.\n   */\n  Polygon: function (polygon) {\n    const array = []\n    const shellGeoJson = extract.LineString.call(this, polygon._shell)\n    array.push(shellGeoJson.coordinates)\n    for (let i = 0; i < polygon._holes.length; ++i) {\n      const hole = polygon._holes[i]\n      const holeGeoJson = extract.LineString.call(this, hole)\n      array.push(holeGeoJson.coordinates)\n    }\n    return {\n      type: 'Polygon',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiPolygon to a GeoJSON object\n   *\n   * @param {MultiPolygon}\n   *          multipolygon MultiPolygon to convert.\n   *\n   * @return {Array} Array of polygons.\n   */\n  MultiPolygon: function (multipolygon) {\n    const array = []\n    for (let i = 0; i < multipolygon._geometries.length; ++i) {\n      const polygon = multipolygon._geometries[i]\n      const geoJson = extract.Polygon.call(this, polygon)\n      array.push(geoJson.coordinates)\n    }\n    return {\n      type: 'MultiPolygon',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a GeometryCollection to a GeoJSON object\n   *\n   * @param {GeometryCollection}\n   *          collection GeometryCollection to convert.\n   *\n   * @return {Array} Array of geometries.\n   */\n  GeometryCollection: function (collection) {\n    const array = []\n    for (let i = 0; i < collection._geometries.length; ++i) {\n      const geometry = collection._geometries[i]\n      const type = geometry.getGeometryType()\n      array.push(extract[type].call(this, geometry))\n    }\n    return {\n      type: 'GeometryCollection',\n      geometries: array\n    }\n  }\n}\n","/**\n * @module org/locationtech/jts/io/GeoJSONReader\n */\n\nimport GeometryFactory from '../geom/GeometryFactory'\nimport GeoJSONParser from './GeoJSONParser'\n\n/**\n * Converts a geometry in GeoJSON to a {@link Geometry}.\n */\nexport default class GeoJSONReader {\n  /**\n   * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,\n   * to allow it to create <code>Geometry</code> objects of the appropriate\n   * implementation. In particular, the <code>GeometryFactory</code> determines\n   * the <code>PrecisionModel</code> and <code>SRID</code> that is used.\n   *\n   * @param {GeometryFactory} geometryFactory\n   */\n  constructor(geometryFactory) {\n    this.parser = new GeoJSONParser(geometryFactory || new GeometryFactory())\n  }\n\n  /**\n   * Reads a GeoJSON representation of a {@link Geometry}\n   *\n   * Will also parse GeoJSON Features/FeatureCollections as custom objects.\n   *\n   * @param {Object|String} geoJson a GeoJSON Object or String.\n   * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>\n   * @memberof module:org/locationtech/jts/io/GeoJSONReader#\n   */\n  read (geoJson) {\n    var geometry = this.parser.read(geoJson)\n    return geometry\n  }\n}\n","import Coordinate from '../geom/Coordinate'\nimport GeometryFactory from '../geom/GeometryFactory'\n\nconst regExes = {\n  'typeStr': /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n  'emptyTypeStr': /^\\s*(\\w+)\\s*EMPTY\\s*$/,\n  'spaces': /\\s+/,\n  'parenComma': /\\)\\s*,\\s*\\(/,\n  'doubleParenComma': /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/, // can't use {2} here\n  'trimParens': /^\\s*\\(?(.*?)\\)?\\s*$/\n}\n\n/**\n * Class for reading and writing Well-Known Text.\n *\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */\n\nexport default class WKTParser {\n  /** Create a new parser for WKT\n   *\n   * @param {GeometryFactory} geometryFactory\n   * @return An instance of WKTParser.\n   * @private\n   */\n  constructor(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory()\n    this.precisionModel = this.geometryFactory.getPrecisionModel()\n  }\n\n  /**\n   * Deserialize a WKT string and return a geometry. Supports WKT for POINT,\n   * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,\n   * and GEOMETRYCOLLECTION.\n   *\n   * @param {String} wkt A WKT string.\n   * @return {Geometry} A geometry instance.\n   * @private\n   */\n  read (wkt) {\n    var geometry, type, str\n    wkt = wkt.replace(/[\\n\\r]/g, ' ')\n    var matches = regExes.typeStr.exec(wkt)\n    if (wkt.search('EMPTY') !== -1) {\n      matches = regExes.emptyTypeStr.exec(wkt)\n      matches[2] = undefined\n    }\n    if (matches) {\n      type = matches[1].toLowerCase()\n      str = matches[2]\n      if (parse[type]) {\n        geometry = parse[type].call(this, str)\n      }\n    }\n\n    if (geometry === undefined) throw new Error('Could not parse WKT ' + wkt)\n\n    return geometry\n  }\n\n  /**\n   * Serialize a geometry into a WKT string.\n   *\n   * @param {Geometry} geometry A feature or array of features.\n   * @return {String} The WKT string representation of the input geometries.\n   * @private\n   */\n  write (geometry) {\n    return this.extractGeometry(geometry)\n  }\n\n  /**\n   * Entry point to construct the WKT for a single Geometry object.\n   *\n   * @param {Geometry} geometry\n   * @return {String} A WKT string of representing the geometry.\n   * @private\n   */\n  extractGeometry (geometry) {\n    var type = geometry.getGeometryType().toLowerCase()\n    if (!extract[type]) {\n      return null\n    }\n    var wktType = type.toUpperCase()\n    var data\n    if (geometry.isEmpty()) {\n      data = wktType + ' EMPTY'\n    } else {\n      data = wktType + '(' + extract[type].call(this, geometry) + ')'\n    }\n    return data\n  }\n}\n\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual data extraction.\n * @private\n */\nconst extract = {\n  coordinate (coordinate) {\n    this.precisionModel.makePrecise(coordinate)\n    return coordinate.x + ' ' + coordinate.y\n  },\n\n  /**\n   * Return a space delimited string of point coordinates.\n   *\n   * @param {Point}\n   *          point\n   * @return {String} A string of coordinates representing the point.\n   */\n  point (point) {\n    return extract.coordinate.call(this, point._coordinates._coordinates[0])\n  },\n\n  /**\n   * Return a comma delimited string of point coordinates from a multipoint.\n   *\n   * @param {MultiPoint}\n   *          multipoint\n   * @return {String} A string of point coordinate strings representing the\n   *         multipoint.\n   */\n  multipoint (multipoint) {\n    var array = []\n    for (let i = 0, len = multipoint._geometries.length; i < len; ++i) {\n      array.push('(' + extract.point.call(this, multipoint._geometries[i]) + ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of point coordinates from a line.\n   *\n   * @param {LineString} linestring\n   * @return {String} A string of point coordinate strings representing the linestring.\n   */\n  linestring (linestring) {\n    var array = []\n    for (let i = 0, len = linestring._points._coordinates.length; i < len; ++i) {\n      array.push(extract.coordinate.call(this, linestring._points._coordinates[i]))\n    }\n    return array.join(',')\n  },\n\n  linearring (linearring) {\n    var array = []\n    for (let i = 0, len = linearring._points._coordinates.length; i < len; ++i) {\n      array.push(extract.coordinate.call(this, linearring._points._coordinates[i]))\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of linestring strings from a\n   * multilinestring.\n   *\n   * @param {MultiLineString} multilinestring\n   * @return {String} A string of of linestring strings representing the multilinestring.\n   */\n  multilinestring (multilinestring) {\n    var array = []\n    for (let i = 0, len = multilinestring._geometries.length; i < len; ++i) {\n      array.push('(' +\n        extract.linestring.call(this, multilinestring._geometries[i]) +\n        ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of linear ring arrays from a polygon.\n   *\n   * @param {Polygon} polygon\n   * @return {String} An array of linear ring arrays representing the polygon.\n   */\n  polygon (polygon) {\n    var array = []\n    array.push('(' + extract.linestring.call(this, polygon._shell) + ')')\n    for (let i = 0, len = polygon._holes.length; i < len; ++i) {\n      array.push('(' + extract.linestring.call(this, polygon._holes[i]) + ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return an array of polygon arrays from a multipolygon.\n   *\n   * @param {MultiPolygon} multipolygon\n   * @return {String} An array of polygon arrays representing the multipolygon.\n   */\n  multipolygon (multipolygon) {\n    var array = []\n    for (let i = 0, len = multipolygon._geometries.length; i < len; ++i) {\n      array.push('(' + extract.polygon.call(this, multipolygon._geometries[i]) + ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an\n   * geometrycollection.\n   *\n   * @param {GeometryCollection} collection\n   * @return {String} internal WKT representation of the collection.\n   */\n  geometrycollection (collection) {\n    var array = []\n    for (let i = 0, len = collection._geometries.length; i < len; ++i) {\n      array.push(this.extractGeometry(collection._geometries[i]))\n    }\n    return array.join(',')\n  }\n}\n\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual parsing.\n * @private\n */\nconst parse = {\n  \n  coord (str) {\n    var coords = str.trim().split(regExes.spaces)\n    var coord = new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1]))\n    this.precisionModel.makePrecise(coord)\n    return coord\n  },\n\n  /**\n   * Return point geometry given a point WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the point.\n   * @return {Point} A point geometry.\n   * @private\n   */\n  point (str) {\n    if (str === undefined)\n      return this.geometryFactory.createPoint()\n    return this.geometryFactory.createPoint(parse.coord.call(this, str))\n  },\n\n  /**\n   * Return a multipoint geometry given a multipoint WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipoint.\n   * @return {Point} A multipoint feature.\n   * @private\n   */\n  multipoint (str) {\n    if (str === undefined)\n      return this.geometryFactory.createMultiPoint()\n    var point\n    var points = str.trim().split(',')\n    var components = []\n    for (let i = 0, len = points.length; i < len; ++i) {\n      point = points[i].replace(regExes.trimParens, '$1')\n      components.push(parse.point.call(this, point))\n    }\n    return this.geometryFactory.createMultiPoint(components)\n  },\n\n  /**\n   * Return a linestring geometry given a linestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linestring.\n   * @return {LineString} A linestring geometry.\n   * @private\n   */\n  linestring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createLineString()\n    }\n\n    var points = str.trim().split(',')\n    var components = []\n    var coords\n    for (let i = 0, len = points.length; i < len; ++i) {\n      components.push(parse.coord.call(this, points[i]))\n    }\n    return this.geometryFactory.createLineString(components)\n  },\n\n  /**\n   * Return a linearring geometry given a linearring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linearring.\n   * @return {LinearRing} A linearring geometry.\n   * @private\n   */\n  linearring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createLinearRing()\n    }\n\n    var points = str.trim().split(',')\n    var components = []\n    var coords\n    for (let i = 0, len = points.length; i < len; ++i) {\n      components.push(parse.coord.call(this, points[i]))\n    }\n    return this.geometryFactory.createLinearRing(components)\n  },\n\n  /**\n   * Return a multilinestring geometry given a multilinestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multilinestring.\n   * @return {MultiLineString} A multilinestring geometry.\n   * @private\n   */\n  multilinestring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createMultiLineString()\n    }\n\n    var line\n    var lines = str.trim().split(regExes.parenComma)\n    var components = []\n    for (let i = 0, len = lines.length; i < len; ++i) {\n      line = lines[i].replace(regExes.trimParens, '$1')\n      components.push(parse.linestring.call(this, line))\n    }\n    return this.geometryFactory.createMultiLineString(components)\n  },\n\n  /**\n   * Return a polygon geometry given a polygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the polygon.\n   * @return {Polygon} A polygon geometry.\n   * @private\n   */\n  polygon (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createPolygon()\n    }\n\n    var ring, linestring, linearring\n    var rings = str.trim().split(regExes.parenComma)\n    var shell\n    var holes = []\n    for (let i = 0, len = rings.length; i < len; ++i) {\n      ring = rings[i].replace(regExes.trimParens, '$1')\n      linestring = parse.linestring.call(this, ring)\n      linearring = this.geometryFactory.createLinearRing(linestring._points)\n      if (i === 0) {\n        shell = linearring\n      } else {\n        holes.push(linearring)\n      }\n    }\n    return this.geometryFactory.createPolygon(shell, holes)\n  },\n\n  /**\n   * Return a multipolygon geometry given a multipolygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipolygon.\n   * @return {MultiPolygon} A multipolygon geometry.\n   * @private\n   */\n  multipolygon (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createMultiPolygon()\n    }\n\n    var polygon\n    var polygons = str.trim().split(regExes.doubleParenComma)\n    var components = []\n    for (let i = 0, len = polygons.length; i < len; ++i) {\n      polygon = polygons[i].replace(regExes.trimParens, '$1')\n      components.push(parse.polygon.call(this, polygon))\n    }\n    return this.geometryFactory.createMultiPolygon(components)\n  },\n\n  /**\n   * Return a geometrycollection given a geometrycollection WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the geometrycollection.\n   * @return {GeometryCollection}\n   * @private\n   */\n  geometrycollection (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createGeometryCollection()\n    }\n\n    // separate components of the collection with |\n    str = str.replace(/,\\s*([A-Za-z])/g, '|$1')\n    var wktArray = str.trim().split('|')\n    var components = []\n    for (let i = 0, len = wktArray.length; i < len; ++i) {\n      components.push(this.read(wktArray[i]))\n    }\n    return this.geometryFactory.createGeometryCollection(components)\n  }\n}\n","/**\n * @module org/locationtech/jts/io/WKTWriter\n */\n\nimport WKTParser from './WKTParser'\n\n/**\n * Writes the Well-Known Text representation of a {@link Geometry}. The\n * Well-Known Text format is defined in the <A\n * HREF=\"http://www.opengis.org/techno/specs.htm\"> OGC Simple Features\n * Specification for SQL</A>.\n * <p>\n * The <code>WKTWriter</code> outputs coordinates rounded to the precision\n * model. Only the maximum number of decimal places necessary to represent the\n * ordinates to the required precision will be output.\n * <p>\n * The SFS WKT spec does not define a special tag for {@link LinearRing}s.\n * Under the spec, rings are output as <code>LINESTRING</code>s.\n */\nexport default class WKTWriter {\n  /**\n   * @param {GeometryFactory} geometryFactory\n   */\n  constructor(geometryFactory) {\n    this.parser = new WKTParser(geometryFactory)\n  }\n  /**\n   * Converts a <code>Geometry</code> to its Well-known Text representation.\n   *\n   * @param {Geometry} geometry a <code>Geometry</code> to process.\n   * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple\n   *         Features Specification).\n   * @memberof module:org/locationtech/jts/io/WKTWriter#\n   */\n  write (geometry) {\n    return this.parser.write(geometry)\n  }\n  /**\n   * Generates the WKT for a <tt>LINESTRING</tt> specified by two\n   * {@link Coordinate}s.\n   *\n   * @param p0 the first coordinate.\n   * @param p1 the second coordinate.\n   *\n   * @return the WKT.\n   * @private\n   */\n  static toLineString (p0, p1) {\n    if (arguments.length !== 2) {\n      throw new Error('Not implemented')\n    }\n\n    return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )'\n  }\n}\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nexport default class Location {\n\tconstructor() {\n\t\tLocation.constructor_.apply(this, arguments);\n\t}\n\tstatic toLocationSymbol(locationValue) {\n\t\tswitch (locationValue) {\n\t\t\tcase Location.EXTERIOR:\n\t\t\t\treturn 'e';\n\t\t\tcase Location.BOUNDARY:\n\t\t\t\treturn 'b';\n\t\t\tcase Location.INTERIOR:\n\t\t\t\treturn 'i';\n\t\t\tcase Location.NONE:\n\t\t\t\treturn '-';\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Unknown location value: \" + locationValue);\n\t}\n\tgetClass() {\n\t\treturn Location;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nLocation.constructor_ = function () {};\nLocation.INTERIOR = 0;\nLocation.BOUNDARY = 1;\nLocation.EXTERIOR = 2;\nLocation.NONE = -1;\n","export default function Exception () {}\n","import Exception from '../../../../java/lang/Exception';\nexport default class NotRepresentableException extends Exception {\n\tconstructor() {\n\t\tsuper();\n\t\tNotRepresentableException.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn NotRepresentableException;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nNotRepresentableException.constructor_ = function () {\n\tException.constructor_.call(this, \"Projective point not representable on the Cartesian plane.\");\n};\n","import NotRepresentableException from './NotRepresentableException';\nimport Coordinate from '../geom/Coordinate';\nimport Double from '../../../../java/lang/Double';\nexport default class HCoordinate {\n\tconstructor() {\n\t\tHCoordinate.constructor_.apply(this, arguments);\n\t}\n\tstatic intersection(p1, p2, q1, q2) {\n\t\tvar px = p1.y - p2.y;\n\t\tvar py = p2.x - p1.x;\n\t\tvar pw = p1.x * p2.y - p2.x * p1.y;\n\t\tvar qx = q1.y - q2.y;\n\t\tvar qy = q2.x - q1.x;\n\t\tvar qw = q1.x * q2.y - q2.x * q1.y;\n\t\tvar x = py * qw - qy * pw;\n\t\tvar y = qx * pw - px * qw;\n\t\tvar w = px * qy - qx * py;\n\t\tvar xInt = x / w;\n\t\tvar yInt = y / w;\n\t\tif (Double.isNaN(xInt) || (Double.isInfinite(xInt) || Double.isNaN(yInt)) || Double.isInfinite(yInt)) {\n\t\t\tthrow new NotRepresentableException();\n\t\t}\n\t\treturn new Coordinate(xInt, yInt);\n\t}\n\tgetY() {\n\t\tvar a = this.y / this.w;\n\t\tif (Double.isNaN(a) || Double.isInfinite(a)) {\n\t\t\tthrow new NotRepresentableException();\n\t\t}\n\t\treturn a;\n\t}\n\tgetX() {\n\t\tvar a = this.x / this.w;\n\t\tif (Double.isNaN(a) || Double.isInfinite(a)) {\n\t\t\tthrow new NotRepresentableException();\n\t\t}\n\t\treturn a;\n\t}\n\tgetCoordinate() {\n\t\tvar p = new Coordinate();\n\t\tp.x = this.getX();\n\t\tp.y = this.getY();\n\t\treturn p;\n\t}\n\tgetClass() {\n\t\treturn HCoordinate;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nHCoordinate.constructor_ = function () {\n\tthis.x = null;\n\tthis.y = null;\n\tthis.w = null;\n\tif (arguments.length === 0) {\n\t\tthis.x = 0.0;\n\t\tthis.y = 0.0;\n\t\tthis.w = 1.0;\n\t} else if (arguments.length === 1) {\n\t\tlet p = arguments[0];\n\t\tthis.x = p.x;\n\t\tthis.y = p.y;\n\t\tthis.w = 1.0;\n\t} else if (arguments.length === 2) {\n\t\tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\t\tlet _x = arguments[0], _y = arguments[1];\n\t\t\tthis.x = _x;\n\t\t\tthis.y = _y;\n\t\t\tthis.w = 1.0;\n\t\t} else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\t\tthis.x = p1.y * p2.w - p2.y * p1.w;\n\t\t\tthis.y = p2.x * p1.w - p1.x * p2.w;\n\t\t\tthis.w = p1.x * p2.y - p2.x * p1.y;\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\t\tthis.x = p1.y - p2.y;\n\t\t\tthis.y = p2.x - p1.x;\n\t\t\tthis.w = p1.x * p2.y - p2.x * p1.y;\n\t\t}\n\t} else if (arguments.length === 3) {\n\t\tlet _x = arguments[0], _y = arguments[1], _w = arguments[2];\n\t\tthis.x = _x;\n\t\tthis.y = _y;\n\t\tthis.w = _w;\n\t} else if (arguments.length === 4) {\n\t\tlet p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3];\n\t\tvar px = p1.y - p2.y;\n\t\tvar py = p2.x - p1.x;\n\t\tvar pw = p1.x * p2.y - p2.x * p1.y;\n\t\tvar qx = q1.y - q2.y;\n\t\tvar qy = q2.x - q1.x;\n\t\tvar qw = q1.x * q2.y - q2.x * q1.y;\n\t\tthis.x = py * qw - qy * pw;\n\t\tthis.y = qx * pw - px * qw;\n\t\tthis.w = px * qy - qx * py;\n\t}\n};\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport MathUtil from '../math/MathUtil';\nimport Envelope from '../geom/Envelope';\nexport default class Distance {\n\tconstructor() {\n\t\tDistance.constructor_.apply(this, arguments);\n\t}\n\tstatic segmentToSegment(A, B, C, D) {\n\t\tif (A.equals(B)) return Distance.pointToSegment(A, C, D);\n\t\tif (C.equals(D)) return Distance.pointToSegment(D, A, B);\n\t\tvar noIntersection = false;\n\t\tif (!Envelope.intersects(A, B, C, D)) {\n\t\t\tnoIntersection = true;\n\t\t} else {\n\t\t\tvar denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);\n\t\t\tif (denom === 0) {\n\t\t\t\tnoIntersection = true;\n\t\t\t} else {\n\t\t\t\tvar r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);\n\t\t\t\tvar s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);\n\t\t\t\tvar s = s_num / denom;\n\t\t\t\tvar r = r_num / denom;\n\t\t\t\tif (r < 0 || r > 1 || s < 0 || s > 1) {\n\t\t\t\t\tnoIntersection = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (noIntersection) {\n\t\t\treturn MathUtil.min(Distance.pointToSegment(A, C, D), Distance.pointToSegment(B, C, D), Distance.pointToSegment(C, A, B), Distance.pointToSegment(D, A, B));\n\t\t}\n\t\treturn 0.0;\n\t}\n\tstatic pointToSegment(p, A, B) {\n\t\tif (A.x === B.x && A.y === B.y) return p.distance(A);\n\t\tvar len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n\t\tvar r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) / len2;\n\t\tif (r <= 0.0) return p.distance(A);\n\t\tif (r >= 1.0) return p.distance(B);\n\t\tvar s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n\t\treturn Math.abs(s) * Math.sqrt(len2);\n\t}\n\tstatic pointToLinePerpendicular(p, A, B) {\n\t\tvar len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n\t\tvar s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n\t\treturn Math.abs(s) * Math.sqrt(len2);\n\t}\n\tstatic pointToSegmentString(p, line) {\n\t\tif (line.length === 0) throw new IllegalArgumentException(\"Line array must contain at least one vertex\");\n\t\tvar minDistance = p.distance(line[0]);\n\t\tfor (var i = 0; i < line.length - 1; i++) {\n\t\t\tvar dist = Distance.pointToSegment(p, line[i], line[i + 1]);\n\t\t\tif (dist < minDistance) {\n\t\t\t\tminDistance = dist;\n\t\t\t}\n\t\t}\n\t\treturn minDistance;\n\t}\n\tgetClass() {\n\t\treturn Distance;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nDistance.constructor_ = function () {};\n","import WKTWriter from '../io/WKTWriter';\nimport Coordinate from '../geom/Coordinate';\nimport Assert from '../util/Assert';\nimport StringBuilder from '../../../../java/lang/StringBuilder';\nexport default class LineIntersector {\n\tconstructor() {\n\t\tLineIntersector.constructor_.apply(this, arguments);\n\t}\n\tstatic computeEdgeDistance(p, p0, p1) {\n\t\tvar dx = Math.abs(p1.x - p0.x);\n\t\tvar dy = Math.abs(p1.y - p0.y);\n\t\tvar dist = -1.0;\n\t\tif (p.equals(p0)) {\n\t\t\tdist = 0.0;\n\t\t} else if (p.equals(p1)) {\n\t\t\tif (dx > dy) dist = dx; else dist = dy;\n\t\t} else {\n\t\t\tvar pdx = Math.abs(p.x - p0.x);\n\t\t\tvar pdy = Math.abs(p.y - p0.y);\n\t\t\tif (dx > dy) dist = pdx; else dist = pdy;\n\t\t\tif (dist === 0.0 && !p.equals(p0)) {\n\t\t\t\tdist = Math.max(pdx, pdy);\n\t\t\t}\n\t\t}\n\t\tAssert.isTrue(!(dist === 0.0 && !p.equals(p0)), \"Bad distance calculation\");\n\t\treturn dist;\n\t}\n\tstatic nonRobustComputeEdgeDistance(p, p1, p2) {\n\t\tvar dx = p.x - p1.x;\n\t\tvar dy = p.y - p1.y;\n\t\tvar dist = Math.sqrt(dx * dx + dy * dy);\n\t\tAssert.isTrue(!(dist === 0.0 && !p.equals(p1)), \"Invalid distance calculation\");\n\t\treturn dist;\n\t}\n\tgetIndexAlongSegment(segmentIndex, intIndex) {\n\t\tthis.computeIntLineIndex();\n\t\treturn this._intLineIndex[segmentIndex][intIndex];\n\t}\n\tgetTopologySummary() {\n\t\tvar catBuilder = new StringBuilder();\n\t\tif (this.isEndPoint()) catBuilder.append(\" endpoint\");\n\t\tif (this._isProper) catBuilder.append(\" proper\");\n\t\tif (this.isCollinear()) catBuilder.append(\" collinear\");\n\t\treturn catBuilder.toString();\n\t}\n\tcomputeIntersection(p1, p2, p3, p4) {\n\t\tthis._inputLines[0][0] = p1;\n\t\tthis._inputLines[0][1] = p2;\n\t\tthis._inputLines[1][0] = p3;\n\t\tthis._inputLines[1][1] = p4;\n\t\tthis._result = this.computeIntersect(p1, p2, p3, p4);\n\t}\n\tgetIntersectionNum() {\n\t\treturn this._result;\n\t}\n\tcomputeIntLineIndex() {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this._intLineIndex === null) {\n\t\t\t\tthis._intLineIndex = Array(2).fill().map(() => Array(2));\n\t\t\t\tthis.computeIntLineIndex(0);\n\t\t\t\tthis.computeIntLineIndex(1);\n\t\t\t}\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet segmentIndex = arguments[0];\n\t\t\tvar dist0 = this.getEdgeDistance(segmentIndex, 0);\n\t\t\tvar dist1 = this.getEdgeDistance(segmentIndex, 1);\n\t\t\tif (dist0 > dist1) {\n\t\t\t\tthis._intLineIndex[segmentIndex][0] = 0;\n\t\t\t\tthis._intLineIndex[segmentIndex][1] = 1;\n\t\t\t} else {\n\t\t\t\tthis._intLineIndex[segmentIndex][0] = 1;\n\t\t\t\tthis._intLineIndex[segmentIndex][1] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tisProper() {\n\t\treturn this.hasIntersection() && this._isProper;\n\t}\n\tsetPrecisionModel(precisionModel) {\n\t\tthis._precisionModel = precisionModel;\n\t}\n\tisInteriorIntersection() {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.isInteriorIntersection(0)) return true;\n\t\t\tif (this.isInteriorIntersection(1)) return true;\n\t\t\treturn false;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet inputLineIndex = arguments[0];\n\t\t\tfor (var i = 0; i < this._result; i++) {\n\t\t\t\tif (!(this._intPt[i].equals2D(this._inputLines[inputLineIndex][0]) || this._intPt[i].equals2D(this._inputLines[inputLineIndex][1]))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\tgetIntersection(intIndex) {\n\t\treturn this._intPt[intIndex];\n\t}\n\tisEndPoint() {\n\t\treturn this.hasIntersection() && !this._isProper;\n\t}\n\thasIntersection() {\n\t\treturn this._result !== LineIntersector.NO_INTERSECTION;\n\t}\n\tgetEdgeDistance(segmentIndex, intIndex) {\n\t\tvar dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);\n\t\treturn dist;\n\t}\n\tisCollinear() {\n\t\treturn this._result === LineIntersector.COLLINEAR_INTERSECTION;\n\t}\n\ttoString() {\n\t\treturn WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + \" - \" + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();\n\t}\n\tgetEndpoint(segmentIndex, ptIndex) {\n\t\treturn this._inputLines[segmentIndex][ptIndex];\n\t}\n\tisIntersection(pt) {\n\t\tfor (var i = 0; i < this._result; i++) {\n\t\t\tif (this._intPt[i].equals2D(pt)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tgetIntersectionAlongSegment(segmentIndex, intIndex) {\n\t\tthis.computeIntLineIndex();\n\t\treturn this._intPt[this._intLineIndex[segmentIndex][intIndex]];\n\t}\n\tgetClass() {\n\t\treturn LineIntersector;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nLineIntersector.constructor_ = function () {\n\tthis._result = null;\n\tthis._inputLines = Array(2).fill().map(() => Array(2));\n\tthis._intPt = new Array(2).fill(null);\n\tthis._intLineIndex = null;\n\tthis._isProper = null;\n\tthis._pa = null;\n\tthis._pb = null;\n\tthis._precisionModel = null;\n\tthis._intPt[0] = new Coordinate();\n\tthis._intPt[1] = new Coordinate();\n\tthis._pa = this._intPt[0];\n\tthis._pb = this._intPt[1];\n\tthis._result = 0;\n};\nLineIntersector.DONT_INTERSECT = 0;\nLineIntersector.DO_INTERSECT = 1;\nLineIntersector.COLLINEAR = 2;\nLineIntersector.NO_INTERSECTION = 0;\nLineIntersector.POINT_INTERSECTION = 1;\nLineIntersector.COLLINEAR_INTERSECTION = 2;\n","import NotRepresentableException from './NotRepresentableException';\nimport Coordinate from '../geom/Coordinate';\nimport Orientation from './Orientation';\nimport CGAlgorithmsDD from './CGAlgorithmsDD';\nimport System from '../../../../java/lang/System';\nimport HCoordinate from './HCoordinate';\nimport Envelope from '../geom/Envelope';\nimport Distance from './Distance';\nimport LineIntersector from './LineIntersector';\nexport default class RobustLineIntersector extends LineIntersector {\n\tconstructor() {\n\t\tsuper();\n\t\tRobustLineIntersector.constructor_.apply(this, arguments);\n\t}\n\tstatic nearestEndpoint(p1, p2, q1, q2) {\n\t\tvar nearestPt = p1;\n\t\tvar minDist = Distance.pointToSegment(p1, q1, q2);\n\t\tvar dist = Distance.pointToSegment(p2, q1, q2);\n\t\tif (dist < minDist) {\n\t\t\tminDist = dist;\n\t\t\tnearestPt = p2;\n\t\t}\n\t\tdist = Distance.pointToSegment(q1, p1, p2);\n\t\tif (dist < minDist) {\n\t\t\tminDist = dist;\n\t\t\tnearestPt = q1;\n\t\t}\n\t\tdist = Distance.pointToSegment(q2, p1, p2);\n\t\tif (dist < minDist) {\n\t\t\tminDist = dist;\n\t\t\tnearestPt = q2;\n\t\t}\n\t\treturn nearestPt;\n\t}\n\tisInSegmentEnvelopes(intPt) {\n\t\tvar env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);\n\t\tvar env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);\n\t\treturn env0.contains(intPt) && env1.contains(intPt);\n\t}\n\tcomputeIntersection() {\n\t\tif (arguments.length === 3) {\n\t\t\tlet p = arguments[0], p1 = arguments[1], p2 = arguments[2];\n\t\t\tthis._isProper = false;\n\t\t\tif (Envelope.intersects(p1, p2, p)) {\n\t\t\t\tif (Orientation.index(p1, p2, p) === 0 && Orientation.index(p2, p1, p) === 0) {\n\t\t\t\t\tthis._isProper = true;\n\t\t\t\t\tif (p.equals(p1) || p.equals(p2)) {\n\t\t\t\t\t\tthis._isProper = false;\n\t\t\t\t\t}\n\t\t\t\t\tthis._result = LineIntersector.POINT_INTERSECTION;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._result = LineIntersector.NO_INTERSECTION;\n\t\t} else return super.computeIntersection.apply(this, arguments);\n\t}\n\tnormalizeToMinimum(n1, n2, n3, n4, normPt) {\n\t\tnormPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);\n\t\tnormPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);\n\t\tn1.x -= normPt.x;\n\t\tn1.y -= normPt.y;\n\t\tn2.x -= normPt.x;\n\t\tn2.y -= normPt.y;\n\t\tn3.x -= normPt.x;\n\t\tn3.y -= normPt.y;\n\t\tn4.x -= normPt.x;\n\t\tn4.y -= normPt.y;\n\t}\n\tsafeHCoordinateIntersection(p1, p2, q1, q2) {\n\t\tvar intPt = null;\n\t\ttry {\n\t\t\tintPt = HCoordinate.intersection(p1, p2, q1, q2);\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotRepresentableException) {\n\t\t\t\tintPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);\n\t\t\t} else throw e;\n\t\t} finally {}\n\t\treturn intPt;\n\t}\n\tintersection(p1, p2, q1, q2) {\n\t\tvar intPt = this.intersectionWithNormalization(p1, p2, q1, q2);\n\t\tif (!this.isInSegmentEnvelopes(intPt)) {\n\t\t\tintPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));\n\t\t}\n\t\tif (this._precisionModel !== null) {\n\t\t\tthis._precisionModel.makePrecise(intPt);\n\t\t}\n\t\treturn intPt;\n\t}\n\tsmallestInAbsValue(x1, x2, x3, x4) {\n\t\tvar x = x1;\n\t\tvar xabs = Math.abs(x);\n\t\tif (Math.abs(x2) < xabs) {\n\t\t\tx = x2;\n\t\t\txabs = Math.abs(x2);\n\t\t}\n\t\tif (Math.abs(x3) < xabs) {\n\t\t\tx = x3;\n\t\t\txabs = Math.abs(x3);\n\t\t}\n\t\tif (Math.abs(x4) < xabs) {\n\t\t\tx = x4;\n\t\t}\n\t\treturn x;\n\t}\n\tcheckDD(p1, p2, q1, q2, intPt) {\n\t\tvar intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);\n\t\tvar isIn = this.isInSegmentEnvelopes(intPtDD);\n\t\tSystem.out.println(\"DD in env = \" + isIn + \"  --------------------- \" + intPtDD);\n\t\tif (intPt.distance(intPtDD) > 0.0001) {\n\t\t\tSystem.out.println(\"Distance = \" + intPt.distance(intPtDD));\n\t\t}\n\t}\n\tintersectionWithNormalization(p1, p2, q1, q2) {\n\t\tvar n1 = new Coordinate(p1);\n\t\tvar n2 = new Coordinate(p2);\n\t\tvar n3 = new Coordinate(q1);\n\t\tvar n4 = new Coordinate(q2);\n\t\tvar normPt = new Coordinate();\n\t\tthis.normalizeToEnvCentre(n1, n2, n3, n4, normPt);\n\t\tvar intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);\n\t\tintPt.x += normPt.x;\n\t\tintPt.y += normPt.y;\n\t\treturn intPt;\n\t}\n\tcomputeCollinearIntersection(p1, p2, q1, q2) {\n\t\tvar p1q1p2 = Envelope.intersects(p1, p2, q1);\n\t\tvar p1q2p2 = Envelope.intersects(p1, p2, q2);\n\t\tvar q1p1q2 = Envelope.intersects(q1, q2, p1);\n\t\tvar q1p2q2 = Envelope.intersects(q1, q2, p2);\n\t\tif (p1q1p2 && p1q2p2) {\n\t\t\tthis._intPt[0] = q1;\n\t\t\tthis._intPt[1] = q2;\n\t\t\treturn LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (q1p1q2 && q1p2q2) {\n\t\t\tthis._intPt[0] = p1;\n\t\t\tthis._intPt[1] = p2;\n\t\t\treturn LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q1p2 && q1p1q2) {\n\t\t\tthis._intPt[0] = q1;\n\t\t\tthis._intPt[1] = p1;\n\t\t\treturn q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q1p2 && q1p2q2) {\n\t\t\tthis._intPt[0] = q1;\n\t\t\tthis._intPt[1] = p2;\n\t\t\treturn q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q2p2 && q1p1q2) {\n\t\t\tthis._intPt[0] = q2;\n\t\t\tthis._intPt[1] = p1;\n\t\t\treturn q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q2p2 && q1p2q2) {\n\t\t\tthis._intPt[0] = q2;\n\t\t\tthis._intPt[1] = p2;\n\t\t\treturn q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\treturn LineIntersector.NO_INTERSECTION;\n\t}\n\tnormalizeToEnvCentre(n00, n01, n10, n11, normPt) {\n\t\tvar minX0 = n00.x < n01.x ? n00.x : n01.x;\n\t\tvar minY0 = n00.y < n01.y ? n00.y : n01.y;\n\t\tvar maxX0 = n00.x > n01.x ? n00.x : n01.x;\n\t\tvar maxY0 = n00.y > n01.y ? n00.y : n01.y;\n\t\tvar minX1 = n10.x < n11.x ? n10.x : n11.x;\n\t\tvar minY1 = n10.y < n11.y ? n10.y : n11.y;\n\t\tvar maxX1 = n10.x > n11.x ? n10.x : n11.x;\n\t\tvar maxY1 = n10.y > n11.y ? n10.y : n11.y;\n\t\tvar intMinX = minX0 > minX1 ? minX0 : minX1;\n\t\tvar intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;\n\t\tvar intMinY = minY0 > minY1 ? minY0 : minY1;\n\t\tvar intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;\n\t\tvar intMidX = (intMinX + intMaxX) / 2.0;\n\t\tvar intMidY = (intMinY + intMaxY) / 2.0;\n\t\tnormPt.x = intMidX;\n\t\tnormPt.y = intMidY;\n\t\tn00.x -= normPt.x;\n\t\tn00.y -= normPt.y;\n\t\tn01.x -= normPt.x;\n\t\tn01.y -= normPt.y;\n\t\tn10.x -= normPt.x;\n\t\tn10.y -= normPt.y;\n\t\tn11.x -= normPt.x;\n\t\tn11.y -= normPt.y;\n\t}\n\tcomputeIntersect(p1, p2, q1, q2) {\n\t\tthis._isProper = false;\n\t\tif (!Envelope.intersects(p1, p2, q1, q2)) return LineIntersector.NO_INTERSECTION;\n\t\tvar Pq1 = Orientation.index(p1, p2, q1);\n\t\tvar Pq2 = Orientation.index(p1, p2, q2);\n\t\tif (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) {\n\t\t\treturn LineIntersector.NO_INTERSECTION;\n\t\t}\n\t\tvar Qp1 = Orientation.index(q1, q2, p1);\n\t\tvar Qp2 = Orientation.index(q1, q2, p2);\n\t\tif (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) {\n\t\t\treturn LineIntersector.NO_INTERSECTION;\n\t\t}\n\t\tvar collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;\n\t\tif (collinear) {\n\t\t\treturn this.computeCollinearIntersection(p1, p2, q1, q2);\n\t\t}\n\t\tif (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {\n\t\t\tthis._isProper = false;\n\t\t\tif (p1.equals2D(q1) || p1.equals2D(q2)) {\n\t\t\t\tthis._intPt[0] = p1;\n\t\t\t} else if (p2.equals2D(q1) || p2.equals2D(q2)) {\n\t\t\t\tthis._intPt[0] = p2;\n\t\t\t} else if (Pq1 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(q1);\n\t\t\t} else if (Pq2 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(q2);\n\t\t\t} else if (Qp1 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(p1);\n\t\t\t} else if (Qp2 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(p2);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._isProper = true;\n\t\t\tthis._intPt[0] = this.intersection(p1, p2, q1, q2);\n\t\t}\n\t\treturn LineIntersector.POINT_INTERSECTION;\n\t}\n\tgetClass() {\n\t\treturn RobustLineIntersector;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRobustLineIntersector.constructor_ = function () {};\n","import Location from '../geom/Location';\nimport hasInterface from '../../../../hasInterface';\nimport Coordinate from '../geom/Coordinate';\nimport Orientation from './Orientation';\nimport CoordinateSequence from '../geom/CoordinateSequence';\nexport default class RayCrossingCounter {\n\tconstructor() {\n\t\tRayCrossingCounter.constructor_.apply(this, arguments);\n\t}\n\tstatic locatePointInRing() {\n\t\tif (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n\t\t\tlet p = arguments[0], ring = arguments[1];\n\t\t\tvar counter = new RayCrossingCounter(p);\n\t\t\tvar p1 = new Coordinate();\n\t\t\tvar p2 = new Coordinate();\n\t\t\tfor (var i = 1; i < ring.size(); i++) {\n\t\t\t\tring.getCoordinate(i, p1);\n\t\t\t\tring.getCoordinate(i - 1, p2);\n\t\t\t\tcounter.countSegment(p1, p2);\n\t\t\t\tif (counter.isOnSegment()) return counter.getLocation();\n\t\t\t}\n\t\t\treturn counter.getLocation();\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n\t\t\tlet p = arguments[0], ring = arguments[1];\n\t\t\tvar counter = new RayCrossingCounter(p);\n\t\t\tfor (var i = 1; i < ring.length; i++) {\n\t\t\t\tvar p1 = ring[i];\n\t\t\t\tvar p2 = ring[i - 1];\n\t\t\t\tcounter.countSegment(p1, p2);\n\t\t\t\tif (counter.isOnSegment()) return counter.getLocation();\n\t\t\t}\n\t\t\treturn counter.getLocation();\n\t\t}\n\t}\n\tcountSegment(p1, p2) {\n\t\tif (p1.x < this._p.x && p2.x < this._p.x) return null;\n\t\tif (this._p.x === p2.x && this._p.y === p2.y) {\n\t\t\tthis._isPointOnSegment = true;\n\t\t\treturn null;\n\t\t}\n\t\tif (p1.y === this._p.y && p2.y === this._p.y) {\n\t\t\tvar minx = p1.x;\n\t\t\tvar maxx = p2.x;\n\t\t\tif (minx > maxx) {\n\t\t\t\tminx = p2.x;\n\t\t\t\tmaxx = p1.x;\n\t\t\t}\n\t\t\tif (this._p.x >= minx && this._p.x <= maxx) {\n\t\t\t\tthis._isPointOnSegment = true;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tif (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {\n\t\t\tvar orient = Orientation.index(p1, p2, this._p);\n\t\t\tif (orient === Orientation.COLLINEAR) {\n\t\t\t\tthis._isPointOnSegment = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (p2.y < p1.y) {\n\t\t\t\torient = -orient;\n\t\t\t}\n\t\t\tif (orient === Orientation.LEFT) {\n\t\t\t\tthis._crossingCount++;\n\t\t\t}\n\t\t}\n\t}\n\tisPointInPolygon() {\n\t\treturn this.getLocation() !== Location.EXTERIOR;\n\t}\n\tgetLocation() {\n\t\tif (this._isPointOnSegment) return Location.BOUNDARY;\n\t\tif (this._crossingCount % 2 === 1) {\n\t\t\treturn Location.INTERIOR;\n\t\t}\n\t\treturn Location.EXTERIOR;\n\t}\n\tisOnSegment() {\n\t\treturn this._isPointOnSegment;\n\t}\n\tgetClass() {\n\t\treturn RayCrossingCounter;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRayCrossingCounter.constructor_ = function () {\n\tthis._p = null;\n\tthis._crossingCount = 0;\n\tthis._isPointOnSegment = false;\n\tlet p = arguments[0];\n\tthis._p = p;\n};\n","import Location from '../geom/Location';\nimport hasInterface from '../../../../hasInterface';\nimport Coordinate from '../geom/Coordinate';\nimport CoordinateSequence from '../geom/CoordinateSequence';\nimport RobustLineIntersector from './RobustLineIntersector';\nimport RayCrossingCounter from './RayCrossingCounter';\nexport default class PointLocation {\n\tconstructor() {\n\t\tPointLocation.constructor_.apply(this, arguments);\n\t}\n\tstatic isOnLine() {\n\t\tif (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n\t\t\tlet p = arguments[0], line = arguments[1];\n\t\t\tvar lineIntersector = new RobustLineIntersector();\n\t\t\tvar p0 = new Coordinate();\n\t\t\tvar p1 = new Coordinate();\n\t\t\tvar n = line.size();\n\t\t\tfor (var i = 1; i < n; i++) {\n\t\t\t\tline.getCoordinate(i - 1, p0);\n\t\t\t\tline.getCoordinate(i, p1);\n\t\t\t\tlineIntersector.computeIntersection(p, p0, p1);\n\t\t\t\tif (lineIntersector.hasIntersection()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n\t\t\tlet p = arguments[0], line = arguments[1];\n\t\t\tvar lineIntersector = new RobustLineIntersector();\n\t\t\tfor (var i = 1; i < line.length; i++) {\n\t\t\t\tvar p0 = line[i - 1];\n\t\t\t\tvar p1 = line[i];\n\t\t\t\tlineIntersector.computeIntersection(p, p0, p1);\n\t\t\t\tif (lineIntersector.hasIntersection()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\tstatic locateInRing(p, ring) {\n\t\treturn RayCrossingCounter.locatePointInRing(p, ring);\n\t}\n\tstatic isInRing(p, ring) {\n\t\treturn PointLocation.locateInRing(p, ring) !== Location.EXTERIOR;\n\t}\n\tgetClass() {\n\t\treturn PointLocation;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPointLocation.constructor_ = function () {};\n","import Iterator from '../../../../java/util/Iterator';\nimport NoSuchElementException from '../../../../java/util/NoSuchElementException';\nimport GeometryCollection from './GeometryCollection';\nexport default class GeometryCollectionIterator {\n\tconstructor() {\n\t\tGeometryCollectionIterator.constructor_.apply(this, arguments);\n\t}\n\tstatic isAtomic(geom) {\n\t\treturn !(geom instanceof GeometryCollection);\n\t}\n\tnext() {\n\t\tif (this._atStart) {\n\t\t\tthis._atStart = false;\n\t\t\tif (GeometryCollectionIterator.isAtomic(this._parent)) this._index++;\n\t\t\treturn this._parent;\n\t\t}\n\t\tif (this._subcollectionIterator !== null) {\n\t\t\tif (this._subcollectionIterator.hasNext()) {\n\t\t\t\treturn this._subcollectionIterator.next();\n\t\t\t} else {\n\t\t\t\tthis._subcollectionIterator = null;\n\t\t\t}\n\t\t}\n\t\tif (this._index >= this._max) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tvar obj = this._parent.getGeometryN(this._index++);\n\t\tif (obj instanceof GeometryCollection) {\n\t\t\tthis._subcollectionIterator = new GeometryCollectionIterator(obj);\n\t\t\treturn this._subcollectionIterator.next();\n\t\t}\n\t\treturn obj;\n\t}\n\tremove() {\n\t\tthrow new UnsupportedOperationException(this.getClass().getName());\n\t}\n\thasNext() {\n\t\tif (this._atStart) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this._subcollectionIterator !== null) {\n\t\t\tif (this._subcollectionIterator.hasNext()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tthis._subcollectionIterator = null;\n\t\t}\n\t\tif (this._index >= this._max) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tgetClass() {\n\t\treturn GeometryCollectionIterator;\n\t}\n\tget interfaces_() {\n\t\treturn [Iterator];\n\t}\n}\nGeometryCollectionIterator.constructor_ = function () {\n\tthis._parent = null;\n\tthis._atStart = null;\n\tthis._max = null;\n\tthis._index = null;\n\tthis._subcollectionIterator = null;\n\tlet parent = arguments[0];\n\tthis._parent = parent;\n\tthis._atStart = true;\n\tthis._index = 0;\n\tthis._max = parent.getNumGeometries();\n};\n","import Location from '../geom/Location';\nimport LineString from '../geom/LineString';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Point from '../geom/Point';\nimport Polygon from '../geom/Polygon';\nimport PointLocation from './PointLocation';\nimport BoundaryNodeRule from './BoundaryNodeRule';\nimport MultiPolygon from '../geom/MultiPolygon';\nimport GeometryCollectionIterator from '../geom/GeometryCollectionIterator';\nimport GeometryCollection from '../geom/GeometryCollection';\nimport MultiLineString from '../geom/MultiLineString';\nexport default class PointLocator {\n\tconstructor() {\n\t\tPointLocator.constructor_.apply(this, arguments);\n\t}\n\tlocateInPolygonRing(p, ring) {\n\t\tif (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n\t\treturn PointLocation.locateInRing(p, ring.getCoordinates());\n\t}\n\tintersects(p, geom) {\n\t\treturn this.locate(p, geom) !== Location.EXTERIOR;\n\t}\n\tupdateLocationInfo(loc) {\n\t\tif (loc === Location.INTERIOR) this._isIn = true;\n\t\tif (loc === Location.BOUNDARY) this._numBoundaries++;\n\t}\n\tcomputeLocation(p, geom) {\n\t\tif (geom instanceof Point) {\n\t\t\tthis.updateLocationInfo(this.locateOnPoint(p, geom));\n\t\t}\n\t\tif (geom instanceof LineString) {\n\t\t\tthis.updateLocationInfo(this.locateOnLineString(p, geom));\n\t\t} else if (geom instanceof Polygon) {\n\t\t\tthis.updateLocationInfo(this.locateInPolygon(p, geom));\n\t\t} else if (geom instanceof MultiLineString) {\n\t\t\tvar ml = geom;\n\t\t\tfor (var i = 0; i < ml.getNumGeometries(); i++) {\n\t\t\t\tvar l = ml.getGeometryN(i);\n\t\t\t\tthis.updateLocationInfo(this.locateOnLineString(p, l));\n\t\t\t}\n\t\t} else if (geom instanceof MultiPolygon) {\n\t\t\tvar mpoly = geom;\n\t\t\tfor (var i = 0; i < mpoly.getNumGeometries(); i++) {\n\t\t\t\tvar poly = mpoly.getGeometryN(i);\n\t\t\t\tthis.updateLocationInfo(this.locateInPolygon(p, poly));\n\t\t\t}\n\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\tvar geomi = new GeometryCollectionIterator(geom);\n\t\t\twhile (geomi.hasNext()) {\n\t\t\t\tvar g2 = geomi.next();\n\t\t\t\tif (g2 !== geom) this.computeLocation(p, g2);\n\t\t\t}\n\t\t}\n\t}\n\tlocateOnPoint(p, pt) {\n\t\tvar ptCoord = pt.getCoordinate();\n\t\tif (ptCoord.equals2D(p)) return Location.INTERIOR;\n\t\treturn Location.EXTERIOR;\n\t}\n\tlocateOnLineString(p, l) {\n\t\tif (!l.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n\t\tvar seq = l.getCoordinateSequence();\n\t\tif (!l.isClosed()) {\n\t\t\tif (p.equals(seq.getCoordinate(0)) || p.equals(seq.getCoordinate(seq.size() - 1))) {\n\t\t\t\treturn Location.BOUNDARY;\n\t\t\t}\n\t\t}\n\t\tif (PointLocation.isOnLine(p, seq)) {\n\t\t\treturn Location.INTERIOR;\n\t\t}\n\t\treturn Location.EXTERIOR;\n\t}\n\tlocateInPolygon(p, poly) {\n\t\tif (poly.isEmpty()) return Location.EXTERIOR;\n\t\tvar shell = poly.getExteriorRing();\n\t\tvar shellLoc = this.locateInPolygonRing(p, shell);\n\t\tif (shellLoc === Location.EXTERIOR) return Location.EXTERIOR;\n\t\tif (shellLoc === Location.BOUNDARY) return Location.BOUNDARY;\n\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n\t\t\tvar hole = poly.getInteriorRingN(i);\n\t\t\tvar holeLoc = this.locateInPolygonRing(p, hole);\n\t\t\tif (holeLoc === Location.INTERIOR) return Location.EXTERIOR;\n\t\t\tif (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;\n\t\t}\n\t\treturn Location.INTERIOR;\n\t}\n\tlocate(p, geom) {\n\t\tif (geom.isEmpty()) return Location.EXTERIOR;\n\t\tif (geom instanceof LineString) {\n\t\t\treturn this.locateOnLineString(p, geom);\n\t\t} else if (geom instanceof Polygon) {\n\t\t\treturn this.locateInPolygon(p, geom);\n\t\t}\n\t\tthis._isIn = false;\n\t\tthis._numBoundaries = 0;\n\t\tthis.computeLocation(p, geom);\n\t\tif (this._boundaryRule.isInBoundary(this._numBoundaries)) return Location.BOUNDARY;\n\t\tif (this._numBoundaries > 0 || this._isIn) return Location.INTERIOR;\n\t\treturn Location.EXTERIOR;\n\t}\n\tgetClass() {\n\t\treturn PointLocator;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPointLocator.constructor_ = function () {\n\tthis._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n\tthis._isIn = null;\n\tthis._numBoundaries = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet boundaryRule = arguments[0];\n\t\tif (boundaryRule === null) throw new IllegalArgumentException(\"Rule must be non-null\");\n\t\tthis._boundaryRule = boundaryRule;\n\t}\n};\n","import Location from './Location';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Dimension from './Dimension';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport StringBuilder from '../../../../java/lang/StringBuilder';\nexport default class IntersectionMatrix {\n\tconstructor() {\n\t\tIntersectionMatrix.constructor_.apply(this, arguments);\n\t}\n\tstatic matches() {\n\t\tif (Number.isInteger(arguments[0]) && typeof arguments[1] === \"string\") {\n\t\t\tlet actualDimensionValue = arguments[0], requiredDimensionSymbol = arguments[1];\n\t\t\tif (requiredDimensionSymbol === Dimension.SYM_DONTCARE) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (requiredDimensionSymbol === Dimension.SYM_TRUE && (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (requiredDimensionSymbol === Dimension.SYM_FALSE && actualDimensionValue === Dimension.FALSE) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (requiredDimensionSymbol === Dimension.SYM_P && actualDimensionValue === Dimension.P) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (requiredDimensionSymbol === Dimension.SYM_L && actualDimensionValue === Dimension.L) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (requiredDimensionSymbol === Dimension.SYM_A && actualDimensionValue === Dimension.A) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (typeof arguments[0] === \"string\" && typeof arguments[1] === \"string\") {\n\t\t\tlet actualDimensionSymbols = arguments[0], requiredDimensionSymbols = arguments[1];\n\t\t\tvar m = new IntersectionMatrix(actualDimensionSymbols);\n\t\t\treturn m.matches(requiredDimensionSymbols);\n\t\t}\n\t}\n\tstatic isTrue(actualDimensionValue) {\n\t\tif (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tisIntersects() {\n\t\treturn !this.isDisjoint();\n\t}\n\tisCovers() {\n\t\tvar hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);\n\t\treturn hasPointInCommon && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n\t}\n\tisCoveredBy() {\n\t\tvar hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);\n\t\treturn hasPointInCommon && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n\t}\n\tset() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet dimensionSymbols = arguments[0];\n\t\t\tfor (var i = 0; i < dimensionSymbols.length; i++) {\n\t\t\t\tvar row = Math.trunc(i / 3);\n\t\t\t\tvar col = i % 3;\n\t\t\t\tthis._matrix[row][col] = Dimension.toDimensionValue(dimensionSymbols.charAt(i));\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet row = arguments[0], column = arguments[1], dimensionValue = arguments[2];\n\t\t\tthis._matrix[row][column] = dimensionValue;\n\t\t}\n\t}\n\tisContains() {\n\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n\t}\n\tsetAtLeast() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet minimumDimensionSymbols = arguments[0];\n\t\t\tfor (var i = 0; i < minimumDimensionSymbols.length; i++) {\n\t\t\t\tvar row = Math.trunc(i / 3);\n\t\t\t\tvar col = i % 3;\n\t\t\t\tthis.setAtLeast(row, col, Dimension.toDimensionValue(minimumDimensionSymbols.charAt(i)));\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet row = arguments[0], column = arguments[1], minimumDimensionValue = arguments[2];\n\t\t\tif (this._matrix[row][column] < minimumDimensionValue) {\n\t\t\t\tthis._matrix[row][column] = minimumDimensionValue;\n\t\t\t}\n\t\t}\n\t}\n\tsetAtLeastIfValid(row, column, minimumDimensionValue) {\n\t\tif (row >= 0 && column >= 0) {\n\t\t\tthis.setAtLeast(row, column, minimumDimensionValue);\n\t\t}\n\t}\n\tisWithin() {\n\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n\t}\n\tisTouches(dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA > dimensionOfGeometryB) {\n\t\t\treturn this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && (IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]));\n\t\t}\n\t\treturn false;\n\t}\n\tisOverlaps(dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A) {\n\t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === 1 && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n\t\t}\n\t\treturn false;\n\t}\n\tisEquals(dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA !== dimensionOfGeometryB) {\n\t\t\treturn false;\n\t\t}\n\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n\t}\n\ttoString() {\n\t\tvar builder = new StringBuilder(\"123456789\");\n\t\tfor (var ai = 0; ai < 3; ai++) {\n\t\t\tfor (var bi = 0; bi < 3; bi++) {\n\t\t\t\tbuilder.setCharAt(3 * ai + bi, Dimension.toDimensionSymbol(this._matrix[ai][bi]));\n\t\t\t}\n\t\t}\n\t\treturn builder.toString();\n\t}\n\tsetAll(dimensionValue) {\n\t\tfor (var ai = 0; ai < 3; ai++) {\n\t\t\tfor (var bi = 0; bi < 3; bi++) {\n\t\t\t\tthis._matrix[ai][bi] = dimensionValue;\n\t\t\t}\n\t\t}\n\t}\n\tget(row, column) {\n\t\treturn this._matrix[row][column];\n\t}\n\ttranspose() {\n\t\tvar temp = this._matrix[1][0];\n\t\tthis._matrix[1][0] = this._matrix[0][1];\n\t\tthis._matrix[0][1] = temp;\n\t\ttemp = this._matrix[2][0];\n\t\tthis._matrix[2][0] = this._matrix[0][2];\n\t\tthis._matrix[0][2] = temp;\n\t\ttemp = this._matrix[2][1];\n\t\tthis._matrix[2][1] = this._matrix[1][2];\n\t\tthis._matrix[1][2] = temp;\n\t\treturn this;\n\t}\n\tmatches(requiredDimensionSymbols) {\n\t\tif (requiredDimensionSymbols.length !== 9) {\n\t\t\tthrow new IllegalArgumentException(\"Should be length 9: \" + requiredDimensionSymbols);\n\t\t}\n\t\tfor (var ai = 0; ai < 3; ai++) {\n\t\t\tfor (var bi = 0; bi < 3; bi++) {\n\t\t\t\tif (!IntersectionMatrix.matches(this._matrix[ai][bi], requiredDimensionSymbols.charAt(3 * ai + bi))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tadd(im) {\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\tfor (var j = 0; j < 3; j++) {\n\t\t\t\tthis.setAtLeast(i, j, im.get(i, j));\n\t\t\t}\n\t\t}\n\t}\n\tisDisjoint() {\n\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.INTERIOR][Location.BOUNDARY] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.BOUNDARY] === Dimension.FALSE;\n\t}\n\tisCrosses(dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A) {\n\t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === 0;\n\t\t}\n\t\treturn false;\n\t}\n\tgetClass() {\n\t\treturn IntersectionMatrix;\n\t}\n\tget interfaces_() {\n\t\treturn [Cloneable];\n\t}\n}\nIntersectionMatrix.constructor_ = function () {\n\tthis._matrix = null;\n\tif (arguments.length === 0) {\n\t\tthis._matrix = Array(3).fill().map(() => Array(3));\n\t\tthis.setAll(Dimension.FALSE);\n\t} else if (arguments.length === 1) {\n\t\tif (typeof arguments[0] === \"string\") {\n\t\t\tlet elements = arguments[0];\n\t\t\tIntersectionMatrix.constructor_.call(this);\n\t\t\tthis.set(elements);\n\t\t} else if (arguments[0] instanceof IntersectionMatrix) {\n\t\t\tlet other = arguments[0];\n\t\t\tIntersectionMatrix.constructor_.call(this);\n\t\t\tthis._matrix[Location.INTERIOR][Location.INTERIOR] = other._matrix[Location.INTERIOR][Location.INTERIOR];\n\t\t\tthis._matrix[Location.INTERIOR][Location.BOUNDARY] = other._matrix[Location.INTERIOR][Location.BOUNDARY];\n\t\t\tthis._matrix[Location.INTERIOR][Location.EXTERIOR] = other._matrix[Location.INTERIOR][Location.EXTERIOR];\n\t\t\tthis._matrix[Location.BOUNDARY][Location.INTERIOR] = other._matrix[Location.BOUNDARY][Location.INTERIOR];\n\t\t\tthis._matrix[Location.BOUNDARY][Location.BOUNDARY] = other._matrix[Location.BOUNDARY][Location.BOUNDARY];\n\t\t\tthis._matrix[Location.BOUNDARY][Location.EXTERIOR] = other._matrix[Location.BOUNDARY][Location.EXTERIOR];\n\t\t\tthis._matrix[Location.EXTERIOR][Location.INTERIOR] = other._matrix[Location.EXTERIOR][Location.INTERIOR];\n\t\t\tthis._matrix[Location.EXTERIOR][Location.BOUNDARY] = other._matrix[Location.EXTERIOR][Location.BOUNDARY];\n\t\t\tthis._matrix[Location.EXTERIOR][Location.EXTERIOR] = other._matrix[Location.EXTERIOR][Location.EXTERIOR];\n\t\t}\n\t}\n};\n","import Coordinate from '../geom/Coordinate';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nexport default class Quadrant {\n\tconstructor() {\n\t\tQuadrant.constructor_.apply(this, arguments);\n\t}\n\tstatic isNorthern(quad) {\n\t\treturn quad === Quadrant.NE || quad === Quadrant.NW;\n\t}\n\tstatic isOpposite(quad1, quad2) {\n\t\tif (quad1 === quad2) return false;\n\t\tvar diff = (quad1 - quad2 + 4) % 4;\n\t\tif (diff === 2) return true;\n\t\treturn false;\n\t}\n\tstatic commonHalfPlane(quad1, quad2) {\n\t\tif (quad1 === quad2) return quad1;\n\t\tvar diff = (quad1 - quad2 + 4) % 4;\n\t\tif (diff === 2) return -1;\n\t\tvar min = quad1 < quad2 ? quad1 : quad2;\n\t\tvar max = quad1 > quad2 ? quad1 : quad2;\n\t\tif (min === 0 && max === 3) return 3;\n\t\treturn min;\n\t}\n\tstatic isInHalfPlane(quad, halfPlane) {\n\t\tif (halfPlane === Quadrant.SE) {\n\t\t\treturn quad === Quadrant.SE || quad === Quadrant.SW;\n\t\t}\n\t\treturn quad === halfPlane || quad === halfPlane + 1;\n\t}\n\tstatic quadrant() {\n\t\tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\t\tlet dx = arguments[0], dy = arguments[1];\n\t\t\tif (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the quadrant for point ( \" + dx + \", \" + dy + \" )\");\n\t\t\tif (dx >= 0.0) {\n\t\t\t\tif (dy >= 0.0) return Quadrant.NE; else return Quadrant.SE;\n\t\t\t} else {\n\t\t\t\tif (dy >= 0.0) return Quadrant.NW; else return Quadrant.SW;\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\t\tif (p1.x === p0.x && p1.y === p0.y) throw new IllegalArgumentException(\"Cannot compute the quadrant for two identical points \" + p0);\n\t\t\tif (p1.x >= p0.x) {\n\t\t\t\tif (p1.y >= p0.y) return Quadrant.NE; else return Quadrant.SE;\n\t\t\t} else {\n\t\t\t\tif (p1.y >= p0.y) return Quadrant.NW; else return Quadrant.SW;\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn Quadrant;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nQuadrant.constructor_ = function () {};\nQuadrant.NE = 0;\nQuadrant.NW = 1;\nQuadrant.SW = 2;\nQuadrant.SE = 3;\n","import Orientation from '../algorithm/Orientation';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Quadrant from './Quadrant';\nimport Assert from '../util/Assert';\nexport default class EdgeEnd {\n\tconstructor() {\n\t\tEdgeEnd.constructor_.apply(this, arguments);\n\t}\n\tcompareDirection(e) {\n\t\tif (this._dx === e._dx && this._dy === e._dy) return 0;\n\t\tif (this._quadrant > e._quadrant) return 1;\n\t\tif (this._quadrant < e._quadrant) return -1;\n\t\treturn Orientation.index(e._p0, e._p1, this._p1);\n\t}\n\tgetDy() {\n\t\treturn this._dy;\n\t}\n\tgetCoordinate() {\n\t\treturn this._p0;\n\t}\n\tsetNode(node) {\n\t\tthis._node = node;\n\t}\n\tprint(out) {\n\t\tvar angle = Math.atan2(this._dy, this._dx);\n\t\tvar className = this.getClass().getName();\n\t\tvar lastDotPos = className.lastIndexOf('.');\n\t\tvar name = className.substring(lastDotPos + 1);\n\t\tout.print(\"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + angle + \"   \" + this._label);\n\t}\n\tcompareTo(obj) {\n\t\tvar e = obj;\n\t\treturn this.compareDirection(e);\n\t}\n\tgetDirectedCoordinate() {\n\t\treturn this._p1;\n\t}\n\tgetDx() {\n\t\treturn this._dx;\n\t}\n\tgetLabel() {\n\t\treturn this._label;\n\t}\n\tgetEdge() {\n\t\treturn this._edge;\n\t}\n\tgetQuadrant() {\n\t\treturn this._quadrant;\n\t}\n\tgetNode() {\n\t\treturn this._node;\n\t}\n\ttoString() {\n\t\tvar angle = Math.atan2(this._dy, this._dx);\n\t\tvar className = this.getClass().getName();\n\t\tvar lastDotPos = className.lastIndexOf('.');\n\t\tvar name = className.substring(lastDotPos + 1);\n\t\treturn \"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + angle + \"   \" + this._label;\n\t}\n\tcomputeLabel(boundaryNodeRule) {}\n\tinit(p0, p1) {\n\t\tthis._p0 = p0;\n\t\tthis._p1 = p1;\n\t\tthis._dx = p1.x - p0.x;\n\t\tthis._dy = p1.y - p0.y;\n\t\tthis._quadrant = Quadrant.quadrant(this._dx, this._dy);\n\t\tAssert.isTrue(!(this._dx === 0 && this._dy === 0), \"EdgeEnd with identical endpoints found\");\n\t}\n\tgetClass() {\n\t\treturn EdgeEnd;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparable];\n\t}\n}\nEdgeEnd.constructor_ = function () {\n\tthis._edge = null;\n\tthis._label = null;\n\tthis._node = null;\n\tthis._p0 = null;\n\tthis._p1 = null;\n\tthis._dx = null;\n\tthis._dy = null;\n\tthis._quadrant = null;\n\tif (arguments.length === 1) {\n\t\tlet edge = arguments[0];\n\t\tthis._edge = edge;\n\t} else if (arguments.length === 3) {\n\t\tlet edge = arguments[0], p0 = arguments[1], p1 = arguments[2];\n\t\tEdgeEnd.constructor_.call(this, edge, p0, p1, null);\n\t} else if (arguments.length === 4) {\n\t\tlet edge = arguments[0], p0 = arguments[1], p1 = arguments[2], label = arguments[3];\n\t\tEdgeEnd.constructor_.call(this, edge);\n\t\tthis.init(p0, p1);\n\t\tthis._label = label;\n\t}\n};\n","export default class Position {\n\tconstructor() {\n\t\tPosition.constructor_.apply(this, arguments);\n\t}\n\tstatic opposite(position) {\n\t\tif (position === Position.LEFT) return Position.RIGHT;\n\t\tif (position === Position.RIGHT) return Position.LEFT;\n\t\treturn position;\n\t}\n\tgetClass() {\n\t\treturn Position;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPosition.constructor_ = function () {};\nPosition.ON = 0;\nPosition.LEFT = 1;\nPosition.RIGHT = 2;\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Location from '../geom/Location';\nimport Position from './Position';\nexport default class TopologyLocation {\n\tconstructor() {\n\t\tTopologyLocation.constructor_.apply(this, arguments);\n\t}\n\tsetAllLocations(locValue) {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tthis.location[i] = locValue;\n\t\t}\n\t}\n\tisNull() {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] !== Location.NONE) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tsetAllLocationsIfNull(locValue) {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] === Location.NONE) this.location[i] = locValue;\n\t\t}\n\t}\n\tisLine() {\n\t\treturn this.location.length === 1;\n\t}\n\tmerge(gl) {\n\t\tif (gl.location.length > this.location.length) {\n\t\t\tvar newLoc = new Array(3).fill(null);\n\t\t\tnewLoc[Position.ON] = this.location[Position.ON];\n\t\t\tnewLoc[Position.LEFT] = Location.NONE;\n\t\t\tnewLoc[Position.RIGHT] = Location.NONE;\n\t\t\tthis.location = newLoc;\n\t\t}\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] === Location.NONE && i < gl.location.length) this.location[i] = gl.location[i];\n\t\t}\n\t}\n\tgetLocations() {\n\t\treturn this.location;\n\t}\n\tflip() {\n\t\tif (this.location.length <= 1) return null;\n\t\tvar temp = this.location[Position.LEFT];\n\t\tthis.location[Position.LEFT] = this.location[Position.RIGHT];\n\t\tthis.location[Position.RIGHT] = temp;\n\t}\n\ttoString() {\n\t\tvar buf = new StringBuffer();\n\t\tif (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.LEFT]));\n\t\tbuf.append(Location.toLocationSymbol(this.location[Position.ON]));\n\t\tif (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]));\n\t\treturn buf.toString();\n\t}\n\tsetLocations(on, left, right) {\n\t\tthis.location[Position.ON] = on;\n\t\tthis.location[Position.LEFT] = left;\n\t\tthis.location[Position.RIGHT] = right;\n\t}\n\tget(posIndex) {\n\t\tif (posIndex < this.location.length) return this.location[posIndex];\n\t\treturn Location.NONE;\n\t}\n\tisArea() {\n\t\treturn this.location.length > 1;\n\t}\n\tisAnyNull() {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] === Location.NONE) return true;\n\t\t}\n\t\treturn false;\n\t}\n\tsetLocation() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet locValue = arguments[0];\n\t\t\tthis.setLocation(Position.ON, locValue);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet locIndex = arguments[0], locValue = arguments[1];\n\t\t\tthis.location[locIndex] = locValue;\n\t\t}\n\t}\n\tinit(size) {\n\t\tthis.location = new Array(size).fill(null);\n\t\tthis.setAllLocations(Location.NONE);\n\t}\n\tisEqualOnSide(le, locIndex) {\n\t\treturn this.location[locIndex] === le.location[locIndex];\n\t}\n\tallPositionsEqual(loc) {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] !== loc) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tgetClass() {\n\t\treturn TopologyLocation;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nTopologyLocation.constructor_ = function () {\n\tthis.location = null;\n\tif (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tlet location = arguments[0];\n\t\t\tthis.init(location.length);\n\t\t} else if (Number.isInteger(arguments[0])) {\n\t\t\tlet on = arguments[0];\n\t\t\tthis.init(1);\n\t\t\tthis.location[Position.ON] = on;\n\t\t} else if (arguments[0] instanceof TopologyLocation) {\n\t\t\tlet gl = arguments[0];\n\t\t\tthis.init(gl.location.length);\n\t\t\tif (gl !== null) {\n\t\t\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\t\t\tthis.location[i] = gl.location[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (arguments.length === 3) {\n\t\tlet on = arguments[0], left = arguments[1], right = arguments[2];\n\t\tthis.init(3);\n\t\tthis.location[Position.ON] = on;\n\t\tthis.location[Position.LEFT] = left;\n\t\tthis.location[Position.RIGHT] = right;\n\t}\n};\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Location from '../geom/Location';\nimport Position from './Position';\nimport TopologyLocation from './TopologyLocation';\nexport default class Label {\n\tconstructor() {\n\t\tLabel.constructor_.apply(this, arguments);\n\t}\n\tstatic toLineLabel(label) {\n\t\tvar lineLabel = new Label(Location.NONE);\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tlineLabel.setLocation(i, label.getLocation(i));\n\t\t}\n\t\treturn lineLabel;\n\t}\n\tgetGeometryCount() {\n\t\tvar count = 0;\n\t\tif (!this.elt[0].isNull()) count++;\n\t\tif (!this.elt[1].isNull()) count++;\n\t\treturn count;\n\t}\n\tsetAllLocations(geomIndex, location) {\n\t\tthis.elt[geomIndex].setAllLocations(location);\n\t}\n\tisNull(geomIndex) {\n\t\treturn this.elt[geomIndex].isNull();\n\t}\n\tsetAllLocationsIfNull() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet location = arguments[0];\n\t\t\tthis.setAllLocationsIfNull(0, location);\n\t\t\tthis.setAllLocationsIfNull(1, location);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], location = arguments[1];\n\t\t\tthis.elt[geomIndex].setAllLocationsIfNull(location);\n\t\t}\n\t}\n\tisLine(geomIndex) {\n\t\treturn this.elt[geomIndex].isLine();\n\t}\n\tmerge(lbl) {\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (this.elt[i] === null && lbl.elt[i] !== null) {\n\t\t\t\tthis.elt[i] = new TopologyLocation(lbl.elt[i]);\n\t\t\t} else {\n\t\t\t\tthis.elt[i].merge(lbl.elt[i]);\n\t\t\t}\n\t\t}\n\t}\n\tflip() {\n\t\tthis.elt[0].flip();\n\t\tthis.elt[1].flip();\n\t}\n\tgetLocation() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet geomIndex = arguments[0];\n\t\t\treturn this.elt[geomIndex].get(Position.ON);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1];\n\t\t\treturn this.elt[geomIndex].get(posIndex);\n\t\t}\n\t}\n\ttoString() {\n\t\tvar buf = new StringBuffer();\n\t\tif (this.elt[0] !== null) {\n\t\t\tbuf.append(\"A:\");\n\t\t\tbuf.append(this.elt[0].toString());\n\t\t}\n\t\tif (this.elt[1] !== null) {\n\t\t\tbuf.append(\" B:\");\n\t\t\tbuf.append(this.elt[1].toString());\n\t\t}\n\t\treturn buf.toString();\n\t}\n\tisArea() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.elt[0].isArea() || this.elt[1].isArea();\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet geomIndex = arguments[0];\n\t\t\treturn this.elt[geomIndex].isArea();\n\t\t}\n\t}\n\tisAnyNull(geomIndex) {\n\t\treturn this.elt[geomIndex].isAnyNull();\n\t}\n\tsetLocation() {\n\t\tif (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], location = arguments[1];\n\t\t\tthis.elt[geomIndex].setLocation(Position.ON, location);\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2];\n\t\t\tthis.elt[geomIndex].setLocation(posIndex, location);\n\t\t}\n\t}\n\tisEqualOnSide(lbl, side) {\n\t\treturn this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);\n\t}\n\tallPositionsEqual(geomIndex, loc) {\n\t\treturn this.elt[geomIndex].allPositionsEqual(loc);\n\t}\n\ttoLine(geomIndex) {\n\t\tif (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]);\n\t}\n\tgetClass() {\n\t\treturn Label;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nLabel.constructor_ = function () {\n\tthis.elt = new Array(2).fill(null);\n\tif (arguments.length === 1) {\n\t\tif (Number.isInteger(arguments[0])) {\n\t\t\tlet onLoc = arguments[0];\n\t\t\tthis.elt[0] = new TopologyLocation(onLoc);\n\t\t\tthis.elt[1] = new TopologyLocation(onLoc);\n\t\t} else if (arguments[0] instanceof Label) {\n\t\t\tlet lbl = arguments[0];\n\t\t\tthis.elt[0] = new TopologyLocation(lbl.elt[0]);\n\t\t\tthis.elt[1] = new TopologyLocation(lbl.elt[1]);\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet geomIndex = arguments[0], onLoc = arguments[1];\n\t\tthis.elt[0] = new TopologyLocation(Location.NONE);\n\t\tthis.elt[1] = new TopologyLocation(Location.NONE);\n\t\tthis.elt[geomIndex].setLocation(onLoc);\n\t} else if (arguments.length === 3) {\n\t\tlet onLoc = arguments[0], leftLoc = arguments[1], rightLoc = arguments[2];\n\t\tthis.elt[0] = new TopologyLocation(onLoc, leftLoc, rightLoc);\n\t\tthis.elt[1] = new TopologyLocation(onLoc, leftLoc, rightLoc);\n\t} else if (arguments.length === 4) {\n\t\tlet geomIndex = arguments[0], onLoc = arguments[1], leftLoc = arguments[2], rightLoc = arguments[3];\n\t\tthis.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n\t\tthis.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n\t\tthis.elt[geomIndex].setLocations(onLoc, leftLoc, rightLoc);\n\t}\n};\n","import EdgeEnd from '../../geomgraph/EdgeEnd';\nimport Label from '../../geomgraph/Label';\nimport ArrayList from '../../../../../java/util/ArrayList';\nexport default class EdgeEndBuilder {\n\tconstructor() {\n\t\tEdgeEndBuilder.constructor_.apply(this, arguments);\n\t}\n\tcreateEdgeEndForNext(edge, l, eiCurr, eiNext) {\n\t\tvar iNext = eiCurr.segmentIndex + 1;\n\t\tif (iNext >= edge.getNumPoints() && eiNext === null) return null;\n\t\tvar pNext = edge.getCoordinate(iNext);\n\t\tif (eiNext !== null && eiNext.segmentIndex === eiCurr.segmentIndex) pNext = eiNext.coord;\n\t\tvar e = new EdgeEnd(edge, eiCurr.coord, pNext, new Label(edge.getLabel()));\n\t\tl.add(e);\n\t}\n\tcreateEdgeEndForPrev(edge, l, eiCurr, eiPrev) {\n\t\tvar iPrev = eiCurr.segmentIndex;\n\t\tif (eiCurr.dist === 0.0) {\n\t\t\tif (iPrev === 0) return null;\n\t\t\tiPrev--;\n\t\t}\n\t\tvar pPrev = edge.getCoordinate(iPrev);\n\t\tif (eiPrev !== null && eiPrev.segmentIndex >= iPrev) pPrev = eiPrev.coord;\n\t\tvar label = new Label(edge.getLabel());\n\t\tlabel.flip();\n\t\tvar e = new EdgeEnd(edge, eiCurr.coord, pPrev, label);\n\t\tl.add(e);\n\t}\n\tcomputeEdgeEnds() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet edges = arguments[0];\n\t\t\tvar l = new ArrayList();\n\t\t\tfor (var i = edges; i.hasNext(); ) {\n\t\t\t\tvar e = i.next();\n\t\t\t\tthis.computeEdgeEnds(e, l);\n\t\t\t}\n\t\t\treturn l;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet edge = arguments[0], l = arguments[1];\n\t\t\tvar eiList = edge.getEdgeIntersectionList();\n\t\t\teiList.addEndpoints();\n\t\t\tvar it = eiList.iterator();\n\t\t\tvar eiPrev = null;\n\t\t\tvar eiCurr = null;\n\t\t\tif (!it.hasNext()) return null;\n\t\t\tvar eiNext = it.next();\n\t\t\tdo {\n\t\t\t\teiPrev = eiCurr;\n\t\t\t\teiCurr = eiNext;\n\t\t\t\teiNext = null;\n\t\t\t\tif (it.hasNext()) eiNext = it.next();\n\t\t\t\tif (eiCurr !== null) {\n\t\t\t\t\tthis.createEdgeEndForPrev(edge, l, eiCurr, eiPrev);\n\t\t\t\t\tthis.createEdgeEndForNext(edge, l, eiCurr, eiNext);\n\t\t\t\t}\n\t\t\t} while (eiCurr !== null);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn EdgeEndBuilder;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdgeEndBuilder.constructor_ = function () {};\n","import Assert from '../util/Assert';\nexport default class GraphComponent {\n\tconstructor() {\n\t\tGraphComponent.constructor_.apply(this, arguments);\n\t}\n\tsetVisited(isVisited) {\n\t\tthis._isVisited = isVisited;\n\t}\n\tsetInResult(isInResult) {\n\t\tthis._isInResult = isInResult;\n\t}\n\tisCovered() {\n\t\treturn this._isCovered;\n\t}\n\tisCoveredSet() {\n\t\treturn this._isCoveredSet;\n\t}\n\tsetLabel(label) {\n\t\tthis._label = label;\n\t}\n\tgetLabel() {\n\t\treturn this._label;\n\t}\n\tsetCovered(isCovered) {\n\t\tthis._isCovered = isCovered;\n\t\tthis._isCoveredSet = true;\n\t}\n\tupdateIM(im) {\n\t\tAssert.isTrue(this._label.getGeometryCount() >= 2, \"found partial label\");\n\t\tthis.computeIM(im);\n\t}\n\tisInResult() {\n\t\treturn this._isInResult;\n\t}\n\tisVisited() {\n\t\treturn this._isVisited;\n\t}\n\tgetClass() {\n\t\treturn GraphComponent;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGraphComponent.constructor_ = function () {\n\tthis._label = null;\n\tthis._isInResult = false;\n\tthis._isCovered = false;\n\tthis._isCoveredSet = false;\n\tthis._isVisited = false;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet label = arguments[0];\n\t\tthis._label = label;\n\t}\n};\n","import Location from '../geom/Location';\nimport Label from './Label';\nimport GraphComponent from './GraphComponent';\nexport default class Node extends GraphComponent {\n\tconstructor() {\n\t\tsuper();\n\t\tNode.constructor_.apply(this, arguments);\n\t}\n\tisIncidentEdgeInResult() {\n\t\tfor (var it = this.getEdges().getEdges().iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.getEdge().isInResult()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\tisIsolated() {\n\t\treturn this._label.getGeometryCount() === 1;\n\t}\n\tgetCoordinate() {\n\t\treturn this._coord;\n\t}\n\tprint(out) {\n\t\tout.println(\"node \" + this._coord + \" lbl: \" + this._label);\n\t}\n\tcomputeIM(im) {}\n\tcomputeMergedLocation(label2, eltIndex) {\n\t\tvar loc = Location.NONE;\n\t\tloc = this._label.getLocation(eltIndex);\n\t\tif (!label2.isNull(eltIndex)) {\n\t\t\tvar nLoc = label2.getLocation(eltIndex);\n\t\t\tif (loc !== Location.BOUNDARY) loc = nLoc;\n\t\t}\n\t\treturn loc;\n\t}\n\tsetLabel() {\n\t\tif (arguments.length === 2 && (Number.isInteger(arguments[1]) && Number.isInteger(arguments[0]))) {\n\t\t\tlet argIndex = arguments[0], onLocation = arguments[1];\n\t\t\tif (this._label === null) {\n\t\t\t\tthis._label = new Label(argIndex, onLocation);\n\t\t\t} else this._label.setLocation(argIndex, onLocation);\n\t\t} else return super.setLabel.apply(this, arguments);\n\t}\n\tgetEdges() {\n\t\treturn this._edges;\n\t}\n\tmergeLabel() {\n\t\tif (arguments[0] instanceof Node) {\n\t\t\tlet n = arguments[0];\n\t\t\tthis.mergeLabel(n._label);\n\t\t} else if (arguments[0] instanceof Label) {\n\t\t\tlet label2 = arguments[0];\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tvar loc = this.computeMergedLocation(label2, i);\n\t\t\t\tvar thisLoc = this._label.getLocation(i);\n\t\t\t\tif (thisLoc === Location.NONE) this._label.setLocation(i, loc);\n\t\t\t}\n\t\t}\n\t}\n\tadd(e) {\n\t\tthis._edges.insert(e);\n\t\te.setNode(this);\n\t}\n\tsetLabelBoundary(argIndex) {\n\t\tif (this._label === null) return null;\n\t\tvar loc = Location.NONE;\n\t\tif (this._label !== null) loc = this._label.getLocation(argIndex);\n\t\tvar newLoc = null;\n\t\tswitch (loc) {\n\t\t\tcase Location.BOUNDARY:\n\t\t\t\tnewLoc = Location.INTERIOR;\n\t\t\t\tbreak;\n\t\t\tcase Location.INTERIOR:\n\t\t\t\tnewLoc = Location.BOUNDARY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnewLoc = Location.BOUNDARY;\n\t\t\t\tbreak;\n\t\t}\n\t\tthis._label.setLocation(argIndex, newLoc);\n\t}\n\tgetClass() {\n\t\treturn Node;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nNode.constructor_ = function () {\n\tthis._coord = null;\n\tthis._edges = null;\n\tlet coord = arguments[0], edges = arguments[1];\n\tthis._coord = coord;\n\tthis._edges = edges;\n\tthis._label = new Label(0, Location.NONE);\n};\n","import Location from '../geom/Location';\nimport Coordinate from '../geom/Coordinate';\nimport Node from './Node';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default class NodeMap {\n\tconstructor() {\n\t\tNodeMap.constructor_.apply(this, arguments);\n\t}\n\tfind(coord) {\n\t\treturn this.nodeMap.get(coord);\n\t}\n\taddNode() {\n\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\tlet coord = arguments[0];\n\t\t\tvar node = this.nodeMap.get(coord);\n\t\t\tif (node === null) {\n\t\t\t\tnode = this.nodeFact.createNode(coord);\n\t\t\t\tthis.nodeMap.put(coord, node);\n\t\t\t}\n\t\t\treturn node;\n\t\t} else if (arguments[0] instanceof Node) {\n\t\t\tlet n = arguments[0];\n\t\t\tvar node = this.nodeMap.get(n.getCoordinate());\n\t\t\tif (node === null) {\n\t\t\t\tthis.nodeMap.put(n.getCoordinate(), n);\n\t\t\t\treturn n;\n\t\t\t}\n\t\t\tnode.mergeLabel(n);\n\t\t\treturn node;\n\t\t}\n\t}\n\tprint(out) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar n = it.next();\n\t\t\tn.print(out);\n\t\t}\n\t}\n\titerator() {\n\t\treturn this.nodeMap.values().iterator();\n\t}\n\tvalues() {\n\t\treturn this.nodeMap.values();\n\t}\n\tgetBoundaryNodes(geomIndex) {\n\t\tvar bdyNodes = new ArrayList();\n\t\tfor (var i = this.iterator(); i.hasNext(); ) {\n\t\t\tvar node = i.next();\n\t\t\tif (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) bdyNodes.add(node);\n\t\t}\n\t\treturn bdyNodes;\n\t}\n\tadd(e) {\n\t\tvar p = e.getCoordinate();\n\t\tvar n = this.addNode(p);\n\t\tn.add(e);\n\t}\n\tgetClass() {\n\t\treturn NodeMap;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nNodeMap.constructor_ = function () {\n\tthis.nodeMap = new TreeMap();\n\tthis.nodeFact = null;\n\tlet nodeFact = arguments[0];\n\tthis.nodeFact = nodeFact;\n};\n","import Coordinate from './Coordinate';\nimport RuntimeException from '../../../../java/lang/RuntimeException';\nexport default class TopologyException extends RuntimeException {\n\tconstructor() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet msg = arguments[0];\n\t\t\tsuper(msg)\n\t\t\tRuntimeException.call(this, msg);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet msg = arguments[0], pt = arguments[1];\n\t\t\tsuper(TopologyException.msgWithCoord(msg, pt))\n\t\t\tthis.name = 'TopologyException';\n\t\t\tthis.pt = new Coordinate(pt);\n\t\t}\n\t}\n\tgetCoordinate() {\n\t\treturn this.pt;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n\tgetClass() {\n\t\treturn TopologyException;\n\t}\n\tstatic msgWithCoord (msg, pt) {\n\t\tif (pt !== null) return msg + \" [ \" + pt + \" ]\";\n\t\treturn msg;\n\t}\n}","export default class PointOnGeometryLocator {\n\tconstructor() {\n\t\tPointOnGeometryLocator.constructor_.apply(this, arguments);\n\t}\n\tlocate(p) {}\n\tgetClass() {\n\t\treturn PointOnGeometryLocator;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPointOnGeometryLocator.constructor_ = function () {};\n","import Location from '../../geom/Location';\nimport Polygon from '../../geom/Polygon';\nimport PointLocation from '../PointLocation';\nimport PointOnGeometryLocator from './PointOnGeometryLocator';\nimport GeometryCollectionIterator from '../../geom/GeometryCollectionIterator';\nimport GeometryCollection from '../../geom/GeometryCollection';\nexport default class SimplePointInAreaLocator {\n\tconstructor() {\n\t\tSimplePointInAreaLocator.constructor_.apply(this, arguments);\n\t}\n\tstatic locatePointInPolygon(p, poly) {\n\t\tif (poly.isEmpty()) return Location.EXTERIOR;\n\t\tvar shell = poly.getExteriorRing();\n\t\tvar shellLoc = SimplePointInAreaLocator.locatePointInRing(p, shell);\n\t\tif (shellLoc !== Location.INTERIOR) return shellLoc;\n\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n\t\t\tvar hole = poly.getInteriorRingN(i);\n\t\t\tvar holeLoc = SimplePointInAreaLocator.locatePointInRing(p, hole);\n\t\t\tif (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;\n\t\t\tif (holeLoc === Location.INTERIOR) return Location.EXTERIOR;\n\t\t}\n\t\treturn Location.INTERIOR;\n\t}\n\tstatic locatePointInRing(p, ring) {\n\t\tif (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n\t\treturn PointLocation.locateInRing(p, ring.getCoordinates());\n\t}\n\tstatic containsPointInPolygon(p, poly) {\n\t\treturn Location.EXTERIOR !== SimplePointInAreaLocator.locatePointInPolygon(p, poly);\n\t}\n\tstatic locateInGeometry(p, geom) {\n\t\tif (geom instanceof Polygon) {\n\t\t\treturn SimplePointInAreaLocator.locatePointInPolygon(p, geom);\n\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\tvar geomi = new GeometryCollectionIterator(geom);\n\t\t\twhile (geomi.hasNext()) {\n\t\t\t\tvar g2 = geomi.next();\n\t\t\t\tif (g2 !== geom) {\n\t\t\t\t\tvar loc = SimplePointInAreaLocator.locateInGeometry(p, g2);\n\t\t\t\t\tif (loc !== Location.EXTERIOR) return loc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Location.EXTERIOR;\n\t}\n\tstatic locate(p, geom) {\n\t\tif (geom.isEmpty()) return Location.EXTERIOR;\n\t\treturn SimplePointInAreaLocator.locateInGeometry(p, geom);\n\t}\n\tlocate(p) {\n\t\treturn SimplePointInAreaLocator.locate(p, this._geom);\n\t}\n\tgetClass() {\n\t\treturn SimplePointInAreaLocator;\n\t}\n\tget interfaces_() {\n\t\treturn [PointOnGeometryLocator];\n\t}\n}\nSimplePointInAreaLocator.constructor_ = function () {\n\tthis._geom = null;\n\tlet geom = arguments[0];\n\tthis._geom = geom;\n};\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Location from '../geom/Location';\nimport Position from './Position';\nimport TopologyException from '../geom/TopologyException';\nimport System from '../../../../java/lang/System';\nimport SimplePointInAreaLocator from '../algorithm/locate/SimplePointInAreaLocator';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Assert from '../util/Assert';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default class EdgeEndStar {\n\tconstructor() {\n\t\tEdgeEndStar.constructor_.apply(this, arguments);\n\t}\n\tgetNextCW(ee) {\n\t\tthis.getEdges();\n\t\tvar i = this._edgeList.indexOf(ee);\n\t\tvar iNextCW = i - 1;\n\t\tif (i === 0) iNextCW = this._edgeList.size() - 1;\n\t\treturn this._edgeList.get(iNextCW);\n\t}\n\tpropagateSideLabels(geomIndex) {\n\t\tvar startLoc = Location.NONE;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tif (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) startLoc = label.getLocation(geomIndex, Position.LEFT);\n\t\t}\n\t\tif (startLoc === Location.NONE) return null;\n\t\tvar currLoc = startLoc;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tif (label.getLocation(geomIndex, Position.ON) === Location.NONE) label.setLocation(geomIndex, Position.ON, currLoc);\n\t\t\tif (label.isArea(geomIndex)) {\n\t\t\t\tvar leftLoc = label.getLocation(geomIndex, Position.LEFT);\n\t\t\t\tvar rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n\t\t\t\tif (rightLoc !== Location.NONE) {\n\t\t\t\t\tif (rightLoc !== currLoc) throw new TopologyException(\"side location conflict\", e.getCoordinate());\n\t\t\t\t\tif (leftLoc === Location.NONE) {\n\t\t\t\t\t\tAssert.shouldNeverReachHere(\"found single null side (at \" + e.getCoordinate() + \")\");\n\t\t\t\t\t}\n\t\t\t\t\tcurrLoc = leftLoc;\n\t\t\t\t} else {\n\t\t\t\t\tAssert.isTrue(label.getLocation(geomIndex, Position.LEFT) === Location.NONE, \"found single null side\");\n\t\t\t\t\tlabel.setLocation(geomIndex, Position.RIGHT, currLoc);\n\t\t\t\t\tlabel.setLocation(geomIndex, Position.LEFT, currLoc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgetCoordinate() {\n\t\tvar it = this.iterator();\n\t\tif (!it.hasNext()) return null;\n\t\tvar e = it.next();\n\t\treturn e.getCoordinate();\n\t}\n\tprint(out) {\n\t\tSystem.out.println(\"EdgeEndStar:   \" + this.getCoordinate());\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\te.print(out);\n\t\t}\n\t}\n\tisAreaLabelsConsistent(geomGraph) {\n\t\tthis.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());\n\t\treturn this.checkAreaLabelsConsistent(0);\n\t}\n\tcheckAreaLabelsConsistent(geomIndex) {\n\t\tvar edges = this.getEdges();\n\t\tif (edges.size() <= 0) return true;\n\t\tvar lastEdgeIndex = edges.size() - 1;\n\t\tvar startLabel = edges.get(lastEdgeIndex).getLabel();\n\t\tvar startLoc = startLabel.getLocation(geomIndex, Position.LEFT);\n\t\tAssert.isTrue(startLoc !== Location.NONE, \"Found unlabelled area edge\");\n\t\tvar currLoc = startLoc;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tAssert.isTrue(label.isArea(geomIndex), \"Found non-area edge\");\n\t\t\tvar leftLoc = label.getLocation(geomIndex, Position.LEFT);\n\t\t\tvar rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n\t\t\tif (leftLoc === rightLoc) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rightLoc !== currLoc) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcurrLoc = leftLoc;\n\t\t}\n\t\treturn true;\n\t}\n\tfindIndex(eSearch) {\n\t\tthis.iterator();\n\t\tfor (var i = 0; i < this._edgeList.size(); i++) {\n\t\t\tvar e = this._edgeList.get(i);\n\t\t\tif (e === eSearch) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\titerator() {\n\t\treturn this.getEdges().iterator();\n\t}\n\tgetEdges() {\n\t\tif (this._edgeList === null) {\n\t\t\tthis._edgeList = new ArrayList(this._edgeMap.values());\n\t\t}\n\t\treturn this._edgeList;\n\t}\n\tgetLocation(geomIndex, p, geom) {\n\t\tif (this._ptInAreaLocation[geomIndex] === Location.NONE) {\n\t\t\tthis._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());\n\t\t}\n\t\treturn this._ptInAreaLocation[geomIndex];\n\t}\n\ttoString() {\n\t\tvar buf = new StringBuffer();\n\t\tbuf.append(\"EdgeEndStar:   \" + this.getCoordinate());\n\t\tbuf.append(\"\\n\");\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tbuf.append(e);\n\t\t\tbuf.append(\"\\n\");\n\t\t}\n\t\treturn buf.toString();\n\t}\n\tcomputeEdgeEndLabels(boundaryNodeRule) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ee = it.next();\n\t\t\tee.computeLabel(boundaryNodeRule);\n\t\t}\n\t}\n\tcomputeLabelling(geomGraph) {\n\t\tthis.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());\n\t\tthis.propagateSideLabels(0);\n\t\tthis.propagateSideLabels(1);\n\t\tvar hasDimensionalCollapseEdge = [false, false];\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tfor (var geomi = 0; geomi < 2; geomi++) {\n\t\t\t\tif (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) hasDimensionalCollapseEdge[geomi] = true;\n\t\t\t}\n\t\t}\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tfor (var geomi = 0; geomi < 2; geomi++) {\n\t\t\t\tif (label.isAnyNull(geomi)) {\n\t\t\t\t\tvar loc = Location.NONE;\n\t\t\t\t\tif (hasDimensionalCollapseEdge[geomi]) {\n\t\t\t\t\t\tloc = Location.EXTERIOR;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar p = e.getCoordinate();\n\t\t\t\t\t\tloc = this.getLocation(geomi, p, geomGraph);\n\t\t\t\t\t}\n\t\t\t\t\tlabel.setAllLocationsIfNull(geomi, loc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgetDegree() {\n\t\treturn this._edgeMap.size();\n\t}\n\tinsertEdgeEnd(e, obj) {\n\t\tthis._edgeMap.put(e, obj);\n\t\tthis._edgeList = null;\n\t}\n\tgetClass() {\n\t\treturn EdgeEndStar;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdgeEndStar.constructor_ = function () {\n\tthis._edgeMap = new TreeMap();\n\tthis._edgeList = null;\n\tthis._ptInAreaLocation = [Location.NONE, Location.NONE];\n};\n","export default class MonotoneChain {\n\tconstructor() {\n\t\tMonotoneChain.constructor_.apply(this, arguments);\n\t}\n\tcomputeIntersections(mc, si) {\n\t\tthis.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);\n\t}\n\tgetClass() {\n\t\treturn MonotoneChain;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nMonotoneChain.constructor_ = function () {\n\tthis.mce = null;\n\tthis.chainIndex = null;\n\tlet mce = arguments[0], chainIndex = arguments[1];\n\tthis.mce = mce;\n\tthis.chainIndex = chainIndex;\n};\n","import Comparable from '../../../../../java/lang/Comparable';\nexport default class SweepLineEvent {\n\tconstructor() {\n\t\tSweepLineEvent.constructor_.apply(this, arguments);\n\t}\n\tisDelete() {\n\t\treturn this._eventType === SweepLineEvent.DELETE;\n\t}\n\tsetDeleteEventIndex(deleteEventIndex) {\n\t\tthis._deleteEventIndex = deleteEventIndex;\n\t}\n\tgetObject() {\n\t\treturn this._obj;\n\t}\n\tcompareTo(o) {\n\t\tvar pe = o;\n\t\tif (this._xValue < pe._xValue) return -1;\n\t\tif (this._xValue > pe._xValue) return 1;\n\t\tif (this._eventType < pe._eventType) return -1;\n\t\tif (this._eventType > pe._eventType) return 1;\n\t\treturn 0;\n\t}\n\tgetInsertEvent() {\n\t\treturn this._insertEvent;\n\t}\n\tisInsert() {\n\t\treturn this._eventType === SweepLineEvent.INSERT;\n\t}\n\tisSameLabel(ev) {\n\t\tif (this._label === null) return false;\n\t\treturn this._label === ev._label;\n\t}\n\tgetDeleteEventIndex() {\n\t\treturn this._deleteEventIndex;\n\t}\n\tgetClass() {\n\t\treturn SweepLineEvent;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparable];\n\t}\n}\nSweepLineEvent.constructor_ = function () {\n\tthis._label = null;\n\tthis._xValue = null;\n\tthis._eventType = null;\n\tthis._insertEvent = null;\n\tthis._deleteEventIndex = null;\n\tthis._obj = null;\n\tif (arguments.length === 2) {\n\t\tlet x = arguments[0], insertEvent = arguments[1];\n\t\tthis._eventType = SweepLineEvent.DELETE;\n\t\tthis._xValue = x;\n\t\tthis._insertEvent = insertEvent;\n\t} else if (arguments.length === 3) {\n\t\tlet label = arguments[0], x = arguments[1], obj = arguments[2];\n\t\tthis._eventType = SweepLineEvent.INSERT;\n\t\tthis._label = label;\n\t\tthis._xValue = x;\n\t\tthis._obj = obj;\n\t}\n};\nSweepLineEvent.INSERT = 1;\nSweepLineEvent.DELETE = 2;\n","export default class EdgeSetIntersector {\n\tconstructor() {\n\t\tEdgeSetIntersector.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn EdgeSetIntersector;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdgeSetIntersector.constructor_ = function () {};\n","import Arrays from './Arrays'\nimport ArrayList from './ArrayList'\n\nconst Collections = {\n  reverseOrder: function () {\n    return {\n      compare (a, b) {\n        return b.compareTo(a)\n      }\n    }\n  },\n  min: function (l) {\n    Collections.sort(l)\n    return l.get(0)\n  },\n  sort: function (l, c) {\n    const a = l.toArray()\n    if (c) {\n      Arrays.sort(a, c)\n    } else {\n      Arrays.sort(a)\n    }\n    const i = l.iterator()\n    for (let pos = 0, alen = a.length; pos < alen; pos++) {\n      i.next()\n      i.set(a[pos])\n    }\n  },\n  singletonList: function (o) {\n    const arrayList = new ArrayList()\n    arrayList.add(o)\n    return arrayList\n  }\n}\n\nexport default Collections\n","export default class SegmentIntersector {\n\tconstructor() {\n\t\tSegmentIntersector.constructor_.apply(this, arguments);\n\t}\n\tstatic isAdjacentSegments(i1, i2) {\n\t\treturn Math.abs(i1 - i2) === 1;\n\t}\n\tisTrivialIntersection(e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1) {\n\t\t\tif (this._li.getIntersectionNum() === 1) {\n\t\t\t\tif (SegmentIntersector.isAdjacentSegments(segIndex0, segIndex1)) return true;\n\t\t\t\tif (e0.isClosed()) {\n\t\t\t\t\tvar maxSegIndex = e0.getNumPoints() - 1;\n\t\t\t\t\tif (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tgetProperIntersectionPoint() {\n\t\treturn this._properIntersectionPoint;\n\t}\n\tsetIsDoneIfProperInt(isDoneWhenProperInt) {\n\t\tthis._isDoneWhenProperInt = isDoneWhenProperInt;\n\t}\n\thasProperInteriorIntersection() {\n\t\treturn this._hasProperInterior;\n\t}\n\tisBoundaryPointInternal(li, bdyNodes) {\n\t\tfor (var i = bdyNodes.iterator(); i.hasNext(); ) {\n\t\t\tvar node = i.next();\n\t\t\tvar pt = node.getCoordinate();\n\t\t\tif (li.isIntersection(pt)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\thasProperIntersection() {\n\t\treturn this._hasProper;\n\t}\n\thasIntersection() {\n\t\treturn this._hasIntersection;\n\t}\n\tisDone() {\n\t\treturn this._isDone;\n\t}\n\tisBoundaryPoint(li, bdyNodes) {\n\t\tif (bdyNodes === null) return false;\n\t\tif (this.isBoundaryPointInternal(li, bdyNodes[0])) return true;\n\t\tif (this.isBoundaryPointInternal(li, bdyNodes[1])) return true;\n\t\treturn false;\n\t}\n\tsetBoundaryNodes(bdyNodes0, bdyNodes1) {\n\t\tthis._bdyNodes = new Array(2).fill(null);\n\t\tthis._bdyNodes[0] = bdyNodes0;\n\t\tthis._bdyNodes[1] = bdyNodes1;\n\t}\n\taddIntersections(e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n\t\tthis.numTests++;\n\t\tvar p00 = e0.getCoordinates()[segIndex0];\n\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n\t\tvar p10 = e1.getCoordinates()[segIndex1];\n\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n\t\tthis._li.computeIntersection(p00, p01, p10, p11);\n\t\tif (this._li.hasIntersection()) {\n\t\t\tif (this._recordIsolated) {\n\t\t\t\te0.setIsolated(false);\n\t\t\t\te1.setIsolated(false);\n\t\t\t}\n\t\t\tthis._numIntersections++;\n\t\t\tif (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n\t\t\t\tthis._hasIntersection = true;\n\t\t\t\tif (this._includeProper || !this._li.isProper()) {\n\t\t\t\t\te0.addIntersections(this._li, segIndex0, 0);\n\t\t\t\t\te1.addIntersections(this._li, segIndex1, 1);\n\t\t\t\t}\n\t\t\t\tif (this._li.isProper()) {\n\t\t\t\t\tthis._properIntersectionPoint = this._li.getIntersection(0).copy();\n\t\t\t\t\tthis._hasProper = true;\n\t\t\t\t\tif (this._isDoneWhenProperInt) {\n\t\t\t\t\t\tthis._isDone = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!this.isBoundaryPoint(this._li, this._bdyNodes)) this._hasProperInterior = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn SegmentIntersector;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nSegmentIntersector.constructor_ = function () {\n\tthis._hasIntersection = false;\n\tthis._hasProper = false;\n\tthis._hasProperInterior = false;\n\tthis._properIntersectionPoint = null;\n\tthis._li = null;\n\tthis._includeProper = null;\n\tthis._recordIsolated = null;\n\tthis._isSelfIntersection = null;\n\tthis._numIntersections = 0;\n\tthis.numTests = 0;\n\tthis._bdyNodes = null;\n\tthis._isDone = false;\n\tthis._isDoneWhenProperInt = false;\n\tlet li = arguments[0], includeProper = arguments[1], recordIsolated = arguments[2];\n\tthis._li = li;\n\tthis._includeProper = includeProper;\n\tthis._recordIsolated = recordIsolated;\n};\n","import hasInterface from '../../../../../hasInterface';\nimport MonotoneChain from './MonotoneChain';\nimport SweepLineEvent from './SweepLineEvent';\nimport EdgeSetIntersector from './EdgeSetIntersector';\nimport Collections from '../../../../../java/util/Collections';\nimport SegmentIntersector from './SegmentIntersector';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport List from '../../../../../java/util/List';\nexport default class SimpleMCSweepLineIntersector extends EdgeSetIntersector {\n\tconstructor() {\n\t\tsuper();\n\t\tSimpleMCSweepLineIntersector.constructor_.apply(this, arguments);\n\t}\n\tprepareEvents() {\n\t\tCollections.sort(this.events);\n\t\tfor (var i = 0; i < this.events.size(); i++) {\n\t\t\tvar ev = this.events.get(i);\n\t\t\tif (ev.isDelete()) {\n\t\t\t\tev.getInsertEvent().setDeleteEventIndex(i);\n\t\t\t}\n\t\t}\n\t}\n\tcomputeIntersections() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet si = arguments[0];\n\t\t\tthis.nOverlaps = 0;\n\t\t\tthis.prepareEvents();\n\t\t\tfor (var i = 0; i < this.events.size(); i++) {\n\t\t\t\tvar ev = this.events.get(i);\n\t\t\t\tif (ev.isInsert()) {\n\t\t\t\t\tthis.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);\n\t\t\t\t}\n\t\t\t\tif (si.isDone()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (arguments[2] instanceof SegmentIntersector && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {\n\t\t\t\tlet edges0 = arguments[0], edges1 = arguments[1], si = arguments[2];\n\t\t\t\tthis.addEdges(edges0, edges0);\n\t\t\t\tthis.addEdges(edges1, edges1);\n\t\t\t\tthis.computeIntersections(si);\n\t\t\t} else if (typeof arguments[2] === \"boolean\" && (hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector)) {\n\t\t\t\tlet edges = arguments[0], si = arguments[1], testAllSegments = arguments[2];\n\t\t\t\tif (testAllSegments) this.addEdges(edges, null); else this.addEdges(edges);\n\t\t\t\tthis.computeIntersections(si);\n\t\t\t}\n\t\t}\n\t}\n\taddEdge(edge, edgeSet) {\n\t\tvar mce = edge.getMonotoneChainEdge();\n\t\tvar startIndex = mce.getStartIndexes();\n\t\tfor (var i = 0; i < startIndex.length - 1; i++) {\n\t\t\tvar mc = new MonotoneChain(mce, i);\n\t\t\tvar insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);\n\t\t\tthis.events.add(insertEvent);\n\t\t\tthis.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));\n\t\t}\n\t}\n\tprocessOverlaps(start, end, ev0, si) {\n\t\tvar mc0 = ev0.getObject();\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar ev1 = this.events.get(i);\n\t\t\tif (ev1.isInsert()) {\n\t\t\t\tvar mc1 = ev1.getObject();\n\t\t\t\tif (!ev0.isSameLabel(ev1)) {\n\t\t\t\t\tmc0.computeIntersections(mc1, si);\n\t\t\t\t\tthis.nOverlaps++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taddEdges() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet edges = arguments[0];\n\t\t\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\t\t\tvar edge = i.next();\n\t\t\t\tthis.addEdge(edge, edge);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet edges = arguments[0], edgeSet = arguments[1];\n\t\t\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\t\t\tvar edge = i.next();\n\t\t\t\tthis.addEdge(edge, edgeSet);\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn SimpleMCSweepLineIntersector;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nSimpleMCSweepLineIntersector.constructor_ = function () {\n\tthis.events = new ArrayList();\n\tthis.nOverlaps = null;\n};\n","export default class ItemVisitor {\n\tconstructor() {\n\t\tItemVisitor.constructor_.apply(this, arguments);\n\t}\n\tvisitItem(item) {}\n\tgetClass() {\n\t\treturn ItemVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nItemVisitor.constructor_ = function () {};\n","import WKTWriter from '../../io/WKTWriter';\nimport Coordinate from '../../geom/Coordinate';\nimport Double from '../../../../../java/lang/Double';\nimport Comparator from '../../../../../java/util/Comparator';\nexport default class IntervalRTreeNode {\n\tconstructor() {\n\t\tIntervalRTreeNode.constructor_.apply(this, arguments);\n\t}\n\tgetMin() {\n\t\treturn this._min;\n\t}\n\tintersects(queryMin, queryMax) {\n\t\tif (this._min > queryMax || this._max < queryMin) return false;\n\t\treturn true;\n\t}\n\tgetMax() {\n\t\treturn this._max;\n\t}\n\ttoString() {\n\t\treturn WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0));\n\t}\n\tgetClass() {\n\t\treturn IntervalRTreeNode;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nclass NodeComparator {\n\tconstructor() {\n\t\tNodeComparator.constructor_.apply(this, arguments);\n\t}\n\tcompare(o1, o2) {\n\t\tvar n1 = o1;\n\t\tvar n2 = o2;\n\t\tvar mid1 = (n1._min + n1._max) / 2;\n\t\tvar mid2 = (n2._min + n2._max) / 2;\n\t\tif (mid1 < mid2) return -1;\n\t\tif (mid1 > mid2) return 1;\n\t\treturn 0;\n\t}\n\tgetClass() {\n\t\treturn NodeComparator;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparator];\n\t}\n}\nNodeComparator.constructor_ = function () {};\nIntervalRTreeNode.NodeComparator = NodeComparator;\nIntervalRTreeNode.constructor_ = function () {\n\tthis._min = Double.POSITIVE_INFINITY;\n\tthis._max = Double.NEGATIVE_INFINITY;\n};\n","import IntervalRTreeNode from './IntervalRTreeNode';\nexport default class IntervalRTreeLeafNode extends IntervalRTreeNode {\n\tconstructor() {\n\t\tsuper();\n\t\tIntervalRTreeLeafNode.constructor_.apply(this, arguments);\n\t}\n\tquery(queryMin, queryMax, visitor) {\n\t\tif (!this.intersects(queryMin, queryMax)) return null;\n\t\tvisitor.visitItem(this._item);\n\t}\n\tgetClass() {\n\t\treturn IntervalRTreeLeafNode;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nIntervalRTreeLeafNode.constructor_ = function () {\n\tthis._item = null;\n\tlet min = arguments[0], max = arguments[1], item = arguments[2];\n\tthis._min = min;\n\tthis._max = max;\n\tthis._item = item;\n};\n","import IntervalRTreeNode from './IntervalRTreeNode';\nexport default class IntervalRTreeBranchNode extends IntervalRTreeNode {\n\tconstructor() {\n\t\tsuper();\n\t\tIntervalRTreeBranchNode.constructor_.apply(this, arguments);\n\t}\n\tbuildExtent(n1, n2) {\n\t\tthis._min = Math.min(n1._min, n2._min);\n\t\tthis._max = Math.max(n1._max, n2._max);\n\t}\n\tquery(queryMin, queryMax, visitor) {\n\t\tif (!this.intersects(queryMin, queryMax)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this._node1 !== null) this._node1.query(queryMin, queryMax, visitor);\n\t\tif (this._node2 !== null) this._node2.query(queryMin, queryMax, visitor);\n\t}\n\tgetClass() {\n\t\treturn IntervalRTreeBranchNode;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nIntervalRTreeBranchNode.constructor_ = function () {\n\tthis._node1 = null;\n\tthis._node2 = null;\n\tlet n1 = arguments[0], n2 = arguments[1];\n\tthis._node1 = n1;\n\tthis._node2 = n2;\n\tthis.buildExtent(this._node1, this._node2);\n};\n","import WKTWriter from '../../io/WKTWriter';\nimport Coordinate from '../../geom/Coordinate';\nimport IntervalRTreeLeafNode from './IntervalRTreeLeafNode';\nimport IntervalRTreeNode from './IntervalRTreeNode';\nimport Collections from '../../../../../java/util/Collections';\nimport System from '../../../../../java/lang/System';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport IntervalRTreeBranchNode from './IntervalRTreeBranchNode';\nexport default class SortedPackedIntervalRTree {\n\tconstructor() {\n\t\tSortedPackedIntervalRTree.constructor_.apply(this, arguments);\n\t}\n\tbuildTree() {\n\t\tCollections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());\n\t\tvar src = this._leaves;\n\t\tvar temp = null;\n\t\tvar dest = new ArrayList();\n\t\twhile (true) {\n\t\t\tthis.buildLevel(src, dest);\n\t\t\tif (dest.size() === 1) return dest.get(0);\n\t\t\ttemp = src;\n\t\t\tsrc = dest;\n\t\t\tdest = temp;\n\t\t}\n\t}\n\tinsert(min, max, item) {\n\t\tif (this._root !== null) throw new IllegalStateException(\"Index cannot be added to once it has been queried\");\n\t\tthis._leaves.add(new IntervalRTreeLeafNode(min, max, item));\n\t}\n\tquery(min, max, visitor) {\n\t\tthis.init();\n\t\tthis._root.query(min, max, visitor);\n\t}\n\tbuildRoot() {\n\t\tif (this._root !== null) return null;\n\t\tthis._root = this.buildTree();\n\t}\n\tprintNode(node) {\n\t\tSystem.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));\n\t}\n\tinit() {\n\t\tif (this._root !== null) return null;\n\t\tthis.buildRoot();\n\t}\n\tbuildLevel(src, dest) {\n\t\tthis._level++;\n\t\tdest.clear();\n\t\tfor (var i = 0; i < src.size(); i += 2) {\n\t\t\tvar n1 = src.get(i);\n\t\t\tvar n2 = i + 1 < src.size() ? src.get(i) : null;\n\t\t\tif (n2 === null) {\n\t\t\t\tdest.add(n1);\n\t\t\t} else {\n\t\t\t\tvar node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));\n\t\t\t\tdest.add(node);\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn SortedPackedIntervalRTree;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nSortedPackedIntervalRTree.constructor_ = function () {\n\tthis._leaves = new ArrayList();\n\tthis._root = null;\n\tthis._level = 0;\n};\n","import NotRepresentableException from '../algorithm/NotRepresentableException';\nimport Coordinate from './Coordinate';\nimport Double from '../../../../java/lang/Double';\nimport Orientation from '../algorithm/Orientation';\nimport Comparable from '../../../../java/lang/Comparable';\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector';\nimport HCoordinate from '../algorithm/HCoordinate';\nimport Serializable from '../../../../java/io/Serializable';\nimport Distance from '../algorithm/Distance';\nexport default class LineSegment {\n\tconstructor() {\n\t\tLineSegment.constructor_.apply(this, arguments);\n\t}\n\tstatic midPoint(p0, p1) {\n\t\treturn new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);\n\t}\n\tminX() {\n\t\treturn Math.min(this.p0.x, this.p1.x);\n\t}\n\torientationIndex() {\n\t\tif (arguments[0] instanceof LineSegment) {\n\t\t\tlet seg = arguments[0];\n\t\t\tvar orient0 = Orientation.index(this.p0, this.p1, seg.p0);\n\t\t\tvar orient1 = Orientation.index(this.p0, this.p1, seg.p1);\n\t\t\tif (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1);\n\t\t\tif (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1);\n\t\t\treturn 0;\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\treturn Orientation.index(this.p0, this.p1, p);\n\t\t}\n\t}\n\ttoGeometry(geomFactory) {\n\t\treturn geomFactory.createLineString([this.p0, this.p1]);\n\t}\n\tisVertical() {\n\t\treturn this.p0.x === this.p1.x;\n\t}\n\tequals(o) {\n\t\tif (!(o instanceof LineSegment)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar other = o;\n\t\treturn this.p0.equals(other.p0) && this.p1.equals(other.p1);\n\t}\n\tintersection(line) {\n\t\tvar li = new RobustLineIntersector();\n\t\tli.computeIntersection(this.p0, this.p1, line.p0, line.p1);\n\t\tif (li.hasIntersection()) return li.getIntersection(0);\n\t\treturn null;\n\t}\n\tproject() {\n\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\tif (p.equals(this.p0) || p.equals(this.p1)) return new Coordinate(p);\n\t\t\tvar r = this.projectionFactor(p);\n\t\t\tvar coord = new Coordinate();\n\t\t\tcoord.x = this.p0.x + r * (this.p1.x - this.p0.x);\n\t\t\tcoord.y = this.p0.y + r * (this.p1.y - this.p0.y);\n\t\t\treturn coord;\n\t\t} else if (arguments[0] instanceof LineSegment) {\n\t\t\tlet seg = arguments[0];\n\t\t\tvar pf0 = this.projectionFactor(seg.p0);\n\t\t\tvar pf1 = this.projectionFactor(seg.p1);\n\t\t\tif (pf0 >= 1.0 && pf1 >= 1.0) return null;\n\t\t\tif (pf0 <= 0.0 && pf1 <= 0.0) return null;\n\t\t\tvar newp0 = this.project(seg.p0);\n\t\t\tif (pf0 < 0.0) newp0 = this.p0;\n\t\t\tif (pf0 > 1.0) newp0 = this.p1;\n\t\t\tvar newp1 = this.project(seg.p1);\n\t\t\tif (pf1 < 0.0) newp1 = this.p0;\n\t\t\tif (pf1 > 1.0) newp1 = this.p1;\n\t\t\treturn new LineSegment(newp0, newp1);\n\t\t}\n\t}\n\tnormalize() {\n\t\tif (this.p1.compareTo(this.p0) < 0) this.reverse();\n\t}\n\tangle() {\n\t\treturn Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);\n\t}\n\tgetCoordinate(i) {\n\t\tif (i === 0) return this.p0;\n\t\treturn this.p1;\n\t}\n\tdistancePerpendicular(p) {\n\t\treturn Distance.pointToLinePerpendicular(p, this.p0, this.p1);\n\t}\n\tminY() {\n\t\treturn Math.min(this.p0.y, this.p1.y);\n\t}\n\tmidPoint() {\n\t\treturn LineSegment.midPoint(this.p0, this.p1);\n\t}\n\tprojectionFactor(p) {\n\t\tif (p.equals(this.p0)) return 0.0;\n\t\tif (p.equals(this.p1)) return 1.0;\n\t\tvar dx = this.p1.x - this.p0.x;\n\t\tvar dy = this.p1.y - this.p0.y;\n\t\tvar len = dx * dx + dy * dy;\n\t\tif (len <= 0.0) return Double.NaN;\n\t\tvar r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;\n\t\treturn r;\n\t}\n\tclosestPoints(line) {\n\t\tvar intPt = this.intersection(line);\n\t\tif (intPt !== null) {\n\t\t\treturn [intPt, intPt];\n\t\t}\n\t\tvar closestPt = new Array(2).fill(null);\n\t\tvar minDistance = Double.MAX_VALUE;\n\t\tvar dist = null;\n\t\tvar close00 = this.closestPoint(line.p0);\n\t\tminDistance = close00.distance(line.p0);\n\t\tclosestPt[0] = close00;\n\t\tclosestPt[1] = line.p0;\n\t\tvar close01 = this.closestPoint(line.p1);\n\t\tdist = close01.distance(line.p1);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t\tclosestPt[0] = close01;\n\t\t\tclosestPt[1] = line.p1;\n\t\t}\n\t\tvar close10 = line.closestPoint(this.p0);\n\t\tdist = close10.distance(this.p0);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t\tclosestPt[0] = this.p0;\n\t\t\tclosestPt[1] = close10;\n\t\t}\n\t\tvar close11 = line.closestPoint(this.p1);\n\t\tdist = close11.distance(this.p1);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t\tclosestPt[0] = this.p1;\n\t\t\tclosestPt[1] = close11;\n\t\t}\n\t\treturn closestPt;\n\t}\n\tclosestPoint(p) {\n\t\tvar factor = this.projectionFactor(p);\n\t\tif (factor > 0 && factor < 1) {\n\t\t\treturn this.project(p);\n\t\t}\n\t\tvar dist0 = this.p0.distance(p);\n\t\tvar dist1 = this.p1.distance(p);\n\t\tif (dist0 < dist1) return this.p0;\n\t\treturn this.p1;\n\t}\n\tmaxX() {\n\t\treturn Math.max(this.p0.x, this.p1.x);\n\t}\n\tgetLength() {\n\t\treturn this.p0.distance(this.p1);\n\t}\n\tcompareTo(o) {\n\t\tvar other = o;\n\t\tvar comp0 = this.p0.compareTo(other.p0);\n\t\tif (comp0 !== 0) return comp0;\n\t\treturn this.p1.compareTo(other.p1);\n\t}\n\treverse() {\n\t\tvar temp = this.p0;\n\t\tthis.p0 = this.p1;\n\t\tthis.p1 = temp;\n\t}\n\tequalsTopo(other) {\n\t\treturn this.p0.equals(other.p0) && this.p1.equals(other.p1) || this.p0.equals(other.p1) && this.p1.equals(other.p0);\n\t}\n\tlineIntersection(line) {\n\t\ttry {\n\t\t\tvar intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);\n\t\t\treturn intPt;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof NotRepresentableException) {} else throw ex;\n\t\t} finally {}\n\t\treturn null;\n\t}\n\tmaxY() {\n\t\treturn Math.max(this.p0.y, this.p1.y);\n\t}\n\tpointAlongOffset(segmentLengthFraction, offsetDistance) {\n\t\tvar segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n\t\tvar segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n\t\tvar dx = this.p1.x - this.p0.x;\n\t\tvar dy = this.p1.y - this.p0.y;\n\t\tvar len = Math.sqrt(dx * dx + dy * dy);\n\t\tvar ux = 0.0;\n\t\tvar uy = 0.0;\n\t\tif (offsetDistance !== 0.0) {\n\t\t\tif (len <= 0.0) throw new IllegalStateException(\"Cannot compute offset from zero-length line segment\");\n\t\t\tux = offsetDistance * dx / len;\n\t\t\tuy = offsetDistance * dy / len;\n\t\t}\n\t\tvar offsetx = segx - uy;\n\t\tvar offsety = segy + ux;\n\t\tvar coord = new Coordinate(offsetx, offsety);\n\t\treturn coord;\n\t}\n\tsetCoordinates() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet ls = arguments[0];\n\t\t\tthis.setCoordinates(ls.p0, ls.p1);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\t\tthis.p0.x = p0.x;\n\t\t\tthis.p0.y = p0.y;\n\t\t\tthis.p1.x = p1.x;\n\t\t\tthis.p1.y = p1.y;\n\t\t}\n\t}\n\tsegmentFraction(inputPt) {\n\t\tvar segFrac = this.projectionFactor(inputPt);\n\t\tif (segFrac < 0.0) segFrac = 0.0; else if (segFrac > 1.0 || Double.isNaN(segFrac)) segFrac = 1.0;\n\t\treturn segFrac;\n\t}\n\ttoString() {\n\t\treturn \"LINESTRING( \" + this.p0.x + \" \" + this.p0.y + \", \" + this.p1.x + \" \" + this.p1.y + \")\";\n\t}\n\tisHorizontal() {\n\t\treturn this.p0.y === this.p1.y;\n\t}\n\tdistance() {\n\t\tif (arguments[0] instanceof LineSegment) {\n\t\t\tlet ls = arguments[0];\n\t\t\treturn Distance.segmentToSegment(this.p0, this.p1, ls.p0, ls.p1);\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\treturn Distance.pointToSegment(p, this.p0, this.p1);\n\t\t}\n\t}\n\tpointAlong(segmentLengthFraction) {\n\t\tvar coord = new Coordinate();\n\t\tcoord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n\t\tcoord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n\t\treturn coord;\n\t}\n\thashCode() {\n\t\tvar bits0 = java.lang.Double.doubleToLongBits(this.p0.x);\n\t\tbits0 ^= java.lang.Double.doubleToLongBits(this.p0.y) * 31;\n\t\tvar hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);\n\t\tvar bits1 = java.lang.Double.doubleToLongBits(this.p1.x);\n\t\tbits1 ^= java.lang.Double.doubleToLongBits(this.p1.y) * 31;\n\t\tvar hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);\n\t\treturn hash0 ^ hash1;\n\t}\n\tgetClass() {\n\t\treturn LineSegment;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparable, Serializable];\n\t}\n}\nLineSegment.constructor_ = function () {\n\tthis.p0 = null;\n\tthis.p1 = null;\n\tif (arguments.length === 0) {\n\t\tLineSegment.constructor_.call(this, new Coordinate(), new Coordinate());\n\t} else if (arguments.length === 1) {\n\t\tlet ls = arguments[0];\n\t\tLineSegment.constructor_.call(this, ls.p0, ls.p1);\n\t} else if (arguments.length === 2) {\n\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\tthis.p0 = p0;\n\t\tthis.p1 = p1;\n\t} else if (arguments.length === 4) {\n\t\tlet x0 = arguments[0], y0 = arguments[1], x1 = arguments[2], y1 = arguments[3];\n\t\tLineSegment.constructor_.call(this, new Coordinate(x0, y0), new Coordinate(x1, y1));\n\t}\n};\nLineSegment.serialVersionUID = 3252005833466256227;\n","import LineString from '../LineString';\nimport Geometry from '../Geometry';\nimport hasInterface from '../../../../../hasInterface';\nimport Collection from '../../../../../java/util/Collection';\nimport LinearRing from '../LinearRing';\nimport GeometryComponentFilter from '../GeometryComponentFilter';\nimport ArrayList from '../../../../../java/util/ArrayList';\nexport default class LinearComponentExtracter {\n\tconstructor() {\n\t\tLinearComponentExtracter.constructor_.apply(this, arguments);\n\t}\n\tstatic getGeometry() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet geom = arguments[0];\n\t\t\treturn geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet geom = arguments[0], forceToLineString = arguments[1];\n\t\t\treturn geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom, forceToLineString));\n\t\t}\n\t}\n\tstatic getLines() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet geom = arguments[0];\n\t\t\treturn LinearComponentExtracter.getLines(geom, false);\n\t\t} else if (arguments.length === 2) {\n\t\t\tif (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n\t\t\t\tlet geoms = arguments[0], lines = arguments[1];\n\t\t\t\tfor (var i = geoms.iterator(); i.hasNext(); ) {\n\t\t\t\t\tvar g = i.next();\n\t\t\t\t\tLinearComponentExtracter.getLines(g, lines);\n\t\t\t\t}\n\t\t\t\treturn lines;\n\t\t\t} else if (arguments[0] instanceof Geometry && typeof arguments[1] === \"boolean\") {\n\t\t\t\tlet geom = arguments[0], forceToLineString = arguments[1];\n\t\t\t\tvar lines = new ArrayList();\n\t\t\t\tgeom.apply(new LinearComponentExtracter(lines, forceToLineString));\n\t\t\t\treturn lines;\n\t\t\t} else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n\t\t\t\tlet geom = arguments[0], lines = arguments[1];\n\t\t\t\tif (geom instanceof LineString) {\n\t\t\t\t\tlines.add(geom);\n\t\t\t\t} else {\n\t\t\t\t\tgeom.apply(new LinearComponentExtracter(lines));\n\t\t\t\t}\n\t\t\t\treturn lines;\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (typeof arguments[2] === \"boolean\" && (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection))) {\n\t\t\t\tlet geoms = arguments[0], lines = arguments[1], forceToLineString = arguments[2];\n\t\t\t\tfor (var i = geoms.iterator(); i.hasNext(); ) {\n\t\t\t\t\tvar g = i.next();\n\t\t\t\t\tLinearComponentExtracter.getLines(g, lines, forceToLineString);\n\t\t\t\t}\n\t\t\t\treturn lines;\n\t\t\t} else if (typeof arguments[2] === \"boolean\" && (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection))) {\n\t\t\t\tlet geom = arguments[0], lines = arguments[1], forceToLineString = arguments[2];\n\t\t\t\tgeom.apply(new LinearComponentExtracter(lines, forceToLineString));\n\t\t\t\treturn lines;\n\t\t\t}\n\t\t}\n\t}\n\tfilter(geom) {\n\t\tif (this._isForcedToLineString && geom instanceof LinearRing) {\n\t\t\tvar line = geom.getFactory().createLineString(geom.getCoordinateSequence());\n\t\t\tthis._lines.add(line);\n\t\t\treturn null;\n\t\t}\n\t\tif (geom instanceof LineString) this._lines.add(geom);\n\t}\n\tsetForceToLineString(isForcedToLineString) {\n\t\tthis._isForcedToLineString = isForcedToLineString;\n\t}\n\tgetClass() {\n\t\treturn LinearComponentExtracter;\n\t}\n\tget interfaces_() {\n\t\treturn [GeometryComponentFilter];\n\t}\n}\nLinearComponentExtracter.constructor_ = function () {\n\tthis._lines = null;\n\tthis._isForcedToLineString = false;\n\tif (arguments.length === 1) {\n\t\tlet lines = arguments[0];\n\t\tthis._lines = lines;\n\t} else if (arguments.length === 2) {\n\t\tlet lines = arguments[0], isForcedToLineString = arguments[1];\n\t\tthis._lines = lines;\n\t\tthis._isForcedToLineString = isForcedToLineString;\n\t}\n};\n","import ItemVisitor from './ItemVisitor';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default class ArrayListVisitor {\n\tconstructor() {\n\t\tArrayListVisitor.constructor_.apply(this, arguments);\n\t}\n\tvisitItem(item) {\n\t\tthis._items.add(item);\n\t}\n\tgetItems() {\n\t\treturn this._items;\n\t}\n\tgetClass() {\n\t\treturn ArrayListVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [ItemVisitor];\n\t}\n}\nArrayListVisitor.constructor_ = function () {\n\tthis._items = new ArrayList();\n};\n","import hasInterface from '../../../../../hasInterface';\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport ItemVisitor from '../../index/ItemVisitor';\nimport PointOnGeometryLocator from './PointOnGeometryLocator';\nimport LinearRing from '../../geom/LinearRing';\nimport SortedPackedIntervalRTree from '../../index/intervalrtree/SortedPackedIntervalRTree';\nimport LineSegment from '../../geom/LineSegment';\nimport Polygonal from '../../geom/Polygonal';\nimport LinearComponentExtracter from '../../geom/util/LinearComponentExtracter';\nimport ArrayListVisitor from '../../index/ArrayListVisitor';\nimport RayCrossingCounter from '../RayCrossingCounter';\nexport default class IndexedPointInAreaLocator {\n\tconstructor() {\n\t\tIndexedPointInAreaLocator.constructor_.apply(this, arguments);\n\t}\n\tlocate(p) {\n\t\tvar rcc = new RayCrossingCounter(p);\n\t\tvar visitor = new SegmentVisitor(rcc);\n\t\tthis._index.query(p.y, p.y, visitor);\n\t\treturn rcc.getLocation();\n\t}\n\tgetClass() {\n\t\treturn IndexedPointInAreaLocator;\n\t}\n\tget interfaces_() {\n\t\treturn [PointOnGeometryLocator];\n\t}\n}\nclass SegmentVisitor {\n\tconstructor() {\n\t\tSegmentVisitor.constructor_.apply(this, arguments);\n\t}\n\tvisitItem(item) {\n\t\tvar seg = item;\n\t\tthis._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));\n\t}\n\tgetClass() {\n\t\treturn SegmentVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [ItemVisitor];\n\t}\n}\nSegmentVisitor.constructor_ = function () {\n\tthis._counter = null;\n\tlet counter = arguments[0];\n\tthis._counter = counter;\n};\nclass IntervalIndexedGeometry {\n\tconstructor() {\n\t\tIntervalIndexedGeometry.constructor_.apply(this, arguments);\n\t}\n\tinit(geom) {\n\t\tvar lines = LinearComponentExtracter.getLines(geom);\n\t\tfor (var i = lines.iterator(); i.hasNext(); ) {\n\t\t\tvar line = i.next();\n\t\t\tvar pts = line.getCoordinates();\n\t\t\tthis.addLine(pts);\n\t\t}\n\t}\n\taddLine(pts) {\n\t\tfor (var i = 1; i < pts.length; i++) {\n\t\t\tvar seg = new LineSegment(pts[i - 1], pts[i]);\n\t\t\tvar min = Math.min(seg.p0.y, seg.p1.y);\n\t\t\tvar max = Math.max(seg.p0.y, seg.p1.y);\n\t\t\tthis._index.insert(min, max, seg);\n\t\t}\n\t}\n\tquery() {\n\t\tif (arguments.length === 2) {\n\t\t\tlet min = arguments[0], max = arguments[1];\n\t\t\tvar visitor = new ArrayListVisitor();\n\t\t\tthis._index.query(min, max, visitor);\n\t\t\treturn visitor.getItems();\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet min = arguments[0], max = arguments[1], visitor = arguments[2];\n\t\t\tthis._index.query(min, max, visitor);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn IntervalIndexedGeometry;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nIntervalIndexedGeometry.constructor_ = function () {\n\tthis._index = new SortedPackedIntervalRTree();\n\tlet geom = arguments[0];\n\tthis.init(geom);\n};\nIndexedPointInAreaLocator.SegmentVisitor = SegmentVisitor;\nIndexedPointInAreaLocator.IntervalIndexedGeometry = IntervalIndexedGeometry;\nIndexedPointInAreaLocator.constructor_ = function () {\n\tthis._index = null;\n\tlet g = arguments[0];\n\tif (!(hasInterface(g, Polygonal) || g instanceof LinearRing)) throw new IllegalArgumentException(\"Argument must be Polygonal or LinearRing\");\n\tthis._index = new IntervalIndexedGeometry(g);\n};\n","import Coordinate from '../geom/Coordinate';\nimport Comparable from '../../../../java/lang/Comparable';\nexport default class EdgeIntersection {\n\tconstructor() {\n\t\tEdgeIntersection.constructor_.apply(this, arguments);\n\t}\n\tgetSegmentIndex() {\n\t\treturn this.segmentIndex;\n\t}\n\tgetCoordinate() {\n\t\treturn this.coord;\n\t}\n\tprint(out) {\n\t\tout.print(this.coord);\n\t\tout.print(\" seg # = \" + this.segmentIndex);\n\t\tout.println(\" dist = \" + this.dist);\n\t}\n\tcompareTo(obj) {\n\t\tvar other = obj;\n\t\treturn this.compare(other.segmentIndex, other.dist);\n\t}\n\tisEndPoint(maxSegmentIndex) {\n\t\tif (this.segmentIndex === 0 && this.dist === 0.0) return true;\n\t\tif (this.segmentIndex === maxSegmentIndex) return true;\n\t\treturn false;\n\t}\n\ttoString() {\n\t\treturn this.coord + \" seg # = \" + this.segmentIndex + \" dist = \" + this.dist;\n\t}\n\tgetDistance() {\n\t\treturn this.dist;\n\t}\n\tcompare(segmentIndex, dist) {\n\t\tif (this.segmentIndex < segmentIndex) return -1;\n\t\tif (this.segmentIndex > segmentIndex) return 1;\n\t\tif (this.dist < dist) return -1;\n\t\tif (this.dist > dist) return 1;\n\t\treturn 0;\n\t}\n\tgetClass() {\n\t\treturn EdgeIntersection;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparable];\n\t}\n}\nEdgeIntersection.constructor_ = function () {\n\tthis.coord = null;\n\tthis.segmentIndex = null;\n\tthis.dist = null;\n\tlet coord = arguments[0], segmentIndex = arguments[1], dist = arguments[2];\n\tthis.coord = new Coordinate(coord);\n\tthis.segmentIndex = segmentIndex;\n\tthis.dist = dist;\n};\n","import EdgeIntersection from './EdgeIntersection';\nimport Coordinate from '../geom/Coordinate';\nimport Label from './Label';\nimport Edge from './Edge';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default class EdgeIntersectionList {\n\tconstructor() {\n\t\tEdgeIntersectionList.constructor_.apply(this, arguments);\n\t}\n\tprint(out) {\n\t\tout.println(\"Intersections:\");\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ei = it.next();\n\t\t\tei.print(out);\n\t\t}\n\t}\n\titerator() {\n\t\treturn this._nodeMap.values().iterator();\n\t}\n\taddSplitEdges(edgeList) {\n\t\tthis.addEndpoints();\n\t\tvar it = this.iterator();\n\t\tvar eiPrev = it.next();\n\t\twhile (it.hasNext()) {\n\t\t\tvar ei = it.next();\n\t\t\tvar newEdge = this.createSplitEdge(eiPrev, ei);\n\t\t\tedgeList.add(newEdge);\n\t\t\teiPrev = ei;\n\t\t}\n\t}\n\taddEndpoints() {\n\t\tvar maxSegIndex = this.edge.pts.length - 1;\n\t\tthis.add(this.edge.pts[0], 0, 0.0);\n\t\tthis.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);\n\t}\n\tcreateSplitEdge(ei0, ei1) {\n\t\tvar npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n\t\tvar lastSegStartPt = this.edge.pts[ei1.segmentIndex];\n\t\tvar useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);\n\t\tif (!useIntPt1) {\n\t\t\tnpts--;\n\t\t}\n\t\tvar pts = new Array(npts).fill(null);\n\t\tvar ipt = 0;\n\t\tpts[ipt++] = new Coordinate(ei0.coord);\n\t\tfor (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n\t\t\tpts[ipt++] = this.edge.pts[i];\n\t\t}\n\t\tif (useIntPt1) pts[ipt] = ei1.coord;\n\t\treturn new Edge(pts, new Label(this.edge._label));\n\t}\n\tadd(intPt, segmentIndex, dist) {\n\t\tvar eiNew = new EdgeIntersection(intPt, segmentIndex, dist);\n\t\tvar ei = this._nodeMap.get(eiNew);\n\t\tif (ei !== null) {\n\t\t\treturn ei;\n\t\t}\n\t\tthis._nodeMap.put(eiNew, eiNew);\n\t\treturn eiNew;\n\t}\n\tisIntersection(pt) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ei = it.next();\n\t\t\tif (ei.coord.equals(pt)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\tgetClass() {\n\t\treturn EdgeIntersectionList;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdgeIntersectionList.constructor_ = function () {\n\tthis._nodeMap = new TreeMap();\n\tthis.edge = null;\n\tlet edge = arguments[0];\n\tthis.edge = edge;\n};\n","import Integer from '../../../../../java/lang/Integer';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Quadrant from '../Quadrant';\nexport default class MonotoneChainIndexer {\n\tconstructor() {\n\t\tMonotoneChainIndexer.constructor_.apply(this, arguments);\n\t}\n\tstatic toIntArray(list) {\n\t\tvar array = new Array(list.size()).fill(null);\n\t\tfor (var i = 0; i < array.length; i++) {\n\t\t\tarray[i] = list.get(i).intValue();\n\t\t}\n\t\treturn array;\n\t}\n\tgetChainStartIndices(pts) {\n\t\tvar start = 0;\n\t\tvar startIndexList = new ArrayList();\n\t\tstartIndexList.add(new Integer(start));\n\t\tdo {\n\t\t\tvar last = this.findChainEnd(pts, start);\n\t\t\tstartIndexList.add(new Integer(last));\n\t\t\tstart = last;\n\t\t} while (start < pts.length - 1);\n\t\tvar startIndex = MonotoneChainIndexer.toIntArray(startIndexList);\n\t\treturn startIndex;\n\t}\n\tfindChainEnd(pts, start) {\n\t\tvar chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);\n\t\tvar last = start + 1;\n\t\twhile (last < pts.length) {\n\t\t\tvar quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n\t\t\tif (quad !== chainQuad) break;\n\t\t\tlast++;\n\t\t}\n\t\treturn last - 1;\n\t}\n\tgetClass() {\n\t\treturn MonotoneChainIndexer;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nMonotoneChainIndexer.constructor_ = function () {};\n","import MonotoneChainIndexer from './MonotoneChainIndexer';\nimport Envelope from '../../geom/Envelope';\nexport default class MonotoneChainEdge {\n\tconstructor() {\n\t\tMonotoneChainEdge.constructor_.apply(this, arguments);\n\t}\n\tgetCoordinates() {\n\t\treturn this.pts;\n\t}\n\tgetMaxX(chainIndex) {\n\t\tvar x1 = this.pts[this.startIndex[chainIndex]].x;\n\t\tvar x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n\t\treturn x1 > x2 ? x1 : x2;\n\t}\n\tgetMinX(chainIndex) {\n\t\tvar x1 = this.pts[this.startIndex[chainIndex]].x;\n\t\tvar x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n\t\treturn x1 < x2 ? x1 : x2;\n\t}\n\tcomputeIntersectsForChain() {\n\t\tif (arguments.length === 4) {\n\t\t\tlet chainIndex0 = arguments[0], mce = arguments[1], chainIndex1 = arguments[2], si = arguments[3];\n\t\t\tthis.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);\n\t\t} else if (arguments.length === 6) {\n\t\t\tlet start0 = arguments[0], end0 = arguments[1], mce = arguments[2], start1 = arguments[3], end1 = arguments[4], ei = arguments[5];\n\t\t\tif (end0 - start0 === 1 && end1 - start1 === 1) {\n\t\t\t\tei.addIntersections(this.e, start0, mce.e, start1);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!this.overlaps(start0, end0, mce, start1, end1)) return null;\n\t\t\tvar mid0 = Math.trunc((start0 + end0) / 2);\n\t\t\tvar mid1 = Math.trunc((start1 + end1) / 2);\n\t\t\tif (start0 < mid0) {\n\t\t\t\tif (start1 < mid1) this.computeIntersectsForChain(start0, mid0, mce, start1, mid1, ei);\n\t\t\t\tif (mid1 < end1) this.computeIntersectsForChain(start0, mid0, mce, mid1, end1, ei);\n\t\t\t}\n\t\t\tif (mid0 < end0) {\n\t\t\t\tif (start1 < mid1) this.computeIntersectsForChain(mid0, end0, mce, start1, mid1, ei);\n\t\t\t\tif (mid1 < end1) this.computeIntersectsForChain(mid0, end0, mce, mid1, end1, ei);\n\t\t\t}\n\t\t}\n\t}\n\toverlaps(start0, end0, mce, start1, end1) {\n\t\treturn Envelope.intersects(this.pts[start0], this.pts[end0], mce.pts[start1], mce.pts[end1]);\n\t}\n\tgetStartIndexes() {\n\t\treturn this.startIndex;\n\t}\n\tcomputeIntersects(mce, si) {\n\t\tfor (var i = 0; i < this.startIndex.length - 1; i++) {\n\t\t\tfor (var j = 0; j < mce.startIndex.length - 1; j++) {\n\t\t\t\tthis.computeIntersectsForChain(i, mce, j, si);\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn MonotoneChainEdge;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nMonotoneChainEdge.constructor_ = function () {\n\tthis.e = null;\n\tthis.pts = null;\n\tthis.startIndex = null;\n\tlet e = arguments[0];\n\tthis.e = e;\n\tthis.pts = e.getCoordinates();\n\tvar mcb = new MonotoneChainIndexer();\n\tthis.startIndex = mcb.getChainStartIndices(this.pts);\n};\n","import Location from '../geom/Location';\nimport Position from './Position';\nexport default class Depth {\n\tconstructor() {\n\t\tDepth.constructor_.apply(this, arguments);\n\t}\n\tstatic depthAtLocation(location) {\n\t\tif (location === Location.EXTERIOR) return 0;\n\t\tif (location === Location.INTERIOR) return 1;\n\t\treturn Depth.NULL_VALUE;\n\t}\n\tgetDepth(geomIndex, posIndex) {\n\t\treturn this._depth[geomIndex][posIndex];\n\t}\n\tsetDepth(geomIndex, posIndex, depthValue) {\n\t\tthis._depth[geomIndex][posIndex] = depthValue;\n\t}\n\tisNull() {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tfor (var j = 0; j < 3; j++) {\n\t\t\t\t\tif (this._depth[i][j] !== Depth.NULL_VALUE) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet geomIndex = arguments[0];\n\t\t\treturn this._depth[geomIndex][1] === Depth.NULL_VALUE;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1];\n\t\t\treturn this._depth[geomIndex][posIndex] === Depth.NULL_VALUE;\n\t\t}\n\t}\n\tnormalize() {\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (!this.isNull(i)) {\n\t\t\t\tvar minDepth = this._depth[i][1];\n\t\t\t\tif (this._depth[i][2] < minDepth) minDepth = this._depth[i][2];\n\t\t\t\tif (minDepth < 0) minDepth = 0;\n\t\t\t\tfor (var j = 1; j < 3; j++) {\n\t\t\t\t\tvar newValue = 0;\n\t\t\t\t\tif (this._depth[i][j] > minDepth) newValue = 1;\n\t\t\t\t\tthis._depth[i][j] = newValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgetDelta(geomIndex) {\n\t\treturn this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT];\n\t}\n\tgetLocation(geomIndex, posIndex) {\n\t\tif (this._depth[geomIndex][posIndex] <= 0) return Location.EXTERIOR;\n\t\treturn Location.INTERIOR;\n\t}\n\ttoString() {\n\t\treturn \"A: \" + this._depth[0][1] + \",\" + this._depth[0][2] + \" B: \" + this._depth[1][1] + \",\" + this._depth[1][2];\n\t}\n\tadd() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet lbl = arguments[0];\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tfor (var j = 1; j < 3; j++) {\n\t\t\t\t\tvar loc = lbl.getLocation(i, j);\n\t\t\t\t\tif (loc === Location.EXTERIOR || loc === Location.INTERIOR) {\n\t\t\t\t\t\tif (this.isNull(i, j)) {\n\t\t\t\t\t\t\tthis._depth[i][j] = Depth.depthAtLocation(loc);\n\t\t\t\t\t\t} else this._depth[i][j] += Depth.depthAtLocation(loc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2];\n\t\t\tif (location === Location.INTERIOR) this._depth[geomIndex][posIndex]++;\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn Depth;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nDepth.constructor_ = function () {\n\tthis._depth = Array(2).fill().map(() => Array(3));\n\tfor (var i = 0; i < 2; i++) {\n\t\tfor (var j = 0; j < 3; j++) {\n\t\t\tthis._depth[i][j] = Depth.NULL_VALUE;\n\t\t}\n\t}\n};\nDepth.NULL_VALUE = -1;\n","import EdgeIntersectionList from './EdgeIntersectionList';\nimport IntersectionMatrix from '../geom/IntersectionMatrix';\nimport MonotoneChainEdge from './index/MonotoneChainEdge';\nimport Position from './Position';\nimport Coordinate from '../geom/Coordinate';\nimport Label from './Label';\nimport Envelope from '../geom/Envelope';\nimport StringBuilder from '../../../../java/lang/StringBuilder';\nimport Depth from './Depth';\nimport GraphComponent from './GraphComponent';\nexport default class Edge extends GraphComponent {\n\tconstructor() {\n\t\tsuper();\n\t\tEdge.constructor_.apply(this, arguments);\n\t}\n\tstatic updateIM() {\n\t\tif (arguments.length === 2 && (arguments[1] instanceof IntersectionMatrix && arguments[0] instanceof Label)) {\n\t\t\tlet label = arguments[0], im = arguments[1];\n\t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);\n\t\t\tif (label.isArea()) {\n\t\t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);\n\t\t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);\n\t\t\t}\n\t\t} else return super.updateIM.apply(this, arguments);\n\t}\n\tgetDepth() {\n\t\treturn this._depth;\n\t}\n\tgetCollapsedEdge() {\n\t\tvar newPts = new Array(2).fill(null);\n\t\tnewPts[0] = this.pts[0];\n\t\tnewPts[1] = this.pts[1];\n\t\tvar newe = new Edge(newPts, Label.toLineLabel(this._label));\n\t\treturn newe;\n\t}\n\tisIsolated() {\n\t\treturn this._isIsolated;\n\t}\n\tgetCoordinates() {\n\t\treturn this.pts;\n\t}\n\tsetIsolated(isIsolated) {\n\t\tthis._isIsolated = isIsolated;\n\t}\n\tsetName(name) {\n\t\tthis._name = name;\n\t}\n\tequals(o) {\n\t\tif (!(o instanceof Edge)) return false;\n\t\tvar e = o;\n\t\tif (this.pts.length !== e.pts.length) return false;\n\t\tvar isEqualForward = true;\n\t\tvar isEqualReverse = true;\n\t\tvar iRev = this.pts.length;\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (!this.pts[i].equals2D(e.pts[i])) {\n\t\t\t\tisEqualForward = false;\n\t\t\t}\n\t\t\tif (!this.pts[i].equals2D(e.pts[-- iRev])) {\n\t\t\t\tisEqualReverse = false;\n\t\t\t}\n\t\t\tif (!isEqualForward && !isEqualReverse) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tgetCoordinate() {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.pts.length > 0) return this.pts[0];\n\t\t\treturn null;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet i = arguments[0];\n\t\t\treturn this.pts[i];\n\t\t}\n\t}\n\tprint(out) {\n\t\tout.print(\"edge \" + this._name + \": \");\n\t\tout.print(\"LINESTRING (\");\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (i > 0) out.print(\",\");\n\t\t\tout.print(this.pts[i].x + \" \" + this.pts[i].y);\n\t\t}\n\t\tout.print(\")  \" + this._label + \" \" + this._depthDelta);\n\t}\n\tcomputeIM(im) {\n\t\tEdge.updateIM(this._label, im);\n\t}\n\tisCollapsed() {\n\t\tif (!this._label.isArea()) return false;\n\t\tif (this.pts.length !== 3) return false;\n\t\tif (this.pts[0].equals(this.pts[2])) return true;\n\t\treturn false;\n\t}\n\tisClosed() {\n\t\treturn this.pts[0].equals(this.pts[this.pts.length - 1]);\n\t}\n\tgetMaximumSegmentIndex() {\n\t\treturn this.pts.length - 1;\n\t}\n\tgetDepthDelta() {\n\t\treturn this._depthDelta;\n\t}\n\tgetNumPoints() {\n\t\treturn this.pts.length;\n\t}\n\tprintReverse(out) {\n\t\tout.print(\"edge \" + this._name + \": \");\n\t\tfor (var i = this.pts.length - 1; i >= 0; i--) {\n\t\t\tout.print(this.pts[i] + \" \");\n\t\t}\n\t\tout.println(\"\");\n\t}\n\tgetMonotoneChainEdge() {\n\t\tif (this._mce === null) this._mce = new MonotoneChainEdge(this);\n\t\treturn this._mce;\n\t}\n\tgetEnvelope() {\n\t\tif (this._env === null) {\n\t\t\tthis._env = new Envelope();\n\t\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\t\tthis._env.expandToInclude(this.pts[i]);\n\t\t\t}\n\t\t}\n\t\treturn this._env;\n\t}\n\taddIntersection(li, segmentIndex, geomIndex, intIndex) {\n\t\tvar intPt = new Coordinate(li.getIntersection(intIndex));\n\t\tvar normalizedSegmentIndex = segmentIndex;\n\t\tvar dist = li.getEdgeDistance(geomIndex, intIndex);\n\t\tvar nextSegIndex = normalizedSegmentIndex + 1;\n\t\tif (nextSegIndex < this.pts.length) {\n\t\t\tvar nextPt = this.pts[nextSegIndex];\n\t\t\tif (intPt.equals2D(nextPt)) {\n\t\t\t\tnormalizedSegmentIndex = nextSegIndex;\n\t\t\t\tdist = 0.0;\n\t\t\t}\n\t\t}\n\t\tvar ei = this.eiList.add(intPt, normalizedSegmentIndex, dist);\n\t}\n\ttoString() {\n\t\tvar builder = new StringBuilder();\n\t\tbuilder.append(\"edge \" + this._name + \": \");\n\t\tbuilder.append(\"LINESTRING (\");\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (i > 0) builder.append(\",\");\n\t\t\tbuilder.append(this.pts[i].x + \" \" + this.pts[i].y);\n\t\t}\n\t\tbuilder.append(\")  \" + this._label + \" \" + this._depthDelta);\n\t\treturn builder.toString();\n\t}\n\tisPointwiseEqual(e) {\n\t\tif (this.pts.length !== e.pts.length) return false;\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (!this.pts[i].equals2D(e.pts[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tsetDepthDelta(depthDelta) {\n\t\tthis._depthDelta = depthDelta;\n\t}\n\tgetEdgeIntersectionList() {\n\t\treturn this.eiList;\n\t}\n\taddIntersections(li, segmentIndex, geomIndex) {\n\t\tfor (var i = 0; i < li.getIntersectionNum(); i++) {\n\t\t\tthis.addIntersection(li, segmentIndex, geomIndex, i);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn Edge;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdge.constructor_ = function () {\n\tthis.pts = null;\n\tthis._env = null;\n\tthis.eiList = new EdgeIntersectionList(this);\n\tthis._name = null;\n\tthis._mce = null;\n\tthis._isIsolated = true;\n\tthis._depth = new Depth();\n\tthis._depthDelta = 0;\n\tif (arguments.length === 1) {\n\t\tlet pts = arguments[0];\n\t\tEdge.constructor_.call(this, pts, null);\n\t} else if (arguments.length === 2) {\n\t\tlet pts = arguments[0], label = arguments[1];\n\t\tthis.pts = pts;\n\t\tthis._label = label;\n\t}\n};\n","import Location from '../geom/Location';\nimport EdgeEnd from './EdgeEnd';\nimport Position from './Position';\nimport TopologyException from '../geom/TopologyException';\nimport Label from './Label';\nexport default class DirectedEdge extends EdgeEnd {\n\tconstructor() {\n\t\tsuper();\n\t\tDirectedEdge.constructor_.apply(this, arguments);\n\t}\n\tstatic depthFactor(currLocation, nextLocation) {\n\t\tif (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) return 1; else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) return -1;\n\t\treturn 0;\n\t}\n\tgetNextMin() {\n\t\treturn this._nextMin;\n\t}\n\tgetDepth(position) {\n\t\treturn this._depth[position];\n\t}\n\tsetVisited(isVisited) {\n\t\tthis._isVisited = isVisited;\n\t}\n\tcomputeDirectedLabel() {\n\t\tthis._label = new Label(this._edge.getLabel());\n\t\tif (!this._isForward) this._label.flip();\n\t}\n\tgetNext() {\n\t\treturn this._next;\n\t}\n\tsetDepth(position, depthVal) {\n\t\tif (this._depth[position] !== -999) {\n\t\t\tif (this._depth[position] !== depthVal) throw new TopologyException(\"assigned depths do not match\", this.getCoordinate());\n\t\t}\n\t\tthis._depth[position] = depthVal;\n\t}\n\tisInteriorAreaEdge() {\n\t\tvar isInteriorAreaEdge = true;\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (!(this._label.isArea(i) && this._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {\n\t\t\t\tisInteriorAreaEdge = false;\n\t\t\t}\n\t\t}\n\t\treturn isInteriorAreaEdge;\n\t}\n\tsetNextMin(nextMin) {\n\t\tthis._nextMin = nextMin;\n\t}\n\tprint(out) {\n\t\tsuper.print.call(this, out);\n\t\tout.print(\" \" + this._depth[Position.LEFT] + \"/\" + this._depth[Position.RIGHT]);\n\t\tout.print(\" (\" + this.getDepthDelta() + \")\");\n\t\tif (this._isInResult) out.print(\" inResult\");\n\t}\n\tsetMinEdgeRing(minEdgeRing) {\n\t\tthis._minEdgeRing = minEdgeRing;\n\t}\n\tisLineEdge() {\n\t\tvar isLine = this._label.isLine(0) || this._label.isLine(1);\n\t\tvar isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);\n\t\tvar isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);\n\t\treturn isLine && isExteriorIfArea0 && isExteriorIfArea1;\n\t}\n\tsetEdgeRing(edgeRing) {\n\t\tthis._edgeRing = edgeRing;\n\t}\n\tgetMinEdgeRing() {\n\t\treturn this._minEdgeRing;\n\t}\n\tgetDepthDelta() {\n\t\tvar depthDelta = this._edge.getDepthDelta();\n\t\tif (!this._isForward) depthDelta = -depthDelta;\n\t\treturn depthDelta;\n\t}\n\tsetInResult(isInResult) {\n\t\tthis._isInResult = isInResult;\n\t}\n\tgetSym() {\n\t\treturn this._sym;\n\t}\n\tisForward() {\n\t\treturn this._isForward;\n\t}\n\tgetEdge() {\n\t\treturn this._edge;\n\t}\n\tprintEdge(out) {\n\t\tthis.print(out);\n\t\tout.print(\" \");\n\t\tif (this._isForward) this._edge.print(out); else this._edge.printReverse(out);\n\t}\n\tsetSym(de) {\n\t\tthis._sym = de;\n\t}\n\tsetVisitedEdge(isVisited) {\n\t\tthis.setVisited(isVisited);\n\t\tthis._sym.setVisited(isVisited);\n\t}\n\tsetEdgeDepths(position, depth) {\n\t\tvar depthDelta = this.getEdge().getDepthDelta();\n\t\tif (!this._isForward) depthDelta = -depthDelta;\n\t\tvar directionFactor = 1;\n\t\tif (position === Position.LEFT) directionFactor = -1;\n\t\tvar oppositePos = Position.opposite(position);\n\t\tvar delta = depthDelta * directionFactor;\n\t\tvar oppositeDepth = depth + delta;\n\t\tthis.setDepth(position, depth);\n\t\tthis.setDepth(oppositePos, oppositeDepth);\n\t}\n\tgetEdgeRing() {\n\t\treturn this._edgeRing;\n\t}\n\tisInResult() {\n\t\treturn this._isInResult;\n\t}\n\tsetNext(next) {\n\t\tthis._next = next;\n\t}\n\tisVisited() {\n\t\treturn this._isVisited;\n\t}\n\tgetClass() {\n\t\treturn DirectedEdge;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nDirectedEdge.constructor_ = function () {\n\tthis._isForward = null;\n\tthis._isInResult = false;\n\tthis._isVisited = false;\n\tthis._sym = null;\n\tthis._next = null;\n\tthis._nextMin = null;\n\tthis._edgeRing = null;\n\tthis._minEdgeRing = null;\n\tthis._depth = [0, -999, -999];\n\tlet edge = arguments[0], isForward = arguments[1];\n\tEdgeEnd.constructor_.call(this, edge);\n\tthis._isForward = isForward;\n\tif (isForward) {\n\t\tthis.init(edge.getCoordinate(0), edge.getCoordinate(1));\n\t} else {\n\t\tvar n = edge.getNumPoints() - 1;\n\t\tthis.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));\n\t}\n\tthis.computeDirectedLabel();\n};\n","import Node from './Node';\nexport default class NodeFactory {\n\tconstructor() {\n\t\tNodeFactory.constructor_.apply(this, arguments);\n\t}\n\tcreateNode(coord) {\n\t\treturn new Node(coord, null);\n\t}\n\tgetClass() {\n\t\treturn NodeFactory;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nNodeFactory.constructor_ = function () {};\n","import Location from '../geom/Location';\nimport Coordinate from '../geom/Coordinate';\nimport Node from './Node';\nimport NodeMap from './NodeMap';\nimport Orientation from '../algorithm/Orientation';\nimport DirectedEdge from './DirectedEdge';\nimport System from '../../../../java/lang/System';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Quadrant from './Quadrant';\nimport NodeFactory from './NodeFactory';\nexport default class PlanarGraph {\n\tconstructor() {\n\t\tPlanarGraph.constructor_.apply(this, arguments);\n\t}\n\tstatic linkResultDirectedEdges(nodes) {\n\t\tfor (var nodeit = nodes.iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().linkResultDirectedEdges();\n\t\t}\n\t}\n\tprintEdges(out) {\n\t\tout.println(\"Edges:\");\n\t\tfor (var i = 0; i < this._edges.size(); i++) {\n\t\t\tout.println(\"edge \" + i + \":\");\n\t\t\tvar e = this._edges.get(i);\n\t\t\te.print(out);\n\t\t\te.eiList.print(out);\n\t\t}\n\t}\n\tfind(coord) {\n\t\treturn this._nodes.find(coord);\n\t}\n\taddNode() {\n\t\tif (arguments[0] instanceof Node) {\n\t\t\tlet node = arguments[0];\n\t\t\treturn this._nodes.addNode(node);\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet coord = arguments[0];\n\t\t\treturn this._nodes.addNode(coord);\n\t\t}\n\t}\n\tgetNodeIterator() {\n\t\treturn this._nodes.iterator();\n\t}\n\tlinkResultDirectedEdges() {\n\t\tfor (var nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().linkResultDirectedEdges();\n\t\t}\n\t}\n\tdebugPrintln(o) {\n\t\tSystem.out.println(o);\n\t}\n\tisBoundaryNode(geomIndex, coord) {\n\t\tvar node = this._nodes.find(coord);\n\t\tif (node === null) return false;\n\t\tvar label = node.getLabel();\n\t\tif (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) return true;\n\t\treturn false;\n\t}\n\tlinkAllDirectedEdges() {\n\t\tfor (var nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().linkAllDirectedEdges();\n\t\t}\n\t}\n\tmatchInSameDirection(p0, p1, ep0, ep1) {\n\t\tif (!p0.equals(ep0)) return false;\n\t\tif (Orientation.index(p0, p1, ep1) === Orientation.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) return true;\n\t\treturn false;\n\t}\n\tgetEdgeEnds() {\n\t\treturn this._edgeEndList;\n\t}\n\tdebugPrint(o) {\n\t\tSystem.out.print(o);\n\t}\n\tgetEdgeIterator() {\n\t\treturn this._edges.iterator();\n\t}\n\tfindEdgeInSameDirection(p0, p1) {\n\t\tfor (var i = 0; i < this._edges.size(); i++) {\n\t\t\tvar e = this._edges.get(i);\n\t\t\tvar eCoord = e.getCoordinates();\n\t\t\tif (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e;\n\t\t\tif (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e;\n\t\t}\n\t\treturn null;\n\t}\n\tinsertEdge(e) {\n\t\tthis._edges.add(e);\n\t}\n\tfindEdgeEnd(e) {\n\t\tfor (var i = this.getEdgeEnds().iterator(); i.hasNext(); ) {\n\t\t\tvar ee = i.next();\n\t\t\tif (ee.getEdge() === e) return ee;\n\t\t}\n\t\treturn null;\n\t}\n\taddEdges(edgesToAdd) {\n\t\tfor (var it = edgesToAdd.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tthis._edges.add(e);\n\t\t\tvar de1 = new DirectedEdge(e, true);\n\t\t\tvar de2 = new DirectedEdge(e, false);\n\t\t\tde1.setSym(de2);\n\t\t\tde2.setSym(de1);\n\t\t\tthis.add(de1);\n\t\t\tthis.add(de2);\n\t\t}\n\t}\n\tadd(e) {\n\t\tthis._nodes.add(e);\n\t\tthis._edgeEndList.add(e);\n\t}\n\tgetNodes() {\n\t\treturn this._nodes.values();\n\t}\n\tfindEdge(p0, p1) {\n\t\tfor (var i = 0; i < this._edges.size(); i++) {\n\t\t\tvar e = this._edges.get(i);\n\t\t\tvar eCoord = e.getCoordinates();\n\t\t\tif (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e;\n\t\t}\n\t\treturn null;\n\t}\n\tgetClass() {\n\t\treturn PlanarGraph;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPlanarGraph.constructor_ = function () {\n\tthis._edges = new ArrayList();\n\tthis._nodes = null;\n\tthis._edgeEndList = new ArrayList();\n\tif (arguments.length === 0) {\n\t\tthis._nodes = new NodeMap(new NodeFactory());\n\t} else if (arguments.length === 1) {\n\t\tlet nodeFact = arguments[0];\n\t\tthis._nodes = new NodeMap(nodeFact);\n\t}\n};\n","import PointLocator from '../algorithm/PointLocator';\nimport Location from '../geom/Location';\nimport LineString from '../geom/LineString';\nimport HashMap from '../../../../java/util/HashMap';\nimport Geometry from '../geom/Geometry';\nimport hasInterface from '../../../../hasInterface';\nimport Position from './Position';\nimport Coordinate from '../geom/Coordinate';\nimport Point from '../geom/Point';\nimport Polygon from '../geom/Polygon';\nimport MultiPoint from '../geom/MultiPoint';\nimport SimpleMCSweepLineIntersector from './index/SimpleMCSweepLineIntersector';\nimport LinearRing from '../geom/LinearRing';\nimport BoundaryNodeRule from '../algorithm/BoundaryNodeRule';\nimport Orientation from '../algorithm/Orientation';\nimport SegmentIntersector from './index/SegmentIntersector';\nimport MultiPolygon from '../geom/MultiPolygon';\nimport Label from './Label';\nimport GeometryCollection from '../geom/GeometryCollection';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nimport Polygonal from '../geom/Polygonal';\nimport IndexedPointInAreaLocator from '../algorithm/locate/IndexedPointInAreaLocator';\nimport Assert from '../util/Assert';\nimport Edge from './Edge';\nimport MultiLineString from '../geom/MultiLineString';\nimport PlanarGraph from './PlanarGraph';\nexport default class GeometryGraph extends PlanarGraph {\n\tconstructor() {\n\t\tsuper();\n\t\tGeometryGraph.constructor_.apply(this, arguments);\n\t}\n\tstatic determineBoundary(boundaryNodeRule, boundaryCount) {\n\t\treturn boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR;\n\t}\n\tinsertBoundaryPoint(argIndex, coord) {\n\t\tvar n = this._nodes.addNode(coord);\n\t\tvar lbl = n.getLabel();\n\t\tvar boundaryCount = 1;\n\t\tvar loc = Location.NONE;\n\t\tloc = lbl.getLocation(argIndex, Position.ON);\n\t\tif (loc === Location.BOUNDARY) boundaryCount++;\n\t\tvar newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);\n\t\tlbl.setLocation(argIndex, newLoc);\n\t}\n\tcomputeSelfNodes() {\n\t\tif (arguments.length === 2) {\n\t\t\tlet li = arguments[0], computeRingSelfNodes = arguments[1];\n\t\t\treturn this.computeSelfNodes(li, computeRingSelfNodes, false);\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet li = arguments[0], computeRingSelfNodes = arguments[1], isDoneIfProperInt = arguments[2];\n\t\t\tvar si = new SegmentIntersector(li, true, false);\n\t\t\tsi.setIsDoneIfProperInt(isDoneIfProperInt);\n\t\t\tvar esi = this.createEdgeSetIntersector();\n\t\t\tvar isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;\n\t\t\tvar computeAllSegments = computeRingSelfNodes || !isRings;\n\t\t\tesi.computeIntersections(this._edges, si, computeAllSegments);\n\t\t\tthis.addSelfIntersectionNodes(this._argIndex);\n\t\t\treturn si;\n\t\t}\n\t}\n\tcomputeSplitEdges(edgelist) {\n\t\tfor (var i = this._edges.iterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\te.eiList.addSplitEdges(edgelist);\n\t\t}\n\t}\n\tcomputeEdgeIntersections(g, li, includeProper) {\n\t\tvar si = new SegmentIntersector(li, includeProper, true);\n\t\tsi.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());\n\t\tvar esi = this.createEdgeSetIntersector();\n\t\tesi.computeIntersections(this._edges, g._edges, si);\n\t\treturn si;\n\t}\n\tgetGeometry() {\n\t\treturn this._parentGeom;\n\t}\n\tgetBoundaryNodeRule() {\n\t\treturn this._boundaryNodeRule;\n\t}\n\thasTooFewPoints() {\n\t\treturn this._hasTooFewPoints;\n\t}\n\taddPoint() {\n\t\tif (arguments[0] instanceof Point) {\n\t\t\tlet p = arguments[0];\n\t\t\tvar coord = p.getCoordinate();\n\t\t\tthis.insertPoint(this._argIndex, coord, Location.INTERIOR);\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet pt = arguments[0];\n\t\t\tthis.insertPoint(this._argIndex, pt, Location.INTERIOR);\n\t\t}\n\t}\n\taddPolygon(p) {\n\t\tthis.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);\n\t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n\t\t\tvar hole = p.getInteriorRingN(i);\n\t\t\tthis.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);\n\t\t}\n\t}\n\taddEdge(e) {\n\t\tthis.insertEdge(e);\n\t\tvar coord = e.getCoordinates();\n\t\tthis.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n\t\tthis.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);\n\t}\n\taddLineString(line) {\n\t\tvar coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n\t\tif (coord.length < 2) {\n\t\t\tthis._hasTooFewPoints = true;\n\t\t\tthis._invalidPoint = coord[0];\n\t\t\treturn null;\n\t\t}\n\t\tvar e = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));\n\t\tthis._lineEdgeMap.put(line, e);\n\t\tthis.insertEdge(e);\n\t\tAssert.isTrue(coord.length >= 2, \"found LineString with single point\");\n\t\tthis.insertBoundaryPoint(this._argIndex, coord[0]);\n\t\tthis.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);\n\t}\n\tgetInvalidPoint() {\n\t\treturn this._invalidPoint;\n\t}\n\tgetBoundaryPoints() {\n\t\tvar coll = this.getBoundaryNodes();\n\t\tvar pts = new Array(coll.size()).fill(null);\n\t\tvar i = 0;\n\t\tfor (var it = coll.iterator(); it.hasNext(); ) {\n\t\t\tvar node = it.next();\n\t\t\tpts[i++] = node.getCoordinate().copy();\n\t\t}\n\t\treturn pts;\n\t}\n\tgetBoundaryNodes() {\n\t\tif (this._boundaryNodes === null) this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);\n\t\treturn this._boundaryNodes;\n\t}\n\taddSelfIntersectionNode(argIndex, coord, loc) {\n\t\tif (this.isBoundaryNode(argIndex, coord)) return null;\n\t\tif (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) this.insertBoundaryPoint(argIndex, coord); else this.insertPoint(argIndex, coord, loc);\n\t}\n\taddPolygonRing(lr, cwLeft, cwRight) {\n\t\tif (lr.isEmpty()) return null;\n\t\tvar coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());\n\t\tif (coord.length < 4) {\n\t\t\tthis._hasTooFewPoints = true;\n\t\t\tthis._invalidPoint = coord[0];\n\t\t\treturn null;\n\t\t}\n\t\tvar left = cwLeft;\n\t\tvar right = cwRight;\n\t\tif (Orientation.isCCW(coord)) {\n\t\t\tleft = cwRight;\n\t\t\tright = cwLeft;\n\t\t}\n\t\tvar e = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));\n\t\tthis._lineEdgeMap.put(lr, e);\n\t\tthis.insertEdge(e);\n\t\tthis.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n\t}\n\tinsertPoint(argIndex, coord, onLocation) {\n\t\tvar n = this._nodes.addNode(coord);\n\t\tvar lbl = n.getLabel();\n\t\tif (lbl === null) {\n\t\t\tn._label = new Label(argIndex, onLocation);\n\t\t} else lbl.setLocation(argIndex, onLocation);\n\t}\n\tcreateEdgeSetIntersector() {\n\t\treturn new SimpleMCSweepLineIntersector();\n\t}\n\taddSelfIntersectionNodes(argIndex) {\n\t\tfor (var i = this._edges.iterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n\t\t\tfor (var eiIt = e.eiList.iterator(); eiIt.hasNext(); ) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tthis.addSelfIntersectionNode(argIndex, ei.coord, eLoc);\n\t\t\t}\n\t\t}\n\t}\n\tadd() {\n\t\tif (arguments.length === 1 && arguments[0] instanceof Geometry) {\n\t\t\tlet g = arguments[0];\n\t\t\tif (g.isEmpty()) return null;\n\t\t\tif (g instanceof MultiPolygon) this._useBoundaryDeterminationRule = false;\n\t\t\tif (g instanceof Polygon) this.addPolygon(g); else if (g instanceof LineString) this.addLineString(g); else if (g instanceof Point) this.addPoint(g); else if (g instanceof MultiPoint) this.addCollection(g); else if (g instanceof MultiLineString) this.addCollection(g); else if (g instanceof MultiPolygon) this.addCollection(g); else if (g instanceof GeometryCollection) this.addCollection(g); else throw new UnsupportedOperationException(g.getClass().getName());\n\t\t} else return super.add.apply(this, arguments);\n\t}\n\taddCollection(gc) {\n\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\tvar g = gc.getGeometryN(i);\n\t\t\tthis.add(g);\n\t\t}\n\t}\n\tlocate(pt) {\n\t\tif (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {\n\t\t\tif (this._areaPtLocator === null) {\n\t\t\t\tthis._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);\n\t\t\t}\n\t\t\treturn this._areaPtLocator.locate(pt);\n\t\t}\n\t\treturn this._ptLocator.locate(pt, this._parentGeom);\n\t}\n\tfindEdge() {\n\t\tif (arguments.length === 1 && arguments[0] instanceof LineString) {\n\t\t\tlet line = arguments[0];\n\t\t\treturn this._lineEdgeMap.get(line);\n\t\t} else return super.findEdge.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn GeometryGraph;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGeometryGraph.constructor_ = function () {\n\tthis._parentGeom = null;\n\tthis._lineEdgeMap = new HashMap();\n\tthis._boundaryNodeRule = null;\n\tthis._useBoundaryDeterminationRule = true;\n\tthis._argIndex = null;\n\tthis._boundaryNodes = null;\n\tthis._hasTooFewPoints = false;\n\tthis._invalidPoint = null;\n\tthis._areaPtLocator = null;\n\tthis._ptLocator = new PointLocator();\n\tif (arguments.length === 2) {\n\t\tlet argIndex = arguments[0], parentGeom = arguments[1];\n\t\tGeometryGraph.constructor_.call(this, argIndex, parentGeom, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n\t} else if (arguments.length === 3) {\n\t\tlet argIndex = arguments[0], parentGeom = arguments[1], boundaryNodeRule = arguments[2];\n\t\tthis._argIndex = argIndex;\n\t\tthis._parentGeom = parentGeom;\n\t\tthis._boundaryNodeRule = boundaryNodeRule;\n\t\tif (parentGeom !== null) {\n\t\t\tthis.add(parentGeom);\n\t\t}\n\t}\n};\n","import Location from '../../geom/Location';\nimport EdgeEnd from '../../geomgraph/EdgeEnd';\nimport Position from '../../geomgraph/Position';\nimport GeometryGraph from '../../geomgraph/GeometryGraph';\nimport Label from '../../geomgraph/Label';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Edge from '../../geomgraph/Edge';\nexport default class EdgeEndBundle extends EdgeEnd {\n\tconstructor() {\n\t\tsuper();\n\t\tEdgeEndBundle.constructor_.apply(this, arguments);\n\t}\n\tinsert(e) {\n\t\tthis._edgeEnds.add(e);\n\t}\n\tprint(out) {\n\t\tout.println(\"EdgeEndBundle--> Label: \" + this._label);\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ee = it.next();\n\t\t\tee.print(out);\n\t\t\tout.println();\n\t\t}\n\t}\n\titerator() {\n\t\treturn this._edgeEnds.iterator();\n\t}\n\tgetEdgeEnds() {\n\t\treturn this._edgeEnds;\n\t}\n\tcomputeLabelOn(geomIndex, boundaryNodeRule) {\n\t\tvar boundaryCount = 0;\n\t\tvar foundInterior = false;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar loc = e.getLabel().getLocation(geomIndex);\n\t\t\tif (loc === Location.BOUNDARY) boundaryCount++;\n\t\t\tif (loc === Location.INTERIOR) foundInterior = true;\n\t\t}\n\t\tvar loc = Location.NONE;\n\t\tif (foundInterior) loc = Location.INTERIOR;\n\t\tif (boundaryCount > 0) {\n\t\t\tloc = GeometryGraph.determineBoundary(boundaryNodeRule, boundaryCount);\n\t\t}\n\t\tthis._label.setLocation(geomIndex, loc);\n\t}\n\tcomputeLabelSide(geomIndex, side) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tif (e.getLabel().isArea()) {\n\t\t\t\tvar loc = e.getLabel().getLocation(geomIndex, side);\n\t\t\t\tif (loc === Location.INTERIOR) {\n\t\t\t\t\tthis._label.setLocation(geomIndex, side, Location.INTERIOR);\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (loc === Location.EXTERIOR) this._label.setLocation(geomIndex, side, Location.EXTERIOR);\n\t\t\t}\n\t\t}\n\t}\n\tgetLabel() {\n\t\treturn this._label;\n\t}\n\tcomputeLabelSides(geomIndex) {\n\t\tthis.computeLabelSide(geomIndex, Position.LEFT);\n\t\tthis.computeLabelSide(geomIndex, Position.RIGHT);\n\t}\n\tupdateIM(im) {\n\t\tEdge.updateIM(this._label, im);\n\t}\n\tcomputeLabel(boundaryNodeRule) {\n\t\tvar isArea = false;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tif (e.getLabel().isArea()) isArea = true;\n\t\t}\n\t\tif (isArea) this._label = new Label(Location.NONE, Location.NONE, Location.NONE); else this._label = new Label(Location.NONE);\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tthis.computeLabelOn(i, boundaryNodeRule);\n\t\t\tif (isArea) this.computeLabelSides(i);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn EdgeEndBundle;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdgeEndBundle.constructor_ = function () {\n\tthis._edgeEnds = new ArrayList();\n\tif (arguments.length === 1) {\n\t\tlet e = arguments[0];\n\t\tEdgeEndBundle.constructor_.call(this, null, e);\n\t} else if (arguments.length === 2) {\n\t\tlet boundaryNodeRule = arguments[0], e = arguments[1];\n\t\tEdgeEnd.constructor_.call(this, e.getEdge(), e.getCoordinate(), e.getDirectedCoordinate(), new Label(e.getLabel()));\n\t\tthis.insert(e);\n\t}\n};\n","import EdgeEndStar from '../../geomgraph/EdgeEndStar';\nimport EdgeEndBundle from './EdgeEndBundle';\nexport default class EdgeEndBundleStar extends EdgeEndStar {\n\tconstructor() {\n\t\tsuper();\n\t\tEdgeEndBundleStar.constructor_.apply(this, arguments);\n\t}\n\tupdateIM(im) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar esb = it.next();\n\t\t\tesb.updateIM(im);\n\t\t}\n\t}\n\tinsert(e) {\n\t\tvar eb = this._edgeMap.get(e);\n\t\tif (eb === null) {\n\t\t\teb = new EdgeEndBundle(e);\n\t\t\tthis.insertEdgeEnd(e, eb);\n\t\t} else {\n\t\t\teb.insert(e);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn EdgeEndBundleStar;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdgeEndBundleStar.constructor_ = function () {};\n","import Node from '../../geomgraph/Node';\nexport default class RelateNode extends Node {\n\tconstructor() {\n\t\tsuper();\n\t\tRelateNode.constructor_.apply(this, arguments);\n\t}\n\tupdateIMFromEdges(im) {\n\t\tthis._edges.updateIM(im);\n\t}\n\tcomputeIM(im) {\n\t\tim.setAtLeastIfValid(this._label.getLocation(0), this._label.getLocation(1), 0);\n\t}\n\tgetClass() {\n\t\treturn RelateNode;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRelateNode.constructor_ = function () {\n\tlet coord = arguments[0], edges = arguments[1];\n\tNode.constructor_.call(this, coord, edges);\n};\n","import EdgeEndBundleStar from './EdgeEndBundleStar';\nimport RelateNode from './RelateNode';\nimport NodeFactory from '../../geomgraph/NodeFactory';\nexport default class RelateNodeFactory extends NodeFactory {\n\tconstructor() {\n\t\tsuper();\n\t\tRelateNodeFactory.constructor_.apply(this, arguments);\n\t}\n\tcreateNode(coord) {\n\t\treturn new RelateNode(coord, new EdgeEndBundleStar());\n\t}\n\tgetClass() {\n\t\treturn RelateNodeFactory;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRelateNodeFactory.constructor_ = function () {};\n","import PointLocator from '../../algorithm/PointLocator';\nimport Location from '../../geom/Location';\nimport IntersectionMatrix from '../../geom/IntersectionMatrix';\nimport EdgeEndBuilder from './EdgeEndBuilder';\nimport NodeMap from '../../geomgraph/NodeMap';\nimport RelateNodeFactory from './RelateNodeFactory';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport RobustLineIntersector from '../../algorithm/RobustLineIntersector';\nimport Assert from '../../util/Assert';\nexport default class RelateComputer {\n\tconstructor() {\n\t\tRelateComputer.constructor_.apply(this, arguments);\n\t}\n\tinsertEdgeEnds(ee) {\n\t\tfor (var i = ee.iterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tthis._nodes.add(e);\n\t\t}\n\t}\n\tcomputeProperIntersectionIM(intersector, im) {\n\t\tvar dimA = this._arg[0].getGeometry().getDimension();\n\t\tvar dimB = this._arg[1].getGeometry().getDimension();\n\t\tvar hasProper = intersector.hasProperIntersection();\n\t\tvar hasProperInterior = intersector.hasProperInteriorIntersection();\n\t\tif (dimA === 2 && dimB === 2) {\n\t\t\tif (hasProper) im.setAtLeast(\"212101212\");\n\t\t} else if (dimA === 2 && dimB === 1) {\n\t\t\tif (hasProper) im.setAtLeast(\"FFF0FFFF2\");\n\t\t\tif (hasProperInterior) im.setAtLeast(\"1FFFFF1FF\");\n\t\t} else if (dimA === 1 && dimB === 2) {\n\t\t\tif (hasProper) im.setAtLeast(\"F0FFFFFF2\");\n\t\t\tif (hasProperInterior) im.setAtLeast(\"1F1FFFFFF\");\n\t\t} else if (dimA === 1 && dimB === 1) {\n\t\t\tif (hasProperInterior) im.setAtLeast(\"0FFFFFFFF\");\n\t\t}\n\t}\n\tlabelIsolatedEdges(thisIndex, targetIndex) {\n\t\tfor (var ei = this._arg[thisIndex].getEdgeIterator(); ei.hasNext(); ) {\n\t\t\tvar e = ei.next();\n\t\t\tif (e.isIsolated()) {\n\t\t\t\tthis.labelIsolatedEdge(e, targetIndex, this._arg[targetIndex].getGeometry());\n\t\t\t\tthis._isolatedEdges.add(e);\n\t\t\t}\n\t\t}\n\t}\n\tlabelIsolatedEdge(e, targetIndex, target) {\n\t\tif (target.getDimension() > 0) {\n\t\t\tvar loc = this._ptLocator.locate(e.getCoordinate(), target);\n\t\t\te.getLabel().setAllLocations(targetIndex, loc);\n\t\t} else {\n\t\t\te.getLabel().setAllLocations(targetIndex, Location.EXTERIOR);\n\t\t}\n\t}\n\tcomputeIM() {\n\t\tvar im = new IntersectionMatrix();\n\t\tim.set(Location.EXTERIOR, Location.EXTERIOR, 2);\n\t\tif (!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal())) {\n\t\t\tthis.computeDisjointIM(im);\n\t\t\treturn im;\n\t\t}\n\t\tthis._arg[0].computeSelfNodes(this._li, false);\n\t\tthis._arg[1].computeSelfNodes(this._li, false);\n\t\tvar intersector = this._arg[0].computeEdgeIntersections(this._arg[1], this._li, false);\n\t\tthis.computeIntersectionNodes(0);\n\t\tthis.computeIntersectionNodes(1);\n\t\tthis.copyNodesAndLabels(0);\n\t\tthis.copyNodesAndLabels(1);\n\t\tthis.labelIsolatedNodes();\n\t\tthis.computeProperIntersectionIM(intersector, im);\n\t\tvar eeBuilder = new EdgeEndBuilder();\n\t\tvar ee0 = eeBuilder.computeEdgeEnds(this._arg[0].getEdgeIterator());\n\t\tthis.insertEdgeEnds(ee0);\n\t\tvar ee1 = eeBuilder.computeEdgeEnds(this._arg[1].getEdgeIterator());\n\t\tthis.insertEdgeEnds(ee1);\n\t\tthis.labelNodeEdges();\n\t\tthis.labelIsolatedEdges(0, 1);\n\t\tthis.labelIsolatedEdges(1, 0);\n\t\tthis.updateIM(im);\n\t\treturn im;\n\t}\n\tlabelNodeEdges() {\n\t\tfor (var ni = this._nodes.iterator(); ni.hasNext(); ) {\n\t\t\tvar node = ni.next();\n\t\t\tnode.getEdges().computeLabelling(this._arg);\n\t\t}\n\t}\n\tcopyNodesAndLabels(argIndex) {\n\t\tfor (var i = this._arg[argIndex].getNodeIterator(); i.hasNext(); ) {\n\t\t\tvar graphNode = i.next();\n\t\t\tvar newNode = this._nodes.addNode(graphNode.getCoordinate());\n\t\t\tnewNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n\t\t}\n\t}\n\tlabelIntersectionNodes(argIndex) {\n\t\tfor (var i = this._arg[argIndex].getEdgeIterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n\t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext(); ) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tvar n = this._nodes.find(ei.coord);\n\t\t\t\tif (n.getLabel().isNull(argIndex)) {\n\t\t\t\t\tif (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex); else n.setLabel(argIndex, Location.INTERIOR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlabelIsolatedNode(n, targetIndex) {\n\t\tvar loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());\n\t\tn.getLabel().setAllLocations(targetIndex, loc);\n\t}\n\tcomputeIntersectionNodes(argIndex) {\n\t\tfor (var i = this._arg[argIndex].getEdgeIterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n\t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext(); ) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tvar n = this._nodes.addNode(ei.coord);\n\t\t\t\tif (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex); else {\n\t\t\t\t\tif (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, Location.INTERIOR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlabelIsolatedNodes() {\n\t\tfor (var ni = this._nodes.iterator(); ni.hasNext(); ) {\n\t\t\tvar n = ni.next();\n\t\t\tvar label = n.getLabel();\n\t\t\tAssert.isTrue(label.getGeometryCount() > 0, \"node with empty label found\");\n\t\t\tif (n.isIsolated()) {\n\t\t\t\tif (label.isNull(0)) this.labelIsolatedNode(n, 0); else this.labelIsolatedNode(n, 1);\n\t\t\t}\n\t\t}\n\t}\n\tupdateIM(im) {\n\t\tfor (var ei = this._isolatedEdges.iterator(); ei.hasNext(); ) {\n\t\t\tvar e = ei.next();\n\t\t\te.updateIM(im);\n\t\t}\n\t\tfor (var ni = this._nodes.iterator(); ni.hasNext(); ) {\n\t\t\tvar node = ni.next();\n\t\t\tnode.updateIM(im);\n\t\t\tnode.updateIMFromEdges(im);\n\t\t}\n\t}\n\tcomputeDisjointIM(im) {\n\t\tvar ga = this._arg[0].getGeometry();\n\t\tif (!ga.isEmpty()) {\n\t\t\tim.set(Location.INTERIOR, Location.EXTERIOR, ga.getDimension());\n\t\t\tim.set(Location.BOUNDARY, Location.EXTERIOR, ga.getBoundaryDimension());\n\t\t}\n\t\tvar gb = this._arg[1].getGeometry();\n\t\tif (!gb.isEmpty()) {\n\t\t\tim.set(Location.EXTERIOR, Location.INTERIOR, gb.getDimension());\n\t\t\tim.set(Location.EXTERIOR, Location.BOUNDARY, gb.getBoundaryDimension());\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn RelateComputer;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRelateComputer.constructor_ = function () {\n\tthis._li = new RobustLineIntersector();\n\tthis._ptLocator = new PointLocator();\n\tthis._arg = null;\n\tthis._nodes = new NodeMap(new RelateNodeFactory());\n\tthis._im = null;\n\tthis._isolatedEdges = new ArrayList();\n\tthis._invalidPoint = null;\n\tlet arg = arguments[0];\n\tthis._arg = arg;\n};\n","import BoundaryNodeRule from '../algorithm/BoundaryNodeRule';\nimport GeometryGraph from '../geomgraph/GeometryGraph';\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector';\nexport default class GeometryGraphOperation {\n\tconstructor() {\n\t\tGeometryGraphOperation.constructor_.apply(this, arguments);\n\t}\n\tgetArgGeometry(i) {\n\t\treturn this._arg[i].getGeometry();\n\t}\n\tsetComputationPrecision(pm) {\n\t\tthis._resultPrecisionModel = pm;\n\t\tthis._li.setPrecisionModel(this._resultPrecisionModel);\n\t}\n\tgetClass() {\n\t\treturn GeometryGraphOperation;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGeometryGraphOperation.constructor_ = function () {\n\tthis._li = new RobustLineIntersector();\n\tthis._resultPrecisionModel = null;\n\tthis._arg = null;\n\tif (arguments.length === 1) {\n\t\tlet g0 = arguments[0];\n\t\tthis.setComputationPrecision(g0.getPrecisionModel());\n\t\tthis._arg = new Array(1).fill(null);\n\t\tthis._arg[0] = new GeometryGraph(0, g0);\n\t\t;\n\t} else if (arguments.length === 2) {\n\t\tlet g0 = arguments[0], g1 = arguments[1];\n\t\tGeometryGraphOperation.constructor_.call(this, g0, g1, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n\t} else if (arguments.length === 3) {\n\t\tlet g0 = arguments[0], g1 = arguments[1], boundaryNodeRule = arguments[2];\n\t\tif (g0.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) this.setComputationPrecision(g0.getPrecisionModel()); else this.setComputationPrecision(g1.getPrecisionModel());\n\t\tthis._arg = new Array(2).fill(null);\n\t\tthis._arg[0] = new GeometryGraph(0, g0, boundaryNodeRule);\n\t\tthis._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);\n\t}\n};\n","import LineString from '../../geom/LineString';\nimport Coordinate from '../../geom/Coordinate';\nimport Point from '../../geom/Point';\nimport Polygon from '../../geom/Polygon';\nexport default class RectangleContains {\n\tconstructor() {\n\t\tRectangleContains.constructor_.apply(this, arguments);\n\t}\n\tstatic contains(rectangle, b) {\n\t\tvar rc = new RectangleContains(rectangle);\n\t\treturn rc.contains(b);\n\t}\n\tisContainedInBoundary(geom) {\n\t\tif (geom instanceof Polygon) return false;\n\t\tif (geom instanceof Point) return this.isPointContainedInBoundary(geom);\n\t\tif (geom instanceof LineString) return this.isLineStringContainedInBoundary(geom);\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar comp = geom.getGeometryN(i);\n\t\t\tif (!this.isContainedInBoundary(comp)) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tisLineSegmentContainedInBoundary(p0, p1) {\n\t\tif (p0.equals(p1)) return this.isPointContainedInBoundary(p0);\n\t\tif (p0.x === p1.x) {\n\t\t\tif (p0.x === this._rectEnv.getMinX() || p0.x === this._rectEnv.getMaxX()) return true;\n\t\t} else if (p0.y === p1.y) {\n\t\t\tif (p0.y === this._rectEnv.getMinY() || p0.y === this._rectEnv.getMaxY()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\tisLineStringContainedInBoundary(line) {\n\t\tvar seq = line.getCoordinateSequence();\n\t\tvar p0 = new Coordinate();\n\t\tvar p1 = new Coordinate();\n\t\tfor (var i = 0; i < seq.size() - 1; i++) {\n\t\t\tseq.getCoordinate(i, p0);\n\t\t\tseq.getCoordinate(i + 1, p1);\n\t\t\tif (!this.isLineSegmentContainedInBoundary(p0, p1)) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tisPointContainedInBoundary() {\n\t\tif (arguments[0] instanceof Point) {\n\t\t\tlet point = arguments[0];\n\t\t\treturn this.isPointContainedInBoundary(point.getCoordinate());\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet pt = arguments[0];\n\t\t\treturn pt.x === this._rectEnv.getMinX() || pt.x === this._rectEnv.getMaxX() || pt.y === this._rectEnv.getMinY() || pt.y === this._rectEnv.getMaxY();\n\t\t}\n\t}\n\tcontains(geom) {\n\t\tif (!this._rectEnv.contains(geom.getEnvelopeInternal())) return false;\n\t\tif (this.isContainedInBoundary(geom)) return false;\n\t\treturn true;\n\t}\n\tgetClass() {\n\t\treturn RectangleContains;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRectangleContains.constructor_ = function () {\n\tthis._rectEnv = null;\n\tlet rectangle = arguments[0];\n\tthis._rectEnv = rectangle.getEnvelopeInternal();\n};\n","import Coordinate from '../geom/Coordinate';\nimport RobustLineIntersector from './RobustLineIntersector';\nimport Envelope from '../geom/Envelope';\nexport default class RectangleLineIntersector {\n\tconstructor() {\n\t\tRectangleLineIntersector.constructor_.apply(this, arguments);\n\t}\n\tintersects(p0, p1) {\n\t\tvar segEnv = new Envelope(p0, p1);\n\t\tif (!this._rectEnv.intersects(segEnv)) return false;\n\t\tif (this._rectEnv.intersects(p0)) return true;\n\t\tif (this._rectEnv.intersects(p1)) return true;\n\t\tif (p0.compareTo(p1) > 0) {\n\t\t\tvar tmp = p0;\n\t\t\tp0 = p1;\n\t\t\tp1 = tmp;\n\t\t}\n\t\tvar isSegUpwards = false;\n\t\tif (p1.y > p0.y) isSegUpwards = true;\n\t\tif (isSegUpwards) {\n\t\t\tthis._li.computeIntersection(p0, p1, this._diagDown0, this._diagDown1);\n\t\t} else {\n\t\t\tthis._li.computeIntersection(p0, p1, this._diagUp0, this._diagUp1);\n\t\t}\n\t\tif (this._li.hasIntersection()) return true;\n\t\treturn false;\n\t}\n\tgetClass() {\n\t\treturn RectangleLineIntersector;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRectangleLineIntersector.constructor_ = function () {\n\tthis._li = new RobustLineIntersector();\n\tthis._rectEnv = null;\n\tthis._diagUp0 = null;\n\tthis._diagUp1 = null;\n\tthis._diagDown0 = null;\n\tthis._diagDown1 = null;\n\tlet rectEnv = arguments[0];\n\tthis._rectEnv = rectEnv;\n\tthis._diagUp0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMinY());\n\tthis._diagUp1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMaxY());\n\tthis._diagDown0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMaxY());\n\tthis._diagDown1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMinY());\n};\n","import GeometryCollection from '../GeometryCollection';\nexport default class ShortCircuitedGeometryVisitor {\n\tconstructor() {\n\t\tShortCircuitedGeometryVisitor.constructor_.apply(this, arguments);\n\t}\n\tapplyTo(geom) {\n\t\tfor (var i = 0; i < geom.getNumGeometries() && !this._isDone; i++) {\n\t\t\tvar element = geom.getGeometryN(i);\n\t\t\tif (!(element instanceof GeometryCollection)) {\n\t\t\t\tthis.visit(element);\n\t\t\t\tif (this.isDone()) {\n\t\t\t\t\tthis._isDone = true;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else this.applyTo(element);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn ShortCircuitedGeometryVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nShortCircuitedGeometryVisitor.constructor_ = function () {\n\tthis._isDone = false;\n};\n","import Coordinate from '../../geom/Coordinate';\nimport Polygon from '../../geom/Polygon';\nimport RectangleLineIntersector from '../../algorithm/RectangleLineIntersector';\nimport ShortCircuitedGeometryVisitor from '../../geom/util/ShortCircuitedGeometryVisitor';\nimport SimplePointInAreaLocator from '../../algorithm/locate/SimplePointInAreaLocator';\nimport LinearComponentExtracter from '../../geom/util/LinearComponentExtracter';\nexport default class RectangleIntersects {\n\tconstructor() {\n\t\tRectangleIntersects.constructor_.apply(this, arguments);\n\t}\n\tstatic intersects(rectangle, b) {\n\t\tvar rp = new RectangleIntersects(rectangle);\n\t\treturn rp.intersects(b);\n\t}\n\tintersects(geom) {\n\t\tif (!this._rectEnv.intersects(geom.getEnvelopeInternal())) return false;\n\t\tvar visitor = new EnvelopeIntersectsVisitor(this._rectEnv);\n\t\tvisitor.applyTo(geom);\n\t\tif (visitor.intersects()) return true;\n\t\tvar ecpVisitor = new GeometryContainsPointVisitor(this._rectangle);\n\t\tecpVisitor.applyTo(geom);\n\t\tif (ecpVisitor.containsPoint()) return true;\n\t\tvar riVisitor = new RectangleIntersectsSegmentVisitor(this._rectangle);\n\t\triVisitor.applyTo(geom);\n\t\tif (riVisitor.intersects()) return true;\n\t\treturn false;\n\t}\n\tgetClass() {\n\t\treturn RectangleIntersects;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRectangleIntersects.constructor_ = function () {\n\tthis._rectangle = null;\n\tthis._rectEnv = null;\n\tlet rectangle = arguments[0];\n\tthis._rectangle = rectangle;\n\tthis._rectEnv = rectangle.getEnvelopeInternal();\n};\nclass EnvelopeIntersectsVisitor extends ShortCircuitedGeometryVisitor {\n\tconstructor() {\n\t\tsuper();\n\t\tEnvelopeIntersectsVisitor.constructor_.apply(this, arguments);\n\t}\n\tisDone() {\n\t\treturn this._intersects === true;\n\t}\n\tvisit(element) {\n\t\tvar elementEnv = element.getEnvelopeInternal();\n\t\tif (!this._rectEnv.intersects(elementEnv)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this._rectEnv.contains(elementEnv)) {\n\t\t\tthis._intersects = true;\n\t\t\treturn null;\n\t\t}\n\t\tif (elementEnv.getMinX() >= this._rectEnv.getMinX() && elementEnv.getMaxX() <= this._rectEnv.getMaxX()) {\n\t\t\tthis._intersects = true;\n\t\t\treturn null;\n\t\t}\n\t\tif (elementEnv.getMinY() >= this._rectEnv.getMinY() && elementEnv.getMaxY() <= this._rectEnv.getMaxY()) {\n\t\t\tthis._intersects = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\tintersects() {\n\t\treturn this._intersects;\n\t}\n\tgetClass() {\n\t\treturn EnvelopeIntersectsVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEnvelopeIntersectsVisitor.constructor_ = function () {\n\tthis._rectEnv = null;\n\tthis._intersects = false;\n\tlet rectEnv = arguments[0];\n\tthis._rectEnv = rectEnv;\n};\nclass GeometryContainsPointVisitor extends ShortCircuitedGeometryVisitor {\n\tconstructor() {\n\t\tsuper();\n\t\tGeometryContainsPointVisitor.constructor_.apply(this, arguments);\n\t}\n\tisDone() {\n\t\treturn this._containsPoint === true;\n\t}\n\tvisit(geom) {\n\t\tif (!(geom instanceof Polygon)) return null;\n\t\tvar elementEnv = geom.getEnvelopeInternal();\n\t\tif (!this._rectEnv.intersects(elementEnv)) return null;\n\t\tvar rectPt = new Coordinate();\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tthis._rectSeq.getCoordinate(i, rectPt);\n\t\t\tif (!elementEnv.contains(rectPt)) continue;\n\t\t\tif (SimplePointInAreaLocator.containsPointInPolygon(rectPt, geom)) {\n\t\t\t\tthis._containsPoint = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\tcontainsPoint() {\n\t\treturn this._containsPoint;\n\t}\n\tgetClass() {\n\t\treturn GeometryContainsPointVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGeometryContainsPointVisitor.constructor_ = function () {\n\tthis._rectSeq = null;\n\tthis._rectEnv = null;\n\tthis._containsPoint = false;\n\tlet rectangle = arguments[0];\n\tthis._rectSeq = rectangle.getExteriorRing().getCoordinateSequence();\n\tthis._rectEnv = rectangle.getEnvelopeInternal();\n};\nclass RectangleIntersectsSegmentVisitor extends ShortCircuitedGeometryVisitor {\n\tconstructor() {\n\t\tsuper();\n\t\tRectangleIntersectsSegmentVisitor.constructor_.apply(this, arguments);\n\t}\n\tintersects() {\n\t\treturn this._hasIntersection;\n\t}\n\tisDone() {\n\t\treturn this._hasIntersection === true;\n\t}\n\tvisit(geom) {\n\t\tvar elementEnv = geom.getEnvelopeInternal();\n\t\tif (!this._rectEnv.intersects(elementEnv)) return null;\n\t\tvar lines = LinearComponentExtracter.getLines(geom);\n\t\tthis.checkIntersectionWithLineStrings(lines);\n\t}\n\tcheckIntersectionWithLineStrings(lines) {\n\t\tfor (var i = lines.iterator(); i.hasNext(); ) {\n\t\t\tvar testLine = i.next();\n\t\t\tthis.checkIntersectionWithSegments(testLine);\n\t\t\tif (this._hasIntersection) return null;\n\t\t}\n\t}\n\tcheckIntersectionWithSegments(testLine) {\n\t\tvar seq1 = testLine.getCoordinateSequence();\n\t\tfor (var j = 1; j < seq1.size(); j++) {\n\t\t\tseq1.getCoordinate(j - 1, this._p0);\n\t\t\tseq1.getCoordinate(j, this._p1);\n\t\t\tif (this._rectIntersector.intersects(this._p0, this._p1)) {\n\t\t\t\tthis._hasIntersection = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn RectangleIntersectsSegmentVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRectangleIntersectsSegmentVisitor.constructor_ = function () {\n\tthis._rectEnv = null;\n\tthis._rectIntersector = null;\n\tthis._hasIntersection = false;\n\tthis._p0 = new Coordinate();\n\tthis._p1 = new Coordinate();\n\tlet rectangle = arguments[0];\n\tthis._rectEnv = rectangle.getEnvelopeInternal();\n\tthis._rectIntersector = new RectangleLineIntersector(this._rectEnv);\n};\n","import RelateComputer from './RelateComputer';\nimport GeometryGraphOperation from '../GeometryGraphOperation';\nimport RectangleContains from '../predicate/RectangleContains';\nimport RectangleIntersects from '../predicate/RectangleIntersects';\nexport default class RelateOp extends GeometryGraphOperation {\n\tconstructor() {\n\t\tsuper();\n\t\tRelateOp.constructor_.apply(this, arguments);\n\t}\n\tstatic covers(g1, g2) {\n\t\tif (g2.getDimension() === 2 && g1.getDimension() < 2) {\n\t\t\treturn false;\n\t\t}\n\t\tif (g2.getDimension() === 1 && g1.getDimension() < 1 && g2.getLength() > 0.0) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!g1.getEnvelopeInternal().covers(g2.getEnvelopeInternal())) return false;\n\t\tif (g1.isRectangle()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn new RelateOp(g1, g2).getIntersectionMatrix().isCovers();\n\t}\n\tstatic intersects(g1, g2) {\n\t\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\t\tif (g1.isRectangle()) {\n\t\t\treturn RectangleIntersects.intersects(g1, g2);\n\t\t}\n\t\tif (g2.isRectangle()) {\n\t\t\treturn RectangleIntersects.intersects(g2, g1);\n\t\t}\n\t\tif (g1.isGeometryCollection() || g2.isGeometryCollection()) {\n\t\t\tvar r = false;\n\t\t\tfor (var i = 0; i < g1.getNumGeometries(); i++) {\n\t\t\t\tfor (var j = 0; j < g2.getNumGeometries(); j++) {\n\t\t\t\t\tif (g1.getGeometryN(i).intersects(g2.getGeometryN(j))) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn new RelateOp(g1, g2).getIntersectionMatrix().isIntersects();\n\t}\n\tstatic touches(g1, g2) {\n\t\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\t\treturn new RelateOp(g1, g2).getIntersectionMatrix().isTouches(g1.getDimension(), g2.getDimension());\n\t}\n\tstatic relate() {\n\t\tif (arguments.length === 2) {\n\t\t\tlet a = arguments[0], b = arguments[1];\n\t\t\tvar relOp = new RelateOp(a, b);\n\t\t\tvar im = relOp.getIntersectionMatrix();\n\t\t\treturn im;\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet a = arguments[0], b = arguments[1], boundaryNodeRule = arguments[2];\n\t\t\tvar relOp = new RelateOp(a, b, boundaryNodeRule);\n\t\t\tvar im = relOp.getIntersectionMatrix();\n\t\t\treturn im;\n\t\t}\n\t}\n\tstatic overlaps(g1, g2) {\n\t\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\t\treturn new RelateOp(g1, g2).getIntersectionMatrix().isOverlaps(g1.getDimension(), g2.getDimension());\n\t}\n\tstatic crosses(g1, g2) {\n\t\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\t\treturn new RelateOp(g1, g2).getIntersectionMatrix().isCrosses(g1.getDimension(), g2.getDimension());\n\t}\n\tstatic contains(g1, g2) {\n\t\tif (g2.getDimension() === 2 && g1.getDimension() < 2) {\n\t\t\treturn false;\n\t\t}\n\t\tif (g2.getDimension() === 1 && g1.getDimension() < 1 && g2.getLength() > 0.0) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!g1.getEnvelopeInternal().contains(g2.getEnvelopeInternal())) return false;\n\t\tif (g1.isRectangle()) {\n\t\t\treturn RectangleContains.contains(g1, g2);\n\t\t}\n\t\treturn new RelateOp(g1, g2).getIntersectionMatrix().isContains();\n\t}\n\tgetIntersectionMatrix() {\n\t\treturn this._relate.computeIM();\n\t}\n\tgetClass() {\n\t\treturn RelateOp;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRelateOp.constructor_ = function () {\n\tthis._relate = null;\n\tif (arguments.length === 2) {\n\t\tlet g0 = arguments[0], g1 = arguments[1];\n\t\tGeometryGraphOperation.constructor_.call(this, g0, g1);\n\t\tthis._relate = new RelateComputer(this._arg);\n\t} else if (arguments.length === 3) {\n\t\tlet g0 = arguments[0], g1 = arguments[1], boundaryNodeRule = arguments[2];\n\t\tGeometryGraphOperation.constructor_.call(this, g0, g1, boundaryNodeRule);\n\t\tthis._relate = new RelateComputer(this._arg);\n\t}\n};\n","import { GeoJSONReader } from 'jsts/org/locationtech/jts/io';\nimport RelateOp from 'jsts/org/locationtech/jts/operation/relate/RelateOp';\n\n/**\n * @classdesc\n * @api\n */\nclass Base {\n  /**\n   * This function get a function filter\n   *\n   * @public\n   * @protected\n   * @function\n   */\n  getFunctionFilter() {}\n\n  /**\n   * This function execute a function filter\n   *\n   * @protected\n   * @param {Array<M.Feature>} features - Features on which the filter runs\n   * @function\n   */\n  execute(features) {}\n\n  /**\n   * This function execute a function filter\n   *\n   * @protected\n   * @param {Array<M.Feature>} features - Features on which the filter runs\n   * @return {Array<M.Feature>} Result of execute\n   * @function\n   */\n  toCQL() {}\n}\n\n/**\n * @classdesc\n * @api\n */\nclass Function extends Base {\n  /**\n   * Creates a Filter Function to filter features\n   *\n   * @param {function} filterFunction - Function to execute\n   * @api\n   */\n  constructor(filterFunction, options = {}) {\n    super();\n    /**\n     * Function to execute\n     * @private\n     * @type {function}\n     */\n    this.filterFunction_ = filterFunction;\n\n    /**\n     * Filter CQL\n     * @private\n     * @type {String}\n     */\n    this.cqlFilter_ = '';\n    if (!M.utils.isNullOrEmpty(options.cqlFilter)) {\n      this.cqlFilter_ = options.cqlFilter;\n    }\n  }\n\n  /**\n   * This function set a function filter\n   *\n   * @public\n   * @function\n   * @api\n   */\n  setFunction(filterFunction) {\n    this.filterFunction_ = filterFunction;\n  }\n\n  /**\n   * This function get a function filter\n   *\n   * @public\n   * @function\n   * @return {M.filter.Function} filter to execute\n   * @api\n   */\n  getFunctionFilter() {\n    return this.filterFunction_;\n  }\n\n  /**\n   * This function execute a function filter\n   *\n   * @public\n   * @function\n   * @param {Array<M.Feature>} features - Features on which the filter runs\n   * @return {Array<M.Feature>} features to passed filter\n   * @api\n   */\n  execute(features) {\n    return features.filter(this.filterFunction_);\n  }\n\n  /**\n   * This function return CQL\n   *\n   * @public\n   * @function\n   * @api\n   * @return {string} CQL\n   */\n  toCQL() {\n    return this.cqlFilter_;\n  }\n}\n\n/**\n * @classdesc\n * @api\n */\nclass Spatial extends Function {\n  /**\n   * Creates a Filter Spatial to filter features\n   *\n   * @api\n   */\n  constructor(FunctionParam, options) {\n    const filterFunction = (feature, index) => {\n      let geometry = null;\n      if (!M.utils.isNullOrEmpty(feature)) {\n        geometry = feature.getGeometry();\n      }\n      return FunctionParam(geometry, index);\n    };\n    super(filterFunction, options);\n  }\n}\n\n/**\n * @function\n * @api\n */\nexport const parseParamToGeometries = (paramParameter) => {\n  let param = paramParameter;\n  let geometries = [];\n  if (param instanceof M.layer.Vector) {\n    geometries = [...param.getFeatures().map(feature => feature.getGeometry())];\n  } else {\n    if (!M.utils.isArray(param)) {\n      param = [param];\n    }\n    geometries = param.map((p) => {\n      let geom;\n      if (p instanceof M.Feature) {\n        geom = p.getGeometry();\n      } else if (M.isObject(p)) {\n        geom = p;\n      }\n      return geom;\n    });\n  }\n\n  return geometries;\n};\n\n/**\n * @private\n * @function\n */\nconst toCQLFilter = (operation, geometries) => {\n  let cqlFilter = '';\n  const wktFormat = new M.format.WKT();\n  geometries.forEach((value, index) => {\n    if (index !== 0) {\n      // es un OR porque se hace una interseccion completa con todas\n      // las geometries\n      cqlFilter += ' OR ';\n    }\n    const geometry = new M.Feature('filtered_geom', {\n      type: 'Feature',\n      geometry: value,\n    });\n    const formatedGeometry = wktFormat.write(geometry);\n    cqlFilter += `${operation}({{geometryName}}, ${formatedGeometry})`;\n  });\n  return cqlFilter;\n};\n\n/**\n * This function creates a spatial filter to know which features intersects\n * another feature or layer\n *\n * @function\n * @api\n */\nexport const intersect = (param) => {\n  const geometries = parseParamToGeometries(param);\n  return new Spatial((geometryToFilter, index) => {\n    const geojsonParser = new GeoJSONReader();\n    const jtsGeomToFilter = geojsonParser.read(geometryToFilter);\n    return geometries.some((geom) => {\n      const jtsGeom = geojsonParser.read(geom);\n      return RelateOp.intersects(jtsGeomToFilter, jtsGeom);\n    });\n  }, {\n    cqlFilter: toCQLFilter('INTERSECTS', geometries),\n  });\n};\n","/* eslint-disable max-len */\n/**\n * @module M/plugin/Attributions\n */\nimport '../assets/css/attributions';\nimport AttributionsImpl from '../../impl/ol/js/attributions';\nimport AttributionsControl from './attributionscontrol';\nimport { intersect } from './filter';\nimport { getValue } from './i18n/language';\n\nconst MODES = {\n  mapAttributions: 1, // Map attributions from vector layer\n  layerAttributions: 2, // Attributions layer from its capabilities wms service\n  mixed: 3, // Mixed mode ( 1 + 2)\n};\n\n/**\n * @typedef {AttributionsOptions}\n *\n * The mode according to which the plugin will consult the attributions.\n * @param {mode}\n * @type {number}\n *\n *\n * @param {url}\n * @type {URLLike}\n */\n\n/**\n * Class of attributions plugin\n * @param {object}\n * @classdesc\n */\nexport default class Attributions extends M.Plugin {\n  /**\n   * @constructor\n   * @extends {M.Plugin}\n   * @param {AttributionsOptions} options\n   * @api\n   */\n  constructor(options = {}) {\n    super();\n\n    if (M.utils.isNullOrEmpty(options.mode) || !Object.values(MODES).includes(options.mode)) {\n      throw new Error(getValue('exception.mode'));\n    }\n\n    if (options.mode === MODES.mapAttributions && !M.utils.isNullOrEmpty(options.url)) {\n      if (M.utils.isNullOrEmpty(options.type)) {\n        throw new Error(getValue('exception.type'));\n      }\n    }\n\n    if (options.mode === MODES.mapAttributions && !M.utils.isNullOrEmpty(options.layerName)) {\n      if (M.utils.isNullOrEmpty(options.type)) {\n        throw new Error(getValue('exception.layerName'));\n      }\n    }\n\n    /**\n     * Facade of the map\n     *\n     * @private\n     * @type {M.Map}\n     */\n    this.map_ = null;\n\n    /**\n     * Array of controls\n     *\n     * @private\n     * @type {Array<M.Control>}\n     */\n    this.controls_ = [];\n\n    /**\n     * Mode of the plugin\n     *\n     * @private\n     * @type {number}\n     */\n    this.mode_ = Number.parseInt(options.mode, 10);\n\n    /**\n     * Vectorial service attributions\n     *\n     * @private\n     * @type {URLLike}\n     */\n    this.url_ = options.url || M.config.attributions.url;\n    /**\n     * Type of the data url\n     *\n     * @private\n     * @type {string}\n     */\n    this.type_ = options.type || 'kml';\n\n    /**\n     * The name of the vector layer hat contains the attribution information.\n     *\n     * @private\n     * @type {string}\n     */\n    this.layerName_ = options.layerName || 'attributions';\n\n    /**\n     * Layer of Mapea with attributions\n     *\n     * @private\n     * @type {M.layer.GeoJSON | M.layer.KML}\n     */\n    this.layer_ = options.layer;\n\n    /**\n     * Zoom from which attributions are displayed\n     *\n     * @private\n     * @type {number}\n     */\n    this.scale_ = Number.parseInt(options.scale, 10) || 10000;\n\n    /**\n     * Parameter of the features of the layer that contains the information of the attributions.\n     *\n     * @private\n     * @type {string}\n     */\n    this.attributionParam_ = options.attributionParam || 'atribucion';\n\n    /**\n     * Parameter of the features of the layer that contains the information of the URL.\n     * @private\n     * @type {URLLike}\n     */\n    this.urlParam_ = options.urlParam || 'url';\n\n    /**\n     * Minimum width of the view control\n     * @private\n     * @type {string}\n     */\n    this.minWidth_ = options.minWidth || '100px';\n\n    /**\n     * Minimum width of the view control\n     * @private\n     * @type {string}\n     */\n    this.maxWidth_ = options.maxWidth || '200px';\n\n    /**\n     * Position of the view control\n     * @private\n     * @type {string}\n     */\n    this.position_ = options.position || 'BL';\n\n    /**\n     * Default text attribution\n     *\n     * @private\n     * @type {string}\n     */\n    // eslint-disable-next-line max-len\n    this.defaultAttribution_ = options.defaultAttribution || M.config.attributions.defaultAttribution;\n\n    /**\n     * Default url attribution\n     *\n     * @private\n     * @type {string}\n     */\n    // eslint-disable-next-line max-len\n    this.defaultURL_ = options.defaultURL || M.config.attributions.defaultURL;\n\n    /**\n     * Tooltip of the UI Plugin\n     *\n     * @private\n     * @type {string}\n     */\n    this.tooltip_ = options.tooltip || getValue('tooltip');\n\n    /**\n     * Position of the view control\n     * @private\n     * @type {string}\n     */\n    this.urlAttribute = options.urlAttribute || 'Gobierno de Espaa';\n\n    window.addEventListener('resize', e => this.setCollapsiblePanel(e));\n  }\n\n  /**\n   * This function adds this plugin into the map\n   *\n   * @public\n   * @function\n   * @param {M.Map} map the map to add the plugin\n   * @api stable\n   */\n  addTo(map) {\n    this.map_ = map;\n    this.impl_ = new AttributionsImpl(map);\n    this.control_ = new AttributionsControl(this.position_, this.closePanel);\n    this.controls_.push(this.control_);\n\n    this.panel_ = new M.ui.Panel('Attributions', {\n      collapsible: window.innerWidth < 769,\n      position: M.ui.position[this.position_],\n      className: 'm-panel-attributions',\n      collapsedButtonClass: 'g-cartografia-info',\n      tooltip: this.tooltip_,\n    });\n\n    this.panel_.addControls(this.control_);\n\n    this.map_.addPanels(this.panel_);\n    this.initMode();\n\n    this.onMoveEnd(() => {\n      this.changeAttributions();\n    });\n  }\n\n  /**\n   * This function destroys this plugin\n   *\n   * @public\n   * @function\n   * @api\n   */\n  destroy() {\n    this.map_.removeControls([this.control_]);\n    this.panel_ = null;\n  }\n\n  /**\n   * @public\n   * @function\n   */\n  initMode() {\n    if (this.mode_ === MODES.mapAttributions) {\n      if (!(this.layer_ instanceof M.layer.Vector)) {\n        const optionsLayer = {\n          name: this.layerName_,\n          url: this.url_,\n        };\n\n        if (this.type_ === 'geojson') {\n          this.layer_ = new M.layer.GeoJSON(optionsLayer, { displayInLayerSwitcher: false });\n        } else if (this.type_ === 'kml') {\n          this.layer_ = new M.layer.KML(optionsLayer, { displayInLayerSwitcher: false });\n        } else if (this.type === 'topojson') {\n          // TODO: Implement in Mapea M.layer.TopoJSON\n        }\n      }\n\n      if (this.map_.getLayers({ name: this.layer_ }).length < 1) {\n        this.map_.addLayers(this.layer_);\n        this.layer_.displayInLayerSwitcher = false;\n        this.layer_.setVisible(false);\n      }\n    }\n  }\n\n\n  /**\n   * This method shows the layer attributions\n   *\n   * @function\n   * @public\n   */\n  changeAttributions() {\n    this.clearContent();\n    if (this.map_.getScale() <= this.scale_) {\n      this.setVisible(true);\n      let mapAttributions = [];\n      if (this.mode_ === MODES.mapAttributions) {\n        mapAttributions = this.getMapAttributions();\n        const zoom = this.map_.getZoom();\n        const baseLayer = this.map_.getBaseLayers()[0];\n        const isHybrid = this.map_.getLayers().filter((l) => {\n          return l.type === 'WMTS' && !l.displayInLayerSwitcher && l.name === 'OI.OrthoimageCoverage';\n        }).length > 0;\n        if ((baseLayer !== undefined && baseLayer.name === 'OI.OrthoimageCoverage') || isHybrid) {\n          if (zoom < 14) {\n            mapAttributions = [{ attribution: 'Copernicus Sentinel 2019', url: 'https://sentinel.esa.int/web/sentinel/home' }].concat(mapAttributions);\n          } else {\n            mapAttributions = [{ attribution: 'Sistema Cartogrfico Nacional', url: 'http://www.scne.es/' }].concat(mapAttributions);\n          }\n        } else if (baseLayer !== undefined && (baseLayer.name === 'IGNBaseTodo' || baseLayer.name === 'EL.GridCoverageDSM')) {\n          mapAttributions = [{ attribution: 'Sistema Cartogrfico Nacional', url: 'http://www.scne.es/' }].concat(mapAttributions);\n        } else if (baseLayer !== undefined && baseLayer.name === 'LC.LandCoverSurfaces') {\n          if (zoom < 14) {\n            mapAttributions = [{ attribution: 'CORINE-Land Cover. Instituto Geogrfico Nacional', url: this.defaultURL_ }].concat(mapAttributions);\n          } else {\n            mapAttributions = [{ attribution: 'Sistema Cartogrfico Nacional', url: 'http://www.scne.es/' }].concat(mapAttributions);\n          }\n        } else {\n          mapAttributions = [{ attribution: this.defaultAttribution_, url: this.defaultURL_ }].concat(mapAttributions);\n        }\n      }\n\n      this.addContent(mapAttributions);\n    } else {\n      const zoom = this.map_.getZoom();\n      const baseLayer = this.map_.getBaseLayers()[0];\n      let mapAttributions = [{ attribution: this.defaultAttribution_, url: this.defaultURL_ }];\n      const isHybrid = this.map_.getLayers().filter((l) => {\n        return l.type === 'WMTS' && !l.displayInLayerSwitcher && l.name === 'OI.OrthoimageCoverage';\n      }).length > 0;\n      if ((baseLayer !== undefined && baseLayer.name === 'OI.OrthoimageCoverage') || isHybrid) {\n        if (zoom < 14) {\n          mapAttributions = [{ attribution: 'Copernicus Sentinel 2019', url: 'https://sentinel.esa.int/web/sentinel/home' }];\n        } else {\n          mapAttributions = [{ attribution: 'Sistema Cartogrfico Nacional', url: 'http://www.scne.es/' }];\n        }\n      } else if (baseLayer !== undefined && (baseLayer.name === 'IGNBaseTodo' || baseLayer.name === 'EL.GridCoverageDSM')) {\n        mapAttributions = [{ attribution: 'Sistema Cartogrfico Nacional', url: 'http://www.scne.es/' }];\n      } else if (baseLayer !== undefined && baseLayer.name === 'LC.LandCoverSurfaces') {\n        if (zoom < 14) {\n          mapAttributions = [{ attribution: 'CORINE-Land Cover. Instituto Geogrfico Nacional', url: this.defaultURL_ }];\n        } else {\n          mapAttributions = [{ attribution: 'Sistema Cartogrfico Nacional', url: 'http://www.scne.es/' }];\n        }\n      }\n\n      this.addContent(mapAttributions);\n    }\n  }\n\n  /**\n   * This method adds the text content to the view attribution\n   *\n   * @function\n   * @public\n   */\n  addContent(attributions) {\n    const html = this.control_.getElement();\n    const links = attributions.map((attrOpt, index, arr) => {\n      const link = document.createElement('a');\n      link.target = '_blank';\n      link.href = attrOpt.url;\n      link.innerHTML = attrOpt.attribution;\n      const attributeURL = this.map_.getScale() > this.scale_ ? '' : ', '.concat(this.urlAttribute);\n      link.innerHTML += arr.length - 1 === index ? attributeURL : ',';\n      return link;\n    });\n    const div = document.createElement('div');\n    links.forEach((link) => {\n      div.append(link);\n    });\n    html.append(div);\n  }\n\n  /**\n   * This method adds the text content to the view attribution\n   *\n   * @function\n   * @public\n   */\n  clearContent() {\n    if (!M.utils.isNullOrEmpty(this.control_)) {\n      const html = this.control_.getElement();\n      html.querySelectorAll('div').forEach(child => html.removeChild(child));\n    }\n  }\n\n  /**\n   * This method toggle de visibility of the view attribution\n   */\n  setVisible(visibility) {\n    const html = this.control_.getElement();\n    html.style.display = visibility === false ? 'none' : '';\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  getMapAttributions() {\n    this.updateBBoxFeature();\n    const featuresAttributions = this.map_.getLayers().filter(l => l.name.includes('attributions'))[0].getFeatures();\n    const interFilter = intersect(this.bboxFeature_);\n    const filteredFeatures = interFilter.execute(featuresAttributions);\n    return filteredFeatures.map((feature) => {\n      return {\n        attribution: feature.getAttribute(this.attributionParam_) || '',\n        url: feature.getAttribute(this.urlParam_) || this.defaultURL_,\n      };\n    }).filter((element, index, array) => // remove repeat elements\n      array.map(e => e.attribution).indexOf(element.attribution) === index);\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  getLayerAttributions() {\n    // TODO:\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  closePanel() {\n    this.getPanel().collapse();\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  changeContentAttribution(content) {\n    this.control_.changeContent(content);\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  updateBBoxFeature() {\n    const { x, y } = this.map_.getBbox();\n    this.bboxFeature_ = new M.Feature('bbox_feature', {\n      type: 'Feature',\n      properties: {},\n      geometry: {\n        type: 'Polygon',\n        coordinates: [\n          [\n            [x.min, y.min],\n            [x.min, y.max],\n            [x.max, y.max],\n            [x.max, y.min],\n            [x.min, y.min],\n          ],\n        ],\n      },\n    });\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  setCollapsiblePanel(e) {\n    if (this.getPanel() && this.getPanel().getTemplatePanel()) {\n      if (e.target.innerWidth < 769) {\n        this.getPanel().getTemplatePanel().classList.remove('no-collapsible');\n        this.closePanel();\n      } else {\n        this.getPanel().getTemplatePanel().classList.add('no-collapsible');\n        this.getPanel().getTemplatePanel().classList.remove('collapsed');\n      }\n    }\n  }\n  /**\n   * @function\n   * @public\n   */\n  onMoveEnd(callback) {\n    this.impl_.registerEvent('moveend', e => callback(e));\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  getPanel() {\n    return this.panel_;\n  }\n\n  /**\n   * Name of the plugin\n   *\n   * @getter\n   * @function\n   */\n  get name() {\n    return 'attributions';\n  }\n\n  /**\n   * Mode of the plugin\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get mode() {\n    return this.mode_;\n  }\n\n  /**\n   * Position of the plugin\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get position() {\n    return this.position_;\n  }\n\n  /**\n   * Scale of the plugin\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get scale() {\n    return this.scale_;\n  }\n\n  /**\n   * Attribution of the plugin\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get defaultAttribution() {\n    return this.defaultAttribution_;\n  }\n\n  /**\n   * Default url of the plugin\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get defaultURL() {\n    return this.defaultURL_;\n  }\n\n  /**\n   * url of the layer\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get url() {\n    return this.url_;\n  }\n\n  /**\n   * Type\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get type() {\n    return this.type_;\n  }\n\n  /**\n   * Layer name\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get layerName() {\n    return this.layerName_;\n  }\n\n  /**\n   * Parameter of the features of the layer that contains the information of the attributions.\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get attributionParam() {\n    return this.attributionParam_;\n  }\n\n  /**\n   * Parameter of the features of the layer that contains the information of the URL.\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get urlParam() {\n    return this.urlParam_;\n  }\n\n  /**\n   * Get the API REST Parameters of the plugin\n   *\n   * @function\n   * @public\n   * @api\n   */\n  getAPIRest() {\n    return `${this.name}=${this.position}*${this.mode}*${this.scale}*${this.defaultAttribution}*${this.defaultURL}*${this.url}*${this.type}*${this.layerName}*${this.attributionParam}*${this.urlParam}*${this.urlAttribute}`;\n  }\n}\n","import M$plugin$Attributions from './/facade/js/attributions';\nimport M$control$AttributionsControl from './/facade/js/attributionscontrol';\nimport M$impl$control$AttributionsControl from './/impl/ol/js/attributionscontrol';\n\nif (!window.M.plugin) window.M.plugin = {};\nif (!window.M.control) window.M.control = {};\nif (!window.M.impl) window.M.impl = {};\nif (!window.M.impl.control) window.M.impl.control = {};\nwindow.M.plugin.Attributions = M$plugin$Attributions;\nwindow.M.control.AttributionsControl = M$control$AttributionsControl;\nwindow.M.impl.control.AttributionsControl = M$impl$control$AttributionsControl;\n"],"sourceRoot":""}