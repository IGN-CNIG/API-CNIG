{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/templates/attributions.html","webpack:///./src/impl/ol/js/attributions.js","webpack:///./src/impl/ol/js/attributionscontrol.js","webpack:///./node_modules/jsts/java/lang/Double.js","webpack:///./src/facade/js/attributionscontrol.js","webpack:///./node_modules/jsts/hasInterface.js","webpack:///./node_modules/jsts/java/lang/Cloneable.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequence.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequenceFactory.js","webpack:///./node_modules/jsts/java/lang/IllegalArgumentException.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryComponentFilter.js","webpack:///./node_modules/jsts/java/lang/Comparable.js","webpack:///./node_modules/jsts/java/io/Serializable.js","webpack:///./node_modules/jsts/org/locationtech/jts/util/NumberUtil.js","webpack:///./node_modules/jsts/java/lang/Long.js","webpack:///./node_modules/jsts/java/util/Comparator.js","webpack:///./node_modules/jsts/java/lang/RuntimeException.js","webpack:///./node_modules/jsts/org/locationtech/jts/util/AssertionFailedException.js","webpack:///./node_modules/jsts/org/locationtech/jts/util/Assert.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Coordinate.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Envelope.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Geometry.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateFilter.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/BoundaryNodeRule.js","webpack:///./node_modules/jsts/java/util/Iterator.js","webpack:///./node_modules/jsts/java/util/Collection.js","webpack:///./node_modules/jsts/java/util/IndexOutOfBoundsException.js","webpack:///./node_modules/jsts/java/util/List.js","webpack:///./node_modules/jsts/java/util/NoSuchElementException.js","webpack:///./node_modules/jsts/java/util/OperationNotSupported.js","webpack:///./node_modules/jsts/java/util/ArrayList.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateList.js","webpack:///./node_modules/jsts/org/locationtech/jts/math/MathUtil.js","webpack:///./node_modules/jsts/java/lang/System.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateArrays.js","webpack:///./node_modules/jsts/java/util/Map.js","webpack:///./node_modules/jsts/java/util/SortedMap.js","webpack:///./node_modules/jsts/java/util/Set.js","webpack:///./node_modules/jsts/java/util/HashSet.js","webpack:///./node_modules/jsts/java/util/TreeMap.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Lineal.js","webpack:///./node_modules/jsts/java/util/SortedSet.js","webpack:///./node_modules/jsts/java/util/TreeSet.js","webpack:///./node_modules/jsts/Map.js","webpack:///./node_modules/jsts/java/util/Arrays.js","webpack:///./node_modules/jsts/java/lang/Character.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Dimension.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryFilter.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequenceFilter.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryCollection.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/MultiLineString.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/BoundaryOp.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/Length.js","webpack:///./node_modules/jsts/java/io/PrintStream.js","webpack:///./node_modules/jsts/java/io/StringReader.js","webpack:///./node_modules/jsts/java/io/ByteArrayOutputStream.js","webpack:///./node_modules/jsts/java/io/IOException.js","webpack:///./node_modules/jsts/java/io/LineNumberReader.js","webpack:///./node_modules/jsts/org/locationtech/jts/util/StringUtil.js","webpack:///./node_modules/jsts/java/lang/StringBuilder.js","webpack:///./node_modules/jsts/java/text/DecimalFormat.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequences.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/LineString.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Puntal.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Point.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/Area.js","webpack:///./node_modules/jsts/java/lang/StringBuffer.js","webpack:///./node_modules/jsts/java/lang/Integer.js","webpack:///./node_modules/jsts/org/locationtech/jts/math/DD.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/CGAlgorithmsDD.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/Orientation.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Polygonal.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Polygon.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/MultiPoint.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/LinearRing.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/MultiPolygon.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/util/GeometryEditor.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/impl/CoordinateArraySequence.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/impl/CoordinateArraySequenceFactory.js","webpack:///./node_modules/jsts/java/util/HashMap.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/PrecisionModel.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryFactory.js","webpack:///./node_modules/jsts/org/locationtech/jts/io/GeoJSONParser.js","webpack:///./node_modules/jsts/org/locationtech/jts/io/GeoJSONReader.js","webpack:///./node_modules/jsts/org/locationtech/jts/io/WKTParser.js","webpack:///./node_modules/jsts/org/locationtech/jts/io/WKTWriter.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Location.js","webpack:///./node_modules/jsts/java/lang/Exception.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/NotRepresentableException.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/HCoordinate.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/Distance.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/LineIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/RobustLineIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/RayCrossingCounter.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/PointLocation.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryCollectionIterator.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/PointLocator.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/IntersectionMatrix.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Quadrant.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeEnd.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Position.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/TopologyLocation.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Label.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/EdgeEndBuilder.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/GraphComponent.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Node.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/NodeMap.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/TopologyException.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/locate/PointOnGeometryLocator.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/locate/SimplePointInAreaLocator.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeEndStar.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChain.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/SweepLineEvent.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/EdgeSetIntersector.js","webpack:///./node_modules/jsts/java/util/Collections.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/SegmentIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/SimpleMCSweepLineIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/ItemVisitor.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/intervalrtree/IntervalRTreeNode.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/intervalrtree/IntervalRTreeLeafNode.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/intervalrtree/IntervalRTreeBranchNode.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/intervalrtree/SortedPackedIntervalRTree.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/LineSegment.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/util/LinearComponentExtracter.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/ArrayListVisitor.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/locate/IndexedPointInAreaLocator.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeIntersection.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeIntersectionList.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChainIndexer.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChainEdge.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Depth.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Edge.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/DirectedEdge.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/NodeFactory.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/PlanarGraph.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/GeometryGraph.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/EdgeEndBundle.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/EdgeEndBundleStar.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/RelateNode.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/RelateNodeFactory.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/RelateComputer.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/GeometryGraphOperation.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/predicate/RectangleContains.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/RectangleLineIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/util/ShortCircuitedGeometryVisitor.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/predicate/RectangleIntersects.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/RelateOp.js","webpack:///./src/facade/js/filter.js","webpack:///./src/facade/js/attributions.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Attributions","map","_this","_classCallCheck","this","_possibleConstructorReturn","_getPrototypeOf","map_","M","type","callback","getMapImpl","on","AttributionsControl","impl","Control","html","getInteractions","forEach","interaction","ol","DoubleClickZoom","dblClickInteraction_","_get","attributionscontrol_getPrototypeOf","log2","floor","pow","MAX_REL_BITS_INTEGER","f64buf","i32buf","position","closePanel","js_attributionscontrol_classCallCheck","utils","isUndefined","AttributionsImplControl","exception","js_attributionscontrol_possibleConstructorReturn","js_attributionscontrol_getPrototypeOf","_this2","Promise","success","fail","template","compileSync","vars","icon","querySelector","addEventListener","html_","control","hasInterface","interfaces_","indexOf","Clonable","CoordinateSequence_CoordinateSequence","[object Object]","constructor_","apply","arguments","index","ordinateIndex","length","env","X","Y","Z","CoordinateSequenceFactory_CoordinateSequenceFactory","Array","IllegalArgumentException","message","GeometryComponentFilter","geom","Comparable","Serializable","NumberUtil","x1","x2","tolerance","Math","abs","Long","high","low","Double","Comparator","RuntimeException","stack","Error","toBinaryString","result","mask","isNaN","Number","isInfinite","isFinite","MAX_VALUE","Float64Array","Int32Array","buffer","doubleToLongBits","longBitsToDouble","bits","x","y","f","skip","sign","exp","NEGATIVE_INFINITY","Infinity","fract","BIAS","NaN","constructor","AssertionFailedException_AssertionFailedException","super","Assert_Assert","shouldNeverReachHere","assertion","isTrue","expectedValue","actualValue","equals","Coordinate_Coordinate","trunc","z","other","equalsWithTolerance","equals2D","e","CloneNotSupportedException","dx","dy","dz","sqrt","hashCode","Coordinate_DimensionalComparator","a","b","o1","o2","c1","c2","compX","compare","compY","_dimensionsToTest","dimensionsToTest","DimensionalComparator","NULL_ORDINATE","serialVersionUID","Envelope_Envelope","p1","p2","q","q1","q2","minq","min","maxq","max","minp","maxp","getWidth","getHeight","otherEnvelope","isNull","_maxx","getMaxX","_maxy","getMaxY","_minx","getMinX","_miny","getMinY","intersects","intMinX","intMinY","intMaxX","intMaxY","covers","expandToInclude","w","h","transX","transY","init","distance","expandBy","deltaX","deltaY","setToNull","y1","y2","Geometry_Geometry","getTypeCode","TYPECODE_GEOMETRYCOLLECTION","_factory","g","equalsTopo","equalsExact","geometryChangedFilter","_envelope","norm","isEmpty","compareToSameClass","comp","_userData","_SRID","getFactory","toGeometry","getEnvelopeInternal","copy","normalize","getPrecisionModel","computeEnvelopeInternal","SRID","userData","iterator","j","hasNext","aElement","next","bElement","comparison","compareTo","TYPECODE_MULTIPOINT","TYPECODE_MULTILINESTRING","TYPECODE_MULTIPOLYGON","geometries","array","factory","getSRID","TYPECODE_POINT","TYPECODE_LINESTRING","TYPECODE_LINEARRING","TYPECODE_POLYGON","TYPENAME_POINT","TYPENAME_MULTIPOINT","TYPENAME_LINESTRING","TYPENAME_LINEARRING","TYPENAME_MULTILINESTRING","TYPENAME_POLYGON","TYPENAME_MULTIPOLYGON","TYPENAME_GEOMETRYCOLLECTION","geometryChangedAction","CoordinateFilter","coord","BoundaryNodeRule","boundaryCount","Mod2BoundaryNodeRule","EndPointBoundaryNodeRule","MultiValentEndPointBoundaryNodeRule","MonoValentEndPointBoundaryNodeRule","Iterator","Collection","IndexOutOfBoundsException","List","NoSuchElementException","OperationNotSupported","ArrayList","array_","addAll","MOD2_BOUNDARY_RULE","ENDPOINT_BOUNDARY_RULE","MULTIVALENT_ENDPOINT_BOUNDARY_RULE","MONOVALENT_ENDPOINT_BOUNDARY_RULE","OGC_SFS_BOUNDARY_RULE","remove","add","size","toArray","set","ensureCapacity","push","splice","clear","element","oldElement","Iterator_","len","found","removeAll","arrayList","arrayList_","position_","CoordinateList_CoordinateList","coll","allowRepeated","isChanged","clone","coordArrayType","obj","isInteger","start","end","inc","fill","MathUtil_MathUtil","ln","log","LOG_10","v1","v2","v3","v4","System","arraycopy","src","srcPos","dest","destPos","getProperty","line.separator","CoordinateArrays_CoordinateArrays","pts","testPts","testPt","coordinates","firstCoordinate","newCoordinates","coord1","coord2","coordinateComparator","coordList","toCoordinateArray","hasRepeatedPoints","last","mid","tmp","nonNull","newCoord","srcStart","destStart","pts1","pts2","coordinate","minCoord","clamp","npts","extractPts","iPts","CoordinateArrays_ForwardComparator","CoordinateArrays_BidirectionalComparator","forwardComp","isEqualReversed","dir1","increasingDirection","dir2","i1","i2","comparePt","Map_Map","SortedMap","Set","HashSet","ForwardComparator","BidirectionalComparator","put","values","entrySet","contains","javascript","util","HashSet_Iterator_","hashSet","hashSet_","BLACK","colorOf","color","parentOf","parent","setColor","leftOf","left","rightOf","right","TreeMap","root_","size_","cmp","oldValue","fixAfterInsertion","rotateLeft","rotateRight","getFirstEntry","successor","ch","containsKey","Lineal","SortedSet","TreeSet","TreeSet_Iterator_","Map_i","treeSet","treeSet_","Arrays","Character","sort","comparator","slice","concat","asList","isWhitespace","toUpperCase","Dimension_Dimension","dimensionValue","FALSE","SYM_FALSE","TRUE","SYM_TRUE","DONTCARE","SYM_DONTCARE","P","SYM_P","L","SYM_L","A","SYM_A","dimensionSymbol","GeometryFilter","CoordinateSequenceFilter","seq","GeometryCollection_GeometryCollection","envelope","_geometries","getNumPoints","k","childCoordinates","getCoordinates","area","getArea","isEquivalentClass","otherCollection","getCoordinate","dimension","getBoundaryDimension","getDimension","sum","getLength","numPoints","revGeoms","reverse","createGeometryCollection","theseElements","otherElements","gc","n1","getNumGeometries","n2","thisGeom","getGeometryN","otherGeom","holeComp","filter","isDone","isGeometryChanged","geometryChanged","checkNotGeometryCollection","hasNullElements","MultiLineString_MultiLineString","isClosed","nLines","revLines","createMultiLineString","BoundaryOp_BoundaryOp","getBoundary","lineStrings","bnRule","mLine","_geom","getEmptyMultiPoint","bdyPts","computeBoundaryCoordinates","_geomFact","createPoint","createMultiPointFromCoords","LineString_LineString","boundaryLineString","boundaryMultiLineString","line","_bnRule","isInBoundary","getStartPoint","createMultiPoint","getEndPoint","_endpointMap","addEndpoint","getCoordinateN","it","entry","valence","getValue","count","getKey","pt","counter","Counter","Length_Length","x0","y0","PrintStream","StringReader","ByteArrayOutputStream","IOException","LineNumberReader","StringUtil_StringUtil","String","os","ps","printStackTrace","toString","depth","stackTrace","lineNumberReader","getStackTrace","readLine","NEWLINE","separator","separatorlen","tokenList","tmpString","pos","token","substring","res","SIMPLE_ORDINATE_FORMAT","format","chars","StringBuilder","str","append","setCharAt","substr","CoordinateSequences_CoordinateSequences","minDim","dim","setOrdinate","getOrdinate","cs1","cs2","cs1Size","fact","newseq","swap","copyCoord","cs","builder","createClosedRing","_points","expandEnvelope","isSimple","otherLineString","equal","getPointN","ofLine","createLineString","points","getCoordinateSequenceFactory","Puntal","Point_Point","_coordinates","getX","getY","IllegalStateException","point","Area_Area","ring","ofRingSigned","p0","StringBuffer","Integer","intValue","DD_DD","valueOf","selfMultiply","parse","strlen","charAt","isNegative","signCh","val","numDigits","numBeforeDec","isDigit","TEN","selfAdd","expStr","parseInt","ex","NumberFormatException","val2","numDecPlaces","scale","divide","multiply","negate","dd","xAbs","xLog10","xMag","buf","_hi","_lo","insertDecimalPoint","magnitude","mag","gt","lt","ONE","decimalPointPos","MAX_PRINT_DIGITS","digit","rebiasBy10","digitChar","subtract","continueExtractingDigits","remMag","isZero","le","selfDivide","yhi","ylo","tc","ty","C","U","hc","hy","u","SPLIT","createNaN","sqr","reciprocal","fhi","ceil","flo","ge","ax","axdd","d2","H","S","T","zhi","zlo","tx","hx","toStandardNotation","toSciNotation","specialStr","getSpecialNumberString","sigDigits","extractSignificantDigits","num","stringOfChar","numZeroes","SCI_NOT_ZERO","digits","SCI_NOT_EXPONENT_CHAR","trailingDigits","digitsWithDecimal","hi","lo","isPositive","PI","TWO_PI","PI_2","E","EPS","CGAlgorithmsDD_CGAlgorithmsDD","orientationIndexFilter","dx1","dy1","dx2","dy2","selfSubtract","signum","denom1","denom2","denom","numx1","numx2","fracP","doubleValue","numy1","numy2","fracQ","pa","pb","pc","detsum","detleft","detright","det","errbound","DP_SAFE_EPSILON","Orientation_Orientation","orientationIndex","nPts","hiPt","hiIndex","iPrev","iNext","prev","disc","CLOCKWISE","RIGHT","COUNTERCLOCKWISE","LEFT","COLLINEAR","STRAIGHT","Polygonal","Polygon_Polygon","_shell","shellCoordinates","_holes","ofRing","getCoordinateSequence","getNumInteriorRing","prevX","prevY","otherPolygon","thisShell","otherPolygonShell","clockwise","uniqueCoordinates","minCoordinate","scroll","isCCW","poly","getExteriorRing","convexHull","otherShell","shellComp","nHole1","nHole2","thisHole","getInteriorRingN","otherHole","rings","createLinearRing","shellCopy","holeCopies","shell","holes","hasNonEmptyElements","MultiPoint_MultiPoint","LinearRing_LinearRing","MINIMUM_VALID_SIZE","GeometryFactory_GeometryFactory","validateConstruction","MultiPolygon_MultiPolygon","createMultiPolygon","allRings","allRingsArray","polygons","GeometryEditor_GeometryEditor","isUserDataCopied","_isUserDataCopied","geometry","operation","editInternal","setUserData","getUserData","editGeometryCollection","editPolygon","edit","getClass","getName","collection","collectionForType","polygon","newPolygon","createPolygon","hole","GeometryEditorOperation","NoOpGeometryOperation","GeometryEditor_CoordinateOperation","GeometryEditor_CoordinateSequenceOperation","CoordinateOperation","CoordinateSequenceOperation","CoordinateArraySequence_CoordinateArraySequence","_dimension","cloneCoordinates","strBuilder","coordSeq","getCoordinateCopy","CoordinateArraySequenceFactory_CoordinateArraySequenceFactory","instanceObject","instance","jsts_Map","proto","objectOnly","_keys","_values","_itp","sharedSize","delete","has","list","TypeError","undefined","keys","sharedIterator","entries","context","done","itp","array2","v","MapImpl","Map","HashMap","PrecisionModel_PrecisionModel","pm1","pm2","otherPrecisionModel","_modelType","_scale","getMaximumSignificantDigits","otherSigDigits","FLOATING","FLOATING_SINGLE","description","FIXED","getScale","round","makePrecise","maxSigDigits","PrecisionModel_Type","nameToTypeMap","_name","Type","modelType","setScale","pm","maximumPreciseValue","multiPolygons","multiPolygonArray","geometryArray","multiLineStrings","multiLineStringArray","lineStringArray","multiPoints","multiPointArray","linearRings","linearRingArray","pointArray","polygonArray","exemplar","geomList","geomClass","isHeterogeneous","hasGeometryCollection","partClass","toGeometryArray","geom0","toPolygonArray","toLineStringArray","toPointArray","_coordinateSequenceFactory","GeometryFactory_CloneOp","_precisionModel","ptSeq","coordinateSequenceFactory","CloneOp","precisionModel","getDefaultCoordinateSequenceFactory","geometryTypes","GeoJSONParser_GeoJSONParser","geometryFactory","json","JSON","getGeometryType","extract","Feature","feature","read","bbox","FeatureCollection","featureCollection","features","sub","Point","MultiPoint","LineString","MultiLineString","Polygon","linearRing","MultiPolygon","GeometryCollection","multipoint","geoJson","linestring","multilinestring","shellGeoJson","holeGeoJson","multipolygon","GeoJSONReader_GeoJSONReader","parser","regExes","typeStr","emptyTypeStr","spaces","parenComma","doubleParenComma","trimParens","WKTParser_WKTParser","wkt","replace","matches","exec","search","toLowerCase","WKTParser_parse","extractGeometry","WKTParser_extract","wktType","join","linearring","coords","trim","split","parseFloat","components","lines","wktArray","WKTWriter_WKTWriter","write","Location_Location","locationValue","EXTERIOR","BOUNDARY","INTERIOR","NONE","Exception","NotRepresentableException_NotRepresentableException","HCoordinate_HCoordinate","px","py","pw","qx","qy","qw","xInt","yInt","_x","_y","_w","Distance_Distance","B","D","pointToSegment","noIntersection","r_num","len2","minDistance","dist","LineIntersector_LineIntersector","pdx","pdy","segmentIndex","intIndex","computeIntLineIndex","_intLineIndex","catBuilder","isEndPoint","_isProper","isCollinear","p3","p4","_inputLines","_result","computeIntersect","getEdgeDistance","hasIntersection","isInteriorIntersection","inputLineIndex","_intPt","NO_INTERSECTION","computeEdgeDistance","COLLINEAR_INTERSECTION","toLineString","getTopologySummary","ptIndex","_pa","_pb","DONT_INTERSECT","DO_INTERSECT","POINT_INTERSECTION","RobustLineIntersector_RobustLineIntersector","nearestPt","minDist","intPt","env0","env1","computeIntersection","n3","n4","normPt","smallestInAbsValue","intersection","nearestEndpoint","intersectionWithNormalization","isInSegmentEnvelopes","x3","x4","xabs","intPtDD","isIn","out","println","normalizeToEnvCentre","safeHCoordinateIntersection","p1q1p2","p1q2p2","q1p1q2","q1p2q2","n00","n01","n10","n11","minX0","minY0","maxX0","maxY0","minX1","minY1","maxX1","maxY1","intMidX","intMidY","Pq1","Pq2","Qp1","Qp2","computeCollinearIntersection","RayCrossingCounter_RayCrossingCounter","countSegment","isOnSegment","getLocation","_p","_isPointOnSegment","minx","maxx","orient","_crossingCount","PointLocation_PointLocation","lineIntersector","locatePointInRing","locateInRing","GeometryCollectionIterator_GeometryCollectionIterator","_atStart","isAtomic","_parent","_index","_subcollectionIterator","_max","UnsupportedOperationException","PointLocator_PointLocator","locate","loc","_isIn","_numBoundaries","updateLocationInfo","locateOnPoint","locateOnLineString","locateInPolygon","ml","mpoly","geomi","g2","computeLocation","isOnLine","shellLoc","locateInPolygonRing","holeLoc","_boundaryRule","boundaryRule","IntersectionMatrix_IntersectionMatrix","actualDimensionValue","requiredDimensionSymbol","actualDimensionSymbols","requiredDimensionSymbols","isDisjoint","_matrix","dimensionSymbols","row","col","toDimensionValue","column","minimumDimensionSymbols","setAtLeast","minimumDimensionValue","dimensionOfGeometryA","dimensionOfGeometryB","isTouches","ai","bi","toDimensionSymbol","temp","im","setAll","elements","Quadrant_Quadrant","quad","NE","NW","quad1","quad2","halfPlane","SE","SW","EdgeEnd_EdgeEnd","_dx","_dy","_quadrant","_p0","_p1","node","_node","angle","atan2","className","lastDotPos","lastIndexOf","print","_label","compareDirection","_edge","boundaryNodeRule","quadrant","edge","label","Position","ON","TopologyLocation_TopologyLocation","locValue","location","gl","newLoc","toLocationSymbol","posIndex","setLocation","locIndex","setAllLocations","Label_Label","lineLabel","elt","geomIndex","setAllLocationsIfNull","isLine","lbl","merge","flip","isArea","isAnyNull","side","isEqualOnSide","allPositionsEqual","onLoc","leftLoc","rightLoc","setLocations","EdgeEndBuilder_EdgeEndBuilder","eiCurr","eiNext","pNext","getLabel","eiPrev","pPrev","edges","computeEdgeEnds","eiList","getEdgeIntersectionList","addEndpoints","createEdgeEndForPrev","createEdgeEndForNext","GraphComponent_GraphComponent","isVisited","_isVisited","isInResult","_isInResult","_isCovered","_isCoveredSet","isCovered","getGeometryCount","computeIM","Node_Node","getEdges","getEdge","_coord","label2","eltIndex","nLoc","setLabel","argIndex","onLocation","_edges","mergeLabel","computeMergedLocation","insert","setNode","NodeMap_NodeMap","nodeMap","nodeFact","createNode","bdyNodes","addNode","TopologyException_TopologyException","msg","msgWithCoord","PointOnGeometryLocator","SimplePointInAreaLocator_SimplePointInAreaLocator","locatePointInPolygon","locateInGeometry","EdgeEndStar_EdgeEndStar","ee","_edgeList","iNextCW","startLoc","currLoc","geomGraph","computeEdgeEndLabels","getBoundaryNodeRule","checkAreaLabelsConsistent","lastEdgeIndex","eSearch","_edgeMap","_ptInAreaLocation","getGeometry","computeLabel","propagateSideLabels","hasDimensionalCollapseEdge","MonotoneChain","mc","si","mce","computeIntersectsForChain","chainIndex","SweepLineEvent_SweepLineEvent","_eventType","DELETE","deleteEventIndex","_deleteEventIndex","_obj","pe","_xValue","_insertEvent","INSERT","ev","insertEvent","EdgeSetIntersector","Collections","reverseOrder","alen","singletonList","util_Collections","SegmentIntersector","e0","segIndex0","e1","segIndex1","_li","getIntersectionNum","isAdjacentSegments","maxSegIndex","_properIntersectionPoint","isDoneWhenProperInt","_isDoneWhenProperInt","_hasProperInterior","li","isIntersection","_hasProper","_hasIntersection","_isDone","isBoundaryPointInternal","bdyNodes0","bdyNodes1","_bdyNodes","numTests","p00","p01","p10","p11","_recordIsolated","setIsolated","_numIntersections","isTrivialIntersection","_includeProper","isProper","addIntersections","getIntersection","isBoundaryPoint","_isSelfIntersection","includeProper","recordIsolated","SimpleMCSweepLineIntersector_SimpleMCSweepLineIntersector","events","isDelete","getInsertEvent","setDeleteEventIndex","nOverlaps","prepareEvents","isInsert","processOverlaps","getDeleteEventIndex","edges0","edges1","addEdges","computeIntersections","edgeSet","getMonotoneChainEdge","startIndex","getStartIndexes","ev0","mc0","getObject","ev1","mc1","isSameLabel","addEdge","ItemVisitor","item","IntervalRTreeNode_IntervalRTreeNode","_min","queryMin","queryMax","IntervalRTreeNode_NodeComparator","mid1","mid2","NodeComparator","POSITIVE_INFINITY","IntervalRTreeLeafNode_IntervalRTreeLeafNode","visitor","visitItem","_item","IntervalRTreeBranchNode_IntervalRTreeBranchNode","_node1","query","_node2","buildExtent","SortedPackedIntervalRTree_SortedPackedIntervalRTree","_leaves","buildLevel","_root","buildTree","_level","buildRoot","LineSegment_LineSegment","seg","orient0","orient1","geomFactory","projectionFactor","pf0","pf1","newp0","project","newp1","pointToLinePerpendicular","midPoint","closestPt","close00","closestPoint","close01","close10","close11","factor","comp0","segmentLengthFraction","offsetDistance","segx","segy","ux","uy","ls","setCoordinates","inputPt","segFrac","segmentToSegment","bits0","java","lang","hash0","bits1","LinearComponentExtracter_LinearComponentExtracter","buildGeometry","getLines","forceToLineString","geoms","_isForcedToLineString","_lines","isForcedToLineString","ArrayListVisitor_ArrayListVisitor","_items","IndexedPointInAreaLocator_IndexedPointInAreaLocator","rcc","IndexedPointInAreaLocator_SegmentVisitor","_counter","IndexedPointInAreaLocator_IntervalIndexedGeometry","addLine","getItems","SegmentVisitor","IntervalIndexedGeometry","EdgeIntersection_EdgeIntersection","maxSegmentIndex","EdgeIntersectionList_EdgeIntersectionList","_nodeMap","edgeList","ei","newEdge","createSplitEdge","ei0","ei1","lastSegStartPt","useIntPt1","ipt","Edge_Edge","eiNew","MonotoneChainIndexer_MonotoneChainIndexer","startIndexList","findChainEnd","toIntArray","chainQuad","MonotoneChainEdge_MonotoneChainEdge","chainIndex0","chainIndex1","start0","end0","start1","end1","overlaps","mid0","mcb","getChainStartIndices","Depth_Depth","NULL_VALUE","_depth","depthValue","minDepth","newValue","depthAtLocation","updateIM","setAtLeastIfValid","newPts","toLineLabel","_isIsolated","isIsolated","isEqualForward","isEqualReverse","iRev","_depthDelta","_mce","_env","normalizedSegmentIndex","nextSegIndex","nextPt","depthDelta","addIntersection","DirectedEdge_DirectedEdge","currLocation","nextLocation","_nextMin","_isForward","_next","depthVal","isInteriorAreaEdge","nextMin","getDepthDelta","minEdgeRing","_minEdgeRing","isExteriorIfArea0","isExteriorIfArea1","edgeRing","_edgeRing","_sym","printReverse","de","setVisited","directionFactor","oppositePos","opposite","oppositeDepth","setDepth","isForward","computeDirectedLabel","NodeFactory_NodeFactory","PlanarGraph_PlanarGraph","nodes","nodeit","linkResultDirectedEdges","_nodes","find","linkAllDirectedEdges","ep0","ep1","_edgeEndList","eCoord","matchInSameDirection","getEdgeEnds","edgesToAdd","de1","de2","setSym","GeometryGraph_GeometryGraph","determineBoundary","_boundaryNodeRule","computeRingSelfNodes","computeSelfNodes","isDoneIfProperInt","setIsDoneIfProperInt","esi","createEdgeSetIntersector","isRings","_parentGeom","computeAllSegments","addSelfIntersectionNodes","_argIndex","edgelist","addSplitEdges","setBoundaryNodes","getBoundaryNodes","_hasTooFewPoints","insertPoint","addPolygonRing","insertEdge","removeRepeatedPoints","_invalidPoint","_lineEdgeMap","insertBoundaryPoint","_boundaryNodes","isBoundaryNode","_useBoundaryDeterminationRule","lr","cwLeft","cwRight","eLoc","eiIt","addSelfIntersectionNode","addPolygon","addLineString","addPoint","addCollection","_areaPtLocator","_ptLocator","findEdge","parentGeom","EdgeEndBundle_EdgeEndBundle","_edgeEnds","foundInterior","computeLabelSide","computeLabelOn","computeLabelSides","getDirectedCoordinate","EdgeEndBundleStar_EdgeEndBundleStar","eb","insertEdgeEnd","RelateNode_RelateNode","RelateNodeFactory_RelateNodeFactory","RelateComputer_RelateComputer","intersector","dimA","_arg","dimB","hasProper","hasProperIntersection","hasProperInterior","hasProperInteriorIntersection","thisIndex","targetIndex","getEdgeIterator","labelIsolatedEdge","_isolatedEdges","target","computeDisjointIM","computeEdgeIntersections","computeIntersectionNodes","copyNodesAndLabels","labelIsolatedNodes","computeProperIntersectionIM","eeBuilder","ee0","insertEdgeEnds","ee1","labelNodeEdges","labelIsolatedEdges","ni","computeLabelling","getNodeIterator","graphNode","setLabelBoundary","labelIsolatedNode","updateIMFromEdges","ga","gb","_im","arg","GeometryGraphOperation","_resultPrecisionModel","setPrecisionModel","g0","setComputationPrecision","g1","RectangleContains_RectangleContains","rectangle","isPointContainedInBoundary","isLineStringContainedInBoundary","isContainedInBoundary","_rectEnv","isLineSegmentContainedInBoundary","RectangleLineIntersector_RectangleLineIntersector","segEnv","isSegUpwards","_diagDown0","_diagDown1","_diagUp0","_diagUp1","rectEnv","ShortCircuitedGeometryVisitor_ShortCircuitedGeometryVisitor","applyTo","visit","RectangleIntersects","RectangleIntersects_EnvelopeIntersectsVisitor","ecpVisitor","RectangleIntersects_GeometryContainsPointVisitor","_rectangle","containsPoint","riVisitor","RectangleIntersects_RectangleIntersectsSegmentVisitor","_intersects","elementEnv","_containsPoint","rectPt","_rectSeq","containsPointInPolygon","checkIntersectionWithLineStrings","testLine","checkIntersectionWithSegments","seq1","_rectIntersector","RelateOp_RelateOp","isRectangle","getIntersectionMatrix","isCovers","isGeometryCollection","isIntersects","isOverlaps","isCrosses","isContains","_relate","Base","Function","filterFunction","options","filter_classCallCheck","filter_possibleConstructorReturn","filter_getPrototypeOf","filterFunction_","cqlFilter_","isNullOrEmpty","cqlFilter","Spatial","FunctionParam","toCQLFilter","wktFormat","WKT","formatedGeometry","intersect","param","paramParameter","layer","Vector","_toConsumableArray","getFeatures","isArray","isObject","parseParamToGeometries","geometryToFilter","geojsonParser","GeoJSONReader","jtsGeomToFilter","some","jtsGeom","RelateOp","MODES","mapAttributions","layerAttributions","mixed","attributions_classCallCheck","attributions_possibleConstructorReturn","attributions_getPrototypeOf","includes","url","layerName","controls_","mode_","url_","config","attributions","type_","layerName_","layer_","scale_","attributionParam_","attributionParam","urlParam_","urlParam","minWidth_","minWidth","maxWidth_","maxWidth","defaultAttribution_","defaultAttribution","defaultURL_","defaultURL","tooltip_","tooltip","window","setCollapsiblePanel","Plugin","impl_","AttributionsImpl","control_","panel_","ui","Panel","collapsible","innerWidth","collapsedButtonClass","addControls","addPanels","initMode","onMoveEnd","changeAttributions","optionsLayer","GeoJSON","displayInLayerSwitcher","KML","getLayers","addLayers","setVisible","clearContent","getMapAttributions","addContent","attribution","getElement","links","attrOpt","arr","link","document","createElement","href","innerHTML","div","querySelectorAll","child","removeChild","visibility","style","display","_this3","updateBBoxFeature","featuresAttributions","bboxFeature_","execute","getAttribute","getPanel","collapse","content","changeContent","_this$map_$getBbox","getBbox","properties","getTemplatePanel","classList","registerEvent","plugin","M$plugin$Attributions","M$control$AttributionsControl","M$impl$control$AttributionsControl"],"mappings":"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","file":"attributions.ol.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = \"<div id=\\\"m-attributions-container\\\" class=\\\"m-control m-container m-attributions\\\">\\n    <button id='close-button' class=\\\"{{icon}}\\\"></button>\\n</div>\";","/**\n * @classdesc\n */\nclass Attributions extends M.Object {\n  /**\n   * @constructor\n   */\n  constructor(map) {\n    super();\n\n    /**\n     * Map of the plugin\n     * @private\n     * @type {M.Map}\n     */\n    this.map_ = map;\n  }\n\n  /**\n   * Register events in ol.Map of M.Map\n   * @public\n   * @function\n   */\n  registerEvent(type, callback) {\n    const olMap = this.map_.getMapImpl();\n\n    olMap.on(type, callback);\n  }\n}\n\nexport default Attributions;\n","/**\n * @module M/impl/control/AttributionsControl\n */\nexport default class AttributionsControl extends M.impl.Control {\n  /**\n   * This function adds the control to the specified map\n   *\n   * @public\n   * @function\n   * @param {M.Map} map to add the plugin\n   * @param {HTMLElement} html of the plugin\n   * @api stable\n   */\n  addTo(map, html) {\n    const olMap = map.getMapImpl();\n    olMap.getInteractions().forEach((interaction) => {\n      if (interaction instanceof ol.interaction.DoubleClickZoom) {\n        this.dblClickInteraction_ = interaction;\n      }\n    });\n    // super addTo - don't delete\n    super.addTo(map, html);\n  }\n}\n","import Long from './Long';\n\nexport default function Double () {}\n\nDouble.isNaN = n => Number.isNaN(n)\nDouble.isInfinite = n => !Number.isFinite(n)\nDouble.MAX_VALUE = Number.MAX_VALUE\n\nif (typeof Float64Array == 'function' &&\n\t  typeof Int32Array == 'function') {\n\t// Simple and fast conversion between double and long bits\n\t// using TypedArrays and ArrayViewBuffers.\n\t(function() {\n\t\tvar EXP_BIT_MASK = 0x7ff00000;\n\t\tvar SIGNIF_BIT_MASK = 0xFFFFF;\n\t\tvar f64buf = new Float64Array(1);\n\t\tvar i32buf = new Int32Array(f64buf.buffer);\n\t\tDouble.doubleToLongBits = function (value) {\n\t\t\tf64buf[0] = value;\n\t\t\tvar low = i32buf[0] | 0;\n\t\t\tvar high = i32buf[1] | 0;\n\t\t\t// Check for NaN based on values of bit fields, maximum\n\t\t\t// exponent and nonzero significand.\n\t\t\tif (((high & EXP_BIT_MASK) === EXP_BIT_MASK) &&\n\t\t\t\t((high & SIGNIF_BIT_MASK) !== 0) &&\n\t\t\t\t(low !== 0)) {\n\t\t\t\tlow = 0 | 0;\n\t\t\t\thigh = 0x7ff80000 | 0;\n\t\t\t}\n\t\t\treturn new Long(high, low);\n\t\t};\n\t\tDouble.longBitsToDouble = function (bits) {\n\t\t\ti32buf[0] = bits.low;\n\t\t\ti32buf[1] = bits.high;\n\t\t\treturn f64buf[0];\n\t\t};\n\t})();\n} else {\n\t// More complex and slower fallback implementation using \n\t// math and the divide-by-two and multiply-by-two algorithms.\n\t(function() {\n\t\tvar BIAS = 1023;\n\t\tvar log2 = Math.log2;\n\t\tvar floor = Math.floor;\n\t\tvar pow = Math.pow;\n\t\tvar MAX_REL_BITS_INTEGER = (function () {\n\t\t\tfor (var i = 53; i > 0; i--) {\n\t\t\t\tvar bits = pow(2, i) - 1;\n\t\t\t\tif (floor(log2(bits)) + 1 === i) {\n\t\t\t\t\treturn bits;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t})();\n\t\tDouble.doubleToLongBits = function (value) {\n\t\t\tvar x, y, f, bits, skip;\n\t\t\tvar sign, exp, high, low;\n\t\n\t\t\t// Get the sign bit and absolute value.\n\t\t\tif (value < 0 || 1 / value === Number.NEGATIVE_INFINITY) {\n\t\t\t\tsign = (1 << 31);\n\t\t\t\tvalue = (-value);\n\t\t\t} else {\n\t\t\t\tsign = 0;\n\t\t\t}\n\t\n\t\t\t// Handle some special values.\n\t\t\tif (value === 0) {\n\t\t\t\t// Handle zeros (+/-0).\n\t\t\t\tlow = 0 | 0;\n\t\t\t\thigh = sign; // exponent: 00..00, significand: 00..00\n\t\t\t\treturn new Long(high, low);\n\t\t\t}\n\t\n\t\t\tif (value === Infinity) {\n\t\t\t\t// Handle infinity (only positive values for value possible).\n\t\t\t\tlow = 0 | 0;\n\t\t\t\thigh = sign | 0x7ff00000; // exponent: 11..11, significand: 00..00\n\t\t\t\treturn new Long(high, low);\n\t\t\t}\n\t\n\t\t\tif (value !== value) {\n\t\t\t\t// Handle NaNs (boiled down to only one distinct NaN).\n\t\t\t\tlow = 0 | 0;\n\t\t\t\thigh = 0x7ff80000; // exponent: 11..11, significand: 10..00\n\t\t\t\treturn new Long(high, low);\n\t\t\t}\n\t\n\t\t\t// Preinitialize variables, that are not neccessarily set by\n\t\t\t// the algorithm.\n\t\t\tbits = 0;\n\t\t\tlow = 0 | 0;\n\t\n\t\t\t// Get the (always positive) integer part of value.\n\t\t\tx = floor(value);\n\t\n\t\t\t// Process the integer part if it's greater than 1. Zero requires\n\t\t\t// no bits at all, 1 represents the implicit (hidden) leading bit,\n\t\t\t// which must not be written as well.\n\t\t\tif (x > 1) {\n\t\t\t\t// If we can reliably determine the number of bits required for\n\t\t\t\t// the integer part,\n\t\t\t\tif (x <= MAX_REL_BITS_INTEGER) {\n\t\t\t\t\t// get the number of bits required to represent it minus 1\n\t\t\t\t\tbits = floor(log2(x)) /* + 1 - 1*/ ;\n\t\t\t\t\t// and simply copy/shift the integer bits into low and high.\n\t\t\t\t\t// That's much faster than the divide-by-two algorithm (saves\n\t\t\t\t\t// up to ~60%).\n\t\t\t\t\t// We always need to mask out the most significant bit, which\n\t\t\t\t\t// is the implicit (aka hidden) bit.\n\t\t\t\t\tif (bits <= 20) {\n\t\t\t\t\t\t// The simple case in which the integer fits into the\n\t\t\t\t\t\t// lower 20 bits of the high word is worth to be handled\n\t\t\t\t\t\t// separately (saves ~25%).\n\t\t\t\t\t\tlow = 0 | 0;\n\t\t\t\t\t\thigh = (x << (20 - bits)) & 0xfffff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Here, the integer part is split into low and high.\n\t\t\t\t\t\t// Since its value may require more than 32 bits, we\n\t\t\t\t\t\t// cannot use bitwise operators (which implicitly cast\n\t\t\t\t\t\t// to Int32), but use arithmetic operators % and / to\n\t\t\t\t\t\t// get low and high parts. The uppper 20 bits go to high,\n\t\t\t\t\t\t// the remaining bits (in f) to low.\n\t\t\t\t\t\tf = bits - 20;\n\t\t\t\t\t\t// Like (1 << f) but safe with even more than 32 bits.\n\t\t\t\t\t\ty = pow(2, f);\n\t\t\t\t\t\tlow = (x % y) << (32 - f);\n\t\t\t\t\t\thigh = (x / y) & 0xfffff;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// For greater values, we must use the much slower divide-by-two\n\t\t\t\t\t// algorithm. Bits are generated from right to left, that is from\n\t\t\t\t\t// least to most significant bit. For each bit, we left-shift both\n\t\t\t\t\t// low and high by one and carry bit #0 from high to #31 in low.\n\t\t\t\t\t// The next bit is then copied into bit #19 in high, the leftmost\n\t\t\t\t\t// bit of the double's significand.\n\t\n\t\t\t\t\t// Preserve x for later user, so work with f.\n\t\t\t\t\tf = x;\n\t\t\t\t\tlow = 0 | 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\ty = f / 2;\n\t\t\t\t\t\tf = floor(y);\n\t\t\t\t\t\tif (f === 0) {\n\t\t\t\t\t\t\t// We just found the most signigicant (1-)bit, which\n\t\t\t\t\t\t\t// is the implicit bit and so, not stored in the double\n\t\t\t\t\t\t\t// value. So, it's time to leave the loop.\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Count this bit, shift low and carry bit #0 from high.\n\t\t\t\t\t\tbits++;\n\t\t\t\t\t\tlow >>>= 1;\n\t\t\t\t\t\tlow |= (high & 0x1) << 31;\n\t\t\t\t\t\t// Shift high.\n\t\t\t\t\t\thigh >>>= 1;\n\t\t\t\t\t\tif (y !== f) {\n\t\t\t\t\t\t\t// Copy the new bit into bit #19 in high (only required if 1).\n\t\t\t\t\t\t\thigh |= 0x80000;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Bias the exponent.\n\t\t\texp = bits + BIAS;\n\t\n\t\t\t// If the integer part is zero, we've not yet seen the implicit\n\t\t\t// leading bit. Variable skip is later used while processing the \n\t\t\t// fractional part (if any).\n\t\t\tskip = (x === 0);\n\t\n\t\t\t// Get fraction only into x.\n\t\t\tx = value - x;\n\t\n\t\t\t// If some significand bits are still left to be filled and\n\t\t\t// the fractional part is not zero, convert the fraction using\n\t\t\t// the multiply-by-2 algorithm.\n\t\t\tif (bits < 52 && x !== 0) {\n\t\n\t\t\t\t// Initialize 'buffer' f, into which newly created bits get\n\t\t\t\t// shifted from right to left.\n\t\t\t\tf = 0;\n\t\n\t\t\t\twhile (true) {\n\t\t\t\t\ty = x * 2;\n\t\t\t\t\tif (y >= 1) {\n\t\t\t\t\t\t// This is a new 1-bit. Add and count this bit, if not\n\t\t\t\t\t\t// prohibited by skip.\n\t\t\t\t\t\tx = y - 1;\n\t\t\t\t\t\tif (!skip) {\n\t\t\t\t\t\t\tf <<= 1;\n\t\t\t\t\t\t\tf |= 1;\n\t\t\t\t\t\t\tbits++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Otherwise, decrement the exponent and unset\n\t\t\t\t\t\t\t// skip, so that all following bits get written.\n\t\t\t\t\t\t\texp--;\n\t\t\t\t\t\t\tskip = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// This is a new 0-bit. Add and count this bit, if not\n\t\t\t\t\t\t// prohibited by skip.\n\t\t\t\t\t\tx = y;\n\t\t\t\t\t\tif (!skip) {\n\t\t\t\t\t\t\tf <<= 1;\n\t\t\t\t\t\t\tbits++;\n\t\t\t\t\t\t} else if (--exp === 0) {\n\t\t\t\t\t\t\t// Otherwise we've just decremented the exponent. If the\n\t\t\t\t\t\t\t// biased exponent is zero now (-1023), we process a\n\t\t\t\t\t\t\t// subnormal number, which has no impled leading 1-bit.\n\t\t\t\t\t\t\t// So, count this 0-bit and unset skip to write out\n\t\t\t\t\t\t\t// all the following bits.\n\t\t\t\t\t\t\tbits++;\n\t\t\t\t\t\t\tskip = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (bits === 20) {\n\t\t\t\t\t\t// When 20 bits have been created in total, we're done with\n\t\t\t\t\t\t// the high word. Copy the bits from 'buffer' f into high\n\t\t\t\t\t\t// and reset 'buffer' f. Following bits will end up in the\n\t\t\t\t\t\t// low word.\n\t\t\t\t\t\thigh |= f;\n\t\t\t\t\t\tf = 0;\n\t\t\t\t\t} else if (bits === 52) {\n\t\t\t\t\t\t// When 52 bits have been created in total, we're done with\n\t\t\t\t\t\t// low word as well. Copy the bits from 'buffer' f into low\n\t\t\t\t\t\t// and exit the loop.\n\t\t\t\t\t\tlow |= f;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (y === 1) {\n\t\t\t\t\t\t// When y is exactly 1, there is no remainder and the process\n\t\t\t\t\t\t// is complete (the number is finite). Copy the bits from\n\t\t\t\t\t\t// 'buffer' f into either low or high and exit the loop.\n\t\t\t\t\t\tif (bits < 20) {\n\t\t\t\t\t\t\thigh |= (f << (20 - bits));\n\t\t\t\t\t\t} else if (bits < 52) {\n\t\t\t\t\t\t\tlow |= (f << (52 - bits));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Copy/shift the exponent and sign bits into the high word.\n\t\t\thigh |= (exp << 20);\n\t\t\thigh |= sign;\n\t\n\t\t\treturn new Long(high, low);\n\t\t};\n\t\tDouble.longBitsToDouble = function (bits) {\n\t\t\tvar x, sign, exp, fract;\n\t\t\tvar high = bits.high;\n\t\t\tvar low = bits.low;\n\t\n\t\t\t// Extract the sign.\n\t\t\tsign = (high & (1 << 31)) ? -1 : 1;\n\t\n\t\t\t// Extract the unbiased exponent.\n\t\t\texp = ((high & 0x7ff00000) >> 20) - BIAS;\n\t\n\t\t\t// Calculate the fraction from left to right. Start\n\t\t\t// off with the 20 lower bits from the high word.\n\t\t\tfract = 0;\n\t\t\tx = (1 << 19);\n\t\t\tfor (var i = 1; i <= 20; i++) {\n\t\t\t\tif (high & x) {\n\t\t\t\t\tfract += pow(2, -i);\n\t\t\t\t}\n\t\t\t\tx >>>= 1;\n\t\t\t}\n\t\t\t// Continue with all 32 bits from the low word.\n\t\t\tx = (1 << 31);\n\t\t\tfor (var i = 21; i <= 52; i++) {\n\t\t\t\tif (low & x) {\n\t\t\t\t\tfract += pow(2, -i);\n\t\t\t\t}\n\t\t\t\tx >>>= 1;\n\t\t\t}\n\t\n\t\t\t// Handle special values.\n\t\t\t// Check for zero and subnormal values.\n\t\t\tif (exp === -BIAS) {\n\t\t\t\tif (fract === 0) {\n\t\t\t\t\t// +/-1.0 * 0.0 => +/-0.0\n\t\t\t\t\treturn sign * 0;\n\t\t\t\t}\n\t\t\t\texp = -1022;\n\t\t\t}\n\t\t\t// Check for +/-Infinity or NaN.\n\t\t\telse if (exp === BIAS + 1) {\n\t\t\t\tif (fract === 0) {\n\t\t\t\t\t// +/-1.0 / 0.0 => +/-Infinity\n\t\t\t\t\treturn sign / 0;\n\t\t\t\t}\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// Nothing special? Seems to be a normal number.\n\t\t\telse {\n\t\t\t\t// Add the implicit leading bit (1*2^0).\n\t\t\t\tfract += 1;\n\t\t\t}\n\t\n\t\t\treturn sign * fract * pow(2, exp);\n\t\t};\n\t})();\n}","/**\n * @module M/control/AttributionsControl\n */\nimport AttributionsImplControl from '../../impl/ol/js/attributionscontrol';\nimport template from '../../templates/attributions';\n\n/**\n * @classdesc\n * Main constructor of the class. Creates a PluginControl\n * control\n */\nexport default class AttributionsControl extends M.Control {\n  /**\n   * @constructor\n   * @extends {M.Control}\n   * @api\n   */\n  constructor(position, closePanel) {\n    if (M.utils.isUndefined(AttributionsImplControl)) {\n      M.exception('La implementacin usada no puede crear controles AttributionsControl');\n    }\n    const impl = new AttributionsImplControl();\n    super(impl, 'Attributions');\n    this.position = position;\n    this.closePanel = closePanel;\n  }\n\n  /**\n   * This function creates the view\n   *\n   * @public\n   * @function\n   * @param {M.Map} map to add the control\n   * @api\n   */\n  createView(map) {\n    this.map = map;\n    return new Promise((success, fail) => {\n      const html = M.template.compileSync(template, {\n        vars: {\n          icon: this.position === 'BR' || this.position === 'TR' ?\n            'g-cartografia-flecha-derecha' : 'g-cartografia-flecha-izquierda',\n        },\n      });\n      html.querySelector('#close-button').addEventListener('click', () => this.closePanel());\n      this.html_ = html;\n\n      success(html);\n    });\n  }\n\n  /**\n   * This function compares controls\n   *\n   * @public\n   * @function\n   * @param {M.Control} control to compare\n   * @api\n   */\n  equals(control) {\n    return control instanceof AttributionsControl;\n  }\n}\n","export default function (o, i) {\n  return o.interfaces_ && o.interfaces_.indexOf(i) > -1\n}\n","export default function Clonable () {}\n","import Cloneable from '../../../../java/lang/Cloneable';\nexport default class CoordinateSequence {\n\tconstructor() {\n\t\tCoordinateSequence.constructor_.apply(this, arguments);\n\t}\n\tsetOrdinate(index, ordinateIndex, value) {}\n\tsize() {}\n\tgetOrdinate(index, ordinateIndex) {}\n\tgetCoordinate() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet i = arguments[0];\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet index = arguments[0], coord = arguments[1];\n\t\t}\n\t}\n\tgetCoordinateCopy(i) {}\n\tgetDimension() {}\n\tgetX(index) {}\n\texpandEnvelope(env) {}\n\tcopy() {}\n\tgetY(index) {}\n\ttoCoordinateArray() {}\n\tgetClass() {\n\t\treturn CoordinateSequence;\n\t}\n\tget interfaces_() {\n\t\treturn [Cloneable];\n\t}\n}\nCoordinateSequence.constructor_ = function () {};\nCoordinateSequence.X = 0;\nCoordinateSequence.Y = 1;\nCoordinateSequence.Z = 2;\nCoordinateSequence.M = 3;\n","import hasInterface from '../../../../hasInterface';\nimport CoordinateSequence from './CoordinateSequence';\nexport default class CoordinateSequenceFactory {\n\tconstructor() {\n\t\tCoordinateSequenceFactory.constructor_.apply(this, arguments);\n\t}\n\tcreate() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordSeq = arguments[0];\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet size = arguments[0], dimension = arguments[1];\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn CoordinateSequenceFactory;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCoordinateSequenceFactory.constructor_ = function () {};\n","export default function IllegalArgumentException (message) {\n  this.message = message\n}\n","export default class GeometryComponentFilter {\n\tconstructor() {\n\t\tGeometryComponentFilter.constructor_.apply(this, arguments);\n\t}\n\tfilter(geom) {}\n\tgetClass() {\n\t\treturn GeometryComponentFilter;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGeometryComponentFilter.constructor_ = function () {};\n","export default function Comparable () {}\n","export default function Serializable () {}\n","export default class NumberUtil {\n\tconstructor() {\n\t\tNumberUtil.constructor_.apply(this, arguments);\n\t}\n\tstatic equalsWithTolerance(x1, x2, tolerance) {\n\t\treturn Math.abs(x1 - x2) <= tolerance;\n\t}\n\tgetClass() {\n\t\treturn NumberUtil;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nNumberUtil.constructor_ = function () {};\n","export default function Long(high, low) {\n  this.low = low | 0\n  this.high = high | 0\n}\n\nLong.toBinaryString = function (i) {\n  var result = ''\n  for (var mask = 0x80000000; mask > 0; mask >>>= 1)\n    result += (i.high & mask) === mask ? '1' : '0'\n  for (var mask = 0x80000000; mask > 0; mask >>>= 1)\n    result += (i.low & mask) === mask ? '1' : '0'\n  return result\n}","export default function Comparator () {}\n","export default function RuntimeException (message) {\n  this.name = 'RuntimeException'\n  this.message = message\n  this.stack = (new Error()).stack\n  Error.call(this, message)\n}\n\nRuntimeException.prototype = Object.create(Error.prototype)\nRuntimeException.prototype.constructor = Error\n","import RuntimeException from '../../../../java/lang/RuntimeException';\nexport default class AssertionFailedException extends RuntimeException {\n\tconstructor() {\n\t\tsuper();\n\t\tAssertionFailedException.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn AssertionFailedException;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nAssertionFailedException.constructor_ = function () {\n\tif (arguments.length === 0) {\n\t\tRuntimeException.constructor_.call(this);\n\t} else if (arguments.length === 1) {\n\t\tlet message = arguments[0];\n\t\tRuntimeException.constructor_.call(this, message);\n\t}\n};\n","import AssertionFailedException from './AssertionFailedException';\nexport default class Assert {\n\tconstructor() {\n\t\tAssert.constructor_.apply(this, arguments);\n\t}\n\tstatic shouldNeverReachHere() {\n\t\tif (arguments.length === 0) {\n\t\t\tAssert.shouldNeverReachHere(null);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet message = arguments[0];\n\t\t\tthrow new AssertionFailedException(\"Should never reach here\" + (message !== null ? \": \" + message : \"\"));\n\t\t}\n\t}\n\tstatic isTrue() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet assertion = arguments[0];\n\t\t\tAssert.isTrue(assertion, null);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet assertion = arguments[0], message = arguments[1];\n\t\t\tif (!assertion) {\n\t\t\t\tif (message === null) {\n\t\t\t\t\tthrow new AssertionFailedException();\n\t\t\t\t} else {\n\t\t\t\t\tthrow new AssertionFailedException(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic equals() {\n\t\tif (arguments.length === 2) {\n\t\t\tlet expectedValue = arguments[0], actualValue = arguments[1];\n\t\t\tAssert.equals(expectedValue, actualValue, null);\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet expectedValue = arguments[0], actualValue = arguments[1], message = arguments[2];\n\t\t\tif (!actualValue.equals(expectedValue)) {\n\t\t\t\tthrow new AssertionFailedException(\"Expected \" + expectedValue + \" but encountered \" + actualValue + (message !== null ? \": \" + message : \"\"));\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn Assert;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nAssert.constructor_ = function () {};\n","import NumberUtil from '../util/NumberUtil';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Double from '../../../../java/lang/Double';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport Comparator from '../../../../java/util/Comparator';\nimport Serializable from '../../../../java/io/Serializable';\nimport Assert from '../util/Assert';\nexport default class Coordinate {\n\tconstructor() {\n\t\tCoordinate.constructor_.apply(this, arguments);\n\t}\n\tstatic hashCode() {\n\t\tif (arguments.length === 1 && typeof arguments[0] === \"number\") {\n\t\t\tlet x = arguments[0];\n\t\t\tvar f = Double.doubleToLongBits(x);\n\t\t\treturn Math.trunc(f ^ f >>> 32);\n\t\t}\n\t}\n\tsetOrdinate(ordinateIndex, value) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase Coordinate.X:\n\t\t\t\tthis.x = value;\n\t\t\t\tbreak;\n\t\t\tcase Coordinate.Y:\n\t\t\t\tthis.y = value;\n\t\t\t\tbreak;\n\t\t\tcase Coordinate.Z:\n\t\t\t\tthis.z = value;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n\t\t}\n\t}\n\tequals2D() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet other = arguments[0];\n\t\t\tif (this.x !== other.x) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.y !== other.y) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet c = arguments[0], tolerance = arguments[1];\n\t\t\tif (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tgetOrdinate(ordinateIndex) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase Coordinate.X:\n\t\t\t\treturn this.x;\n\t\t\tcase Coordinate.Y:\n\t\t\t\treturn this.y;\n\t\t\tcase Coordinate.Z:\n\t\t\t\treturn this.z;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n\t}\n\tequals3D(other) {\n\t\treturn this.x === other.x && this.y === other.y && (this.z === other.z || Double.isNaN(this.z) && Double.isNaN(other.z));\n\t}\n\tequals(other) {\n\t\tif (!(other instanceof Coordinate)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.equals2D(other);\n\t}\n\tequalInZ(c, tolerance) {\n\t\treturn NumberUtil.equalsWithTolerance(this.z, c.z, tolerance);\n\t}\n\tcompareTo(o) {\n\t\tvar other = o;\n\t\tif (this.x < other.x) return -1;\n\t\tif (this.x > other.x) return 1;\n\t\tif (this.y < other.y) return -1;\n\t\tif (this.y > other.y) return 1;\n\t\treturn 0;\n\t}\n\tclone() {\n\t\ttry {\n\t\t\tvar coord = null;\n\t\t\treturn coord;\n\t\t} catch (e) {\n\t\t\tif (e instanceof CloneNotSupportedException) {\n\t\t\t\tAssert.shouldNeverReachHere(\"this shouldn't happen because this class is Cloneable\");\n\t\t\t\treturn null;\n\t\t\t} else throw e;\n\t\t} finally {}\n\t}\n\tcopy() {\n\t\treturn new Coordinate(this);\n\t}\n\ttoString() {\n\t\treturn \"(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\n\t}\n\tdistance3D(c) {\n\t\tvar dx = this.x - c.x;\n\t\tvar dy = this.y - c.y;\n\t\tvar dz = this.z - c.z;\n\t\treturn Math.sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n\tdistance(c) {\n\t\tvar dx = this.x - c.x;\n\t\tvar dy = this.y - c.y;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\thashCode() {\n\t\tvar result = 17;\n\t\tresult = 37 * result + Coordinate.hashCode(this.x);\n\t\tresult = 37 * result + Coordinate.hashCode(this.y);\n\t\treturn result;\n\t}\n\tsetCoordinate(other) {\n\t\tthis.x = other.x;\n\t\tthis.y = other.y;\n\t\tthis.z = other.z;\n\t}\n\tgetClass() {\n\t\treturn Coordinate;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparable, Cloneable, Serializable];\n\t}\n}\nclass DimensionalComparator {\n\tconstructor() {\n\t\tDimensionalComparator.constructor_.apply(this, arguments);\n\t}\n\tstatic compare(a, b) {\n\t\tif (a < b) return -1;\n\t\tif (a > b) return 1;\n\t\tif (Double.isNaN(a)) {\n\t\t\tif (Double.isNaN(b)) return 0;\n\t\t\treturn -1;\n\t\t}\n\t\tif (Double.isNaN(b)) return 1;\n\t\treturn 0;\n\t}\n\tcompare(o1, o2) {\n\t\tvar c1 = o1;\n\t\tvar c2 = o2;\n\t\tvar compX = DimensionalComparator.compare(c1.x, c2.x);\n\t\tif (compX !== 0) return compX;\n\t\tvar compY = DimensionalComparator.compare(c1.y, c2.y);\n\t\tif (compY !== 0) return compY;\n\t\tif (this._dimensionsToTest <= 2) return 0;\n\t\tvar compZ = DimensionalComparator.compare(c1.z, c2.z);\n\t\treturn compZ;\n\t}\n\tgetClass() {\n\t\treturn DimensionalComparator;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparator];\n\t}\n}\nDimensionalComparator.constructor_ = function () {\n\tthis._dimensionsToTest = 2;\n\tif (arguments.length === 0) {\n\t\tDimensionalComparator.constructor_.call(this, 2);\n\t} else if (arguments.length === 1) {\n\t\tlet dimensionsToTest = arguments[0];\n\t\tif (dimensionsToTest !== 2 && dimensionsToTest !== 3) throw new IllegalArgumentException(\"only 2 or 3 dimensions may be specified\");\n\t\tthis._dimensionsToTest = dimensionsToTest;\n\t}\n};\nCoordinate.DimensionalComparator = DimensionalComparator;\nCoordinate.constructor_ = function () {\n\tthis.x = null;\n\tthis.y = null;\n\tthis.z = null;\n\tif (arguments.length === 0) {\n\t\tCoordinate.constructor_.call(this, 0.0, 0.0);\n\t} else if (arguments.length === 1) {\n\t\tlet c = arguments[0];\n\t\tCoordinate.constructor_.call(this, c.x, c.y, c.z);\n\t} else if (arguments.length === 2) {\n\t\tlet x = arguments[0], y = arguments[1];\n\t\tCoordinate.constructor_.call(this, x, y, Coordinate.NULL_ORDINATE);\n\t} else if (arguments.length === 3) {\n\t\tlet x = arguments[0], y = arguments[1], z = arguments[2];\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t}\n};\nCoordinate.serialVersionUID = 6683108902428366910;\nCoordinate.NULL_ORDINATE = Double.NaN;\nCoordinate.X = 0;\nCoordinate.Y = 1;\nCoordinate.Z = 2;\n","import Coordinate from './Coordinate';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Serializable from '../../../../java/io/Serializable';\nexport default class Envelope {\n\tconstructor() {\n\t\tEnvelope.constructor_.apply(this, arguments);\n\t}\n\tstatic intersects() {\n\t\tif (arguments.length === 3) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1], q = arguments[2];\n\t\t\tif (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && (q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3];\n\t\t\tvar minq = Math.min(q1.x, q2.x);\n\t\t\tvar maxq = Math.max(q1.x, q2.x);\n\t\t\tvar minp = Math.min(p1.x, p2.x);\n\t\t\tvar maxp = Math.max(p1.x, p2.x);\n\t\t\tif (minp > maxq) return false;\n\t\t\tif (maxp < minq) return false;\n\t\t\tminq = Math.min(q1.y, q2.y);\n\t\t\tmaxq = Math.max(q1.y, q2.y);\n\t\t\tminp = Math.min(p1.y, p2.y);\n\t\t\tmaxp = Math.max(p1.y, p2.y);\n\t\t\tif (minp > maxq) return false;\n\t\t\tif (maxp < minq) return false;\n\t\t\treturn true;\n\t\t}\n\t}\n\tgetArea() {\n\t\treturn this.getWidth() * this.getHeight();\n\t}\n\tequals(other) {\n\t\tif (!(other instanceof Envelope)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar otherEnvelope = other;\n\t\tif (this.isNull()) {\n\t\t\treturn otherEnvelope.isNull();\n\t\t}\n\t\treturn this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY();\n\t}\n\tintersection(env) {\n\t\tif (this.isNull() || env.isNull() || !this.intersects(env)) return new Envelope();\n\t\tvar intMinX = this._minx > env._minx ? this._minx : env._minx;\n\t\tvar intMinY = this._miny > env._miny ? this._miny : env._miny;\n\t\tvar intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;\n\t\tvar intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;\n\t\treturn new Envelope(intMinX, intMaxX, intMinY, intMaxY);\n\t}\n\tisNull() {\n\t\treturn this._maxx < this._minx;\n\t}\n\tgetMaxX() {\n\t\treturn this._maxx;\n\t}\n\tcovers() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\treturn this.covers(p.x, p.y);\n\t\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\tif (this.isNull() || other.isNull()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\tif (this.isNull()) return false;\n\t\t\treturn x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy;\n\t\t}\n\t}\n\tintersects() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\tif (this.isNull() || other.isNull()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny);\n\t\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\treturn this.intersects(p.x, p.y);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tif (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\t\t\tlet a = arguments[0], b = arguments[1];\n\t\t\t\tif (this.isNull()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tvar envminx = a.x < b.x ? a.x : b.x;\n\t\t\t\tif (envminx > this._maxx) return false;\n\t\t\t\tvar envmaxx = a.x > b.x ? a.x : b.x;\n\t\t\t\tif (envmaxx < this._minx) return false;\n\t\t\t\tvar envminy = a.y < b.y ? a.y : b.y;\n\t\t\t\tif (envminy > this._maxy) return false;\n\t\t\t\tvar envmaxy = a.y > b.y ? a.y : b.y;\n\t\t\t\tif (envmaxy < this._miny) return false;\n\t\t\t\treturn true;\n\t\t\t} else if (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\t\tif (this.isNull()) return false;\n\t\t\t\treturn !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny);\n\t\t\t}\n\t\t}\n\t}\n\tgetMinY() {\n\t\treturn this._miny;\n\t}\n\tgetMinX() {\n\t\treturn this._minx;\n\t}\n\texpandToInclude() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\tthis.expandToInclude(p.x, p.y);\n\t\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\tif (other.isNull()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (this.isNull()) {\n\t\t\t\t\tthis._minx = other.getMinX();\n\t\t\t\t\tthis._maxx = other.getMaxX();\n\t\t\t\t\tthis._miny = other.getMinY();\n\t\t\t\t\tthis._maxy = other.getMaxY();\n\t\t\t\t} else {\n\t\t\t\t\tif (other._minx < this._minx) {\n\t\t\t\t\t\tthis._minx = other._minx;\n\t\t\t\t\t}\n\t\t\t\t\tif (other._maxx > this._maxx) {\n\t\t\t\t\t\tthis._maxx = other._maxx;\n\t\t\t\t\t}\n\t\t\t\t\tif (other._miny < this._miny) {\n\t\t\t\t\t\tthis._miny = other._miny;\n\t\t\t\t\t}\n\t\t\t\t\tif (other._maxy > this._maxy) {\n\t\t\t\t\t\tthis._maxy = other._maxy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\tif (this.isNull()) {\n\t\t\t\tthis._minx = x;\n\t\t\t\tthis._maxx = x;\n\t\t\t\tthis._miny = y;\n\t\t\t\tthis._maxy = y;\n\t\t\t} else {\n\t\t\t\tif (x < this._minx) {\n\t\t\t\t\tthis._minx = x;\n\t\t\t\t}\n\t\t\t\tif (x > this._maxx) {\n\t\t\t\t\tthis._maxx = x;\n\t\t\t\t}\n\t\t\t\tif (y < this._miny) {\n\t\t\t\t\tthis._miny = y;\n\t\t\t\t}\n\t\t\t\tif (y > this._maxy) {\n\t\t\t\t\tthis._maxy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tminExtent() {\n\t\tif (this.isNull()) return 0.0;\n\t\tvar w = this.getWidth();\n\t\tvar h = this.getHeight();\n\t\tif (w < h) return w;\n\t\treturn h;\n\t}\n\tgetWidth() {\n\t\tif (this.isNull()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._maxx - this._minx;\n\t}\n\tcompareTo(o) {\n\t\tvar env = o;\n\t\tif (this.isNull()) {\n\t\t\tif (env.isNull()) return 0;\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tif (env.isNull()) return 1;\n\t\t}\n\t\tif (this._minx < env._minx) return -1;\n\t\tif (this._minx > env._minx) return 1;\n\t\tif (this._miny < env._miny) return -1;\n\t\tif (this._miny > env._miny) return 1;\n\t\tif (this._maxx < env._maxx) return -1;\n\t\tif (this._maxx > env._maxx) return 1;\n\t\tif (this._maxy < env._maxy) return -1;\n\t\tif (this._maxy > env._maxy) return 1;\n\t\treturn 0;\n\t}\n\ttranslate(transX, transY) {\n\t\tif (this.isNull()) {\n\t\t\treturn null;\n\t\t}\n\t\tthis.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);\n\t}\n\ttoString() {\n\t\treturn \"Env[\" + this._minx + \" : \" + this._maxx + \", \" + this._miny + \" : \" + this._maxy + \"]\";\n\t}\n\tsetToNull() {\n\t\tthis._minx = 0;\n\t\tthis._maxx = -1;\n\t\tthis._miny = 0;\n\t\tthis._maxy = -1;\n\t}\n\tgetHeight() {\n\t\tif (this.isNull()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._maxy - this._miny;\n\t}\n\tmaxExtent() {\n\t\tif (this.isNull()) return 0.0;\n\t\tvar w = this.getWidth();\n\t\tvar h = this.getHeight();\n\t\tif (w > h) return w;\n\t\treturn h;\n\t}\n\texpandBy() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet distance = arguments[0];\n\t\t\tthis.expandBy(distance, distance);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet deltaX = arguments[0], deltaY = arguments[1];\n\t\t\tif (this.isNull()) return null;\n\t\t\tthis._minx -= deltaX;\n\t\t\tthis._maxx += deltaX;\n\t\t\tthis._miny -= deltaY;\n\t\t\tthis._maxy += deltaY;\n\t\t\tif (this._minx > this._maxx || this._miny > this._maxy) this.setToNull();\n\t\t}\n\t}\n\tcontains() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\treturn this.covers(other);\n\t\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\treturn this.covers(p);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\treturn this.covers(x, y);\n\t\t}\n\t}\n\tcentre() {\n\t\tif (this.isNull()) return null;\n\t\treturn new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0);\n\t}\n\tinit() {\n\t\tif (arguments.length === 0) {\n\t\t\tthis.setToNull();\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\tthis.init(p.x, p.x, p.y, p.y);\n\t\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\t\tlet env = arguments[0];\n\t\t\t\tthis._minx = env._minx;\n\t\t\t\tthis._maxx = env._maxx;\n\t\t\t\tthis._miny = env._miny;\n\t\t\t\tthis._maxy = env._maxy;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\t\tthis.init(p1.x, p2.x, p1.y, p2.y);\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet x1 = arguments[0], x2 = arguments[1], y1 = arguments[2], y2 = arguments[3];\n\t\t\tif (x1 < x2) {\n\t\t\t\tthis._minx = x1;\n\t\t\t\tthis._maxx = x2;\n\t\t\t} else {\n\t\t\t\tthis._minx = x2;\n\t\t\t\tthis._maxx = x1;\n\t\t\t}\n\t\t\tif (y1 < y2) {\n\t\t\t\tthis._miny = y1;\n\t\t\t\tthis._maxy = y2;\n\t\t\t} else {\n\t\t\t\tthis._miny = y2;\n\t\t\t\tthis._maxy = y1;\n\t\t\t}\n\t\t}\n\t}\n\tgetMaxY() {\n\t\treturn this._maxy;\n\t}\n\tdistance(env) {\n\t\tif (this.intersects(env)) return 0;\n\t\tvar dx = 0.0;\n\t\tif (this._maxx < env._minx) dx = env._minx - this._maxx; else if (this._minx > env._maxx) dx = this._minx - env._maxx;\n\t\tvar dy = 0.0;\n\t\tif (this._maxy < env._miny) dy = env._miny - this._maxy; else if (this._miny > env._maxy) dy = this._miny - env._maxy;\n\t\tif (dx === 0.0) return dy;\n\t\tif (dy === 0.0) return dx;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\thashCode() {\n\t\tvar result = 17;\n\t\tresult = 37 * result + Coordinate.hashCode(this._minx);\n\t\tresult = 37 * result + Coordinate.hashCode(this._maxx);\n\t\tresult = 37 * result + Coordinate.hashCode(this._miny);\n\t\tresult = 37 * result + Coordinate.hashCode(this._maxy);\n\t\treturn result;\n\t}\n\tgetClass() {\n\t\treturn Envelope;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparable, Serializable];\n\t}\n}\nEnvelope.constructor_ = function () {\n\tthis._minx = null;\n\tthis._maxx = null;\n\tthis._miny = null;\n\tthis._maxy = null;\n\tif (arguments.length === 0) {\n\t\tthis.init();\n\t} else if (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\tthis.init(p.x, p.x, p.y, p.y);\n\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\tlet env = arguments[0];\n\t\t\tthis.init(env);\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\tthis.init(p1.x, p2.x, p1.y, p2.y);\n\t} else if (arguments.length === 4) {\n\t\tlet x1 = arguments[0], x2 = arguments[1], y1 = arguments[2], y2 = arguments[3];\n\t\tthis.init(x1, x2, y1, y2);\n\t}\n};\nEnvelope.serialVersionUID = 5873921885273102420;\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport Serializable from '../../../../java/io/Serializable';\nimport Envelope from './Envelope';\nexport default class Geometry {\n\tconstructor() {\n\t\tGeometry.constructor_.apply(this, arguments);\n\t}\n\tisGeometryCollection() {\n\t\treturn this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION;\n\t}\n\tgetFactory() {\n\t\treturn this._factory;\n\t}\n\tgetGeometryN(n) {\n\t\treturn this;\n\t}\n\tgetArea() {\n\t\treturn 0.0;\n\t}\n\tisRectangle() {\n\t\treturn false;\n\t}\n\tequals() {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tlet g = arguments[0];\n\t\t\tif (g === null) return false;\n\t\t\treturn this.equalsTopo(g);\n\t\t} else if (arguments[0] instanceof Object) {\n\t\t\tlet o = arguments[0];\n\t\t\tif (!(o instanceof Geometry)) return false;\n\t\t\tvar g = o;\n\t\t\treturn this.equalsExact(g);\n\t\t}\n\t}\n\tequalsExact(other) {\n\t\treturn this === other || this.equalsExact(other, 0);\n\t}\n\tgeometryChanged() {\n\t\tthis.apply(Geometry.geometryChangedFilter);\n\t}\n\tgeometryChangedAction() {\n\t\tthis._envelope = null;\n\t}\n\tequalsNorm(g) {\n\t\tif (g === null) return false;\n\t\treturn this.norm().equalsExact(g.norm());\n\t}\n\tgetLength() {\n\t\treturn 0.0;\n\t}\n\tgetNumGeometries() {\n\t\treturn 1;\n\t}\n\tcompareTo() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar other = o;\n\t\t\tif (this.getTypeCode() !== other.getTypeCode()) {\n\t\t\t\treturn this.getTypeCode() - other.getTypeCode();\n\t\t\t}\n\t\t\tif (this.isEmpty() && other.isEmpty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (other.isEmpty()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn this.compareToSameClass(o);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar other = o;\n\t\t\tif (this.getTypeCode() !== other.getTypeCode()) {\n\t\t\t\treturn this.getTypeCode() - other.getTypeCode();\n\t\t\t}\n\t\t\tif (this.isEmpty() && other.isEmpty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (other.isEmpty()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn this.compareToSameClass(o, comp);\n\t\t}\n\t}\n\tgetUserData() {\n\t\treturn this._userData;\n\t}\n\tgetSRID() {\n\t\treturn this._SRID;\n\t}\n\tgetEnvelope() {\n\t\treturn this.getFactory().toGeometry(this.getEnvelopeInternal());\n\t}\n\tcheckNotGeometryCollection(g) {\n\t\tif (g.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION) {\n\t\t\tthrow new IllegalArgumentException(\"This method does not support GeometryCollection arguments\");\n\t\t}\n\t}\n\tequal(a, b, tolerance) {\n\t\tif (tolerance === 0) {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\treturn a.distance(b) <= tolerance;\n\t}\n\tnorm() {\n\t\tvar copy = this.copy();\n\t\tcopy.normalize();\n\t\treturn copy;\n\t}\n\tgetPrecisionModel() {\n\t\treturn this._factory.getPrecisionModel();\n\t}\n\tgetEnvelopeInternal() {\n\t\tif (this._envelope === null) {\n\t\t\tthis._envelope = this.computeEnvelopeInternal();\n\t\t}\n\t\treturn new Envelope(this._envelope);\n\t}\n\tsetSRID(SRID) {\n\t\tthis._SRID = SRID;\n\t}\n\tsetUserData(userData) {\n\t\tthis._userData = userData;\n\t}\n\tcompare(a, b) {\n\t\tvar i = a.iterator();\n\t\tvar j = b.iterator();\n\t\twhile (i.hasNext() && j.hasNext()) {\n\t\t\tvar aElement = i.next();\n\t\t\tvar bElement = j.next();\n\t\t\tvar comparison = aElement.compareTo(bElement);\n\t\t\tif (comparison !== 0) {\n\t\t\t\treturn comparison;\n\t\t\t}\n\t\t}\n\t\tif (i.hasNext()) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (j.hasNext()) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\thashCode() {\n\t\treturn this.getEnvelopeInternal().hashCode();\n\t}\n\tisGeometryCollectionOrDerived() {\n\t\tif (this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === Geometry.TYPECODE_MULTIPOINT || this.getTypeCode() === Geometry.TYPECODE_MULTILINESTRING || this.getTypeCode() === Geometry.TYPECODE_MULTIPOLYGON) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tget interfaces_() {\n\t\treturn [Cloneable, Comparable, Serializable];\n\t}\n\tgetClass() {\n\t\treturn Geometry;\n\t}\n\tstatic hasNonEmptyElements(geometries) {\n\t\tfor (var i = 0; i < geometries.length; i++) {\n\t\t\tif (!geometries[i].isEmpty()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tstatic hasNullElements(array) {\n\t\tfor (var i = 0; i < array.length; i++) {\n\t\t\tif (array[i] === null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\nGeometry.constructor_ = function (factory) {\n\tif (!factory)\n\t\treturn;\n\tthis._envelope = null;\n\tthis._userData = null;\n\tthis._factory = factory;\n\tthis._SRID = factory.getSRID();\n};\nGeometry.serialVersionUID = 8763622679187376702;\nGeometry.TYPECODE_POINT = 0;\nGeometry.TYPECODE_MULTIPOINT = 1;\nGeometry.TYPECODE_LINESTRING = 2;\nGeometry.TYPECODE_LINEARRING = 3;\nGeometry.TYPECODE_MULTILINESTRING = 4;\nGeometry.TYPECODE_POLYGON = 5;\nGeometry.TYPECODE_MULTIPOLYGON = 6;\nGeometry.TYPECODE_GEOMETRYCOLLECTION = 7;\nGeometry.TYPENAME_POINT = \"Point\";\nGeometry.TYPENAME_MULTIPOINT = \"MultiPoint\";\nGeometry.TYPENAME_LINESTRING = \"LineString\";\nGeometry.TYPENAME_LINEARRING = \"LinearRing\";\nGeometry.TYPENAME_MULTILINESTRING = \"MultiLineString\";\nGeometry.TYPENAME_POLYGON = \"Polygon\";\nGeometry.TYPENAME_MULTIPOLYGON = \"MultiPolygon\";\nGeometry.TYPENAME_GEOMETRYCOLLECTION = \"GeometryCollection\";\nGeometry.geometryChangedFilter = {\n\tget interfaces_() {\n\t\treturn [GeometryComponentFilter];\n\t},\n\tfilter(geom) {\n\t\tgeom.geometryChangedAction();\n\t}\n};\n","export default class CoordinateFilter {\n\tconstructor() {\n\t\tCoordinateFilter.constructor_.apply(this, arguments);\n\t}\n\tfilter(coord) {}\n\tgetClass() {\n\t\treturn CoordinateFilter;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCoordinateFilter.constructor_ = function () {};\n","export default class BoundaryNodeRule {\n\tconstructor() {\n\t\tBoundaryNodeRule.constructor_.apply(this, arguments);\n\t}\n\tisInBoundary(boundaryCount) {}\n\tgetClass() {\n\t\treturn BoundaryNodeRule;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nclass Mod2BoundaryNodeRule {\n\tconstructor() {\n\t\tMod2BoundaryNodeRule.constructor_.apply(this, arguments);\n\t}\n\tisInBoundary(boundaryCount) {\n\t\treturn boundaryCount % 2 === 1;\n\t}\n\tgetClass() {\n\t\treturn Mod2BoundaryNodeRule;\n\t}\n\tget interfaces_() {\n\t\treturn [BoundaryNodeRule];\n\t}\n}\nMod2BoundaryNodeRule.constructor_ = function () {};\nclass EndPointBoundaryNodeRule {\n\tconstructor() {\n\t\tEndPointBoundaryNodeRule.constructor_.apply(this, arguments);\n\t}\n\tisInBoundary(boundaryCount) {\n\t\treturn boundaryCount > 0;\n\t}\n\tgetClass() {\n\t\treturn EndPointBoundaryNodeRule;\n\t}\n\tget interfaces_() {\n\t\treturn [BoundaryNodeRule];\n\t}\n}\nEndPointBoundaryNodeRule.constructor_ = function () {};\nclass MultiValentEndPointBoundaryNodeRule {\n\tconstructor() {\n\t\tMultiValentEndPointBoundaryNodeRule.constructor_.apply(this, arguments);\n\t}\n\tisInBoundary(boundaryCount) {\n\t\treturn boundaryCount > 1;\n\t}\n\tgetClass() {\n\t\treturn MultiValentEndPointBoundaryNodeRule;\n\t}\n\tget interfaces_() {\n\t\treturn [BoundaryNodeRule];\n\t}\n}\nMultiValentEndPointBoundaryNodeRule.constructor_ = function () {};\nclass MonoValentEndPointBoundaryNodeRule {\n\tconstructor() {\n\t\tMonoValentEndPointBoundaryNodeRule.constructor_.apply(this, arguments);\n\t}\n\tisInBoundary(boundaryCount) {\n\t\treturn boundaryCount === 1;\n\t}\n\tgetClass() {\n\t\treturn MonoValentEndPointBoundaryNodeRule;\n\t}\n\tget interfaces_() {\n\t\treturn [BoundaryNodeRule];\n\t}\n}\nMonoValentEndPointBoundaryNodeRule.constructor_ = function () {};\nBoundaryNodeRule.Mod2BoundaryNodeRule = Mod2BoundaryNodeRule;\nBoundaryNodeRule.EndPointBoundaryNodeRule = EndPointBoundaryNodeRule;\nBoundaryNodeRule.MultiValentEndPointBoundaryNodeRule = MultiValentEndPointBoundaryNodeRule;\nBoundaryNodeRule.MonoValentEndPointBoundaryNodeRule = MonoValentEndPointBoundaryNodeRule;\nBoundaryNodeRule.constructor_ = function () {};\nBoundaryNodeRule.MOD2_BOUNDARY_RULE = new Mod2BoundaryNodeRule();\nBoundaryNodeRule.ENDPOINT_BOUNDARY_RULE = new EndPointBoundaryNodeRule();\nBoundaryNodeRule.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new MultiValentEndPointBoundaryNodeRule();\nBoundaryNodeRule.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new MonoValentEndPointBoundaryNodeRule();\nBoundaryNodeRule.OGC_SFS_BOUNDARY_RULE = BoundaryNodeRule.MOD2_BOUNDARY_RULE;\n","/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html\n * @constructor\n * @private\n */\nexport default function Iterator() {};\n\n/**\n * Returns true if the iteration has more elements.\n * @return {boolean}\n */\nIterator.prototype.hasNext = function() {};\n\n/**\n * Returns the next element in the iteration.\n * @return {Object}\n */\nIterator.prototype.next = function() {};\n\n/**\n * Removes from the underlying collection the last element returned by the\n * iterator (optional operation).\n */\nIterator.prototype.remove = function() {};\n","import Iterator from './Iterator'\n\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html\n *\n * @constructor\n * @private\n */\nexport default function Collection() {};\n\n/**\n * Ensures that this collection contains the specified element (optional\n * operation).\n * @param {Object} e\n * @return {boolean}\n */\nCollection.prototype.add = function() {};\n\n\n/**\n * Appends all of the elements in the specified collection to the end of this\n * list, in the order that they are returned by the specified collection's\n * iterator (optional operation).\n * @param {javascript.util.Collection} c\n * @return {boolean}\n */\nCollection.prototype.addAll = function() {};\n\n\n/**\n * Returns true if this collection contains no elements.\n * @return {boolean}\n */\nCollection.prototype.isEmpty = function() {};\n\n\n/**\n * Returns an iterator over the elements in this collection.\n * @return {javascript.util.Iterator}\n */\nCollection.prototype.iterator = function() {};\n\n\n/**\n * Returns an iterator over the elements in this collection.\n * @return {number}\n */\nCollection.prototype.size = function() {};\n\n\n/**\n * Returns an array containing all of the elements in this collection.\n * @return {Array}\n */\nCollection.prototype.toArray = function() {};\n\n\n/**\n * Removes a single instance of the specified element from this collection if it\n * is present. (optional)\n * @param {Object} e\n * @return {boolean}\n */\nCollection.prototype.remove = function() {};\n","/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nexport default function IndexOutOfBoundsException(message) {\n  this.message = message || '';\n};\nIndexOutOfBoundsException.prototype = new Error();\n\n/**\n * @type {string}\n */\nIndexOutOfBoundsException.prototype.name = 'IndexOutOfBoundsException';\n","import Collection from './Collection'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html\n *\n * @extends {javascript.util.Collection}\n * @constructor\n * @private\n */\nexport default function List() { };\nList.prototype = Object.create(Collection.prototype);\nList.prototype.constructor = List\n\n/**\n * Returns the element at the specified position in this list.\n * @param {number} index\n * @return {Object}\n */\nList.prototype.get = function() { };\n\n\n/**\n * Replaces the element at the specified position in this list with the\n * specified element (optional operation).\n * @param {number} index\n * @param {Object} e\n * @return {Object}\n */\nList.prototype.set = function() { };\n\n\n/**\n * Returns true if this collection contains no elements.\n * @return {boolean}\n */\nList.prototype.isEmpty = function() { };\n","/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nexport default function NoSuchElementException(message) {\n  this.message = message || '';\n};\nNoSuchElementException.prototype = new Error();\n\n\n/**\n * @type {string}\n */\nNoSuchElementException.prototype.name = 'NoSuchElementException';\n","/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nexport default function OperationNotSupported(message) {\n  this.message = message || '';\n};\nOperationNotSupported.prototype = new Error();\n\n\n/**\n * @type {string}\n */\nOperationNotSupported.prototype.name = 'OperationNotSupported';\n","import Collection from './Collection'\nimport IndexOutOfBoundsException from './IndexOutOfBoundsException'\nimport Iterator from './Iterator'\nimport List from './List'\nimport NoSuchElementException from './NoSuchElementException'\nimport OperationNotSupported from './OperationNotSupported'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html\n *\n * @extends List\n * @private\n */\nexport default function ArrayList () {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n};\nArrayList.prototype = Object.create(List.prototype)\nArrayList.prototype.constructor = ArrayList;\n\nArrayList.prototype.ensureCapacity = function () {}\nArrayList.prototype.interfaces_ = [List, Collection]\n\n/**\n * @override\n */\nArrayList.prototype.add = function(e) {\n  if (arguments.length === 1) {\n    this.array_.push(e)\n  } else {\n    this.array_.splice(arguments[0], 0, arguments[1])\n  }\n  return true\n};\n\nArrayList.prototype.clear = function() {\n  this.array_ = []\n}\n\n/**\n * @override\n */\nArrayList.prototype.addAll = function(c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.add(i.next());\n  }\n  return true;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.set = function(index, element) {\n  var oldElement = this.array_[index];\n  this.array_[index] = element;\n  return oldElement;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.iterator = function() {\n  return new Iterator_(this);\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.get = function(index) {\n  if (index < 0 || index >= this.size()) {\n    throw new IndexOutOfBoundsException();\n  }\n\n  return this.array_[index];\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.isEmpty = function() {\n  return this.array_.length === 0;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.size = function() {\n  return this.array_.length;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.toArray = function() {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.remove = function(o) {\n  var found = false;\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    if (this.array_[i] === o) {\n      this.array_.splice(i, 1);\n      found = true;\n      break;\n    }\n  }\n\n  return found;\n};\n\n\nArrayList.prototype.removeAll = function(c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.remove(i.next());\n  }\n  return true;\n};\n\n\n\n/**\n * @extends {Iterator}\n * @param {ArrayList} arrayList\n * @constructor\n * @private\n */\nvar Iterator_ = function(arrayList) {\n  /**\n   * @type {ArrayList}\n   * @private\n  */\n  this.arrayList_ = arrayList;\n  /**\n   * @type {number}\n   * @private\n  */\n  this.position_ = 0;\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.next = function() {\n  if (this.position_ === this.arrayList_.size()) {\n    throw new NoSuchElementException();\n  }\n  return this.arrayList_.get(this.position_++);\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.hasNext = function() {\n  if (this.position_ < this.arrayList_.size()) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * TODO: should be in ListIterator\n * @override\n */\nIterator_.prototype.set = function(element) {\n  return this.arrayList_.set(this.position_ - 1, element);\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.remove = function() {\n  this.arrayList_.remove(this.arrayList_.get(this.position_));\n};\n","import hasInterface from '../../../../hasInterface';\nimport Collection from '../../../../java/util/Collection';\nimport Coordinate from './Coordinate';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default class CoordinateList extends ArrayList {\n\tconstructor() {\n\t\tsuper();\n\t\tCoordinateList.constructor_.apply(this, arguments);\n\t}\n\tgetCoordinate(i) {\n\t\treturn this.get(i);\n\t}\n\taddAll() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"boolean\" && hasInterface(arguments[0], Collection))) {\n\t\t\tlet coll = arguments[0], allowRepeated = arguments[1];\n\t\t\tvar isChanged = false;\n\t\t\tfor (var i = coll.iterator(); i.hasNext(); ) {\n\t\t\t\tthis.add(i.next(), allowRepeated);\n\t\t\t\tisChanged = true;\n\t\t\t}\n\t\t\treturn isChanged;\n\t\t} else return super.addAll.apply(this, arguments);\n\t}\n\tclone() {\n\t\tvar clone = super.clone.call(this);\n\t\tfor (var i = 0; i < this.size(); i++) {\n\t\t\tclone.add(i, this.get(i).clone());\n\t\t}\n\t\treturn clone;\n\t}\n\ttoCoordinateArray() {\n\t\treturn this.toArray(CoordinateList.coordArrayType);\n\t}\n\tadd() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet coord = arguments[0];\n\t\t\tsuper.add.call(this, coord);\n\t\t} else if (arguments.length === 2) {\n\t\t\tif (arguments[0] instanceof Array && typeof arguments[1] === \"boolean\") {\n\t\t\t\tlet coord = arguments[0], allowRepeated = arguments[1];\n\t\t\t\tthis.add(coord, allowRepeated, true);\n\t\t\t\treturn true;\n\t\t\t} else if (arguments[0] instanceof Coordinate && typeof arguments[1] === \"boolean\") {\n\t\t\t\tlet coord = arguments[0], allowRepeated = arguments[1];\n\t\t\t\tif (!allowRepeated) {\n\t\t\t\t\tif (this.size() >= 1) {\n\t\t\t\t\t\tvar last = this.get(this.size() - 1);\n\t\t\t\t\t\tif (last.equals2D(coord)) return null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsuper.add.call(this, coord);\n\t\t\t} else if (arguments[0] instanceof Object && typeof arguments[1] === \"boolean\") {\n\t\t\t\tlet obj = arguments[0], allowRepeated = arguments[1];\n\t\t\t\tthis.add(obj, allowRepeated);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (typeof arguments[2] === \"boolean\" && (arguments[0] instanceof Array && typeof arguments[1] === \"boolean\")) {\n\t\t\t\tlet coord = arguments[0], allowRepeated = arguments[1], direction = arguments[2];\n\t\t\t\tif (direction) {\n\t\t\t\t\tfor (var i = 0; i < coord.length; i++) {\n\t\t\t\t\t\tthis.add(coord[i], allowRepeated);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i = coord.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tthis.add(coord[i], allowRepeated);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else if (typeof arguments[2] === \"boolean\" && (Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate)) {\n\t\t\t\tlet i = arguments[0], coord = arguments[1], allowRepeated = arguments[2];\n\t\t\t\tif (!allowRepeated) {\n\t\t\t\t\tvar size = this.size();\n\t\t\t\t\tif (size > 0) {\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\tvar prev = this.get(i - 1);\n\t\t\t\t\t\t\tif (prev.equals2D(coord)) return null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i < size) {\n\t\t\t\t\t\t\tvar next = this.get(i);\n\t\t\t\t\t\t\tif (next.equals2D(coord)) return null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsuper.add.call(this, i, coord);\n\t\t\t}\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet coord = arguments[0], allowRepeated = arguments[1], start = arguments[2], end = arguments[3];\n\t\t\tvar inc = 1;\n\t\t\tif (start > end) inc = -1;\n\t\t\tfor (var i = start; i !== end; i += inc) {\n\t\t\t\tthis.add(coord[i], allowRepeated);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tcloseRing() {\n\t\tif (this.size() > 0) this.add(new Coordinate(this.get(0)), false);\n\t}\n\tgetClass() {\n\t\treturn CoordinateList;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCoordinateList.constructor_ = function () {\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet coord = arguments[0];\n\t\tthis.ensureCapacity(coord.length);\n\t\tthis.add(coord, true);\n\t} else if (arguments.length === 2) {\n\t\tlet coord = arguments[0], allowRepeated = arguments[1];\n\t\tthis.ensureCapacity(coord.length);\n\t\tthis.add(coord, allowRepeated);\n\t}\n};\nCoordinateList.coordArrayType = new Array(0).fill(null);\n","import Double from '../../../../java/lang/Double';\nexport default class MathUtil {\n\tconstructor() {\n\t\tMathUtil.constructor_.apply(this, arguments);\n\t}\n\tstatic log10(x) {\n\t\tvar ln = Math.log(x);\n\t\tif (Double.isInfinite(ln)) return ln;\n\t\tif (Double.isNaN(ln)) return ln;\n\t\treturn ln / MathUtil.LOG_10;\n\t}\n\tstatic min(v1, v2, v3, v4) {\n\t\tvar min = v1;\n\t\tif (v2 < min) min = v2;\n\t\tif (v3 < min) min = v3;\n\t\tif (v4 < min) min = v4;\n\t\treturn min;\n\t}\n\tstatic clamp() {\n\t\tif (typeof arguments[2] === \"number\" && (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\")) {\n\t\t\tlet x = arguments[0], min = arguments[1], max = arguments[2];\n\t\t\tif (x < min) return min;\n\t\t\tif (x > max) return max;\n\t\t\treturn x;\n\t\t} else if (Number.isInteger(arguments[2]) && (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))) {\n\t\t\tlet x = arguments[0], min = arguments[1], max = arguments[2];\n\t\t\tif (x < min) return min;\n\t\t\tif (x > max) return max;\n\t\t\treturn x;\n\t\t}\n\t}\n\tstatic wrap(index, max) {\n\t\tif (index < 0) {\n\t\t\treturn max - -index % max;\n\t\t}\n\t\treturn index % max;\n\t}\n\tstatic max() {\n\t\tif (arguments.length === 3) {\n\t\t\tlet v1 = arguments[0], v2 = arguments[1], v3 = arguments[2];\n\t\t\tvar max = v1;\n\t\t\tif (v2 > max) max = v2;\n\t\t\tif (v3 > max) max = v3;\n\t\t\treturn max;\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet v1 = arguments[0], v2 = arguments[1], v3 = arguments[2], v4 = arguments[3];\n\t\t\tvar max = v1;\n\t\t\tif (v2 > max) max = v2;\n\t\t\tif (v3 > max) max = v3;\n\t\t\tif (v4 > max) max = v4;\n\t\t\treturn max;\n\t\t}\n\t}\n\tstatic average(x1, x2) {\n\t\treturn (x1 + x2) / 2.0;\n\t}\n\tgetClass() {\n\t\treturn MathUtil;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nMathUtil.constructor_ = function () {};\nMathUtil.LOG_10 = Math.log(10);\n","export default function System () { }\n\nSystem.arraycopy = (src, srcPos, dest, destPos, len) => {\n  let c = 0\n  for (let i = srcPos; i < srcPos + len; i++) {\n    dest[destPos + c] = src[i]\n    c++\n  }\n}\n\nSystem.getProperty = (name) => {\n  return {\n    'line.separator': '\\n'\n  }[name]\n}\n","import CoordinateList from './CoordinateList';\nimport Coordinate from './Coordinate';\nimport MathUtil from '../math/MathUtil';\nimport System from '../../../../java/lang/System';\nimport Comparator from '../../../../java/util/Comparator';\nimport Envelope from './Envelope';\nexport default class CoordinateArrays {\n\tconstructor() {\n\t\tCoordinateArrays.constructor_.apply(this, arguments);\n\t}\n\tstatic isRing(pts) {\n\t\tif (pts.length < 4) return false;\n\t\tif (!pts[0].equals2D(pts[pts.length - 1])) return false;\n\t\treturn true;\n\t}\n\tstatic ptNotInList(testPts, pts) {\n\t\tfor (var i = 0; i < testPts.length; i++) {\n\t\t\tvar testPt = testPts[i];\n\t\t\tif (CoordinateArrays.indexOf(testPt, pts) < 0) return testPt;\n\t\t}\n\t\treturn null;\n\t}\n\tstatic scroll(coordinates, firstCoordinate) {\n\t\tvar i = CoordinateArrays.indexOf(firstCoordinate, coordinates);\n\t\tif (i < 0) return null;\n\t\tvar newCoordinates = new Array(coordinates.length).fill(null);\n\t\tSystem.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);\n\t\tSystem.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);\n\t\tSystem.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);\n\t}\n\tstatic equals() {\n\t\tif (arguments.length === 2) {\n\t\t\tlet coord1 = arguments[0], coord2 = arguments[1];\n\t\t\tif (coord1 === coord2) return true;\n\t\t\tif (coord1 === null || coord2 === null) return false;\n\t\t\tif (coord1.length !== coord2.length) return false;\n\t\t\tfor (var i = 0; i < coord1.length; i++) {\n\t\t\t\tif (!coord1[i].equals(coord2[i])) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet coord1 = arguments[0], coord2 = arguments[1], coordinateComparator = arguments[2];\n\t\t\tif (coord1 === coord2) return true;\n\t\t\tif (coord1 === null || coord2 === null) return false;\n\t\t\tif (coord1.length !== coord2.length) return false;\n\t\t\tfor (var i = 0; i < coord1.length; i++) {\n\t\t\t\tif (coordinateComparator.compare(coord1[i], coord2[i]) !== 0) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tstatic intersection(coordinates, env) {\n\t\tvar coordList = new CoordinateList();\n\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\tif (env.intersects(coordinates[i])) coordList.add(coordinates[i], true);\n\t\t}\n\t\treturn coordList.toCoordinateArray();\n\t}\n\tstatic hasRepeatedPoints(coord) {\n\t\tfor (var i = 1; i < coord.length; i++) {\n\t\t\tif (coord[i - 1].equals(coord[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tstatic removeRepeatedPoints(coord) {\n\t\tif (!CoordinateArrays.hasRepeatedPoints(coord)) return coord;\n\t\tvar coordList = new CoordinateList(coord, false);\n\t\treturn coordList.toCoordinateArray();\n\t}\n\tstatic reverse(coord) {\n\t\tvar last = coord.length - 1;\n\t\tvar mid = Math.trunc(last / 2);\n\t\tfor (var i = 0; i <= mid; i++) {\n\t\t\tvar tmp = coord[i];\n\t\t\tcoord[i] = coord[last - i];\n\t\t\tcoord[last - i] = tmp;\n\t\t}\n\t}\n\tstatic removeNull(coord) {\n\t\tvar nonNull = 0;\n\t\tfor (var i = 0; i < coord.length; i++) {\n\t\t\tif (coord[i] !== null) nonNull++;\n\t\t}\n\t\tvar newCoord = new Array(nonNull).fill(null);\n\t\tif (nonNull === 0) return newCoord;\n\t\tvar j = 0;\n\t\tfor (var i = 0; i < coord.length; i++) {\n\t\t\tif (coord[i] !== null) newCoord[j++] = coord[i];\n\t\t}\n\t\treturn newCoord;\n\t}\n\tstatic copyDeep() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet coordinates = arguments[0];\n\t\t\tvar copy = new Array(coordinates.length).fill(null);\n\t\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\t\tcopy[i] = new Coordinate(coordinates[i]);\n\t\t\t}\n\t\t\treturn copy;\n\t\t} else if (arguments.length === 5) {\n\t\t\tlet src = arguments[0], srcStart = arguments[1], dest = arguments[2], destStart = arguments[3], length = arguments[4];\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tdest[destStart + i] = new Coordinate(src[srcStart + i]);\n\t\t\t}\n\t\t}\n\t}\n\tstatic isEqualReversed(pts1, pts2) {\n\t\tfor (var i = 0; i < pts1.length; i++) {\n\t\t\tvar p1 = pts1[i];\n\t\t\tvar p2 = pts2[pts1.length - i - 1];\n\t\t\tif (p1.compareTo(p2) !== 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic envelope(coordinates) {\n\t\tvar env = new Envelope();\n\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\tenv.expandToInclude(coordinates[i]);\n\t\t}\n\t\treturn env;\n\t}\n\tstatic toCoordinateArray(coordList) {\n\t\treturn coordList.toArray(CoordinateArrays.coordArrayType);\n\t}\n\tstatic atLeastNCoordinatesOrNothing(n, c) {\n\t\treturn c.length >= n ? c : [];\n\t}\n\tstatic indexOf(coordinate, coordinates) {\n\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\tif (coordinate.equals(coordinates[i])) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tstatic increasingDirection(pts) {\n\t\tfor (var i = 0; i < Math.trunc(pts.length / 2); i++) {\n\t\t\tvar j = pts.length - 1 - i;\n\t\t\tvar comp = pts[i].compareTo(pts[j]);\n\t\t\tif (comp !== 0) return comp;\n\t\t}\n\t\treturn 1;\n\t}\n\tstatic compare(pts1, pts2) {\n\t\tvar i = 0;\n\t\twhile (i < pts1.length && i < pts2.length) {\n\t\t\tvar compare = pts1[i].compareTo(pts2[i]);\n\t\t\tif (compare !== 0) return compare;\n\t\t\ti++;\n\t\t}\n\t\tif (i < pts2.length) return -1;\n\t\tif (i < pts1.length) return 1;\n\t\treturn 0;\n\t}\n\tstatic minCoordinate(coordinates) {\n\t\tvar minCoord = null;\n\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\tif (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {\n\t\t\t\tminCoord = coordinates[i];\n\t\t\t}\n\t\t}\n\t\treturn minCoord;\n\t}\n\tstatic extract(pts, start, end) {\n\t\tstart = MathUtil.clamp(start, 0, pts.length);\n\t\tend = MathUtil.clamp(end, -1, pts.length);\n\t\tvar npts = end - start + 1;\n\t\tif (end < 0) npts = 0;\n\t\tif (start >= pts.length) npts = 0;\n\t\tif (end < start) npts = 0;\n\t\tvar extractPts = new Array(npts).fill(null);\n\t\tif (npts === 0) return extractPts;\n\t\tvar iPts = 0;\n\t\tfor (var i = start; i <= end; i++) {\n\t\t\textractPts[iPts++] = pts[i];\n\t\t}\n\t\treturn extractPts;\n\t}\n\tgetClass() {\n\t\treturn CoordinateArrays;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nclass ForwardComparator {\n\tconstructor() {\n\t\tForwardComparator.constructor_.apply(this, arguments);\n\t}\n\tcompare(o1, o2) {\n\t\tvar pts1 = o1;\n\t\tvar pts2 = o2;\n\t\treturn CoordinateArrays.compare(pts1, pts2);\n\t}\n\tgetClass() {\n\t\treturn ForwardComparator;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparator];\n\t}\n}\nForwardComparator.constructor_ = function () {};\nclass BidirectionalComparator {\n\tconstructor() {\n\t\tBidirectionalComparator.constructor_.apply(this, arguments);\n\t}\n\tcompare(o1, o2) {\n\t\tvar pts1 = o1;\n\t\tvar pts2 = o2;\n\t\tif (pts1.length < pts2.length) return -1;\n\t\tif (pts1.length > pts2.length) return 1;\n\t\tif (pts1.length === 0) return 0;\n\t\tvar forwardComp = CoordinateArrays.compare(pts1, pts2);\n\t\tvar isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);\n\t\tif (isEqualRev) return 0;\n\t\treturn forwardComp;\n\t}\n\tOLDcompare(o1, o2) {\n\t\tvar pts1 = o1;\n\t\tvar pts2 = o2;\n\t\tif (pts1.length < pts2.length) return -1;\n\t\tif (pts1.length > pts2.length) return 1;\n\t\tif (pts1.length === 0) return 0;\n\t\tvar dir1 = CoordinateArrays.increasingDirection(pts1);\n\t\tvar dir2 = CoordinateArrays.increasingDirection(pts2);\n\t\tvar i1 = dir1 > 0 ? 0 : pts1.length - 1;\n\t\tvar i2 = dir2 > 0 ? 0 : pts1.length - 1;\n\t\tfor (var i = 0; i < pts1.length; i++) {\n\t\t\tvar comparePt = pts1[i1].compareTo(pts2[i2]);\n\t\t\tif (comparePt !== 0) return comparePt;\n\t\t\ti1 += dir1;\n\t\t\ti2 += dir2;\n\t\t}\n\t\treturn 0;\n\t}\n\tgetClass() {\n\t\treturn BidirectionalComparator;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparator];\n\t}\n}\nBidirectionalComparator.constructor_ = function () {};\nCoordinateArrays.ForwardComparator = ForwardComparator;\nCoordinateArrays.BidirectionalComparator = BidirectionalComparator;\nCoordinateArrays.constructor_ = function () {};\nCoordinateArrays.coordArrayType = new Array(0).fill(null);\n","/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html\n *\n * @constructor\n * @private\n */\nexport default function Map() {};\n\n\n/**\n * Returns the value to which the specified key is mapped, or null if this map\n * contains no mapping for the key.\n * @param {Object} key\n * @return {Object}\n */\nMap.prototype.get = function() {};\n\n\n/**\n * Associates the specified value with the specified key in this map (optional\n * operation).\n * @param {Object} key\n * @param {Object} value\n * @return {Object}\n */\nMap.prototype.put = function() {};\n\n\n/**\n * Returns the number of key-value mappings in this map.\n * @return {number}\n */\nMap.prototype.size = function() {};\n\n\n/**\n * Returns a Collection view of the values contained in this map.\n * @return {javascript.util.Collection}\n */\nMap.prototype.values = function() {};\n\n/**\n * Returns a {@link Set} view of the mappings contained in this map.\n * The set is backed by the map, so changes to the map are\n * reflected in the set, and vice-versa.  If the map is modified\n * while an iteration over the set is in progress (except through\n * the iterator's own <tt>remove</tt> operation, or through the\n * <tt>setValue</tt> operation on a map entry returned by the\n * iterator) the results of the iteration are undefined.  The set\n * supports element removal, which removes the corresponding\n * mapping from the map, via the <tt>Iterator.remove</tt>,\n * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and\n * <tt>clear</tt> operations.  It does not support the\n * <tt>add</tt> or <tt>addAll</tt> operations.\n *\n * @return {Set} a set view of the mappings contained in this map\n */\nMap.prototype.entrySet = function() {};\n","import Map from './Map'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html\n *\n * @extends {Map}\n * @constructor\n * @private\n */\nexport default function SortedMap() {};\nSortedMap.prototype = new Map();\n","import Collection from './Collection'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html\n *\n * @extends {Collection}\n * @constructor\n * @private\n */\nexport default function Set() {};\nSet.prototype = new Collection();\n\n\n/**\n * Returns true if this set contains the specified element. More formally,\n * returns true if and only if this set contains an element e such that (o==null ?\n * e==null : o.equals(e)).\n * @param {Object} e\n * @return {boolean}\n */\nSet.prototype.contains = function() {};\n","import Collection from './Collection'\nimport Iterator from './Iterator'\nimport NoSuchElementException from './NoSuchElementException'\nimport OperationNotSupported from './OperationNotSupported'\nimport Set from './Set'\n\n/**\n * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html\n *\n * @extends {javascript.util.Set}\n * @constructor\n * @private\n */\nexport default function HashSet() {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n};\nHashSet.prototype = new Set();\n\n\n/**\n * @override\n */\nHashSet.prototype.contains = function(o) {\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this.array_[i];\n    if (e === o) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.add = function(o) {\n  if (this.contains(o)) {\n    return false;\n  }\n\n  this.array_.push(o);\n\n  return true;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.addAll = function(c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.add(i.next());\n  }\n  return true;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.remove = function(o) {\n  throw new javascript.util.OperationNotSupported();\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.size = function() {\n  return this.array_.length;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.isEmpty = function() {\n  return this.array_.length === 0;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.toArray = function() {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.iterator = function() {\n  return new Iterator_(this);\n};\n\n\n\n/**\n * @extends {Iterator}\n * @param {HashSet} hashSet\n * @constructor\n * @private\n */\nvar Iterator_ = function(hashSet) {\n  /**\n   * @type {HashSet}\n   * @private\n   */\n  this.hashSet_ = hashSet;\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.next = function() {\n  if (this.position_ === this.hashSet_.size()) {\n    throw new NoSuchElementException();\n  }\n  return this.hashSet_.array_[this.position_++];\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.hasNext = function() {\n  if (this.position_ < this.hashSet_.size()) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.remove = function() {\n  throw new OperationNotSupported();\n};\n","import ArrayList from './ArrayList'\nimport SortedMap from './SortedMap'\nimport HashSet from './HashSet'\n\nconst BLACK = 0\nconst RED = 1\nfunction colorOf (p) { return (p == null ? BLACK : p.color) }\nfunction parentOf (p) { return (p == null ? null : p.parent) }\nfunction setColor (p, c) { if (p !== null) p.color = c }\nfunction leftOf (p) { return (p == null ? null : p.left) }\nfunction rightOf (p) { return (p == null ? null : p.right) }\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html\n *\n * @extends {SortedMap}\n * @constructor\n * @private\n */\nexport default function TreeMap() {\n  /**\n   * @type {Object}\n   * @private\n   */\n  this.root_ = null;\n  /**\n   * @type {number}\n   * @private\n  */\n  this.size_ = 0;\n};\nTreeMap.prototype = new SortedMap();\n\n\n/**\n * @override\n */\nTreeMap.prototype.get = function(key) {\n  var p = this.root_;\n  while (p !== null) {\n    var cmp = key['compareTo'](p.key);\n    if (cmp < 0) {\n      p = p.left;\n    } else if (cmp > 0) {\n      p = p.right;\n    } else {\n      return p.value;\n    }\n  }\n  return null;\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.put = function(key, value) {\n  if (this.root_ === null) {\n    this.root_ = {\n      key: key,\n      value: value,\n      left: null,\n      right: null,\n      parent: null,\n      color: BLACK,\n      getValue() { return this.value },\n      getKey() { return this.key }\n    };\n    this.size_ = 1;\n    return null;\n  }\n  var t = this.root_, parent, cmp;\n  do {\n    parent = t;\n    cmp = key['compareTo'](t.key);\n    if (cmp < 0) {\n      t = t.left;\n    } else if (cmp > 0) {\n      t = t.right;\n    } else {\n      var oldValue = t.value;\n      t.value = value;\n      return oldValue;\n    }\n  } while (t !== null);\n  var e = {\n    key: key,\n    left: null,\n    right: null,\n    value: value,\n    parent: parent,\n    color: BLACK,\n    getValue() { return this.value },\n    getKey() { return this.key }\n  };\n  if (cmp < 0) {\n    parent.left = e;\n  } else {\n    parent.right = e;\n  }\n  this.fixAfterInsertion(e);\n  this.size_++;\n  return null;\n};\n\n\n/**\n * @param {Object} x\n */\nTreeMap.prototype.fixAfterInsertion = function(x) {\n  x.color = RED;\n  while (x != null && x != this.root_ && x.parent.color == RED) {\n    if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n      var y = rightOf(parentOf(parentOf(x)));\n      if (colorOf(y) == RED) {\n        setColor(parentOf(x), BLACK);\n        setColor(y, BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        x = parentOf(parentOf(x));\n      } else {\n        if (x == rightOf(parentOf(x))) {\n          x = parentOf(x);\n          this.rotateLeft(x);\n        }\n        setColor(parentOf(x), BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        this.rotateRight(parentOf(parentOf(x)));\n      }\n    } else {\n      var y = leftOf(parentOf(parentOf(x)));\n      if (colorOf(y) == RED) {\n        setColor(parentOf(x), BLACK);\n        setColor(y, BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        x = parentOf(parentOf(x));\n      } else {\n        if (x == leftOf(parentOf(x))) {\n          x = parentOf(x);\n          this.rotateRight(x);\n        }\n        setColor(parentOf(x), BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        this.rotateLeft(parentOf(parentOf(x)));\n      }\n    }\n  }\n  this.root_.color = BLACK;\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.values = function() {\n  var arrayList = new ArrayList();\n  var p = this.getFirstEntry();\n  if (p !== null) {\n    arrayList.add(p.value);\n    while ((p = TreeMap.successor(p)) !== null) {\n      arrayList.add(p.value);\n    }\n  }\n  return arrayList;\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.entrySet = function() {\n  var hashSet = new HashSet();\n  var p = this.getFirstEntry();\n  if (p !== null) {\n    hashSet.add(p);\n    while ((p = TreeMap.successor(p)) !== null) {\n      hashSet.add(p);\n    }\n  }\n  return hashSet;\n};\n\n\n/**\n * @param {Object} p\n */\nTreeMap.prototype.rotateLeft = function(p) {\n  if (p != null) {\n    var r = p.right;\n    p.right = r.left;\n    if (r.left != null)\n      r.left.parent = p;\n    r.parent = p.parent;\n    if (p.parent == null)\n      this.root_ = r;\n    else if (p.parent.left == p)\n      p.parent.left = r;\n    else\n      p.parent.right = r;\n    r.left = p;\n    p.parent = r;\n  }\n};\n\n\n/**\n * @param {Object} p\n */\nTreeMap.prototype.rotateRight = function(p) {\n  if (p != null) {\n    var l = p.left;\n    p.left = l.right;\n    if (l.right != null) l.right.parent = p;\n    l.parent = p.parent;\n    if (p.parent == null)\n      this.root_ = l;\n    else if (p.parent.right == p)\n      p.parent.right = l;\n    else p.parent.left = l;\n    l.right = p;\n    p.parent = l;\n  }\n};\n\n\n/**\n * @return {Object}\n */\nTreeMap.prototype.getFirstEntry = function() {\n  var p = this.root_;\n  if (p != null) {\n    while (p.left != null) {\n      p = p.left;\n    }\n  }\n  return p;\n};\n\n\n/**\n * @param {Object} t\n * @return {Object}\n * @private\n */\nTreeMap.successor = function(t) {\n  if (t === null)\n    return null;\n  else if (t.right !== null) {\n    var p = t.right;\n    while (p.left !== null) {\n      p = p.left;\n    }\n    return p;\n  } else {\n    var p = t.parent;\n    var ch = t;\n    while (p !== null && ch === p.right) {\n      ch = p;\n      p = p.parent;\n    }\n    return p;\n  }\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.size = function() {\n  return this.size_;\n};\n\n\nTreeMap.prototype.containsKey = function(key) {\n  var p = this.root_;\n  while (p !== null) {\n    var cmp = key['compareTo'](p.key);\n    if (cmp < 0) {\n      p = p.left;\n    } else if (cmp > 0) {\n      p = p.right;\n    } else {\n      return true;\n    }\n  }\n  return false;\n};\n","export default class Lineal {\n\tconstructor() {\n\t\tLineal.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn Lineal;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nLineal.constructor_ = function () {};\n","import Set from './Set'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html\n *\n * @extends {Set}\n * @constructor\n * @private\n */\nexport default function SortedSet() {};\nSortedSet.prototype = new Set();\n","import Collection from './Collection'\nimport Iterator from './Iterator'\nimport NoSuchElementException from './NoSuchElementException'\nimport OperationNotSupported from './OperationNotSupported'\nimport SortedSet from './SortedSet'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html\n *\n * @extends {SortedSet}\n * @constructor\n * @private\n */\nexport default function TreeSet() {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n};\nTreeSet.prototype = new SortedSet();\n\n\n/**\n * @override\n */\nTreeSet.prototype.contains = function(o) {\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this.array_[i];\n    if (e['compareTo'](o) === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.add = function(o) {\n  if (this.contains(o)) {\n    return false;\n  }\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this.array_[i];\n    if (e['compareTo'](o) === 1) {\n      this.array_.splice(i, 0, o);\n      return true;\n    }\n  }\n\n  this.array_.push(o);\n\n  return true;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.addAll = function(c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.add(i.next());\n  }\n  return true;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.remove = function(e) {\n  throw new OperationNotSupported();\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.size = function() {\n  return this.array_.length;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.isEmpty = function() {\n  return this.array_.length === 0;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.toArray = function() {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.iterator = function() {\n  return new Iterator_(this);\n};\n\n\n\n/**\n * @extends {javascript.util.Iterator}\n * @param {javascript.util.TreeSet} treeSet\n * @constructor\n * @private\n */\nvar Iterator_ = function(treeSet) {\n  /**\n   * @type {javascript.util.TreeSet}\n   * @private\n   */\n  this.treeSet_ = treeSet;\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.next = function() {\n  if (this.position_ === this.treeSet_.size()) {\n    throw new NoSuchElementException();\n  }\n  return this.treeSet_.array_[this.position_++];\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.hasNext = function() {\n  if (this.position_ < this.treeSet_.size()) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.remove = function() {\n  throw new OperationNotSupported();\n};\n","// shared pointer\nvar i\n// shortcuts\nvar defineProperty = Object.defineProperty\nfunction is (a, b) { return (a === b) || (a !== a && b !== b) } // eslint-disable-line\n\nexport default createCollection({\n  // WeakMap#delete(key:void*):boolean\n  'delete': sharedDelete,\n  // :was Map#get(key:void*[, d3fault:void*]):void*\n  // Map#has(key:void*):boolean\n  has: mapHas,\n  // Map#get(key:void*):boolean\n  get: sharedGet,\n  // Map#set(key:void*, value:void*):void\n  set: sharedSet,\n  // Map#keys(void):Iterator\n  keys: sharedKeys,\n  // Map#values(void):Iterator\n  values: sharedValues,\n  // Map#entries(void):Iterator\n  entries: mapEntries,\n  // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`\n  forEach: sharedForEach,\n  // Map#clear():\n  clear: sharedClear\n})\n\nfunction createCollection (proto, objectOnly) {\n  function Collection (a) {\n    if (!this || this.constructor !== Collection) return new Collection(a)\n    this._keys = []\n    this._values = []\n    this._itp = [] // iteration pointers\n    this.objectOnly = objectOnly\n\n    // parse initial iterable argument passed\n    if (a) init.call(this, a)\n  }\n\n  // define size for non object-only collections\n  if (!objectOnly) {\n    defineProperty(proto, 'size', {\n      get: sharedSize\n    })\n  }\n\n  // set prototype\n  proto.constructor = Collection\n  Collection.prototype = proto\n\n  return Collection\n}\n\nfunction init (a) {\n  // init Set argument, like `[1,2,3,{}]`\n  if (this.add) a.forEach(this.add, this)\n  // init Map argument like `[[1,2], [{}, 4]]`\n  else a.forEach(function (a) { this.set(a[0], a[1]) }, this)\n}\n\nfunction sharedDelete (key) {\n  if (this.has(key)) {\n    this._keys.splice(i, 1)\n    this._values.splice(i, 1)\n    // update iteration pointers\n    this._itp.forEach(function (p) { if (i < p[0]) p[0]-- })\n  }\n  // Aurora here does it while Canary doesn't\n  return i > -1\n}\n\nfunction sharedGet (key) {\n  return this.has(key) ? this._values[i] : undefined\n}\n\nfunction has (list, key) {\n  if (this.objectOnly && key !== Object(key)) throw new TypeError('Invalid value used as weak collection key')\n  // NaN or 0 passed\n  if (key !== key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} // eslint-disable-line\n  else i = list.indexOf(key)\n  return i > -1\n}\n\nfunction mapHas (value) {\n  return has.call(this, this._keys, value)\n}\n\nfunction sharedSet (key, value) {\n  this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value\n  return this\n}\n\nfunction sharedClear () {\n  (this._keys || 0).length =\n    this._values.length = 0\n}\n\nfunction sharedKeys () {\n  return sharedIterator(this._itp, this._keys)\n}\n\nfunction sharedValues () {\n  return sharedIterator(this._itp, this._values)\n}\n\nfunction mapEntries () {\n  return sharedIterator(this._itp, this._keys, this._values)\n}\n\nfunction sharedIterator (itp, array, array2) {\n  var p = [0]\n  var done = false\n  itp.push(p)\n  return {\n    next: function () {\n      var v\n      var k = p[0]\n      if (!done && k < array.length) {\n        v = array2 ? [array[k], array2[k]] : array[k]\n        p[0]++\n      } else {\n        done = true\n        itp.splice(itp.indexOf(p), 1)\n      }\n      return { done: done, value: v }\n    }\n  }\n}\n\nfunction sharedSize () {\n  return this._values.length\n}\n\nfunction sharedForEach (callback, context) {\n  var it = this.entries()\n  for (;;) {\n    var r = it.next()\n    if (r.done) break\n    callback.call(context, r.value[1], r.value[0], this)\n  }\n}\n","import ArrayList from './ArrayList'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html\n *\n * @constructor\n * @private\n */\nexport default function Arrays() {};\n\n/**\n */\nArrays.sort = function() {\n  var a = arguments[0], i, t, comparator, compare;\n  if (arguments.length === 1) {\n    compare = function(a, b) {\n      return a.compareTo(b);\n    }\n    a.sort(compare);\n    return;\n  } else if (arguments.length === 2) {\n    comparator = arguments[1];\n    compare = function(a, b) {\n      return comparator['compare'](a, b);\n    };\n    a.sort(compare);\n  } else if (arguments.length === 3) {\n    t = a.slice(arguments[1], arguments[2]);\n    t.sort();\n    var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n    a.splice(0, a.length);\n    for (i = 0; i < r.length; i++) {\n      a.push(r[i]);\n    }\n    return;\n  } else if (arguments.length === 4) {\n    t = a.slice(arguments[1], arguments[2]);\n    comparator = arguments[3];\n    compare = function(a, b) {\n      return comparator['compare'](a, b);\n    };\n    t.sort(compare);\n    r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n    a.splice(0, a.length);\n    for (i = 0; i < r.length; i++) {\n      a.push(r[i]);\n    }\n    return;\n  }\n};\n\n\n/**\n * @param {Array} array\n * @return {ArrayList}\n */\nArrays.asList = function(array) {\n  var arrayList = new ArrayList();\n  for (var i = 0, len = array.length; i < len; i++) {\n    arrayList.add(array[i]);\n  }\n  return arrayList;\n};\n","export default function Character () {}\nCharacter.isWhitespace = c => ((c <= 32 && c >= 0) || c == 127)\nCharacter.toUpperCase = c => c.toUpperCase()\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Character from '../../../../java/lang/Character';\nexport default class Dimension {\n\tconstructor() {\n\t\tDimension.constructor_.apply(this, arguments);\n\t}\n\tstatic toDimensionSymbol(dimensionValue) {\n\t\tswitch (dimensionValue) {\n\t\t\tcase Dimension.FALSE:\n\t\t\t\treturn Dimension.SYM_FALSE;\n\t\t\tcase Dimension.TRUE:\n\t\t\t\treturn Dimension.SYM_TRUE;\n\t\t\tcase Dimension.DONTCARE:\n\t\t\t\treturn Dimension.SYM_DONTCARE;\n\t\t\tcase Dimension.P:\n\t\t\t\treturn Dimension.SYM_P;\n\t\t\tcase Dimension.L:\n\t\t\t\treturn Dimension.SYM_L;\n\t\t\tcase Dimension.A:\n\t\t\t\treturn Dimension.SYM_A;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Unknown dimension value: \" + dimensionValue);\n\t}\n\tstatic toDimensionValue(dimensionSymbol) {\n\t\tswitch (Character.toUpperCase(dimensionSymbol)) {\n\t\t\tcase Dimension.SYM_FALSE:\n\t\t\t\treturn Dimension.FALSE;\n\t\t\tcase Dimension.SYM_TRUE:\n\t\t\t\treturn Dimension.TRUE;\n\t\t\tcase Dimension.SYM_DONTCARE:\n\t\t\t\treturn Dimension.DONTCARE;\n\t\t\tcase Dimension.SYM_P:\n\t\t\t\treturn Dimension.P;\n\t\t\tcase Dimension.SYM_L:\n\t\t\t\treturn Dimension.L;\n\t\t\tcase Dimension.SYM_A:\n\t\t\t\treturn Dimension.A;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Unknown dimension symbol: \" + dimensionSymbol);\n\t}\n\tgetClass() {\n\t\treturn Dimension;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nDimension.constructor_ = function () {};\nDimension.P = 0;\nDimension.L = 1;\nDimension.A = 2;\nDimension.FALSE = -1;\nDimension.TRUE = -2;\nDimension.DONTCARE = -3;\nDimension.SYM_FALSE = 'F';\nDimension.SYM_TRUE = 'T';\nDimension.SYM_DONTCARE = '*';\nDimension.SYM_P = '0';\nDimension.SYM_L = '1';\nDimension.SYM_A = '2';\n","export default class GeometryFilter {\n\tconstructor() {\n\t\tGeometryFilter.constructor_.apply(this, arguments);\n\t}\n\tfilter(geom) {}\n\tgetClass() {\n\t\treturn GeometryFilter;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGeometryFilter.constructor_ = function () {};\n","export default class CoordinateSequenceFilter {\n\tconstructor() {\n\t\tCoordinateSequenceFilter.constructor_.apply(this, arguments);\n\t}\n\tfilter(seq, i) {}\n\tisDone() {}\n\tisGeometryChanged() {}\n\tgetClass() {\n\t\treturn CoordinateSequenceFilter;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCoordinateSequenceFilter.constructor_ = function () {};\n","import TreeSet from '../../../../java/util/TreeSet';\nimport Geometry from './Geometry';\nimport Arrays from '../../../../java/util/Arrays';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Dimension from './Dimension';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nimport Envelope from './Envelope';\nimport Assert from '../util/Assert';\nexport default class GeometryCollection extends Geometry {\n\tconstructor() {\n\t\tsuper();\n\t\tGeometryCollection.constructor_.apply(this, arguments);\n\t}\n\tcomputeEnvelopeInternal() {\n\t\tvar envelope = new Envelope();\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tenvelope.expandToInclude(this._geometries[i].getEnvelopeInternal());\n\t\t}\n\t\treturn envelope;\n\t}\n\tgetGeometryN(n) {\n\t\treturn this._geometries[n];\n\t}\n\tgetCoordinates() {\n\t\tvar coordinates = new Array(this.getNumPoints()).fill(null);\n\t\tvar k = -1;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tvar childCoordinates = this._geometries[i].getCoordinates();\n\t\t\tfor (var j = 0; j < childCoordinates.length; j++) {\n\t\t\t\tk++;\n\t\t\t\tcoordinates[k] = childCoordinates[j];\n\t\t\t}\n\t\t}\n\t\treturn coordinates;\n\t}\n\tgetArea() {\n\t\tvar area = 0.0;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tarea += this._geometries[i].getArea();\n\t\t}\n\t\treturn area;\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar otherCollection = other;\n\t\t\tif (this._geometries.length !== otherCollection._geometries.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tif (!this._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tnormalize() {\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tthis._geometries[i].normalize();\n\t\t}\n\t\tArrays.sort(this._geometries);\n\t}\n\tgetCoordinate() {\n\t\tif (this.isEmpty()) return null;\n\t\treturn this._geometries[0].getCoordinate();\n\t}\n\tgetBoundaryDimension() {\n\t\tvar dimension = Dimension.FALSE;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tdimension = Math.max(dimension, this._geometries[i].getBoundaryDimension());\n\t\t}\n\t\treturn dimension;\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_GEOMETRYCOLLECTION;\n\t}\n\tgetDimension() {\n\t\tvar dimension = Dimension.FALSE;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tdimension = Math.max(dimension, this._geometries[i].getDimension());\n\t\t}\n\t\treturn dimension;\n\t}\n\tgetLength() {\n\t\tvar sum = 0.0;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tsum += this._geometries[i].getLength();\n\t\t}\n\t\treturn sum;\n\t}\n\tgetNumPoints() {\n\t\tvar numPoints = 0;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tnumPoints += this._geometries[i].getNumPoints();\n\t\t}\n\t\treturn numPoints;\n\t}\n\tgetNumGeometries() {\n\t\treturn this._geometries.length;\n\t}\n\treverse() {\n\t\tvar n = this._geometries.length;\n\t\tvar revGeoms = new Array(n).fill(null);\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\trevGeoms[i] = this._geometries[i].reverse();\n\t\t}\n\t\treturn this.getFactory().createGeometryCollection(revGeoms);\n\t}\n\tcompareToSameClass() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar theseElements = new TreeSet(Arrays.asList(this._geometries));\n\t\t\tvar otherElements = new TreeSet(Arrays.asList(o._geometries));\n\t\t\treturn this.compare(theseElements, otherElements);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar gc = o;\n\t\t\tvar n1 = this.getNumGeometries();\n\t\t\tvar n2 = gc.getNumGeometries();\n\t\t\tvar i = 0;\n\t\t\twhile (i < n1 && i < n2) {\n\t\t\t\tvar thisGeom = this.getGeometryN(i);\n\t\t\t\tvar otherGeom = gc.getGeometryN(i);\n\t\t\t\tvar holeComp = thisGeom.compareToSameClass(otherGeom, comp);\n\t\t\t\tif (holeComp !== 0) return holeComp;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i < n1) return 1;\n\t\t\tif (i < n2) return -1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tapply() {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this._geometries.length === 0) return null;\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t\tif (filter.isDone()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t}\n\t\t}\n\t}\n\tgetBoundary() {\n\t\tthis.checkNotGeometryCollection(this);\n\t\tAssert.shouldNeverReachHere();\n\t\treturn null;\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_GEOMETRYCOLLECTION;\n\t}\n\tcopy() {\n\t\tvar geometries = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < geometries.length; i++) {\n\t\t\tgeometries[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new GeometryCollection(geometries, this._factory);\n\t}\n\tisEmpty() {\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tif (!this._geometries[i].isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tgetClass() {\n\t\treturn GeometryCollection;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGeometryCollection.constructor_ = function () {\n\tthis._geometries = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 2) {\n\t\tlet geometries = arguments[0], factory = arguments[1];\n\t\tGeometry.constructor_.call(this, factory);\n\t\tif (geometries === null) {\n\t\t\tgeometries = [];\n\t\t}\n\t\tif (Geometry.hasNullElements(geometries)) {\n\t\t\tthrow new IllegalArgumentException(\"geometries must not contain null elements\");\n\t\t}\n\t\tthis._geometries = geometries;\n\t}\n};\nGeometryCollection.serialVersionUID = -5694727726395021467;\n","import Geometry from './Geometry';\nimport BoundaryOp from '../operation/BoundaryOp';\nimport Lineal from './Lineal';\nimport GeometryCollection from './GeometryCollection';\nimport Dimension from './Dimension';\nexport default class MultiLineString extends GeometryCollection {\n\tconstructor() {\n\t\tsuper();\n\t\tMultiLineString.constructor_.apply(this, arguments);\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn super.equalsExact.call(this, other, tolerance);\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tgetBoundaryDimension() {\n\t\tif (this.isClosed()) {\n\t\t\treturn Dimension.FALSE;\n\t\t}\n\t\treturn 0;\n\t}\n\tisClosed() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tif (!this._geometries[i].isClosed()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_MULTILINESTRING;\n\t}\n\tgetDimension() {\n\t\treturn 1;\n\t}\n\treverse() {\n\t\tvar nLines = this._geometries.length;\n\t\tvar revLines = new Array(nLines).fill(null);\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\trevLines[nLines - 1 - i] = this._geometries[i].reverse();\n\t\t}\n\t\treturn this.getFactory().createMultiLineString(revLines);\n\t}\n\tgetBoundary() {\n\t\treturn new BoundaryOp(this).getBoundary();\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_MULTILINESTRING;\n\t}\n\tcopy() {\n\t\tvar lineStrings = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < lineStrings.length; i++) {\n\t\t\tlineStrings[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new MultiLineString(lineStrings, this._factory);\n\t}\n\tgetClass() {\n\t\treturn MultiLineString;\n\t}\n\tget interfaces_() {\n\t\treturn [Lineal];\n\t}\n}\nMultiLineString.constructor_ = function () {\n\tlet lineStrings = arguments[0], factory = arguments[1];\n\tGeometryCollection.constructor_.call(this, lineStrings, factory);\n};\nMultiLineString.serialVersionUID = 8166665132445433741;\n","import LineString from '../geom/LineString';\nimport BoundaryNodeRule from '../algorithm/BoundaryNodeRule';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport TreeMap from '../../../../java/util/TreeMap';\nimport MultiLineString from '../geom/MultiLineString';\nexport default class BoundaryOp {\n\tconstructor() {\n\t\tBoundaryOp.constructor_.apply(this, arguments);\n\t}\n\tstatic getBoundary() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet g = arguments[0];\n\t\t\tvar bop = new BoundaryOp(g);\n\t\t\treturn bop.getBoundary();\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet g = arguments[0], bnRule = arguments[1];\n\t\t\tvar bop = new BoundaryOp(g, bnRule);\n\t\t\treturn bop.getBoundary();\n\t\t}\n\t}\n\tboundaryMultiLineString(mLine) {\n\t\tif (this._geom.isEmpty()) {\n\t\t\treturn this.getEmptyMultiPoint();\n\t\t}\n\t\tvar bdyPts = this.computeBoundaryCoordinates(mLine);\n\t\tif (bdyPts.length === 1) {\n\t\t\treturn this._geomFact.createPoint(bdyPts[0]);\n\t\t}\n\t\treturn this._geomFact.createMultiPointFromCoords(bdyPts);\n\t}\n\tgetBoundary() {\n\t\tif (this._geom instanceof LineString) return this.boundaryLineString(this._geom);\n\t\tif (this._geom instanceof MultiLineString) return this.boundaryMultiLineString(this._geom);\n\t\treturn this._geom.getBoundary();\n\t}\n\tboundaryLineString(line) {\n\t\tif (this._geom.isEmpty()) {\n\t\t\treturn this.getEmptyMultiPoint();\n\t\t}\n\t\tif (line.isClosed()) {\n\t\t\tvar closedEndpointOnBoundary = this._bnRule.isInBoundary(2);\n\t\t\tif (closedEndpointOnBoundary) {\n\t\t\t\treturn line.getStartPoint();\n\t\t\t} else {\n\t\t\t\treturn this._geomFact.createMultiPoint();\n\t\t\t}\n\t\t}\n\t\treturn this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()]);\n\t}\n\tgetEmptyMultiPoint() {\n\t\treturn this._geomFact.createMultiPoint();\n\t}\n\tcomputeBoundaryCoordinates(mLine) {\n\t\tvar bdyPts = new ArrayList();\n\t\tthis._endpointMap = new TreeMap();\n\t\tfor (var i = 0; i < mLine.getNumGeometries(); i++) {\n\t\t\tvar line = mLine.getGeometryN(i);\n\t\t\tif (line.getNumPoints() === 0) continue;\n\t\t\tthis.addEndpoint(line.getCoordinateN(0));\n\t\t\tthis.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));\n\t\t}\n\t\tfor (var it = this._endpointMap.entrySet().iterator(); it.hasNext(); ) {\n\t\t\tvar entry = it.next();\n\t\t\tvar counter = entry.getValue();\n\t\t\tvar valence = counter.count;\n\t\t\tif (this._bnRule.isInBoundary(valence)) {\n\t\t\t\tbdyPts.add(entry.getKey());\n\t\t\t}\n\t\t}\n\t\treturn CoordinateArrays.toCoordinateArray(bdyPts);\n\t}\n\taddEndpoint(pt) {\n\t\tvar counter = this._endpointMap.get(pt);\n\t\tif (counter === null) {\n\t\t\tcounter = new Counter();\n\t\t\tthis._endpointMap.put(pt, counter);\n\t\t}\n\t\tcounter.count++;\n\t}\n\tgetClass() {\n\t\treturn BoundaryOp;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nBoundaryOp.constructor_ = function () {\n\tthis._geom = null;\n\tthis._geomFact = null;\n\tthis._bnRule = null;\n\tthis._endpointMap = null;\n\tif (arguments.length === 1) {\n\t\tlet geom = arguments[0];\n\t\tBoundaryOp.constructor_.call(this, geom, BoundaryNodeRule.MOD2_BOUNDARY_RULE);\n\t} else if (arguments.length === 2) {\n\t\tlet geom = arguments[0], bnRule = arguments[1];\n\t\tthis._geom = geom;\n\t\tthis._geomFact = geom.getFactory();\n\t\tthis._bnRule = bnRule;\n\t}\n};\nclass Counter {\n\tconstructor() {\n\t\tCounter.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn Counter;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCounter.constructor_ = function () {\n\tthis.count = null;\n};\n","import Coordinate from '../geom/Coordinate';\nexport default class Length {\n\tconstructor() {\n\t\tLength.constructor_.apply(this, arguments);\n\t}\n\tstatic ofLine(pts) {\n\t\tvar n = pts.size();\n\t\tif (n <= 1) return 0.0;\n\t\tvar len = 0.0;\n\t\tvar p = new Coordinate();\n\t\tpts.getCoordinate(0, p);\n\t\tvar x0 = p.x;\n\t\tvar y0 = p.y;\n\t\tfor (var i = 1; i < n; i++) {\n\t\t\tpts.getCoordinate(i, p);\n\t\t\tvar x1 = p.x;\n\t\t\tvar y1 = p.y;\n\t\t\tvar dx = x1 - x0;\n\t\t\tvar dy = y1 - y0;\n\t\t\tlen += Math.sqrt(dx * dx + dy * dy);\n\t\t\tx0 = x1;\n\t\t\ty0 = y1;\n\t\t}\n\t\treturn len;\n\t}\n\tgetClass() {\n\t\treturn Length;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nLength.constructor_ = function () {};\n","export default function PrintStream () {}\n","export default function StringReader () {}\n","export default function ByteArrayOutputStream () {}\n","export default function IOException () {}\n","export default function LineNumberReader () {}\n","import PrintStream from '../../../../java/io/PrintStream';\nimport StringReader from '../../../../java/io/StringReader';\nimport DecimalFormat from '../../../../java/text/DecimalFormat';\nimport System from '../../../../java/lang/System';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport ByteArrayOutputStream from '../../../../java/io/ByteArrayOutputStream';\nimport Assert from './Assert';\nimport IOException from '../../../../java/io/IOException';\nimport LineNumberReader from '../../../../java/io/LineNumberReader';\nexport default class StringUtil {\n\tconstructor() {\n\t\tStringUtil.constructor_.apply(this, arguments);\n\t}\n\tstatic chars(c, n) {\n\t\tvar ch = new Array(n).fill(null);\n\t\tfor (var i = 0; i < n; i++) {\n\t\t\tch[i] = c;\n\t\t}\n\t\treturn new String(ch);\n\t}\n\tstatic getStackTrace() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet t = arguments[0];\n\t\t\tvar os = new ByteArrayOutputStream();\n\t\t\tvar ps = new PrintStream(os);\n\t\t\tt.printStackTrace(ps);\n\t\t\treturn os.toString();\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet t = arguments[0], depth = arguments[1];\n\t\t\tvar stackTrace = \"\";\n\t\t\tvar stringReader = new StringReader(StringUtil.getStackTrace(t));\n\t\t\tvar lineNumberReader = new LineNumberReader(stringReader);\n\t\t\tfor (var i = 0; i < depth; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tstackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e instanceof IOException) {\n\t\t\t\t\t\tAssert.shouldNeverReachHere();\n\t\t\t\t\t} else throw e;\n\t\t\t\t} finally {}\n\t\t\t}\n\t\t\treturn stackTrace;\n\t\t}\n\t}\n\tstatic split(s, separator) {\n\t\tvar separatorlen = separator.length;\n\t\tvar tokenList = new ArrayList();\n\t\tvar tmpString = \"\" + s;\n\t\tvar pos = tmpString.indexOf(separator);\n\t\twhile (pos >= 0) {\n\t\t\tvar token = tmpString.substring(0, pos);\n\t\t\ttokenList.add(token);\n\t\t\ttmpString = tmpString.substring(pos + separatorlen);\n\t\t\tpos = tmpString.indexOf(separator);\n\t\t}\n\t\tif (tmpString.length > 0) tokenList.add(tmpString);\n\t\tvar res = new Array(tokenList.size()).fill(null);\n\t\tfor (var i = 0; i < res.length; i++) {\n\t\t\tres[i] = tokenList.get(i);\n\t\t}\n\t\treturn res;\n\t}\n\tstatic toString() {\n\t\tif (arguments.length === 1 && typeof arguments[0] === \"number\") {\n\t\t\tlet d = arguments[0];\n\t\t\treturn StringUtil.SIMPLE_ORDINATE_FORMAT.format(d);\n\t\t}\n\t}\n\tstatic spaces(n) {\n\t\treturn StringUtil.chars(' ', n);\n\t}\n\tgetClass() {\n\t\treturn StringUtil;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nStringUtil.constructor_ = function () {};\nStringUtil.NEWLINE = System.getProperty(\"line.separator\");\nStringUtil.SIMPLE_ORDINATE_FORMAT = new DecimalFormat(\"0.#\");\n","export default function StringBuilder (str) {\n    this.str = str\n  }\n  \n  StringBuilder.prototype.append = function (e) {\n    this.str += e\n  }\n  \n  StringBuilder.prototype.setCharAt = function (i, c) {\n    this.str = this.str.substr(0, i) + c + this.str.substr(i + 1)\n  }\n  \n  StringBuilder.prototype.toString = function (e) {\n    return this.str\n  }\n  ","export default function DecimalFormat () {}\n","import hasInterface from '../../../../hasInterface';\nimport StringUtil from '../util/StringUtil';\nimport Double from '../../../../java/lang/Double';\nimport CoordinateSequence from './CoordinateSequence';\nimport StringBuilder from '../../../../java/lang/StringBuilder';\nexport default class CoordinateSequences {\n\tconstructor() {\n\t\tCoordinateSequences.constructor_.apply(this, arguments);\n\t}\n\tstatic copyCoord(src, srcPos, dest, destPos) {\n\t\tvar minDim = Math.min(src.getDimension(), dest.getDimension());\n\t\tfor (var dim = 0; dim < minDim; dim++) {\n\t\t\tdest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));\n\t\t}\n\t}\n\tstatic isRing(seq) {\n\t\tvar n = seq.size();\n\t\tif (n === 0) return true;\n\t\tif (n <= 3) return false;\n\t\treturn seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n\t}\n\tstatic isEqual(cs1, cs2) {\n\t\tvar cs1Size = cs1.size();\n\t\tvar cs2Size = cs2.size();\n\t\tif (cs1Size !== cs2Size) return false;\n\t\tvar dim = Math.min(cs1.getDimension(), cs2.getDimension());\n\t\tfor (var i = 0; i < cs1Size; i++) {\n\t\t\tfor (var d = 0; d < dim; d++) {\n\t\t\t\tvar v1 = cs1.getOrdinate(i, d);\n\t\t\t\tvar v2 = cs2.getOrdinate(i, d);\n\t\t\t\tif (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) continue;\n\t\t\t\tif (Double.isNaN(v1) && Double.isNaN(v2)) continue;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tstatic extend(fact, seq, size) {\n\t\tvar newseq = fact.create(size, seq.getDimension());\n\t\tvar n = seq.size();\n\t\tCoordinateSequences.copy(seq, 0, newseq, 0, n);\n\t\tif (n > 0) {\n\t\t\tfor (var i = n; i < size; i++) CoordinateSequences.copy(seq, n - 1, newseq, i, 1);\n\t\t}\n\t\treturn newseq;\n\t}\n\tstatic reverse(seq) {\n\t\tvar last = seq.size() - 1;\n\t\tvar mid = Math.trunc(last / 2);\n\t\tfor (var i = 0; i <= mid; i++) {\n\t\t\tCoordinateSequences.swap(seq, i, last - i);\n\t\t}\n\t}\n\tstatic swap(seq, i, j) {\n\t\tif (i === j) return null;\n\t\tfor (var dim = 0; dim < seq.getDimension(); dim++) {\n\t\t\tvar tmp = seq.getOrdinate(i, dim);\n\t\t\tseq.setOrdinate(i, dim, seq.getOrdinate(j, dim));\n\t\t\tseq.setOrdinate(j, dim, tmp);\n\t\t}\n\t}\n\tstatic copy(src, srcPos, dest, destPos, length) {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tCoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);\n\t\t}\n\t}\n\tstatic toString() {\n\t\tif (arguments.length === 1 && hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\tlet cs = arguments[0];\n\t\t\tvar size = cs.size();\n\t\t\tif (size === 0) return \"()\";\n\t\t\tvar dim = cs.getDimension();\n\t\t\tvar builder = new StringBuilder();\n\t\t\tbuilder.append('(');\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tif (i > 0) builder.append(\" \");\n\t\t\t\tfor (var d = 0; d < dim; d++) {\n\t\t\t\t\tif (d > 0) builder.append(\",\");\n\t\t\t\t\tbuilder.append(StringUtil.toString(cs.getOrdinate(i, d)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuilder.append(')');\n\t\t\treturn builder.toString();\n\t\t}\n\t}\n\tstatic ensureValidRing(fact, seq) {\n\t\tvar n = seq.size();\n\t\tif (n === 0) return seq;\n\t\tif (n <= 3) return CoordinateSequences.createClosedRing(fact, seq, 4);\n\t\tvar isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n\t\tif (isClosed) return seq;\n\t\treturn CoordinateSequences.createClosedRing(fact, seq, n + 1);\n\t}\n\tstatic createClosedRing(fact, seq, size) {\n\t\tvar newseq = fact.create(size, seq.getDimension());\n\t\tvar n = seq.size();\n\t\tCoordinateSequences.copy(seq, 0, newseq, 0, n);\n\t\tfor (var i = n; i < size; i++) CoordinateSequences.copy(seq, 0, newseq, i, 1);\n\t\treturn newseq;\n\t}\n\tgetClass() {\n\t\treturn CoordinateSequences;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCoordinateSequences.constructor_ = function () {};\n","import Geometry from './Geometry';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport BoundaryOp from '../operation/BoundaryOp';\nimport Length from '../algorithm/Length';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Lineal from './Lineal';\nimport CoordinateSequences from './CoordinateSequences';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Dimension from './Dimension';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nimport Envelope from './Envelope';\nexport default class LineString extends Geometry {\n\tconstructor() {\n\t\tsuper();\n\t\tLineString.constructor_.apply(this, arguments);\n\t}\n\tcomputeEnvelopeInternal() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn new Envelope();\n\t\t}\n\t\treturn this._points.expandEnvelope(new Envelope());\n\t}\n\tisRing() {\n\t\treturn this.isClosed() && this.isSimple();\n\t}\n\tgetCoordinates() {\n\t\treturn this._points.toCoordinateArray();\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar otherLineString = other;\n\t\t\tif (this._points.size() !== otherLineString._points.size()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\t\tif (!this.equal(this._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tnormalize() {\n\t\tfor (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {\n\t\t\tvar j = this._points.size() - 1 - i;\n\t\t\tif (!this._points.getCoordinate(i).equals(this._points.getCoordinate(j))) {\n\t\t\t\tif (this._points.getCoordinate(i).compareTo(this._points.getCoordinate(j)) > 0) {\n\t\t\t\t\tvar copy = this._points.copy();\n\t\t\t\t\tCoordinateSequences.reverse(copy);\n\t\t\t\t\tthis._points = copy;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\tgetCoordinate() {\n\t\tif (this.isEmpty()) return null;\n\t\treturn this._points.getCoordinate(0);\n\t}\n\tgetBoundaryDimension() {\n\t\tif (this.isClosed()) {\n\t\t\treturn Dimension.FALSE;\n\t\t}\n\t\treturn 0;\n\t}\n\tisClosed() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));\n\t}\n\tgetEndPoint() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.getPointN(this.getNumPoints() - 1);\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_LINESTRING;\n\t}\n\tgetDimension() {\n\t\treturn 1;\n\t}\n\tgetLength() {\n\t\treturn Length.ofLine(this._points);\n\t}\n\tgetNumPoints() {\n\t\treturn this._points.size();\n\t}\n\treverse() {\n\t\tvar seq = this._points.copy();\n\t\tCoordinateSequences.reverse(seq);\n\t\tvar revLine = this.getFactory().createLineString(seq);\n\t\treturn revLine;\n\t}\n\tcompareToSameClass() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar line = o;\n\t\t\tvar i = 0;\n\t\t\tvar j = 0;\n\t\t\twhile (i < this._points.size() && j < line._points.size()) {\n\t\t\t\tvar comparison = this._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));\n\t\t\t\tif (comparison !== 0) {\n\t\t\t\t\treturn comparison;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (i < this._points.size()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (j < line._points.size()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar line = o;\n\t\t\treturn comp.compare(this._points, line._points);\n\t\t}\n\t}\n\tapply() {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\t\tfilter.filter(this._points.getCoordinate(i));\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this._points.size() === 0) return null;\n\t\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\t\tfilter.filter(this._points, i);\n\t\t\t\tif (filter.isDone()) break;\n\t\t\t}\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t}\n\t}\n\tgetBoundary() {\n\t\treturn new BoundaryOp(this).getBoundary();\n\t}\n\tisEquivalentClass(other) {\n\t\treturn other instanceof LineString;\n\t}\n\tgetCoordinateN(n) {\n\t\treturn this._points.getCoordinate(n);\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_LINESTRING;\n\t}\n\tcopy() {\n\t\treturn new LineString(this._points.copy(), this._factory);\n\t}\n\tgetCoordinateSequence() {\n\t\treturn this._points;\n\t}\n\tisEmpty() {\n\t\treturn this._points.size() === 0;\n\t}\n\tinit(points) {\n\t\tif (points === null) {\n\t\t\tpoints = this.getFactory().getCoordinateSequenceFactory().create([]);\n\t\t}\n\t\tif (points.size() === 1) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid number of points in LineString (found \" + points.size() + \" - must be 0 or >= 2)\");\n\t\t}\n\t\tthis._points = points;\n\t}\n\tisCoordinate(pt) {\n\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\tif (this._points.getCoordinate(i).equals(pt)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tgetStartPoint() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.getPointN(0);\n\t}\n\tgetPointN(n) {\n\t\treturn this.getFactory().createPoint(this._points.getCoordinate(n));\n\t}\n\tgetClass() {\n\t\treturn LineString;\n\t}\n\tget interfaces_() {\n\t\treturn [Lineal];\n\t}\n}\nLineString.constructor_ = function () {\n\tthis._points = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 2) {\n\t\tlet points = arguments[0], factory = arguments[1];\n\t\tGeometry.constructor_.call(this, factory);\n\t\tthis.init(points);\n\t}\n};\nLineString.serialVersionUID = 3110669828065365560;\n","export default class Puntal {\n\tconstructor() {\n\t\tPuntal.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn Puntal;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPuntal.constructor_ = function () {};\n","import Geometry from './Geometry';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Dimension from './Dimension';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nimport Puntal from './Puntal';\nimport Envelope from './Envelope';\nimport Assert from '../util/Assert';\nexport default class Point extends Geometry {\n\tconstructor() {\n\t\tsuper();\n\t\tPoint.constructor_.apply(this, arguments);\n\t}\n\tcomputeEnvelopeInternal() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn new Envelope();\n\t\t}\n\t\tvar env = new Envelope();\n\t\tenv.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));\n\t\treturn env;\n\t}\n\tgetCoordinates() {\n\t\treturn this.isEmpty() ? [] : [this.getCoordinate()];\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.isEmpty() && other.isEmpty()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (this.isEmpty() !== other.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tnormalize() {}\n\tgetCoordinate() {\n\t\treturn this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;\n\t}\n\tgetBoundaryDimension() {\n\t\treturn Dimension.FALSE;\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_POINT;\n\t}\n\tgetDimension() {\n\t\treturn 0;\n\t}\n\tgetNumPoints() {\n\t\treturn this.isEmpty() ? 0 : 1;\n\t}\n\treverse() {\n\t\treturn this.copy();\n\t}\n\tgetX() {\n\t\tif (this.getCoordinate() === null) {\n\t\t\tthrow new IllegalStateException(\"getX called on empty Point\");\n\t\t}\n\t\treturn this.getCoordinate().x;\n\t}\n\tcompareToSameClass() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet other = arguments[0];\n\t\t\tvar point = other;\n\t\t\treturn this.getCoordinate().compareTo(point.getCoordinate());\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet other = arguments[0], comp = arguments[1];\n\t\t\tvar point = other;\n\t\t\treturn comp.compare(this._coordinates, point._coordinates);\n\t\t}\n\t}\n\tapply() {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfilter.filter(this.getCoordinate());\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this.isEmpty()) return null;\n\t\t\tfilter.filter(this._coordinates, 0);\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t}\n\t}\n\tgetBoundary() {\n\t\treturn this.getFactory().createGeometryCollection();\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_POINT;\n\t}\n\tcopy() {\n\t\treturn new Point(this._coordinates.copy(), this._factory);\n\t}\n\tgetCoordinateSequence() {\n\t\treturn this._coordinates;\n\t}\n\tgetY() {\n\t\tif (this.getCoordinate() === null) {\n\t\t\tthrow new IllegalStateException(\"getY called on empty Point\");\n\t\t}\n\t\treturn this.getCoordinate().y;\n\t}\n\tisEmpty() {\n\t\treturn this._coordinates.size() === 0;\n\t}\n\tinit(coordinates) {\n\t\tif (coordinates === null) {\n\t\t\tcoordinates = this.getFactory().getCoordinateSequenceFactory().create([]);\n\t\t}\n\t\tAssert.isTrue(coordinates.size() <= 1);\n\t\tthis._coordinates = coordinates;\n\t}\n\tisSimple() {\n\t\treturn true;\n\t}\n\tgetClass() {\n\t\treturn Point;\n\t}\n\tget interfaces_() {\n\t\treturn [Puntal];\n\t}\n}\nPoint.constructor_ = function () {\n\tthis._coordinates = null;\n\tlet coordinates = arguments[0], factory = arguments[1];\n\tGeometry.constructor_.call(this, factory);\n\tthis.init(coordinates);\n};\nPoint.serialVersionUID = 4902022702746614570;\n","import hasInterface from '../../../../hasInterface';\nimport Coordinate from '../geom/Coordinate';\nimport CoordinateSequence from '../geom/CoordinateSequence';\nexport default class Area {\n\tconstructor() {\n\t\tArea.constructor_.apply(this, arguments);\n\t}\n\tstatic ofRing() {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tlet ring = arguments[0];\n\t\t\treturn Math.abs(Area.ofRingSigned(ring));\n\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\tlet ring = arguments[0];\n\t\t\treturn Math.abs(Area.ofRingSigned(ring));\n\t\t}\n\t}\n\tstatic ofRingSigned() {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tlet ring = arguments[0];\n\t\t\tif (ring.length < 3) return 0.0;\n\t\t\tvar sum = 0.0;\n\t\t\tvar x0 = ring[0].x;\n\t\t\tfor (var i = 1; i < ring.length - 1; i++) {\n\t\t\t\tvar x = ring[i].x - x0;\n\t\t\t\tvar y1 = ring[i + 1].y;\n\t\t\t\tvar y2 = ring[i - 1].y;\n\t\t\t\tsum += x * (y2 - y1);\n\t\t\t}\n\t\t\treturn sum / 2.0;\n\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\tlet ring = arguments[0];\n\t\t\tvar n = ring.size();\n\t\t\tif (n < 3) return 0.0;\n\t\t\tvar p0 = new Coordinate();\n\t\t\tvar p1 = new Coordinate();\n\t\t\tvar p2 = new Coordinate();\n\t\t\tring.getCoordinate(0, p1);\n\t\t\tring.getCoordinate(1, p2);\n\t\t\tvar x0 = p1.x;\n\t\t\tp2.x -= x0;\n\t\t\tvar sum = 0.0;\n\t\t\tfor (var i = 1; i < n - 1; i++) {\n\t\t\t\tp0.y = p1.y;\n\t\t\t\tp1.x = p2.x;\n\t\t\t\tp1.y = p2.y;\n\t\t\t\tring.getCoordinate(i + 1, p2);\n\t\t\t\tp2.x -= x0;\n\t\t\t\tsum += p1.x * (p0.y - p2.y);\n\t\t\t}\n\t\t\treturn sum / 2.0;\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn Area;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nArea.constructor_ = function () {};\n","export default function StringBuffer (str) {\n  this.str = str\n}\n\nStringBuffer.prototype.append = function (e) {\n  this.str += e\n}\n\nStringBuffer.prototype.setCharAt = function (i, c) {\n  this.str = this.str.substr(0, i) + c + this.str.substr(i + 1)\n}\n\nStringBuffer.prototype.toString = function (e) {\n  return this.str\n}\n","export default function Integer (value) {\n  this.value = value\n}\n\nInteger.prototype.intValue = function () {\n  return this.value\n}\nInteger.prototype.compareTo = function (o) {\n  if (this.value < o) return -1\n  if (this.value > o) return 1\n  return 0\n}\n\nInteger.isNaN = n => Number.isNaN(n)\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Double from '../../../../java/lang/Double';\nimport Integer from '../../../../java/lang/Integer';\nimport Character from '../../../../java/lang/Character';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport Serializable from '../../../../java/io/Serializable';\nexport default class DD {\n\tconstructor() {\n\t\tDD.constructor_.apply(this, arguments);\n\t}\n\tstatic sqr(x) {\n\t\treturn DD.valueOf(x).selfMultiply(x);\n\t}\n\tstatic valueOf() {\n\t\tif (typeof arguments[0] === \"string\") {\n\t\t\tlet str = arguments[0];\n\t\t\treturn DD.parse(str);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet x = arguments[0];\n\t\t\treturn new DD(x);\n\t\t}\n\t}\n\tstatic sqrt(x) {\n\t\treturn DD.valueOf(x).sqrt();\n\t}\n\tstatic parse(str) {\n\t\tvar i = 0;\n\t\tvar strlen = str.length;\n\t\twhile (Character.isWhitespace(str.charAt(i))) i++;\n\t\tvar isNegative = false;\n\t\tif (i < strlen) {\n\t\t\tvar signCh = str.charAt(i);\n\t\t\tif (signCh === '-' || signCh === '+') {\n\t\t\t\ti++;\n\t\t\t\tif (signCh === '-') isNegative = true;\n\t\t\t}\n\t\t}\n\t\tvar val = new DD();\n\t\tvar numDigits = 0;\n\t\tvar numBeforeDec = 0;\n\t\tvar exp = 0;\n\t\twhile (true) {\n\t\t\tif (i >= strlen) break;\n\t\t\tvar ch = str.charAt(i);\n\t\t\ti++;\n\t\t\tif (Character.isDigit(ch)) {\n\t\t\t\tvar d = ch - '0';\n\t\t\t\tval.selfMultiply(DD.TEN);\n\t\t\t\tval.selfAdd(d);\n\t\t\t\tnumDigits++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch === '.') {\n\t\t\t\tnumBeforeDec = numDigits;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch === 'e' || ch === 'E') {\n\t\t\t\tvar expStr = str.substring(i);\n\t\t\t\ttry {\n\t\t\t\t\texp = Integer.parseInt(expStr);\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tif (ex instanceof NumberFormatException) {\n\t\t\t\t\t\tthrow new NumberFormatException(\"Invalid exponent \" + expStr + \" in string \" + str);\n\t\t\t\t\t} else throw ex;\n\t\t\t\t} finally {}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthrow new NumberFormatException(\"Unexpected character '\" + ch + \"' at position \" + i + \" in string \" + str);\n\t\t}\n\t\tvar val2 = val;\n\t\tvar numDecPlaces = numDigits - numBeforeDec - exp;\n\t\tif (numDecPlaces === 0) {\n\t\t\tval2 = val;\n\t\t} else if (numDecPlaces > 0) {\n\t\t\tvar scale = DD.TEN.pow(numDecPlaces);\n\t\t\tval2 = val.divide(scale);\n\t\t} else if (numDecPlaces < 0) {\n\t\t\tvar scale = DD.TEN.pow(-numDecPlaces);\n\t\t\tval2 = val.multiply(scale);\n\t\t}\n\t\tif (isNegative) {\n\t\t\treturn val2.negate();\n\t\t}\n\t\treturn val2;\n\t}\n\tstatic createNaN() {\n\t\treturn new DD(Double.NaN, Double.NaN);\n\t}\n\tstatic copy(dd) {\n\t\treturn new DD(dd);\n\t}\n\tstatic magnitude(x) {\n\t\tvar xAbs = Math.abs(x);\n\t\tvar xLog10 = Math.log(xAbs) / Math.log(10);\n\t\tvar xMag = Math.trunc(Math.floor(xLog10));\n\t\tvar xApprox = Math.pow(10, xMag);\n\t\tif (xApprox * 10 <= xAbs) xMag += 1;\n\t\treturn xMag;\n\t}\n\tstatic stringOfChar(ch, len) {\n\t\tvar buf = new StringBuffer();\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tbuf.append(ch);\n\t\t}\n\t\treturn buf.toString();\n\t}\n\tle(y) {\n\t\treturn this._hi < y._hi || this._hi === y._hi && this._lo <= y._lo;\n\t}\n\textractSignificantDigits(insertDecimalPoint, magnitude) {\n\t\tvar y = this.abs();\n\t\tvar mag = DD.magnitude(y._hi);\n\t\tvar scale = DD.TEN.pow(mag);\n\t\ty = y.divide(scale);\n\t\tif (y.gt(DD.TEN)) {\n\t\t\ty = y.divide(DD.TEN);\n\t\t\tmag += 1;\n\t\t} else if (y.lt(DD.ONE)) {\n\t\t\ty = y.multiply(DD.TEN);\n\t\t\tmag -= 1;\n\t\t}\n\t\tvar decimalPointPos = mag + 1;\n\t\tvar buf = new StringBuffer();\n\t\tvar numDigits = DD.MAX_PRINT_DIGITS - 1;\n\t\tfor (var i = 0; i <= numDigits; i++) {\n\t\t\tif (insertDecimalPoint && i === decimalPointPos) {\n\t\t\t\tbuf.append('.');\n\t\t\t}\n\t\t\tvar digit = Math.trunc(y._hi);\n\t\t\tif (digit < 0 || digit > 9) {}\n\t\t\tif (digit < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar rebiasBy10 = false;\n\t\t\tvar digitChar = 0;\n\t\t\tif (digit > 9) {\n\t\t\t\trebiasBy10 = true;\n\t\t\t\tdigitChar = '9';\n\t\t\t} else {\n\t\t\t\tdigitChar = '0' + digit;\n\t\t\t}\n\t\t\tbuf.append(digitChar);\n\t\t\ty = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);\n\t\t\tif (rebiasBy10) y.selfAdd(DD.TEN);\n\t\t\tvar continueExtractingDigits = true;\n\t\t\tvar remMag = DD.magnitude(y._hi);\n\t\t\tif (remMag < 0 && Math.abs(remMag) >= numDigits - i) continueExtractingDigits = false;\n\t\t\tif (!continueExtractingDigits) break;\n\t\t}\n\t\tmagnitude[0] = mag;\n\t\treturn buf.toString();\n\t}\n\tsqr() {\n\t\treturn this.multiply(this);\n\t}\n\tdoubleValue() {\n\t\treturn this._hi + this._lo;\n\t}\n\tsubtract() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\treturn this.add(y.negate());\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\treturn this.add(-y);\n\t\t}\n\t}\n\tequals() {\n\t\tif (arguments.length === 1 && arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\treturn this._hi === y._hi && this._lo === y._lo;\n\t\t}\n\t}\n\tisZero() {\n\t\treturn this._hi === 0.0 && this._lo === 0.0;\n\t}\n\tselfSubtract() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\tif (this.isNaN()) return this;\n\t\t\treturn this.selfAdd(-y._hi, -y._lo);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\tif (this.isNaN()) return this;\n\t\t\treturn this.selfAdd(-y, 0.0);\n\t\t}\n\t}\n\tgetSpecialNumberString() {\n\t\tif (this.isZero()) return \"0.0\";\n\t\tif (this.isNaN()) return \"NaN \";\n\t\treturn null;\n\t}\n\tmin(x) {\n\t\tif (this.le(x)) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn x;\n\t\t}\n\t}\n\tselfDivide() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof DD) {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfDivide(y._hi, y._lo);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfDivide(y, 0.0);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet yhi = arguments[0], ylo = arguments[1];\n\t\t\tvar hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;\n\t\t\tC = this._hi / yhi;\n\t\t\tc = DD.SPLIT * C;\n\t\t\thc = c - C;\n\t\t\tu = DD.SPLIT * yhi;\n\t\t\thc = c - hc;\n\t\t\ttc = C - hc;\n\t\t\thy = u - yhi;\n\t\t\tU = C * yhi;\n\t\t\thy = u - hy;\n\t\t\tty = yhi - hy;\n\t\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n\t\t\tc = (this._hi - U - u + this._lo - C * ylo) / yhi;\n\t\t\tu = C + c;\n\t\t\tthis._hi = u;\n\t\t\tthis._lo = C - u + c;\n\t\t\treturn this;\n\t\t}\n\t}\n\tdump() {\n\t\treturn \"DD<\" + this._hi + \", \" + this._lo + \">\";\n\t}\n\tdivide() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\tvar hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;\n\t\t\tC = this._hi / y._hi;\n\t\t\tc = DD.SPLIT * C;\n\t\t\thc = c - C;\n\t\t\tu = DD.SPLIT * y._hi;\n\t\t\thc = c - hc;\n\t\t\ttc = C - hc;\n\t\t\thy = u - y._hi;\n\t\t\tU = C * y._hi;\n\t\t\thy = u - hy;\n\t\t\tty = y._hi - hy;\n\t\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n\t\t\tc = (this._hi - U - u + this._lo - C * y._lo) / y._hi;\n\t\t\tu = C + c;\n\t\t\tvar zhi = u;\n\t\t\tvar zlo = C - u + c;\n\t\t\treturn new DD(zhi, zlo);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\tif (Double.isNaN(y)) return DD.createNaN();\n\t\t\treturn DD.copy(this).selfDivide(y, 0.0);\n\t\t}\n\t}\n\tge(y) {\n\t\treturn this._hi > y._hi || this._hi === y._hi && this._lo >= y._lo;\n\t}\n\tpow(exp) {\n\t\tif (exp === 0.0) return DD.valueOf(1.0);\n\t\tvar r = new DD(this);\n\t\tvar s = DD.valueOf(1.0);\n\t\tvar n = Math.abs(exp);\n\t\tif (n > 1) {\n\t\t\twhile (n > 0) {\n\t\t\t\tif (n % 2 === 1) {\n\t\t\t\t\ts.selfMultiply(r);\n\t\t\t\t}\n\t\t\t\tn /= 2;\n\t\t\t\tif (n > 0) r = r.sqr();\n\t\t\t}\n\t\t} else {\n\t\t\ts = r;\n\t\t}\n\t\tif (exp < 0) return s.reciprocal();\n\t\treturn s;\n\t}\n\tceil() {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tvar fhi = Math.ceil(this._hi);\n\t\tvar flo = 0.0;\n\t\tif (fhi === this._hi) {\n\t\t\tflo = Math.ceil(this._lo);\n\t\t}\n\t\treturn new DD(fhi, flo);\n\t}\n\tcompareTo(o) {\n\t\tvar other = o;\n\t\tif (this._hi < other._hi) return -1;\n\t\tif (this._hi > other._hi) return 1;\n\t\tif (this._lo < other._lo) return -1;\n\t\tif (this._lo > other._lo) return 1;\n\t\treturn 0;\n\t}\n\trint() {\n\t\tif (this.isNaN()) return this;\n\t\tvar plus5 = this.add(0.5);\n\t\treturn plus5.floor();\n\t}\n\tsetValue() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet value = arguments[0];\n\t\t\tthis.init(value);\n\t\t\treturn this;\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet value = arguments[0];\n\t\t\tthis.init(value);\n\t\t\treturn this;\n\t\t}\n\t}\n\tmax(x) {\n\t\tif (this.ge(x)) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn x;\n\t\t}\n\t}\n\tsqrt() {\n\t\tif (this.isZero()) return DD.valueOf(0.0);\n\t\tif (this.isNegative()) {\n\t\t\treturn DD.NaN;\n\t\t}\n\t\tvar x = 1.0 / Math.sqrt(this._hi);\n\t\tvar ax = this._hi * x;\n\t\tvar axdd = DD.valueOf(ax);\n\t\tvar diffSq = this.subtract(axdd.sqr());\n\t\tvar d2 = diffSq._hi * (x * 0.5);\n\t\treturn axdd.add(d2);\n\t}\n\tselfAdd() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof DD) {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfAdd(y._hi, y._lo);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\tvar H = null, h = null, S = null, s = null, e = null, f = null;\n\t\t\t\tS = this._hi + y;\n\t\t\t\te = S - this._hi;\n\t\t\t\ts = S - e;\n\t\t\t\ts = y - e + (this._hi - s);\n\t\t\t\tf = s + this._lo;\n\t\t\t\tH = S + f;\n\t\t\t\th = f + (S - H);\n\t\t\t\tthis._hi = H + h;\n\t\t\t\tthis._lo = h + (H - this._hi);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet yhi = arguments[0], ylo = arguments[1];\n\t\t\tvar H = null, h = null, T = null, t = null, S = null, s = null, e = null, f = null;\n\t\t\tS = this._hi + yhi;\n\t\t\tT = this._lo + ylo;\n\t\t\te = S - this._hi;\n\t\t\tf = T - this._lo;\n\t\t\ts = S - e;\n\t\t\tt = T - f;\n\t\t\ts = yhi - e + (this._hi - s);\n\t\t\tt = ylo - f + (this._lo - t);\n\t\t\te = s + T;\n\t\t\tH = S + e;\n\t\t\th = e + (S - H);\n\t\t\te = t + h;\n\t\t\tvar zhi = H + e;\n\t\t\tvar zlo = e + (H - zhi);\n\t\t\tthis._hi = zhi;\n\t\t\tthis._lo = zlo;\n\t\t\treturn this;\n\t\t}\n\t}\n\tselfMultiply() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof DD) {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfMultiply(y._hi, y._lo);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfMultiply(y, 0.0);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet yhi = arguments[0], ylo = arguments[1];\n\t\t\tvar hx = null, tx = null, hy = null, ty = null, C = null, c = null;\n\t\t\tC = DD.SPLIT * this._hi;\n\t\t\thx = C - this._hi;\n\t\t\tc = DD.SPLIT * yhi;\n\t\t\thx = C - hx;\n\t\t\ttx = this._hi - hx;\n\t\t\thy = c - yhi;\n\t\t\tC = this._hi * yhi;\n\t\t\thy = c - hy;\n\t\t\tty = yhi - hy;\n\t\t\tc = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);\n\t\t\tvar zhi = C + c;\n\t\t\thx = C - zhi;\n\t\t\tvar zlo = c + hx;\n\t\t\tthis._hi = zhi;\n\t\t\tthis._lo = zlo;\n\t\t\treturn this;\n\t\t}\n\t}\n\tselfSqr() {\n\t\treturn this.selfMultiply(this);\n\t}\n\tfloor() {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tvar fhi = Math.floor(this._hi);\n\t\tvar flo = 0.0;\n\t\tif (fhi === this._hi) {\n\t\t\tflo = Math.floor(this._lo);\n\t\t}\n\t\treturn new DD(fhi, flo);\n\t}\n\tnegate() {\n\t\tif (this.isNaN()) return this;\n\t\treturn new DD(-this._hi, -this._lo);\n\t}\n\tclone() {\n\t\ttry {\n\t\t\treturn null;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof CloneNotSupportedException) {\n\t\t\t\treturn null;\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t}\n\tmultiply() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\tif (y.isNaN()) return DD.createNaN();\n\t\t\treturn DD.copy(this).selfMultiply(y);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\tif (Double.isNaN(y)) return DD.createNaN();\n\t\t\treturn DD.copy(this).selfMultiply(y, 0.0);\n\t\t}\n\t}\n\tisNaN() {\n\t\treturn Double.isNaN(this._hi);\n\t}\n\tintValue() {\n\t\treturn Math.trunc(this._hi);\n\t}\n\ttoString() {\n\t\tvar mag = DD.magnitude(this._hi);\n\t\tif (mag >= -3 && mag <= 20) return this.toStandardNotation();\n\t\treturn this.toSciNotation();\n\t}\n\ttoStandardNotation() {\n\t\tvar specialStr = this.getSpecialNumberString();\n\t\tif (specialStr !== null) return specialStr;\n\t\tvar magnitude = new Array(1).fill(null);\n\t\tvar sigDigits = this.extractSignificantDigits(true, magnitude);\n\t\tvar decimalPointPos = magnitude[0] + 1;\n\t\tvar num = sigDigits;\n\t\tif (sigDigits.charAt(0) === '.') {\n\t\t\tnum = \"0\" + sigDigits;\n\t\t} else if (decimalPointPos < 0) {\n\t\t\tnum = \"0.\" + DD.stringOfChar('0', -decimalPointPos) + sigDigits;\n\t\t} else if (sigDigits.indexOf('.') === -1) {\n\t\t\tvar numZeroes = decimalPointPos - sigDigits.length;\n\t\t\tvar zeroes = DD.stringOfChar('0', numZeroes);\n\t\t\tnum = sigDigits + zeroes + \".0\";\n\t\t}\n\t\tif (this.isNegative()) return \"-\" + num;\n\t\treturn num;\n\t}\n\treciprocal() {\n\t\tvar hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;\n\t\tC = 1.0 / this._hi;\n\t\tc = DD.SPLIT * C;\n\t\thc = c - C;\n\t\tu = DD.SPLIT * this._hi;\n\t\thc = c - hc;\n\t\ttc = C - hc;\n\t\thy = u - this._hi;\n\t\tU = C * this._hi;\n\t\thy = u - hy;\n\t\tty = this._hi - hy;\n\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n\t\tc = (1.0 - U - u - C * this._lo) / this._hi;\n\t\tvar zhi = C + c;\n\t\tvar zlo = C - zhi + c;\n\t\treturn new DD(zhi, zlo);\n\t}\n\ttoSciNotation() {\n\t\tif (this.isZero()) return DD.SCI_NOT_ZERO;\n\t\tvar specialStr = this.getSpecialNumberString();\n\t\tif (specialStr !== null) return specialStr;\n\t\tvar magnitude = new Array(1).fill(null);\n\t\tvar digits = this.extractSignificantDigits(false, magnitude);\n\t\tvar expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];\n\t\tif (digits.charAt(0) === '0') {\n\t\t\tthrow new IllegalStateException(\"Found leading zero: \" + digits);\n\t\t}\n\t\tvar trailingDigits = \"\";\n\t\tif (digits.length > 1) trailingDigits = digits.substring(1);\n\t\tvar digitsWithDecimal = digits.charAt(0) + \".\" + trailingDigits;\n\t\tif (this.isNegative()) return \"-\" + digitsWithDecimal + expStr;\n\t\treturn digitsWithDecimal + expStr;\n\t}\n\tabs() {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tif (this.isNegative()) return this.negate();\n\t\treturn new DD(this);\n\t}\n\tisPositive() {\n\t\treturn this._hi > 0.0 || this._hi === 0.0 && this._lo > 0.0;\n\t}\n\tlt(y) {\n\t\treturn this._hi < y._hi || this._hi === y._hi && this._lo < y._lo;\n\t}\n\tadd() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\treturn DD.copy(this).selfAdd(y);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\treturn DD.copy(this).selfAdd(y);\n\t\t}\n\t}\n\tinit() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (typeof arguments[0] === \"number\") {\n\t\t\t\tlet x = arguments[0];\n\t\t\t\tthis._hi = x;\n\t\t\t\tthis._lo = 0.0;\n\t\t\t} else if (arguments[0] instanceof DD) {\n\t\t\t\tlet dd = arguments[0];\n\t\t\t\tthis._hi = dd._hi;\n\t\t\t\tthis._lo = dd._lo;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet hi = arguments[0], lo = arguments[1];\n\t\t\tthis._hi = hi;\n\t\t\tthis._lo = lo;\n\t\t}\n\t}\n\tgt(y) {\n\t\treturn this._hi > y._hi || this._hi === y._hi && this._lo > y._lo;\n\t}\n\tisNegative() {\n\t\treturn this._hi < 0.0 || this._hi === 0.0 && this._lo < 0.0;\n\t}\n\ttrunc() {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tif (this.isPositive()) return this.floor(); else return this.ceil();\n\t}\n\tsignum() {\n\t\tif (this._hi > 0) return 1;\n\t\tif (this._hi < 0) return -1;\n\t\tif (this._lo > 0) return 1;\n\t\tif (this._lo < 0) return -1;\n\t\treturn 0;\n\t}\n\tgetClass() {\n\t\treturn DD;\n\t}\n\tget interfaces_() {\n\t\treturn [Serializable, Comparable, Cloneable];\n\t}\n}\nDD.constructor_ = function () {\n\tthis._hi = 0.0;\n\tthis._lo = 0.0;\n\tif (arguments.length === 0) {\n\t\tthis.init(0.0);\n\t} else if (arguments.length === 1) {\n\t\tif (typeof arguments[0] === \"number\") {\n\t\t\tlet x = arguments[0];\n\t\t\tthis.init(x);\n\t\t} else if (arguments[0] instanceof DD) {\n\t\t\tlet dd = arguments[0];\n\t\t\tthis.init(dd);\n\t\t} else if (typeof arguments[0] === \"string\") {\n\t\t\tlet str = arguments[0];\n\t\t\tDD.constructor_.call(this, DD.parse(str));\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet hi = arguments[0], lo = arguments[1];\n\t\tthis.init(hi, lo);\n\t}\n};\nDD.PI = new DD(3.141592653589793116e+00, 1.224646799147353207e-16);\nDD.TWO_PI = new DD(6.283185307179586232e+00, 2.449293598294706414e-16);\nDD.PI_2 = new DD(1.570796326794896558e+00, 6.123233995736766036e-17);\nDD.E = new DD(2.718281828459045091e+00, 1.445646891729250158e-16);\nDD.NaN = new DD(Double.NaN, Double.NaN);\nDD.EPS = 1.23259516440783e-32;\nDD.SPLIT = 134217729.0;\nDD.MAX_PRINT_DIGITS = 32;\nDD.TEN = DD.valueOf(10.0);\nDD.ONE = DD.valueOf(1.0);\nDD.SCI_NOT_EXPONENT_CHAR = \"E\";\nDD.SCI_NOT_ZERO = \"0.0E0\";\n","import Coordinate from '../geom/Coordinate';\nimport DD from '../math/DD';\nexport default class CGAlgorithmsDD {\n\tconstructor() {\n\t\tCGAlgorithmsDD.constructor_.apply(this, arguments);\n\t}\n\tstatic orientationIndex(p1, p2, q) {\n\t\tvar index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);\n\t\tif (index <= 1) return index;\n\t\tvar dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);\n\t\tvar dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);\n\t\tvar dx2 = DD.valueOf(q.x).selfAdd(-p2.x);\n\t\tvar dy2 = DD.valueOf(q.y).selfAdd(-p2.y);\n\t\treturn dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();\n\t}\n\tstatic signOfDet2x2() {\n\t\tif (arguments[3] instanceof DD && (arguments[2] instanceof DD && (arguments[0] instanceof DD && arguments[1] instanceof DD))) {\n\t\t\tlet x1 = arguments[0], y1 = arguments[1], x2 = arguments[2], y2 = arguments[3];\n\t\t\tvar det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n\t\t\treturn det.signum();\n\t\t} else if (typeof arguments[3] === \"number\" && (typeof arguments[2] === \"number\" && (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\"))) {\n\t\t\tlet dx1 = arguments[0], dy1 = arguments[1], dx2 = arguments[2], dy2 = arguments[3];\n\t\t\tvar x1 = DD.valueOf(dx1);\n\t\t\tvar y1 = DD.valueOf(dy1);\n\t\t\tvar x2 = DD.valueOf(dx2);\n\t\t\tvar y2 = DD.valueOf(dy2);\n\t\t\tvar det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n\t\t\treturn det.signum();\n\t\t}\n\t}\n\tstatic intersection(p1, p2, q1, q2) {\n\t\tvar denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));\n\t\tvar denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));\n\t\tvar denom = denom1.subtract(denom2);\n\t\tvar numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n\t\tvar numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n\t\tvar numx = numx1.subtract(numx2);\n\t\tvar fracP = numx.selfDivide(denom).doubleValue();\n\t\tvar x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();\n\t\tvar numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n\t\tvar numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n\t\tvar numy = numy1.subtract(numy2);\n\t\tvar fracQ = numy.selfDivide(denom).doubleValue();\n\t\tvar y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();\n\t\treturn new Coordinate(x, y);\n\t}\n\tstatic orientationIndexFilter(pa, pb, pc) {\n\t\tvar detsum = null;\n\t\tvar detleft = (pa.x - pc.x) * (pb.y - pc.y);\n\t\tvar detright = (pa.y - pc.y) * (pb.x - pc.x);\n\t\tvar det = detleft - detright;\n\t\tif (detleft > 0.0) {\n\t\t\tif (detright <= 0.0) {\n\t\t\t\treturn CGAlgorithmsDD.signum(det);\n\t\t\t} else {\n\t\t\t\tdetsum = detleft + detright;\n\t\t\t}\n\t\t} else if (detleft < 0.0) {\n\t\t\tif (detright >= 0.0) {\n\t\t\t\treturn CGAlgorithmsDD.signum(det);\n\t\t\t} else {\n\t\t\t\tdetsum = -detleft - detright;\n\t\t\t}\n\t\t} else {\n\t\t\treturn CGAlgorithmsDD.signum(det);\n\t\t}\n\t\tvar errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;\n\t\tif (det >= errbound || -det >= errbound) {\n\t\t\treturn CGAlgorithmsDD.signum(det);\n\t\t}\n\t\treturn 2;\n\t}\n\tstatic signum(x) {\n\t\tif (x > 0) return 1;\n\t\tif (x < 0) return -1;\n\t\treturn 0;\n\t}\n\tgetClass() {\n\t\treturn CGAlgorithmsDD;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCGAlgorithmsDD.constructor_ = function () {};\nCGAlgorithmsDD.DP_SAFE_EPSILON = 1e-15;\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport CGAlgorithmsDD from './CGAlgorithmsDD';\nexport default class Orientation {\n\tconstructor() {\n\t\tOrientation.constructor_.apply(this, arguments);\n\t}\n\tstatic index(p1, p2, q) {\n\t\treturn CGAlgorithmsDD.orientationIndex(p1, p2, q);\n\t}\n\tstatic isCCW(ring) {\n\t\tvar nPts = ring.length - 1;\n\t\tif (nPts < 3) throw new IllegalArgumentException(\"Ring has fewer than 4 points, so orientation cannot be determined\");\n\t\tvar hiPt = ring[0];\n\t\tvar hiIndex = 0;\n\t\tfor (var i = 1; i <= nPts; i++) {\n\t\t\tvar p = ring[i];\n\t\t\tif (p.y > hiPt.y) {\n\t\t\t\thiPt = p;\n\t\t\t\thiIndex = i;\n\t\t\t}\n\t\t}\n\t\tvar iPrev = hiIndex;\n\t\tdo {\n\t\t\tiPrev = iPrev - 1;\n\t\t\tif (iPrev < 0) iPrev = nPts;\n\t\t} while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);\n\t\tvar iNext = hiIndex;\n\t\tdo {\n\t\t\tiNext = (iNext + 1) % nPts;\n\t\t} while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);\n\t\tvar prev = ring[iPrev];\n\t\tvar next = ring[iNext];\n\t\tif (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;\n\t\tvar disc = Orientation.index(prev, hiPt, next);\n\t\tvar isCCW = null;\n\t\tif (disc === 0) {\n\t\t\tisCCW = prev.x > next.x;\n\t\t} else {\n\t\t\tisCCW = disc > 0;\n\t\t}\n\t\treturn isCCW;\n\t}\n\tgetClass() {\n\t\treturn Orientation;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nOrientation.constructor_ = function () {};\nOrientation.CLOCKWISE = -1;\nOrientation.RIGHT = Orientation.CLOCKWISE;\nOrientation.COUNTERCLOCKWISE = 1;\nOrientation.LEFT = Orientation.COUNTERCLOCKWISE;\nOrientation.COLLINEAR = 0;\nOrientation.STRAIGHT = Orientation.COLLINEAR;\n","export default class Polygonal {\n\tconstructor() {\n\t\tPolygonal.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn Polygonal;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPolygonal.constructor_ = function () {};\n","import Area from '../algorithm/Area';\nimport Geometry from './Geometry';\nimport Arrays from '../../../../java/util/Arrays';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Orientation from '../algorithm/Orientation';\nimport System from '../../../../java/lang/System';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport CoordinateArrays from './CoordinateArrays';\nimport Polygonal from './Polygonal';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nexport default class Polygon extends Geometry {\n\tconstructor() {\n\t\tsuper();\n\t\tPolygon.constructor_.apply(this, arguments);\n\t}\n\tcomputeEnvelopeInternal() {\n\t\treturn this._shell.getEnvelopeInternal();\n\t}\n\tgetCoordinates() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn [];\n\t\t}\n\t\tvar coordinates = new Array(this.getNumPoints()).fill(null);\n\t\tvar k = -1;\n\t\tvar shellCoordinates = this._shell.getCoordinates();\n\t\tfor (var x = 0; x < shellCoordinates.length; x++) {\n\t\t\tk++;\n\t\t\tcoordinates[k] = shellCoordinates[x];\n\t\t}\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tvar childCoordinates = this._holes[i].getCoordinates();\n\t\t\tfor (var j = 0; j < childCoordinates.length; j++) {\n\t\t\t\tk++;\n\t\t\t\tcoordinates[k] = childCoordinates[j];\n\t\t\t}\n\t\t}\n\t\treturn coordinates;\n\t}\n\tgetArea() {\n\t\tvar area = 0.0;\n\t\tarea += Area.ofRing(this._shell.getCoordinateSequence());\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tarea -= Area.ofRing(this._holes[i].getCoordinateSequence());\n\t\t}\n\t\treturn area;\n\t}\n\tisRectangle() {\n\t\tif (this.getNumInteriorRing() !== 0) return false;\n\t\tif (this._shell === null) return false;\n\t\tif (this._shell.getNumPoints() !== 5) return false;\n\t\tvar seq = this._shell.getCoordinateSequence();\n\t\tvar env = this.getEnvelopeInternal();\n\t\tfor (var i = 0; i < 5; i++) {\n\t\t\tvar x = seq.getX(i);\n\t\t\tif (!(x === env.getMinX() || x === env.getMaxX())) return false;\n\t\t\tvar y = seq.getY(i);\n\t\t\tif (!(y === env.getMinY() || y === env.getMaxY())) return false;\n\t\t}\n\t\tvar prevX = seq.getX(0);\n\t\tvar prevY = seq.getY(0);\n\t\tfor (var i = 1; i <= 4; i++) {\n\t\t\tvar x = seq.getX(i);\n\t\t\tvar y = seq.getY(i);\n\t\t\tvar xChanged = x !== prevX;\n\t\t\tvar yChanged = y !== prevY;\n\t\t\tif (xChanged === yChanged) return false;\n\t\t\tprevX = x;\n\t\t\tprevY = y;\n\t\t}\n\t\treturn true;\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar otherPolygon = other;\n\t\t\tvar thisShell = this._shell;\n\t\t\tvar otherPolygonShell = otherPolygon._shell;\n\t\t\tif (!thisShell.equalsExact(otherPolygonShell, tolerance)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this._holes.length !== otherPolygon._holes.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tif (!this._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tnormalize() {\n\t\tif (arguments.length === 0) {\n\t\t\tthis.normalize(this._shell, true);\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tthis.normalize(this._holes[i], false);\n\t\t\t}\n\t\t\tArrays.sort(this._holes);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet ring = arguments[0], clockwise = arguments[1];\n\t\t\tif (ring.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);\n\t\t\tSystem.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);\n\t\t\tvar minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());\n\t\t\tCoordinateArrays.scroll(uniqueCoordinates, minCoordinate);\n\t\t\tSystem.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);\n\t\t\tring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];\n\t\t\tif (Orientation.isCCW(ring.getCoordinates()) === clockwise) {\n\t\t\t\tCoordinateArrays.reverse(ring.getCoordinates());\n\t\t\t}\n\t\t}\n\t}\n\tgetCoordinate() {\n\t\treturn this._shell.getCoordinate();\n\t}\n\tgetNumInteriorRing() {\n\t\treturn this._holes.length;\n\t}\n\tgetBoundaryDimension() {\n\t\treturn 1;\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_POLYGON;\n\t}\n\tgetDimension() {\n\t\treturn 2;\n\t}\n\tgetLength() {\n\t\tvar len = 0.0;\n\t\tlen += this._shell.getLength();\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tlen += this._holes[i].getLength();\n\t\t}\n\t\treturn len;\n\t}\n\tgetNumPoints() {\n\t\tvar numPoints = this._shell.getNumPoints();\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tnumPoints += this._holes[i].getNumPoints();\n\t\t}\n\t\treturn numPoints;\n\t}\n\treverse() {\n\t\tvar poly = this.copy();\n\t\tpoly._shell = this._shell.copy().reverse();\n\t\tpoly._holes = new Array(this._holes.length).fill(null);\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tpoly._holes[i] = this._holes[i].copy().reverse();\n\t\t}\n\t\treturn poly;\n\t}\n\tconvexHull() {\n\t\treturn this.getExteriorRing().convexHull();\n\t}\n\tcompareToSameClass() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar thisShell = this._shell;\n\t\t\tvar otherShell = o._shell;\n\t\t\treturn thisShell.compareToSameClass(otherShell);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar poly = o;\n\t\t\tvar thisShell = this._shell;\n\t\t\tvar otherShell = poly._shell;\n\t\t\tvar shellComp = thisShell.compareToSameClass(otherShell, comp);\n\t\t\tif (shellComp !== 0) return shellComp;\n\t\t\tvar nHole1 = this.getNumInteriorRing();\n\t\t\tvar nHole2 = poly.getNumInteriorRing();\n\t\t\tvar i = 0;\n\t\t\twhile (i < nHole1 && i < nHole2) {\n\t\t\t\tvar thisHole = this.getInteriorRingN(i);\n\t\t\t\tvar otherHole = poly.getInteriorRingN(i);\n\t\t\t\tvar holeComp = thisHole.compareToSameClass(otherHole, comp);\n\t\t\t\tif (holeComp !== 0) return holeComp;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i < nHole1) return 1;\n\t\t\tif (i < nHole2) return -1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tapply() {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tthis._shell.apply(filter);\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tthis._holes[i].apply(filter);\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tthis._shell.apply(filter);\n\t\t\tif (!filter.isDone()) {\n\t\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\t\tthis._holes[i].apply(filter);\n\t\t\t\t\tif (filter.isDone()) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t\tthis._shell.apply(filter);\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tthis._holes[i].apply(filter);\n\t\t\t}\n\t\t}\n\t}\n\tgetBoundary() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn this.getFactory().createMultiLineString();\n\t\t}\n\t\tvar rings = new Array(this._holes.length + 1).fill(null);\n\t\trings[0] = this._shell;\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\trings[i + 1] = this._holes[i];\n\t\t}\n\t\tif (rings.length <= 1) return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());\n\t\treturn this.getFactory().createMultiLineString(rings);\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_POLYGON;\n\t}\n\tcopy() {\n\t\tvar shellCopy = this._shell.copy();\n\t\tvar holeCopies = new Array(this._holes.length).fill(null);\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tholeCopies[i] = this._holes[i].copy();\n\t\t}\n\t\treturn new Polygon(shellCopy, holeCopies, this._factory);\n\t}\n\tgetExteriorRing() {\n\t\treturn this._shell;\n\t}\n\tisEmpty() {\n\t\treturn this._shell.isEmpty();\n\t}\n\tgetInteriorRingN(n) {\n\t\treturn this._holes[n];\n\t}\n\tgetClass() {\n\t\treturn Polygon;\n\t}\n\tget interfaces_() {\n\t\treturn [Polygonal];\n\t}\n}\nPolygon.constructor_ = function () {\n\tthis._shell = null;\n\tthis._holes = null;\n\tlet shell = arguments[0], holes = arguments[1], factory = arguments[2];\n\tGeometry.constructor_.call(this, factory);\n\tif (shell === null) {\n\t\tshell = this.getFactory().createLinearRing();\n\t}\n\tif (holes === null) {\n\t\tholes = [];\n\t}\n\tif (Geometry.hasNullElements(holes)) {\n\t\tthrow new IllegalArgumentException(\"holes must not contain null elements\");\n\t}\n\tif (shell.isEmpty() && Geometry.hasNonEmptyElements(holes)) {\n\t\tthrow new IllegalArgumentException(\"shell is empty but holes are not\");\n\t}\n\tthis._shell = shell;\n\tthis._holes = holes;\n};\nPolygon.serialVersionUID = -3494792200821764533;\n","import Geometry from './Geometry';\nimport GeometryCollection from './GeometryCollection';\nimport Dimension from './Dimension';\nimport Puntal from './Puntal';\nexport default class MultiPoint extends GeometryCollection {\n\tconstructor() {\n\t\tsuper();\n\t\tMultiPoint.constructor_.apply(this, arguments);\n\t}\n\tisValid() {\n\t\treturn true;\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn super.equalsExact.call(this, other, tolerance);\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tgetCoordinate() {\n\t\tif (arguments.length === 1 && Number.isInteger(arguments[0])) {\n\t\t\tlet n = arguments[0];\n\t\t\treturn this._geometries[n].getCoordinate();\n\t\t} else return super.getCoordinate.apply(this, arguments);\n\t}\n\tgetBoundaryDimension() {\n\t\treturn Dimension.FALSE;\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_MULTIPOINT;\n\t}\n\tgetDimension() {\n\t\treturn 0;\n\t}\n\tgetBoundary() {\n\t\treturn this.getFactory().createGeometryCollection();\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_MULTIPOINT;\n\t}\n\tcopy() {\n\t\tvar points = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < points.length; i++) {\n\t\t\tpoints[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new MultiPoint(points, this._factory);\n\t}\n\tgetClass() {\n\t\treturn MultiPoint;\n\t}\n\tget interfaces_() {\n\t\treturn [Puntal];\n\t}\n}\nMultiPoint.constructor_ = function () {\n\tlet points = arguments[0], factory = arguments[1];\n\tGeometryCollection.constructor_.call(this, points, factory);\n};\nMultiPoint.serialVersionUID = -8048474874175355449;\n","import LineString from './LineString';\nimport Geometry from './Geometry';\nimport hasInterface from '../../../../hasInterface';\nimport GeometryFactory from './GeometryFactory';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport CoordinateSequences from './CoordinateSequences';\nimport CoordinateSequence from './CoordinateSequence';\nimport Dimension from './Dimension';\nexport default class LinearRing extends LineString {\n\tconstructor() {\n\t\tsuper();\n\t\tLinearRing.constructor_.apply(this, arguments);\n\t}\n\tgetBoundaryDimension() {\n\t\treturn Dimension.FALSE;\n\t}\n\tisClosed() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn super.isClosed.call(this);\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_LINEARRING;\n\t}\n\treverse() {\n\t\tvar seq = this._points.copy();\n\t\tCoordinateSequences.reverse(seq);\n\t\tvar rev = this.getFactory().createLinearRing(seq);\n\t\treturn rev;\n\t}\n\tvalidateConstruction() {\n\t\tif (!this.isEmpty() && !super.isClosed.call(this)) {\n\t\t\tthrow new IllegalArgumentException(\"Points of LinearRing do not form a closed linestring\");\n\t\t}\n\t\tif (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid number of points in LinearRing (found \" + this.getCoordinateSequence().size() + \" - must be 0 or >= 4)\");\n\t\t}\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_LINEARRING;\n\t}\n\tcopy() {\n\t\treturn new LinearRing(this._points.copy(), this._factory);\n\t}\n\tgetClass() {\n\t\treturn LinearRing;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nLinearRing.constructor_ = function () {\n\tif (arguments[0] instanceof Array && arguments[1] instanceof GeometryFactory) {\n\t\tlet points = arguments[0], factory = arguments[1];\n\t\tLinearRing.constructor_.call(this, factory.getCoordinateSequenceFactory().create(points), factory);\n\t} else if (hasInterface(arguments[0], CoordinateSequence) && arguments[1] instanceof GeometryFactory) {\n\t\tlet points = arguments[0], factory = arguments[1];\n\t\tLineString.constructor_.call(this, points, factory);\n\t\tthis.validateConstruction();\n\t}\n};\nLinearRing.MINIMUM_VALID_SIZE = 4;\nLinearRing.serialVersionUID = -4261142084085851829;\n","import Geometry from './Geometry';\nimport GeometryCollection from './GeometryCollection';\nimport Polygonal from './Polygonal';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default class MultiPolygon extends GeometryCollection {\n\tconstructor() {\n\t\tsuper();\n\t\tMultiPolygon.constructor_.apply(this, arguments);\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn super.equalsExact.call(this, other, tolerance);\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tgetBoundaryDimension() {\n\t\treturn 1;\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_MULTIPOLYGON;\n\t}\n\tgetDimension() {\n\t\treturn 2;\n\t}\n\treverse() {\n\t\tvar n = this._geometries.length;\n\t\tvar revGeoms = new Array(n).fill(null);\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\trevGeoms[i] = this._geometries[i].reverse();\n\t\t}\n\t\treturn this.getFactory().createMultiPolygon(revGeoms);\n\t}\n\tgetBoundary() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn this.getFactory().createMultiLineString();\n\t\t}\n\t\tvar allRings = new ArrayList();\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tvar polygon = this._geometries[i];\n\t\t\tvar rings = polygon.getBoundary();\n\t\t\tfor (var j = 0; j < rings.getNumGeometries(); j++) {\n\t\t\t\tallRings.add(rings.getGeometryN(j));\n\t\t\t}\n\t\t}\n\t\tvar allRingsArray = new Array(allRings.size()).fill(null);\n\t\treturn this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_MULTIPOLYGON;\n\t}\n\tcopy() {\n\t\tvar polygons = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < polygons.length; i++) {\n\t\t\tpolygons[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new MultiPolygon(polygons, this._factory);\n\t}\n\tgetClass() {\n\t\treturn MultiPolygon;\n\t}\n\tget interfaces_() {\n\t\treturn [Polygonal];\n\t}\n}\nMultiPolygon.constructor_ = function () {\n\tlet polygons = arguments[0], factory = arguments[1];\n\tGeometryCollection.constructor_.call(this, polygons, factory);\n};\nMultiPolygon.serialVersionUID = -551033529766975875;\n","import LineString from '../LineString';\nimport Point from '../Point';\nimport Polygon from '../Polygon';\nimport MultiPoint from '../MultiPoint';\nimport LinearRing from '../LinearRing';\nimport MultiPolygon from '../MultiPolygon';\nimport GeometryCollection from '../GeometryCollection';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Assert from '../../util/Assert';\nimport MultiLineString from '../MultiLineString';\nexport default class GeometryEditor {\n\tconstructor() {\n\t\tGeometryEditor.constructor_.apply(this, arguments);\n\t}\n\tsetCopyUserData(isUserDataCopied) {\n\t\tthis._isUserDataCopied = isUserDataCopied;\n\t}\n\tedit(geometry, operation) {\n\t\tif (geometry === null) return null;\n\t\tvar result = this.editInternal(geometry, operation);\n\t\tif (this._isUserDataCopied) {\n\t\t\tresult.setUserData(geometry.getUserData());\n\t\t}\n\t\treturn result;\n\t}\n\teditInternal(geometry, operation) {\n\t\tif (this._factory === null) this._factory = geometry.getFactory();\n\t\tif (geometry instanceof GeometryCollection) {\n\t\t\treturn this.editGeometryCollection(geometry, operation);\n\t\t}\n\t\tif (geometry instanceof Polygon) {\n\t\t\treturn this.editPolygon(geometry, operation);\n\t\t}\n\t\tif (geometry instanceof Point) {\n\t\t\treturn operation.edit(geometry, this._factory);\n\t\t}\n\t\tif (geometry instanceof LineString) {\n\t\t\treturn operation.edit(geometry, this._factory);\n\t\t}\n\t\tAssert.shouldNeverReachHere(\"Unsupported Geometry class: \" + geometry.getClass().getName());\n\t\treturn null;\n\t}\n\teditGeometryCollection(collection, operation) {\n\t\tvar collectionForType = operation.edit(collection, this._factory);\n\t\tvar geometries = new ArrayList();\n\t\tfor (var i = 0; i < collectionForType.getNumGeometries(); i++) {\n\t\t\tvar geometry = this.edit(collectionForType.getGeometryN(i), operation);\n\t\t\tif (geometry === null || geometry.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgeometries.add(geometry);\n\t\t}\n\t\tif (collectionForType.getClass() === MultiPoint) {\n\t\t\treturn this._factory.createMultiPoint(geometries.toArray([]));\n\t\t}\n\t\tif (collectionForType.getClass() === MultiLineString) {\n\t\t\treturn this._factory.createMultiLineString(geometries.toArray([]));\n\t\t}\n\t\tif (collectionForType.getClass() === MultiPolygon) {\n\t\t\treturn this._factory.createMultiPolygon(geometries.toArray([]));\n\t\t}\n\t\treturn this._factory.createGeometryCollection(geometries.toArray([]));\n\t}\n\teditPolygon(polygon, operation) {\n\t\tvar newPolygon = operation.edit(polygon, this._factory);\n\t\tif (newPolygon === null) newPolygon = this._factory.createPolygon();\n\t\tif (newPolygon.isEmpty()) {\n\t\t\treturn newPolygon;\n\t\t}\n\t\tvar shell = this.edit(newPolygon.getExteriorRing(), operation);\n\t\tif (shell === null || shell.isEmpty()) {\n\t\t\treturn this._factory.createPolygon();\n\t\t}\n\t\tvar holes = new ArrayList();\n\t\tfor (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {\n\t\t\tvar hole = this.edit(newPolygon.getInteriorRingN(i), operation);\n\t\t\tif (hole === null || hole.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tholes.add(hole);\n\t\t}\n\t\treturn this._factory.createPolygon(shell, holes.toArray([]));\n\t}\n\tgetClass() {\n\t\treturn GeometryEditor;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nfunction GeometryEditorOperation() {}\nGeometryEditor.GeometryEditorOperation = GeometryEditorOperation;\nclass NoOpGeometryOperation {\n\tconstructor() {\n\t\tNoOpGeometryOperation.constructor_.apply(this, arguments);\n\t}\n\tedit(geometry, factory) {\n\t\treturn geometry;\n\t}\n\tgetClass() {\n\t\treturn NoOpGeometryOperation;\n\t}\n\tget interfaces_() {\n\t\treturn [GeometryEditorOperation];\n\t}\n}\nNoOpGeometryOperation.constructor_ = function () {};\nclass CoordinateOperation {\n\tconstructor() {\n\t\tCoordinateOperation.constructor_.apply(this, arguments);\n\t}\n\tedit(geometry, factory) {\n\t\tvar coordinates = this.edit(geometry.getCoordinates(), geometry);\n\t\tif (geometry instanceof LinearRing) {\n\t\t\tif (coordinates === null) return factory.createLinearRing(); else return factory.createLinearRing(coordinates);\n\t\t}\n\t\tif (geometry instanceof LineString) {\n\t\t\tif (coordinates === null) return factory.createLineString(); else return factory.createLineString(coordinates);\n\t\t}\n\t\tif (geometry instanceof Point) {\n\t\t\tif (coordinates === null || coordinates.length === 0) return factory.createPoint(); else return factory.createPoint(coordinates[0]);\n\t\t}\n\t\treturn geometry;\n\t}\n\tgetClass() {\n\t\treturn CoordinateOperation;\n\t}\n\tget interfaces_() {\n\t\treturn [GeometryEditorOperation];\n\t}\n}\nCoordinateOperation.constructor_ = function () {};\nclass CoordinateSequenceOperation {\n\tconstructor() {\n\t\tCoordinateSequenceOperation.constructor_.apply(this, arguments);\n\t}\n\tedit(geometry, factory) {\n\t\tif (geometry instanceof LinearRing) {\n\t\t\treturn factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry));\n\t\t}\n\t\tif (geometry instanceof LineString) {\n\t\t\treturn factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry));\n\t\t}\n\t\tif (geometry instanceof Point) {\n\t\t\treturn factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry));\n\t\t}\n\t\treturn geometry;\n\t}\n\tgetClass() {\n\t\treturn CoordinateSequenceOperation;\n\t}\n\tget interfaces_() {\n\t\treturn [GeometryEditorOperation];\n\t}\n}\nCoordinateSequenceOperation.constructor_ = function () {};\nGeometryEditor.NoOpGeometryOperation = NoOpGeometryOperation;\nGeometryEditor.CoordinateOperation = CoordinateOperation;\nGeometryEditor.CoordinateSequenceOperation = CoordinateSequenceOperation;\nGeometryEditor.constructor_ = function () {\n\tthis._factory = null;\n\tthis._isUserDataCopied = false;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet factory = arguments[0];\n\t\tthis._factory = factory;\n\t}\n};\n","import hasInterface from '../../../../../hasInterface';\nimport Coordinate from '../Coordinate';\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport Double from '../../../../../java/lang/Double';\nimport CoordinateSequence from '../CoordinateSequence';\nimport Serializable from '../../../../../java/io/Serializable';\nimport StringBuilder from '../../../../../java/lang/StringBuilder';\nexport default class CoordinateArraySequence {\n\tconstructor() {\n\t\tCoordinateArraySequence.constructor_.apply(this, arguments);\n\t}\n\tsetOrdinate(index, ordinateIndex, value) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase CoordinateSequence.X:\n\t\t\t\tthis._coordinates[index].x = value;\n\t\t\t\tbreak;\n\t\t\tcase CoordinateSequence.Y:\n\t\t\t\tthis._coordinates[index].y = value;\n\t\t\t\tbreak;\n\t\t\tcase CoordinateSequence.Z:\n\t\t\t\tthis._coordinates[index].z = value;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"invalid ordinateIndex\");\n\t\t}\n\t}\n\tsize() {\n\t\treturn this._coordinates.length;\n\t}\n\tgetOrdinate(index, ordinateIndex) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase CoordinateSequence.X:\n\t\t\t\treturn this._coordinates[index].x;\n\t\t\tcase CoordinateSequence.Y:\n\t\t\t\treturn this._coordinates[index].y;\n\t\t\tcase CoordinateSequence.Z:\n\t\t\t\treturn this._coordinates[index].z;\n\t\t}\n\t\treturn Double.NaN;\n\t}\n\tgetCoordinate() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet i = arguments[0];\n\t\t\treturn this._coordinates[i];\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet index = arguments[0], coord = arguments[1];\n\t\t\tcoord.x = this._coordinates[index].x;\n\t\t\tcoord.y = this._coordinates[index].y;\n\t\t\tcoord.z = this._coordinates[index].z;\n\t\t}\n\t}\n\tgetCoordinateCopy(i) {\n\t\treturn new Coordinate(this._coordinates[i]);\n\t}\n\tgetDimension() {\n\t\treturn this._dimension;\n\t}\n\tgetX(index) {\n\t\treturn this._coordinates[index].x;\n\t}\n\texpandEnvelope(env) {\n\t\tfor (var i = 0; i < this._coordinates.length; i++) {\n\t\t\tenv.expandToInclude(this._coordinates[i]);\n\t\t}\n\t\treturn env;\n\t}\n\tcopy() {\n\t\tvar cloneCoordinates = new Array(this.size()).fill(null);\n\t\tfor (var i = 0; i < this._coordinates.length; i++) {\n\t\t\tcloneCoordinates[i] = this._coordinates[i].copy();\n\t\t}\n\t\treturn new CoordinateArraySequence(cloneCoordinates, this._dimension);\n\t}\n\ttoString() {\n\t\tif (this._coordinates.length > 0) {\n\t\t\tvar strBuilder = new StringBuilder(17 * this._coordinates.length);\n\t\t\tstrBuilder.append('(');\n\t\t\tstrBuilder.append(this._coordinates[0]);\n\t\t\tfor (var i = 1; i < this._coordinates.length; i++) {\n\t\t\t\tstrBuilder.append(\", \");\n\t\t\t\tstrBuilder.append(this._coordinates[i]);\n\t\t\t}\n\t\t\tstrBuilder.append(')');\n\t\t\treturn strBuilder.toString();\n\t\t} else {\n\t\t\treturn \"()\";\n\t\t}\n\t}\n\tgetY(index) {\n\t\treturn this._coordinates[index].y;\n\t}\n\ttoCoordinateArray() {\n\t\treturn this._coordinates;\n\t}\n\tgetClass() {\n\t\treturn CoordinateArraySequence;\n\t}\n\tget interfaces_() {\n\t\treturn [CoordinateSequence, Serializable];\n\t}\n}\nCoordinateArraySequence.constructor_ = function () {\n\tthis._dimension = 3;\n\tthis._coordinates = null;\n\tif (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tlet coordinates = arguments[0];\n\t\t\tCoordinateArraySequence.constructor_.call(this, coordinates, 3);\n\t\t} else if (Number.isInteger(arguments[0])) {\n\t\t\tlet size = arguments[0];\n\t\t\tthis._coordinates = new Array(size).fill(null);\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tthis._coordinates[i] = new Coordinate();\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\tlet coordSeq = arguments[0];\n\t\t\tif (coordSeq === null) {\n\t\t\t\tthis._coordinates = new Array(0).fill(null);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis._dimension = coordSeq.getDimension();\n\t\t\tthis._coordinates = new Array(coordSeq.size()).fill(null);\n\t\t\tfor (var i = 0; i < this._coordinates.length; i++) {\n\t\t\t\tthis._coordinates[i] = coordSeq.getCoordinateCopy(i);\n\t\t\t}\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tif (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n\t\t\tlet coordinates = arguments[0], dimension = arguments[1];\n\t\t\tthis._coordinates = coordinates;\n\t\t\tthis._dimension = dimension;\n\t\t\tif (coordinates === null) this._coordinates = new Array(0).fill(null);\n\t\t} else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n\t\t\tlet size = arguments[0], dimension = arguments[1];\n\t\t\tthis._coordinates = new Array(size).fill(null);\n\t\t\tthis._dimension = dimension;\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tthis._coordinates[i] = new Coordinate();\n\t\t\t}\n\t\t}\n\t}\n};\nCoordinateArraySequence.serialVersionUID = -915438501601840650;\n","import CoordinateSequenceFactory from '../CoordinateSequenceFactory';\nimport hasInterface from '../../../../../hasInterface';\nimport CoordinateArraySequence from './CoordinateArraySequence';\nimport CoordinateSequence from '../CoordinateSequence';\nimport Serializable from '../../../../../java/io/Serializable';\nexport default class CoordinateArraySequenceFactory {\n\tconstructor() {\n\t\tCoordinateArraySequenceFactory.constructor_.apply(this, arguments);\n\t}\n\tstatic instance() {\n\t\treturn CoordinateArraySequenceFactory.instanceObject;\n\t}\n\treadResolve() {\n\t\treturn CoordinateArraySequenceFactory.instance();\n\t}\n\tcreate() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new CoordinateArraySequence(coordinates);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordSeq = arguments[0];\n\t\t\t\treturn new CoordinateArraySequence(coordSeq);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet size = arguments[0], dimension = arguments[1];\n\t\t\tif (dimension > 3) dimension = 3;\n\t\t\tif (dimension < 2) return new CoordinateArraySequence(size);\n\t\t\treturn new CoordinateArraySequence(size, dimension);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn CoordinateArraySequenceFactory;\n\t}\n\tget interfaces_() {\n\t\treturn [CoordinateSequenceFactory, Serializable];\n\t}\n}\nCoordinateArraySequenceFactory.constructor_ = function () {};\nCoordinateArraySequenceFactory.serialVersionUID = -4099577099607551657;\nCoordinateArraySequenceFactory.instanceObject = new CoordinateArraySequenceFactory();\n","import ArrayList from './ArrayList'\nimport MapInterface from './Map'\nimport HashSet from './HashSet'\nimport MapPolyfill from '../../Map'\n\nlet MapImpl = typeof Map === 'undefined' || !Map.prototype.values ? MapPolyfill : Map\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html\n *\n * @extends {javascript.util.Map}\n * @constructor\n * @private\n */\nexport default function HashMap () {\n  /**\n   * @type {Object}\n   * @private\n  */\n  this.map_ = new MapImpl()\n}\nHashMap.prototype = new MapInterface()\n\n/**\n * @override\n */\nHashMap.prototype.get = function (key) {\n  return this.map_.get(key) || null\n}\n\n/**\n * @override\n */\nHashMap.prototype.put = function (key, value) {\n  this.map_.set(key, value)\n  return value\n}\n\n/**\n * @override\n */\nHashMap.prototype.values = function () {\n  const arrayList = new ArrayList()\n  const it = this.map_.values()\n  let o = it.next()\n  while (!o.done) {\n    arrayList.add(o.value)\n    o = it.next()\n  }\n  return arrayList\n}\n\n/**\n * @override\n */\nHashMap.prototype.entrySet = function () {\n  const hashSet = new HashSet()\n  this.map_.entries().forEach(entry => hashSet.add(entry))\n  return hashSet\n}\n\n/**\n * @override\n */\nHashMap.prototype.size = function () {\n  return this.map_.size()\n}\n","import HashMap from '../../../../java/util/HashMap';\nimport Coordinate from './Coordinate';\nimport Double from '../../../../java/lang/Double';\nimport Integer from '../../../../java/lang/Integer';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Serializable from '../../../../java/io/Serializable';\nexport default class PrecisionModel {\n\tconstructor() {\n\t\tPrecisionModel.constructor_.apply(this, arguments);\n\t}\n\tstatic mostPrecise(pm1, pm2) {\n\t\tif (pm1.compareTo(pm2) >= 0) return pm1;\n\t\treturn pm2;\n\t}\n\tequals(other) {\n\t\tif (!(other instanceof PrecisionModel)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar otherPrecisionModel = other;\n\t\treturn this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale;\n\t}\n\tcompareTo(o) {\n\t\tvar other = o;\n\t\tvar sigDigits = this.getMaximumSignificantDigits();\n\t\tvar otherSigDigits = other.getMaximumSignificantDigits();\n\t\treturn new Integer(sigDigits).compareTo(new Integer(otherSigDigits));\n\t}\n\tgetScale() {\n\t\treturn this._scale;\n\t}\n\tisFloating() {\n\t\treturn this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE;\n\t}\n\tgetType() {\n\t\treturn this._modelType;\n\t}\n\ttoString() {\n\t\tvar description = \"UNKNOWN\";\n\t\tif (this._modelType === PrecisionModel.FLOATING) {\n\t\t\tdescription = \"Floating\";\n\t\t} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n\t\t\tdescription = \"Floating-Single\";\n\t\t} else if (this._modelType === PrecisionModel.FIXED) {\n\t\t\tdescription = \"Fixed (Scale=\" + this.getScale() + \")\";\n\t\t}\n\t\treturn description;\n\t}\n\tmakePrecise() {\n\t\tif (typeof arguments[0] === \"number\") {\n\t\t\tlet val = arguments[0];\n\t\t\tif (Double.isNaN(val)) return val;\n\t\t\tif (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n\t\t\t\tvar floatSingleVal = val;\n\t\t\t\treturn floatSingleVal;\n\t\t\t}\n\t\t\tif (this._modelType === PrecisionModel.FIXED) {\n\t\t\t\treturn Math.round(val * this._scale) / this._scale;\n\t\t\t}\n\t\t\treturn val;\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet coord = arguments[0];\n\t\t\tif (this._modelType === PrecisionModel.FLOATING) return null;\n\t\t\tcoord.x = this.makePrecise(coord.x);\n\t\t\tcoord.y = this.makePrecise(coord.y);\n\t\t}\n\t}\n\tgetMaximumSignificantDigits() {\n\t\tvar maxSigDigits = 16;\n\t\tif (this._modelType === PrecisionModel.FLOATING) {\n\t\t\tmaxSigDigits = 16;\n\t\t} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n\t\t\tmaxSigDigits = 6;\n\t\t} else if (this._modelType === PrecisionModel.FIXED) {\n\t\t\tmaxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));\n\t\t}\n\t\treturn maxSigDigits;\n\t}\n\tsetScale(scale) {\n\t\tthis._scale = Math.abs(scale);\n\t}\n\tgetClass() {\n\t\treturn PrecisionModel;\n\t}\n\tget interfaces_() {\n\t\treturn [Serializable, Comparable];\n\t}\n}\nclass Type {\n\tconstructor() {\n\t\tType.constructor_.apply(this, arguments);\n\t}\n\treadResolve() {\n\t\treturn Type.nameToTypeMap.get(this._name);\n\t}\n\ttoString() {\n\t\treturn this._name;\n\t}\n\tgetClass() {\n\t\treturn Type;\n\t}\n\tget interfaces_() {\n\t\treturn [Serializable];\n\t}\n}\nType.constructor_ = function () {\n\tthis._name = null;\n\tlet name = arguments[0];\n\tthis._name = name;\n\tType.nameToTypeMap.put(name, this);\n};\nType.serialVersionUID = -5528602631731589822;\nType.nameToTypeMap = new HashMap();\nPrecisionModel.Type = Type;\nPrecisionModel.constructor_ = function () {\n\tthis._modelType = null;\n\tthis._scale = null;\n\tif (arguments.length === 0) {\n\t\tthis._modelType = PrecisionModel.FLOATING;\n\t} else if (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Type) {\n\t\t\tlet modelType = arguments[0];\n\t\t\tthis._modelType = modelType;\n\t\t\tif (modelType === PrecisionModel.FIXED) {\n\t\t\t\tthis.setScale(1.0);\n\t\t\t}\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet scale = arguments[0];\n\t\t\tthis._modelType = PrecisionModel.FIXED;\n\t\t\tthis.setScale(scale);\n\t\t} else if (arguments[0] instanceof PrecisionModel) {\n\t\t\tlet pm = arguments[0];\n\t\t\tthis._modelType = pm._modelType;\n\t\t\tthis._scale = pm._scale;\n\t\t}\n\t}\n};\nPrecisionModel.serialVersionUID = 7777263578777803835;\nPrecisionModel.FIXED = new Type(\"FIXED\");\nPrecisionModel.FLOATING = new Type(\"FLOATING\");\nPrecisionModel.FLOATING_SINGLE = new Type(\"FLOATING SINGLE\");\nPrecisionModel.maximumPreciseValue = 9007199254740992.0;\n","import CoordinateSequenceFactory from './CoordinateSequenceFactory';\nimport LineString from './LineString';\nimport Geometry from './Geometry';\nimport hasInterface from '../../../../hasInterface';\nimport Coordinate from './Coordinate';\nimport Point from './Point';\nimport Polygon from './Polygon';\nimport MultiPoint from './MultiPoint';\nimport GeometryEditor from './util/GeometryEditor';\nimport LinearRing from './LinearRing';\nimport CoordinateArraySequenceFactory from './impl/CoordinateArraySequenceFactory';\nimport MultiPolygon from './MultiPolygon';\nimport CoordinateSequences from './CoordinateSequences';\nimport CoordinateSequence from './CoordinateSequence';\nimport GeometryCollection from './GeometryCollection';\nimport PrecisionModel from './PrecisionModel';\nimport Serializable from '../../../../java/io/Serializable';\nimport Assert from '../util/Assert';\nimport MultiLineString from './MultiLineString';\nexport default class GeometryFactory {\n\tconstructor() {\n\t\tGeometryFactory.constructor_.apply(this, arguments);\n\t}\n\tstatic toMultiPolygonArray(multiPolygons) {\n\t\tvar multiPolygonArray = new Array(multiPolygons.size()).fill(null);\n\t\treturn multiPolygons.toArray(multiPolygonArray);\n\t}\n\tstatic toGeometryArray(geometries) {\n\t\tif (geometries === null) return null;\n\t\tvar geometryArray = new Array(geometries.size()).fill(null);\n\t\treturn geometries.toArray(geometryArray);\n\t}\n\tstatic getDefaultCoordinateSequenceFactory() {\n\t\treturn CoordinateArraySequenceFactory.instance();\n\t}\n\tstatic toMultiLineStringArray(multiLineStrings) {\n\t\tvar multiLineStringArray = new Array(multiLineStrings.size()).fill(null);\n\t\treturn multiLineStrings.toArray(multiLineStringArray);\n\t}\n\tstatic toLineStringArray(lineStrings) {\n\t\tvar lineStringArray = new Array(lineStrings.size()).fill(null);\n\t\treturn lineStrings.toArray(lineStringArray);\n\t}\n\tstatic toMultiPointArray(multiPoints) {\n\t\tvar multiPointArray = new Array(multiPoints.size()).fill(null);\n\t\treturn multiPoints.toArray(multiPointArray);\n\t}\n\tstatic toLinearRingArray(linearRings) {\n\t\tvar linearRingArray = new Array(linearRings.size()).fill(null);\n\t\treturn linearRings.toArray(linearRingArray);\n\t}\n\tstatic toPointArray(points) {\n\t\tvar pointArray = new Array(points.size()).fill(null);\n\t\treturn points.toArray(pointArray);\n\t}\n\tstatic toPolygonArray(polygons) {\n\t\tvar polygonArray = new Array(polygons.size()).fill(null);\n\t\treturn polygons.toArray(polygonArray);\n\t}\n\tstatic createPointFromInternalCoord(coord, exemplar) {\n\t\texemplar.getPrecisionModel().makePrecise(coord);\n\t\treturn exemplar.getFactory().createPoint(coord);\n\t}\n\ttoGeometry(envelope) {\n\t\tif (envelope.isNull()) {\n\t\t\treturn this.createPoint();\n\t\t}\n\t\tif (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {\n\t\t\treturn this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()));\n\t\t}\n\t\tif (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {\n\t\t\treturn this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())]);\n\t\t}\n\t\treturn this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null);\n\t}\n\tcreateLineString() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createLineString(this.getCoordinateSequenceFactory().create([]));\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn this.createLineString(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new LineString(coordinates, this);\n\t\t\t}\n\t\t}\n\t}\n\tcreateMultiLineString() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new MultiLineString(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet lineStrings = arguments[0];\n\t\t\treturn new MultiLineString(lineStrings, this);\n\t\t}\n\t}\n\tbuildGeometry(geomList) {\n\t\tvar geomClass = null;\n\t\tvar isHeterogeneous = false;\n\t\tvar hasGeometryCollection = false;\n\t\tfor (var i = geomList.iterator(); i.hasNext(); ) {\n\t\t\tvar geom = i.next();\n\t\t\tvar partClass = geom.getClass();\n\t\t\tif (geomClass === null) {\n\t\t\t\tgeomClass = partClass;\n\t\t\t}\n\t\t\tif (partClass !== geomClass) {\n\t\t\t\tisHeterogeneous = true;\n\t\t\t}\n\t\t\tif (geom instanceof GeometryCollection) hasGeometryCollection = true;\n\t\t}\n\t\tif (geomClass === null) {\n\t\t\treturn this.createGeometryCollection();\n\t\t}\n\t\tif (isHeterogeneous || hasGeometryCollection) {\n\t\t\treturn this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));\n\t\t}\n\t\tvar geom0 = geomList.iterator().next();\n\t\tvar isCollection = geomList.size() > 1;\n\t\tif (isCollection) {\n\t\t\tif (geom0 instanceof Polygon) {\n\t\t\t\treturn this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));\n\t\t\t} else if (geom0 instanceof LineString) {\n\t\t\t\treturn this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));\n\t\t\t} else if (geom0 instanceof Point) {\n\t\t\t\treturn this.createMultiPoint(GeometryFactory.toPointArray(geomList));\n\t\t\t}\n\t\t\tAssert.shouldNeverReachHere(\"Unhandled class: \" + geom0.getClass().getName());\n\t\t}\n\t\treturn geom0;\n\t}\n\tcreateMultiPointFromCoords(coordinates) {\n\t\treturn this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t}\n\tcreatePoint() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createPoint(this.getCoordinateSequenceFactory().create([]));\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet coordinate = arguments[0];\n\t\t\t\treturn this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new Point(coordinates, this);\n\t\t\t}\n\t\t}\n\t}\n\tgetCoordinateSequenceFactory() {\n\t\treturn this._coordinateSequenceFactory;\n\t}\n\tcreatePolygon() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createPolygon(null, null);\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet shell = arguments[0];\n\t\t\t\treturn this.createPolygon(this.createLinearRing(shell));\n\t\t\t} else if (arguments[0] instanceof Array) {\n\t\t\t\tlet shell = arguments[0];\n\t\t\t\treturn this.createPolygon(this.createLinearRing(shell));\n\t\t\t} else if (arguments[0] instanceof LinearRing) {\n\t\t\t\tlet shell = arguments[0];\n\t\t\t\treturn this.createPolygon(shell, null);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet shell = arguments[0], holes = arguments[1];\n\t\t\treturn new Polygon(shell, holes, this);\n\t\t}\n\t}\n\tgetSRID() {\n\t\treturn this._SRID;\n\t}\n\tcreateGeometryCollection() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new GeometryCollection(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet geometries = arguments[0];\n\t\t\treturn new GeometryCollection(geometries, this);\n\t\t}\n\t}\n\tcreateGeometry(g) {\n\t\tvar editor = new GeometryEditor(this);\n\t\treturn editor.edit(g, new CloneOp(this._coordinateSequenceFactory));\n\t}\n\tgetPrecisionModel() {\n\t\treturn this._precisionModel;\n\t}\n\tcreateLinearRing() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createLinearRing(this.getCoordinateSequenceFactory().create([]));\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new LinearRing(coordinates, this);\n\t\t\t}\n\t\t}\n\t}\n\tcreateMultiPolygon() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new MultiPolygon(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet polygons = arguments[0];\n\t\t\treturn new MultiPolygon(polygons, this);\n\t\t}\n\t}\n\tcreateMultiPoint() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new MultiPoint(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet point = arguments[0];\n\t\t\t\treturn new MultiPoint(point, this);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\tif (coordinates === null) {\n\t\t\t\t\treturn this.createMultiPoint(new Array(0).fill(null));\n\t\t\t\t}\n\t\t\t\tvar points = new Array(coordinates.size()).fill(null);\n\t\t\t\tfor (var i = 0; i < coordinates.size(); i++) {\n\t\t\t\t\tvar ptSeq = this.getCoordinateSequenceFactory().create(1, coordinates.getDimension());\n\t\t\t\t\tCoordinateSequences.copy(coordinates, i, ptSeq, 0, 1);\n\t\t\t\t\tpoints[i] = this.createPoint(ptSeq);\n\t\t\t\t}\n\t\t\t\treturn this.createMultiPoint(points);\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn GeometryFactory;\n\t}\n\tget interfaces_() {\n\t\treturn [Serializable];\n\t}\n}\nclass CloneOp extends GeometryEditor.CoordinateSequenceOperation {\n\tconstructor() {\n\t\tsuper();\n\t\tCloneOp.constructor_.apply(this, arguments);\n\t}\n\tedit() {\n\t\tif (arguments.length === 2 && (arguments[1] instanceof Geometry && hasInterface(arguments[0], CoordinateSequence))) {\n\t\t\tlet coordSeq = arguments[0], geometry = arguments[1];\n\t\t\treturn this.coordinateSequenceFactory.create(coordSeq);\n\t\t} else return super.edit.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn CloneOp;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCloneOp.constructor_ = function () {\n\tthis.coordinateSequenceFactory = null;\n\tlet coordinateSequenceFactory = arguments[0];\n\tthis.coordinateSequenceFactory = coordinateSequenceFactory;\n};\nGeometryFactory.CloneOp = CloneOp;\nGeometryFactory.constructor_ = function () {\n\tthis._precisionModel = null;\n\tthis._coordinateSequenceFactory = null;\n\tthis._SRID = null;\n\tif (arguments.length === 0) {\n\t\tGeometryFactory.constructor_.call(this, new PrecisionModel(), 0);\n\t} else if (arguments.length === 1) {\n\t\tif (hasInterface(arguments[0], CoordinateSequenceFactory)) {\n\t\t\tlet coordinateSequenceFactory = arguments[0];\n\t\t\tGeometryFactory.constructor_.call(this, new PrecisionModel(), 0, coordinateSequenceFactory);\n\t\t} else if (arguments[0] instanceof PrecisionModel) {\n\t\t\tlet precisionModel = arguments[0];\n\t\t\tGeometryFactory.constructor_.call(this, precisionModel, 0, GeometryFactory.getDefaultCoordinateSequenceFactory());\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet precisionModel = arguments[0], SRID = arguments[1];\n\t\tGeometryFactory.constructor_.call(this, precisionModel, SRID, GeometryFactory.getDefaultCoordinateSequenceFactory());\n\t} else if (arguments.length === 3) {\n\t\tlet precisionModel = arguments[0], SRID = arguments[1], coordinateSequenceFactory = arguments[2];\n\t\tthis._precisionModel = precisionModel;\n\t\tthis._coordinateSequenceFactory = coordinateSequenceFactory;\n\t\tthis._SRID = SRID;\n\t}\n};\nGeometryFactory.serialVersionUID = -6820524753094095635;\n","import Coordinate from '../geom/Coordinate'\nimport GeometryFactory from '../geom/GeometryFactory'\n\nconst geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon']\n\n/**\n * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */\n\n/**\n * Create a new parser for GeoJSON\n *\n * @param {GeometryFactory} geometryFactory\n * @return An instance of GeoJsonParser.\n * @constructor\n * @private\n */\nexport default class GeoJSONParser {\n  constructor(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory()\n  }\n\n  /**\n   * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries\n   *\n   * @param {}\n   *          A GeoJSON object.\n   * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.\n   * @private\n   */\n  read (json) {\n    let obj\n    if (typeof json === 'string')\n      obj = JSON.parse(json)\n    else\n      obj = json\n\n    const type = obj.type\n\n    if (!parse[type])\n      throw new Error('Unknown GeoJSON type: ' + obj.type)\n\n    if (geometryTypes.indexOf(type) !== -1)\n      return parse[type].call(this, obj.coordinates)\n    else if (type === 'GeometryCollection')\n      return parse[type].call(this, obj.geometries)\n\n    // feature or feature collection\n    return parse[type].call(this, obj)\n  }\n\n  /**\n   * Serialize a Geometry object into GeoJSON\n   *\n   * @param {Geometry}\n   *          geometry A Geometry or array of Geometries.\n   * @return {Object} A GeoJSON object represting the input Geometry/Geometries.\n   * @private\n   */\n  write (geometry) {\n    const type = geometry.getGeometryType()\n\n    if (!extract[type])\n      throw new Error('Geometry is not supported')\n\n    return extract[type].call(this, geometry)\n  }\n} \n\nconst parse = {\n  /**\n   * Parse a GeoJSON Feature object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.\n   */\n  Feature: function (obj) {\n    const feature = {}\n\n    for (let key in obj)\n      feature[key] = obj[key]\n\n    if (obj.geometry) {\n      const type = obj.geometry.type\n      if (!parse[type])\n        throw new Error('Unknown GeoJSON type: ' + obj.type)\n      feature.geometry = this.read(obj.geometry)\n    }\n\n    if (obj.bbox)\n      feature.bbox = parse.bbox.call(this, obj.bbox)\n\n    return feature\n  },\n\n  /**\n   * Parse a GeoJSON FeatureCollection object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.\n   */\n  FeatureCollection: function (obj) {\n    const featureCollection = {}\n\n    if (obj.features) {\n      featureCollection.features = []\n\n      for (let i = 0; i < obj.features.length; ++i)\n        featureCollection.features.push(this.read(obj.features[i]))\n    }\n\n    if (obj.bbox)\n      featureCollection.bbox = this.parse.bbox.call(this, obj.bbox)\n\n    return featureCollection\n  },\n\n  /**\n   * Convert the ordinates in an array to an array of Coordinates\n   *\n   * @param {Array}\n   *          array Array with {Number}s.\n   *\n   * @return {Array} Array with Coordinates.\n   */\n  coordinates: function (array) {\n    const coordinates = []\n    for (let i = 0; i < array.length; ++i) {\n      const sub = array[i]\n      coordinates.push(new Coordinate(sub[0], sub[1]))\n    }\n    return coordinates\n  },\n\n  /**\n   * Convert the bbox to a LinearRing\n   *\n   * @param {Array}\n   *          array Array with [xMin, yMin, xMax, yMax].\n   *\n   * @return {Array} Array with Coordinates.\n   */\n  bbox: function (array) {\n    return this.geometryFactory.createLinearRing([\n      new Coordinate(array[0], array[1]),\n      new Coordinate(array[2], array[1]),\n      new Coordinate(array[2], array[3]),\n      new Coordinate(array[0], array[3]),\n      new Coordinate(array[0], array[1])\n    ])\n  },\n\n  /**\n   * Convert an Array with ordinates to a Point\n   *\n   * @param {Array}\n   *          array Array with ordinates.\n   *\n   * @return {Point} Point.\n   */\n  Point: function (array) {\n    const coordinate = new Coordinate(array[0], array[1])\n    return this.geometryFactory.createPoint(coordinate)\n  },\n\n  /**\n   * Convert an Array with coordinates to a MultiPoint\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiPoint} MultiPoint.\n   */\n  MultiPoint: function (array) {\n    const points = []\n    for (let i = 0; i < array.length; ++i)\n      points.push(parse.Point.call(this, array[i]))\n    return this.geometryFactory.createMultiPoint(points)\n  },\n\n  /**\n   * Convert an Array with coordinates to a LineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {LineString} LineString.\n   */\n  LineString: function (array) {\n    const coordinates = parse.coordinates.call(this, array)\n    return this.geometryFactory.createLineString(coordinates)\n  },\n\n  /**\n   * Convert an Array with coordinates to a MultiLineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiLineString} MultiLineString.\n   */\n  MultiLineString: function (array) {\n    const lineStrings = []\n    for (let i = 0; i < array.length; ++i)\n      lineStrings.push(parse.LineString.call(this, array[i]))\n    return this.geometryFactory.createMultiLineString(lineStrings)\n  },\n\n  /**\n   * Convert an Array to a Polygon\n   *\n   * @param {Array}\n   *          array Array with shell and holes.\n   *\n   * @return {Polygon} Polygon.\n   */\n  Polygon: function (array) {\n    const shellCoordinates = parse.coordinates.call(this, array[0])\n    const shell = this.geometryFactory.createLinearRing(shellCoordinates)\n    const holes = []\n    for (let i = 1; i < array.length; ++i) {\n      var hole = array[i]\n      var coordinates = parse.coordinates.call(this, hole)\n      var linearRing = this.geometryFactory.createLinearRing(coordinates)\n      holes.push(linearRing)\n    }\n    return this.geometryFactory.createPolygon(shell, holes)\n  },\n\n  /**\n   * Convert an Array to a MultiPolygon\n   *\n   * @param {Array}\n   *          array Array of arrays with shell and rings.\n   *\n   * @return {MultiPolygon} MultiPolygon.\n   */\n  MultiPolygon: function (array) {\n    const polygons = []\n    for (let i = 0; i < array.length; ++i) {\n      const polygon = array[i]\n      polygons.push(parse.Polygon.call(this, polygon))\n    }\n    return this.geometryFactory.createMultiPolygon(polygons)\n  },\n\n  /**\n   * Convert an Array to a GeometryCollection\n   *\n   * @param {Array}\n   *          array Array of GeoJSON geometries.\n   *\n   * @return {GeometryCollection} GeometryCollection.\n   */\n  GeometryCollection: function (array) {\n    const geometries = []\n    for (let i = 0; i < array.length; ++i) {\n      const geometry = array[i]\n      geometries.push(this.read(geometry))\n    }\n    return this.geometryFactory.createGeometryCollection(geometries)\n  }\n}\n\nconst extract = {\n  /**\n   * Convert a Coordinate to an Array\n   *\n   * @param {Coordinate}\n   *          coordinate Coordinate to convert.\n   *\n   * @return {Array} Array of ordinates.\n   */\n  coordinate: function (coordinate) {\n    return [coordinate.x, coordinate.y]\n  },\n\n  /**\n   * Convert a Point to a GeoJSON object\n   *\n   * @param {Point}\n   *          point Point to convert.\n   *\n   * @return {Array} Array of 2 ordinates (paired to a coordinate).\n   */\n  Point: function (point) {\n    const array = extract.coordinate.call(this, point.getCoordinate())\n    return {\n      type: 'Point',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiPoint to a GeoJSON object\n   *\n   * @param {MultiPoint}\n   *          multipoint MultiPoint to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */\n  MultiPoint: function (multipoint) {\n    const array = []\n    for (let i = 0; i < multipoint._geometries.length; ++i) {\n      const point = multipoint._geometries[i]\n      const geoJson = extract.Point.call(this, point)\n      array.push(geoJson.coordinates)\n    }\n    return {\n      type: 'MultiPoint',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a LineString to a GeoJSON object\n   *\n   * @param {LineString}\n   *          linestring LineString to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */\n  LineString: function (linestring) {\n    const array = []\n    const coordinates = linestring.getCoordinates()\n    for (let i = 0; i < coordinates.length; ++i) {\n      const coordinate = coordinates[i]\n      array.push(extract.coordinate.call(this, coordinate))\n    }\n    return {\n      type: 'LineString',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiLineString to a GeoJSON object\n   *\n   * @param {MultiLineString}\n   *          multilinestring MultiLineString to convert.\n   *\n   * @return {Array} Array of Array of coordinates.\n   */\n  MultiLineString: function (multilinestring) {\n    const array = []\n    for (let i = 0; i < multilinestring._geometries.length; ++i) {\n      const linestring = multilinestring._geometries[i]\n      const geoJson = extract.LineString.call(this, linestring)\n      array.push(geoJson.coordinates)\n    }\n    return {\n      type: 'MultiLineString',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a Polygon to a GeoJSON object\n   *\n   * @param {Polygon}\n   *          polygon Polygon to convert.\n   *\n   * @return {Array} Array with shell, holes.\n   */\n  Polygon: function (polygon) {\n    const array = []\n    const shellGeoJson = extract.LineString.call(this, polygon._shell)\n    array.push(shellGeoJson.coordinates)\n    for (let i = 0; i < polygon._holes.length; ++i) {\n      const hole = polygon._holes[i]\n      const holeGeoJson = extract.LineString.call(this, hole)\n      array.push(holeGeoJson.coordinates)\n    }\n    return {\n      type: 'Polygon',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiPolygon to a GeoJSON object\n   *\n   * @param {MultiPolygon}\n   *          multipolygon MultiPolygon to convert.\n   *\n   * @return {Array} Array of polygons.\n   */\n  MultiPolygon: function (multipolygon) {\n    const array = []\n    for (let i = 0; i < multipolygon._geometries.length; ++i) {\n      const polygon = multipolygon._geometries[i]\n      const geoJson = extract.Polygon.call(this, polygon)\n      array.push(geoJson.coordinates)\n    }\n    return {\n      type: 'MultiPolygon',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a GeometryCollection to a GeoJSON object\n   *\n   * @param {GeometryCollection}\n   *          collection GeometryCollection to convert.\n   *\n   * @return {Array} Array of geometries.\n   */\n  GeometryCollection: function (collection) {\n    const array = []\n    for (let i = 0; i < collection._geometries.length; ++i) {\n      const geometry = collection._geometries[i]\n      const type = geometry.getGeometryType()\n      array.push(extract[type].call(this, geometry))\n    }\n    return {\n      type: 'GeometryCollection',\n      geometries: array\n    }\n  }\n}\n","/**\n * @module org/locationtech/jts/io/GeoJSONReader\n */\n\nimport GeometryFactory from '../geom/GeometryFactory'\nimport GeoJSONParser from './GeoJSONParser'\n\n/**\n * Converts a geometry in GeoJSON to a {@link Geometry}.\n */\nexport default class GeoJSONReader {\n  /**\n   * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,\n   * to allow it to create <code>Geometry</code> objects of the appropriate\n   * implementation. In particular, the <code>GeometryFactory</code> determines\n   * the <code>PrecisionModel</code> and <code>SRID</code> that is used.\n   *\n   * @param {GeometryFactory} geometryFactory\n   */\n  constructor(geometryFactory) {\n    this.parser = new GeoJSONParser(geometryFactory || new GeometryFactory())\n  }\n\n  /**\n   * Reads a GeoJSON representation of a {@link Geometry}\n   *\n   * Will also parse GeoJSON Features/FeatureCollections as custom objects.\n   *\n   * @param {Object|String} geoJson a GeoJSON Object or String.\n   * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>\n   * @memberof module:org/locationtech/jts/io/GeoJSONReader#\n   */\n  read (geoJson) {\n    var geometry = this.parser.read(geoJson)\n    return geometry\n  }\n}\n","import Coordinate from '../geom/Coordinate'\nimport GeometryFactory from '../geom/GeometryFactory'\n\nconst regExes = {\n  'typeStr': /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n  'emptyTypeStr': /^\\s*(\\w+)\\s*EMPTY\\s*$/,\n  'spaces': /\\s+/,\n  'parenComma': /\\)\\s*,\\s*\\(/,\n  'doubleParenComma': /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/, // can't use {2} here\n  'trimParens': /^\\s*\\(?(.*?)\\)?\\s*$/\n}\n\n/**\n * Class for reading and writing Well-Known Text.\n *\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */\n\nexport default class WKTParser {\n  /** Create a new parser for WKT\n   *\n   * @param {GeometryFactory} geometryFactory\n   * @return An instance of WKTParser.\n   * @private\n   */\n  constructor(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory()\n    this.precisionModel = this.geometryFactory.getPrecisionModel()\n  }\n\n  /**\n   * Deserialize a WKT string and return a geometry. Supports WKT for POINT,\n   * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,\n   * and GEOMETRYCOLLECTION.\n   *\n   * @param {String} wkt A WKT string.\n   * @return {Geometry} A geometry instance.\n   * @private\n   */\n  read (wkt) {\n    var geometry, type, str\n    wkt = wkt.replace(/[\\n\\r]/g, ' ')\n    var matches = regExes.typeStr.exec(wkt)\n    if (wkt.search('EMPTY') !== -1) {\n      matches = regExes.emptyTypeStr.exec(wkt)\n      matches[2] = undefined\n    }\n    if (matches) {\n      type = matches[1].toLowerCase()\n      str = matches[2]\n      if (parse[type]) {\n        geometry = parse[type].call(this, str)\n      }\n    }\n\n    if (geometry === undefined) throw new Error('Could not parse WKT ' + wkt)\n\n    return geometry\n  }\n\n  /**\n   * Serialize a geometry into a WKT string.\n   *\n   * @param {Geometry} geometry A feature or array of features.\n   * @return {String} The WKT string representation of the input geometries.\n   * @private\n   */\n  write (geometry) {\n    return this.extractGeometry(geometry)\n  }\n\n  /**\n   * Entry point to construct the WKT for a single Geometry object.\n   *\n   * @param {Geometry} geometry\n   * @return {String} A WKT string of representing the geometry.\n   * @private\n   */\n  extractGeometry (geometry) {\n    var type = geometry.getGeometryType().toLowerCase()\n    if (!extract[type]) {\n      return null\n    }\n    var wktType = type.toUpperCase()\n    var data\n    if (geometry.isEmpty()) {\n      data = wktType + ' EMPTY'\n    } else {\n      data = wktType + '(' + extract[type].call(this, geometry) + ')'\n    }\n    return data\n  }\n}\n\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual data extraction.\n * @private\n */\nconst extract = {\n  coordinate (coordinate) {\n    this.precisionModel.makePrecise(coordinate)\n    return coordinate.x + ' ' + coordinate.y\n  },\n\n  /**\n   * Return a space delimited string of point coordinates.\n   *\n   * @param {Point}\n   *          point\n   * @return {String} A string of coordinates representing the point.\n   */\n  point (point) {\n    return extract.coordinate.call(this, point._coordinates._coordinates[0])\n  },\n\n  /**\n   * Return a comma delimited string of point coordinates from a multipoint.\n   *\n   * @param {MultiPoint}\n   *          multipoint\n   * @return {String} A string of point coordinate strings representing the\n   *         multipoint.\n   */\n  multipoint (multipoint) {\n    var array = []\n    for (let i = 0, len = multipoint._geometries.length; i < len; ++i) {\n      array.push('(' + extract.point.call(this, multipoint._geometries[i]) + ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of point coordinates from a line.\n   *\n   * @param {LineString} linestring\n   * @return {String} A string of point coordinate strings representing the linestring.\n   */\n  linestring (linestring) {\n    var array = []\n    for (let i = 0, len = linestring._points._coordinates.length; i < len; ++i) {\n      array.push(extract.coordinate.call(this, linestring._points._coordinates[i]))\n    }\n    return array.join(',')\n  },\n\n  linearring (linearring) {\n    var array = []\n    for (let i = 0, len = linearring._points._coordinates.length; i < len; ++i) {\n      array.push(extract.coordinate.call(this, linearring._points._coordinates[i]))\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of linestring strings from a\n   * multilinestring.\n   *\n   * @param {MultiLineString} multilinestring\n   * @return {String} A string of of linestring strings representing the multilinestring.\n   */\n  multilinestring (multilinestring) {\n    var array = []\n    for (let i = 0, len = multilinestring._geometries.length; i < len; ++i) {\n      array.push('(' +\n        extract.linestring.call(this, multilinestring._geometries[i]) +\n        ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of linear ring arrays from a polygon.\n   *\n   * @param {Polygon} polygon\n   * @return {String} An array of linear ring arrays representing the polygon.\n   */\n  polygon (polygon) {\n    var array = []\n    array.push('(' + extract.linestring.call(this, polygon._shell) + ')')\n    for (let i = 0, len = polygon._holes.length; i < len; ++i) {\n      array.push('(' + extract.linestring.call(this, polygon._holes[i]) + ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return an array of polygon arrays from a multipolygon.\n   *\n   * @param {MultiPolygon} multipolygon\n   * @return {String} An array of polygon arrays representing the multipolygon.\n   */\n  multipolygon (multipolygon) {\n    var array = []\n    for (let i = 0, len = multipolygon._geometries.length; i < len; ++i) {\n      array.push('(' + extract.polygon.call(this, multipolygon._geometries[i]) + ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an\n   * geometrycollection.\n   *\n   * @param {GeometryCollection} collection\n   * @return {String} internal WKT representation of the collection.\n   */\n  geometrycollection (collection) {\n    var array = []\n    for (let i = 0, len = collection._geometries.length; i < len; ++i) {\n      array.push(this.extractGeometry(collection._geometries[i]))\n    }\n    return array.join(',')\n  }\n}\n\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual parsing.\n * @private\n */\nconst parse = {\n  \n  coord (str) {\n    var coords = str.trim().split(regExes.spaces)\n    var coord = new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1]))\n    this.precisionModel.makePrecise(coord)\n    return coord\n  },\n\n  /**\n   * Return point geometry given a point WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the point.\n   * @return {Point} A point geometry.\n   * @private\n   */\n  point (str) {\n    if (str === undefined)\n      return this.geometryFactory.createPoint()\n    return this.geometryFactory.createPoint(parse.coord.call(this, str))\n  },\n\n  /**\n   * Return a multipoint geometry given a multipoint WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipoint.\n   * @return {Point} A multipoint feature.\n   * @private\n   */\n  multipoint (str) {\n    if (str === undefined)\n      return this.geometryFactory.createMultiPoint()\n    var point\n    var points = str.trim().split(',')\n    var components = []\n    for (let i = 0, len = points.length; i < len; ++i) {\n      point = points[i].replace(regExes.trimParens, '$1')\n      components.push(parse.point.call(this, point))\n    }\n    return this.geometryFactory.createMultiPoint(components)\n  },\n\n  /**\n   * Return a linestring geometry given a linestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linestring.\n   * @return {LineString} A linestring geometry.\n   * @private\n   */\n  linestring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createLineString()\n    }\n\n    var points = str.trim().split(',')\n    var components = []\n    var coords\n    for (let i = 0, len = points.length; i < len; ++i) {\n      components.push(parse.coord.call(this, points[i]))\n    }\n    return this.geometryFactory.createLineString(components)\n  },\n\n  /**\n   * Return a linearring geometry given a linearring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linearring.\n   * @return {LinearRing} A linearring geometry.\n   * @private\n   */\n  linearring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createLinearRing()\n    }\n\n    var points = str.trim().split(',')\n    var components = []\n    var coords\n    for (let i = 0, len = points.length; i < len; ++i) {\n      components.push(parse.coord.call(this, points[i]))\n    }\n    return this.geometryFactory.createLinearRing(components)\n  },\n\n  /**\n   * Return a multilinestring geometry given a multilinestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multilinestring.\n   * @return {MultiLineString} A multilinestring geometry.\n   * @private\n   */\n  multilinestring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createMultiLineString()\n    }\n\n    var line\n    var lines = str.trim().split(regExes.parenComma)\n    var components = []\n    for (let i = 0, len = lines.length; i < len; ++i) {\n      line = lines[i].replace(regExes.trimParens, '$1')\n      components.push(parse.linestring.call(this, line))\n    }\n    return this.geometryFactory.createMultiLineString(components)\n  },\n\n  /**\n   * Return a polygon geometry given a polygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the polygon.\n   * @return {Polygon} A polygon geometry.\n   * @private\n   */\n  polygon (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createPolygon()\n    }\n\n    var ring, linestring, linearring\n    var rings = str.trim().split(regExes.parenComma)\n    var shell\n    var holes = []\n    for (let i = 0, len = rings.length; i < len; ++i) {\n      ring = rings[i].replace(regExes.trimParens, '$1')\n      linestring = parse.linestring.call(this, ring)\n      linearring = this.geometryFactory.createLinearRing(linestring._points)\n      if (i === 0) {\n        shell = linearring\n      } else {\n        holes.push(linearring)\n      }\n    }\n    return this.geometryFactory.createPolygon(shell, holes)\n  },\n\n  /**\n   * Return a multipolygon geometry given a multipolygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipolygon.\n   * @return {MultiPolygon} A multipolygon geometry.\n   * @private\n   */\n  multipolygon (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createMultiPolygon()\n    }\n\n    var polygon\n    var polygons = str.trim().split(regExes.doubleParenComma)\n    var components = []\n    for (let i = 0, len = polygons.length; i < len; ++i) {\n      polygon = polygons[i].replace(regExes.trimParens, '$1')\n      components.push(parse.polygon.call(this, polygon))\n    }\n    return this.geometryFactory.createMultiPolygon(components)\n  },\n\n  /**\n   * Return a geometrycollection given a geometrycollection WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the geometrycollection.\n   * @return {GeometryCollection}\n   * @private\n   */\n  geometrycollection (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createGeometryCollection()\n    }\n\n    // separate components of the collection with |\n    str = str.replace(/,\\s*([A-Za-z])/g, '|$1')\n    var wktArray = str.trim().split('|')\n    var components = []\n    for (let i = 0, len = wktArray.length; i < len; ++i) {\n      components.push(this.read(wktArray[i]))\n    }\n    return this.geometryFactory.createGeometryCollection(components)\n  }\n}\n","/**\n * @module org/locationtech/jts/io/WKTWriter\n */\n\nimport WKTParser from './WKTParser'\n\n/**\n * Writes the Well-Known Text representation of a {@link Geometry}. The\n * Well-Known Text format is defined in the <A\n * HREF=\"http://www.opengis.org/techno/specs.htm\"> OGC Simple Features\n * Specification for SQL</A>.\n * <p>\n * The <code>WKTWriter</code> outputs coordinates rounded to the precision\n * model. Only the maximum number of decimal places necessary to represent the\n * ordinates to the required precision will be output.\n * <p>\n * The SFS WKT spec does not define a special tag for {@link LinearRing}s.\n * Under the spec, rings are output as <code>LINESTRING</code>s.\n */\nexport default class WKTWriter {\n  /**\n   * @param {GeometryFactory} geometryFactory\n   */\n  constructor(geometryFactory) {\n    this.parser = new WKTParser(geometryFactory)\n  }\n  /**\n   * Converts a <code>Geometry</code> to its Well-known Text representation.\n   *\n   * @param {Geometry} geometry a <code>Geometry</code> to process.\n   * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple\n   *         Features Specification).\n   * @memberof module:org/locationtech/jts/io/WKTWriter#\n   */\n  write (geometry) {\n    return this.parser.write(geometry)\n  }\n  /**\n   * Generates the WKT for a <tt>LINESTRING</tt> specified by two\n   * {@link Coordinate}s.\n   *\n   * @param p0 the first coordinate.\n   * @param p1 the second coordinate.\n   *\n   * @return the WKT.\n   * @private\n   */\n  static toLineString (p0, p1) {\n    if (arguments.length !== 2) {\n      throw new Error('Not implemented')\n    }\n\n    return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )'\n  }\n}\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nexport default class Location {\n\tconstructor() {\n\t\tLocation.constructor_.apply(this, arguments);\n\t}\n\tstatic toLocationSymbol(locationValue) {\n\t\tswitch (locationValue) {\n\t\t\tcase Location.EXTERIOR:\n\t\t\t\treturn 'e';\n\t\t\tcase Location.BOUNDARY:\n\t\t\t\treturn 'b';\n\t\t\tcase Location.INTERIOR:\n\t\t\t\treturn 'i';\n\t\t\tcase Location.NONE:\n\t\t\t\treturn '-';\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Unknown location value: \" + locationValue);\n\t}\n\tgetClass() {\n\t\treturn Location;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nLocation.constructor_ = function () {};\nLocation.INTERIOR = 0;\nLocation.BOUNDARY = 1;\nLocation.EXTERIOR = 2;\nLocation.NONE = -1;\n","export default function Exception () {}\n","import Exception from '../../../../java/lang/Exception';\nexport default class NotRepresentableException extends Exception {\n\tconstructor() {\n\t\tsuper();\n\t\tNotRepresentableException.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn NotRepresentableException;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nNotRepresentableException.constructor_ = function () {\n\tException.constructor_.call(this, \"Projective point not representable on the Cartesian plane.\");\n};\n","import NotRepresentableException from './NotRepresentableException';\nimport Coordinate from '../geom/Coordinate';\nimport Double from '../../../../java/lang/Double';\nexport default class HCoordinate {\n\tconstructor() {\n\t\tHCoordinate.constructor_.apply(this, arguments);\n\t}\n\tstatic intersection(p1, p2, q1, q2) {\n\t\tvar px = p1.y - p2.y;\n\t\tvar py = p2.x - p1.x;\n\t\tvar pw = p1.x * p2.y - p2.x * p1.y;\n\t\tvar qx = q1.y - q2.y;\n\t\tvar qy = q2.x - q1.x;\n\t\tvar qw = q1.x * q2.y - q2.x * q1.y;\n\t\tvar x = py * qw - qy * pw;\n\t\tvar y = qx * pw - px * qw;\n\t\tvar w = px * qy - qx * py;\n\t\tvar xInt = x / w;\n\t\tvar yInt = y / w;\n\t\tif (Double.isNaN(xInt) || (Double.isInfinite(xInt) || Double.isNaN(yInt)) || Double.isInfinite(yInt)) {\n\t\t\tthrow new NotRepresentableException();\n\t\t}\n\t\treturn new Coordinate(xInt, yInt);\n\t}\n\tgetY() {\n\t\tvar a = this.y / this.w;\n\t\tif (Double.isNaN(a) || Double.isInfinite(a)) {\n\t\t\tthrow new NotRepresentableException();\n\t\t}\n\t\treturn a;\n\t}\n\tgetX() {\n\t\tvar a = this.x / this.w;\n\t\tif (Double.isNaN(a) || Double.isInfinite(a)) {\n\t\t\tthrow new NotRepresentableException();\n\t\t}\n\t\treturn a;\n\t}\n\tgetCoordinate() {\n\t\tvar p = new Coordinate();\n\t\tp.x = this.getX();\n\t\tp.y = this.getY();\n\t\treturn p;\n\t}\n\tgetClass() {\n\t\treturn HCoordinate;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nHCoordinate.constructor_ = function () {\n\tthis.x = null;\n\tthis.y = null;\n\tthis.w = null;\n\tif (arguments.length === 0) {\n\t\tthis.x = 0.0;\n\t\tthis.y = 0.0;\n\t\tthis.w = 1.0;\n\t} else if (arguments.length === 1) {\n\t\tlet p = arguments[0];\n\t\tthis.x = p.x;\n\t\tthis.y = p.y;\n\t\tthis.w = 1.0;\n\t} else if (arguments.length === 2) {\n\t\tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\t\tlet _x = arguments[0], _y = arguments[1];\n\t\t\tthis.x = _x;\n\t\t\tthis.y = _y;\n\t\t\tthis.w = 1.0;\n\t\t} else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\t\tthis.x = p1.y * p2.w - p2.y * p1.w;\n\t\t\tthis.y = p2.x * p1.w - p1.x * p2.w;\n\t\t\tthis.w = p1.x * p2.y - p2.x * p1.y;\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\t\tthis.x = p1.y - p2.y;\n\t\t\tthis.y = p2.x - p1.x;\n\t\t\tthis.w = p1.x * p2.y - p2.x * p1.y;\n\t\t}\n\t} else if (arguments.length === 3) {\n\t\tlet _x = arguments[0], _y = arguments[1], _w = arguments[2];\n\t\tthis.x = _x;\n\t\tthis.y = _y;\n\t\tthis.w = _w;\n\t} else if (arguments.length === 4) {\n\t\tlet p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3];\n\t\tvar px = p1.y - p2.y;\n\t\tvar py = p2.x - p1.x;\n\t\tvar pw = p1.x * p2.y - p2.x * p1.y;\n\t\tvar qx = q1.y - q2.y;\n\t\tvar qy = q2.x - q1.x;\n\t\tvar qw = q1.x * q2.y - q2.x * q1.y;\n\t\tthis.x = py * qw - qy * pw;\n\t\tthis.y = qx * pw - px * qw;\n\t\tthis.w = px * qy - qx * py;\n\t}\n};\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport MathUtil from '../math/MathUtil';\nimport Envelope from '../geom/Envelope';\nexport default class Distance {\n\tconstructor() {\n\t\tDistance.constructor_.apply(this, arguments);\n\t}\n\tstatic segmentToSegment(A, B, C, D) {\n\t\tif (A.equals(B)) return Distance.pointToSegment(A, C, D);\n\t\tif (C.equals(D)) return Distance.pointToSegment(D, A, B);\n\t\tvar noIntersection = false;\n\t\tif (!Envelope.intersects(A, B, C, D)) {\n\t\t\tnoIntersection = true;\n\t\t} else {\n\t\t\tvar denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);\n\t\t\tif (denom === 0) {\n\t\t\t\tnoIntersection = true;\n\t\t\t} else {\n\t\t\t\tvar r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);\n\t\t\t\tvar s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);\n\t\t\t\tvar s = s_num / denom;\n\t\t\t\tvar r = r_num / denom;\n\t\t\t\tif (r < 0 || r > 1 || s < 0 || s > 1) {\n\t\t\t\t\tnoIntersection = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (noIntersection) {\n\t\t\treturn MathUtil.min(Distance.pointToSegment(A, C, D), Distance.pointToSegment(B, C, D), Distance.pointToSegment(C, A, B), Distance.pointToSegment(D, A, B));\n\t\t}\n\t\treturn 0.0;\n\t}\n\tstatic pointToSegment(p, A, B) {\n\t\tif (A.x === B.x && A.y === B.y) return p.distance(A);\n\t\tvar len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n\t\tvar r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) / len2;\n\t\tif (r <= 0.0) return p.distance(A);\n\t\tif (r >= 1.0) return p.distance(B);\n\t\tvar s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n\t\treturn Math.abs(s) * Math.sqrt(len2);\n\t}\n\tstatic pointToLinePerpendicular(p, A, B) {\n\t\tvar len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n\t\tvar s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n\t\treturn Math.abs(s) * Math.sqrt(len2);\n\t}\n\tstatic pointToSegmentString(p, line) {\n\t\tif (line.length === 0) throw new IllegalArgumentException(\"Line array must contain at least one vertex\");\n\t\tvar minDistance = p.distance(line[0]);\n\t\tfor (var i = 0; i < line.length - 1; i++) {\n\t\t\tvar dist = Distance.pointToSegment(p, line[i], line[i + 1]);\n\t\t\tif (dist < minDistance) {\n\t\t\t\tminDistance = dist;\n\t\t\t}\n\t\t}\n\t\treturn minDistance;\n\t}\n\tgetClass() {\n\t\treturn Distance;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nDistance.constructor_ = function () {};\n","import WKTWriter from '../io/WKTWriter';\nimport Coordinate from '../geom/Coordinate';\nimport Assert from '../util/Assert';\nimport StringBuilder from '../../../../java/lang/StringBuilder';\nexport default class LineIntersector {\n\tconstructor() {\n\t\tLineIntersector.constructor_.apply(this, arguments);\n\t}\n\tstatic computeEdgeDistance(p, p0, p1) {\n\t\tvar dx = Math.abs(p1.x - p0.x);\n\t\tvar dy = Math.abs(p1.y - p0.y);\n\t\tvar dist = -1.0;\n\t\tif (p.equals(p0)) {\n\t\t\tdist = 0.0;\n\t\t} else if (p.equals(p1)) {\n\t\t\tif (dx > dy) dist = dx; else dist = dy;\n\t\t} else {\n\t\t\tvar pdx = Math.abs(p.x - p0.x);\n\t\t\tvar pdy = Math.abs(p.y - p0.y);\n\t\t\tif (dx > dy) dist = pdx; else dist = pdy;\n\t\t\tif (dist === 0.0 && !p.equals(p0)) {\n\t\t\t\tdist = Math.max(pdx, pdy);\n\t\t\t}\n\t\t}\n\t\tAssert.isTrue(!(dist === 0.0 && !p.equals(p0)), \"Bad distance calculation\");\n\t\treturn dist;\n\t}\n\tstatic nonRobustComputeEdgeDistance(p, p1, p2) {\n\t\tvar dx = p.x - p1.x;\n\t\tvar dy = p.y - p1.y;\n\t\tvar dist = Math.sqrt(dx * dx + dy * dy);\n\t\tAssert.isTrue(!(dist === 0.0 && !p.equals(p1)), \"Invalid distance calculation\");\n\t\treturn dist;\n\t}\n\tgetIndexAlongSegment(segmentIndex, intIndex) {\n\t\tthis.computeIntLineIndex();\n\t\treturn this._intLineIndex[segmentIndex][intIndex];\n\t}\n\tgetTopologySummary() {\n\t\tvar catBuilder = new StringBuilder();\n\t\tif (this.isEndPoint()) catBuilder.append(\" endpoint\");\n\t\tif (this._isProper) catBuilder.append(\" proper\");\n\t\tif (this.isCollinear()) catBuilder.append(\" collinear\");\n\t\treturn catBuilder.toString();\n\t}\n\tcomputeIntersection(p1, p2, p3, p4) {\n\t\tthis._inputLines[0][0] = p1;\n\t\tthis._inputLines[0][1] = p2;\n\t\tthis._inputLines[1][0] = p3;\n\t\tthis._inputLines[1][1] = p4;\n\t\tthis._result = this.computeIntersect(p1, p2, p3, p4);\n\t}\n\tgetIntersectionNum() {\n\t\treturn this._result;\n\t}\n\tcomputeIntLineIndex() {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this._intLineIndex === null) {\n\t\t\t\tthis._intLineIndex = Array(2).fill().map(() => Array(2));\n\t\t\t\tthis.computeIntLineIndex(0);\n\t\t\t\tthis.computeIntLineIndex(1);\n\t\t\t}\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet segmentIndex = arguments[0];\n\t\t\tvar dist0 = this.getEdgeDistance(segmentIndex, 0);\n\t\t\tvar dist1 = this.getEdgeDistance(segmentIndex, 1);\n\t\t\tif (dist0 > dist1) {\n\t\t\t\tthis._intLineIndex[segmentIndex][0] = 0;\n\t\t\t\tthis._intLineIndex[segmentIndex][1] = 1;\n\t\t\t} else {\n\t\t\t\tthis._intLineIndex[segmentIndex][0] = 1;\n\t\t\t\tthis._intLineIndex[segmentIndex][1] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tisProper() {\n\t\treturn this.hasIntersection() && this._isProper;\n\t}\n\tsetPrecisionModel(precisionModel) {\n\t\tthis._precisionModel = precisionModel;\n\t}\n\tisInteriorIntersection() {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.isInteriorIntersection(0)) return true;\n\t\t\tif (this.isInteriorIntersection(1)) return true;\n\t\t\treturn false;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet inputLineIndex = arguments[0];\n\t\t\tfor (var i = 0; i < this._result; i++) {\n\t\t\t\tif (!(this._intPt[i].equals2D(this._inputLines[inputLineIndex][0]) || this._intPt[i].equals2D(this._inputLines[inputLineIndex][1]))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\tgetIntersection(intIndex) {\n\t\treturn this._intPt[intIndex];\n\t}\n\tisEndPoint() {\n\t\treturn this.hasIntersection() && !this._isProper;\n\t}\n\thasIntersection() {\n\t\treturn this._result !== LineIntersector.NO_INTERSECTION;\n\t}\n\tgetEdgeDistance(segmentIndex, intIndex) {\n\t\tvar dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);\n\t\treturn dist;\n\t}\n\tisCollinear() {\n\t\treturn this._result === LineIntersector.COLLINEAR_INTERSECTION;\n\t}\n\ttoString() {\n\t\treturn WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + \" - \" + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();\n\t}\n\tgetEndpoint(segmentIndex, ptIndex) {\n\t\treturn this._inputLines[segmentIndex][ptIndex];\n\t}\n\tisIntersection(pt) {\n\t\tfor (var i = 0; i < this._result; i++) {\n\t\t\tif (this._intPt[i].equals2D(pt)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tgetIntersectionAlongSegment(segmentIndex, intIndex) {\n\t\tthis.computeIntLineIndex();\n\t\treturn this._intPt[this._intLineIndex[segmentIndex][intIndex]];\n\t}\n\tgetClass() {\n\t\treturn LineIntersector;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nLineIntersector.constructor_ = function () {\n\tthis._result = null;\n\tthis._inputLines = Array(2).fill().map(() => Array(2));\n\tthis._intPt = new Array(2).fill(null);\n\tthis._intLineIndex = null;\n\tthis._isProper = null;\n\tthis._pa = null;\n\tthis._pb = null;\n\tthis._precisionModel = null;\n\tthis._intPt[0] = new Coordinate();\n\tthis._intPt[1] = new Coordinate();\n\tthis._pa = this._intPt[0];\n\tthis._pb = this._intPt[1];\n\tthis._result = 0;\n};\nLineIntersector.DONT_INTERSECT = 0;\nLineIntersector.DO_INTERSECT = 1;\nLineIntersector.COLLINEAR = 2;\nLineIntersector.NO_INTERSECTION = 0;\nLineIntersector.POINT_INTERSECTION = 1;\nLineIntersector.COLLINEAR_INTERSECTION = 2;\n","import NotRepresentableException from './NotRepresentableException';\nimport Coordinate from '../geom/Coordinate';\nimport Orientation from './Orientation';\nimport CGAlgorithmsDD from './CGAlgorithmsDD';\nimport System from '../../../../java/lang/System';\nimport HCoordinate from './HCoordinate';\nimport Envelope from '../geom/Envelope';\nimport Distance from './Distance';\nimport LineIntersector from './LineIntersector';\nexport default class RobustLineIntersector extends LineIntersector {\n\tconstructor() {\n\t\tsuper();\n\t\tRobustLineIntersector.constructor_.apply(this, arguments);\n\t}\n\tstatic nearestEndpoint(p1, p2, q1, q2) {\n\t\tvar nearestPt = p1;\n\t\tvar minDist = Distance.pointToSegment(p1, q1, q2);\n\t\tvar dist = Distance.pointToSegment(p2, q1, q2);\n\t\tif (dist < minDist) {\n\t\t\tminDist = dist;\n\t\t\tnearestPt = p2;\n\t\t}\n\t\tdist = Distance.pointToSegment(q1, p1, p2);\n\t\tif (dist < minDist) {\n\t\t\tminDist = dist;\n\t\t\tnearestPt = q1;\n\t\t}\n\t\tdist = Distance.pointToSegment(q2, p1, p2);\n\t\tif (dist < minDist) {\n\t\t\tminDist = dist;\n\t\t\tnearestPt = q2;\n\t\t}\n\t\treturn nearestPt;\n\t}\n\tisInSegmentEnvelopes(intPt) {\n\t\tvar env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);\n\t\tvar env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);\n\t\treturn env0.contains(intPt) && env1.contains(intPt);\n\t}\n\tcomputeIntersection() {\n\t\tif (arguments.length === 3) {\n\t\t\tlet p = arguments[0], p1 = arguments[1], p2 = arguments[2];\n\t\t\tthis._isProper = false;\n\t\t\tif (Envelope.intersects(p1, p2, p)) {\n\t\t\t\tif (Orientation.index(p1, p2, p) === 0 && Orientation.index(p2, p1, p) === 0) {\n\t\t\t\t\tthis._isProper = true;\n\t\t\t\t\tif (p.equals(p1) || p.equals(p2)) {\n\t\t\t\t\t\tthis._isProper = false;\n\t\t\t\t\t}\n\t\t\t\t\tthis._result = LineIntersector.POINT_INTERSECTION;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._result = LineIntersector.NO_INTERSECTION;\n\t\t} else return super.computeIntersection.apply(this, arguments);\n\t}\n\tnormalizeToMinimum(n1, n2, n3, n4, normPt) {\n\t\tnormPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);\n\t\tnormPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);\n\t\tn1.x -= normPt.x;\n\t\tn1.y -= normPt.y;\n\t\tn2.x -= normPt.x;\n\t\tn2.y -= normPt.y;\n\t\tn3.x -= normPt.x;\n\t\tn3.y -= normPt.y;\n\t\tn4.x -= normPt.x;\n\t\tn4.y -= normPt.y;\n\t}\n\tsafeHCoordinateIntersection(p1, p2, q1, q2) {\n\t\tvar intPt = null;\n\t\ttry {\n\t\t\tintPt = HCoordinate.intersection(p1, p2, q1, q2);\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotRepresentableException) {\n\t\t\t\tintPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);\n\t\t\t} else throw e;\n\t\t} finally {}\n\t\treturn intPt;\n\t}\n\tintersection(p1, p2, q1, q2) {\n\t\tvar intPt = this.intersectionWithNormalization(p1, p2, q1, q2);\n\t\tif (!this.isInSegmentEnvelopes(intPt)) {\n\t\t\tintPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));\n\t\t}\n\t\tif (this._precisionModel !== null) {\n\t\t\tthis._precisionModel.makePrecise(intPt);\n\t\t}\n\t\treturn intPt;\n\t}\n\tsmallestInAbsValue(x1, x2, x3, x4) {\n\t\tvar x = x1;\n\t\tvar xabs = Math.abs(x);\n\t\tif (Math.abs(x2) < xabs) {\n\t\t\tx = x2;\n\t\t\txabs = Math.abs(x2);\n\t\t}\n\t\tif (Math.abs(x3) < xabs) {\n\t\t\tx = x3;\n\t\t\txabs = Math.abs(x3);\n\t\t}\n\t\tif (Math.abs(x4) < xabs) {\n\t\t\tx = x4;\n\t\t}\n\t\treturn x;\n\t}\n\tcheckDD(p1, p2, q1, q2, intPt) {\n\t\tvar intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);\n\t\tvar isIn = this.isInSegmentEnvelopes(intPtDD);\n\t\tSystem.out.println(\"DD in env = \" + isIn + \"  --------------------- \" + intPtDD);\n\t\tif (intPt.distance(intPtDD) > 0.0001) {\n\t\t\tSystem.out.println(\"Distance = \" + intPt.distance(intPtDD));\n\t\t}\n\t}\n\tintersectionWithNormalization(p1, p2, q1, q2) {\n\t\tvar n1 = new Coordinate(p1);\n\t\tvar n2 = new Coordinate(p2);\n\t\tvar n3 = new Coordinate(q1);\n\t\tvar n4 = new Coordinate(q2);\n\t\tvar normPt = new Coordinate();\n\t\tthis.normalizeToEnvCentre(n1, n2, n3, n4, normPt);\n\t\tvar intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);\n\t\tintPt.x += normPt.x;\n\t\tintPt.y += normPt.y;\n\t\treturn intPt;\n\t}\n\tcomputeCollinearIntersection(p1, p2, q1, q2) {\n\t\tvar p1q1p2 = Envelope.intersects(p1, p2, q1);\n\t\tvar p1q2p2 = Envelope.intersects(p1, p2, q2);\n\t\tvar q1p1q2 = Envelope.intersects(q1, q2, p1);\n\t\tvar q1p2q2 = Envelope.intersects(q1, q2, p2);\n\t\tif (p1q1p2 && p1q2p2) {\n\t\t\tthis._intPt[0] = q1;\n\t\t\tthis._intPt[1] = q2;\n\t\t\treturn LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (q1p1q2 && q1p2q2) {\n\t\t\tthis._intPt[0] = p1;\n\t\t\tthis._intPt[1] = p2;\n\t\t\treturn LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q1p2 && q1p1q2) {\n\t\t\tthis._intPt[0] = q1;\n\t\t\tthis._intPt[1] = p1;\n\t\t\treturn q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q1p2 && q1p2q2) {\n\t\t\tthis._intPt[0] = q1;\n\t\t\tthis._intPt[1] = p2;\n\t\t\treturn q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q2p2 && q1p1q2) {\n\t\t\tthis._intPt[0] = q2;\n\t\t\tthis._intPt[1] = p1;\n\t\t\treturn q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q2p2 && q1p2q2) {\n\t\t\tthis._intPt[0] = q2;\n\t\t\tthis._intPt[1] = p2;\n\t\t\treturn q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\treturn LineIntersector.NO_INTERSECTION;\n\t}\n\tnormalizeToEnvCentre(n00, n01, n10, n11, normPt) {\n\t\tvar minX0 = n00.x < n01.x ? n00.x : n01.x;\n\t\tvar minY0 = n00.y < n01.y ? n00.y : n01.y;\n\t\tvar maxX0 = n00.x > n01.x ? n00.x : n01.x;\n\t\tvar maxY0 = n00.y > n01.y ? n00.y : n01.y;\n\t\tvar minX1 = n10.x < n11.x ? n10.x : n11.x;\n\t\tvar minY1 = n10.y < n11.y ? n10.y : n11.y;\n\t\tvar maxX1 = n10.x > n11.x ? n10.x : n11.x;\n\t\tvar maxY1 = n10.y > n11.y ? n10.y : n11.y;\n\t\tvar intMinX = minX0 > minX1 ? minX0 : minX1;\n\t\tvar intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;\n\t\tvar intMinY = minY0 > minY1 ? minY0 : minY1;\n\t\tvar intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;\n\t\tvar intMidX = (intMinX + intMaxX) / 2.0;\n\t\tvar intMidY = (intMinY + intMaxY) / 2.0;\n\t\tnormPt.x = intMidX;\n\t\tnormPt.y = intMidY;\n\t\tn00.x -= normPt.x;\n\t\tn00.y -= normPt.y;\n\t\tn01.x -= normPt.x;\n\t\tn01.y -= normPt.y;\n\t\tn10.x -= normPt.x;\n\t\tn10.y -= normPt.y;\n\t\tn11.x -= normPt.x;\n\t\tn11.y -= normPt.y;\n\t}\n\tcomputeIntersect(p1, p2, q1, q2) {\n\t\tthis._isProper = false;\n\t\tif (!Envelope.intersects(p1, p2, q1, q2)) return LineIntersector.NO_INTERSECTION;\n\t\tvar Pq1 = Orientation.index(p1, p2, q1);\n\t\tvar Pq2 = Orientation.index(p1, p2, q2);\n\t\tif (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) {\n\t\t\treturn LineIntersector.NO_INTERSECTION;\n\t\t}\n\t\tvar Qp1 = Orientation.index(q1, q2, p1);\n\t\tvar Qp2 = Orientation.index(q1, q2, p2);\n\t\tif (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) {\n\t\t\treturn LineIntersector.NO_INTERSECTION;\n\t\t}\n\t\tvar collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;\n\t\tif (collinear) {\n\t\t\treturn this.computeCollinearIntersection(p1, p2, q1, q2);\n\t\t}\n\t\tif (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {\n\t\t\tthis._isProper = false;\n\t\t\tif (p1.equals2D(q1) || p1.equals2D(q2)) {\n\t\t\t\tthis._intPt[0] = p1;\n\t\t\t} else if (p2.equals2D(q1) || p2.equals2D(q2)) {\n\t\t\t\tthis._intPt[0] = p2;\n\t\t\t} else if (Pq1 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(q1);\n\t\t\t} else if (Pq2 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(q2);\n\t\t\t} else if (Qp1 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(p1);\n\t\t\t} else if (Qp2 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(p2);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._isProper = true;\n\t\t\tthis._intPt[0] = this.intersection(p1, p2, q1, q2);\n\t\t}\n\t\treturn LineIntersector.POINT_INTERSECTION;\n\t}\n\tgetClass() {\n\t\treturn RobustLineIntersector;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRobustLineIntersector.constructor_ = function () {};\n","import Location from '../geom/Location';\nimport hasInterface from '../../../../hasInterface';\nimport Coordinate from '../geom/Coordinate';\nimport Orientation from './Orientation';\nimport CoordinateSequence from '../geom/CoordinateSequence';\nexport default class RayCrossingCounter {\n\tconstructor() {\n\t\tRayCrossingCounter.constructor_.apply(this, arguments);\n\t}\n\tstatic locatePointInRing() {\n\t\tif (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n\t\t\tlet p = arguments[0], ring = arguments[1];\n\t\t\tvar counter = new RayCrossingCounter(p);\n\t\t\tvar p1 = new Coordinate();\n\t\t\tvar p2 = new Coordinate();\n\t\t\tfor (var i = 1; i < ring.size(); i++) {\n\t\t\t\tring.getCoordinate(i, p1);\n\t\t\t\tring.getCoordinate(i - 1, p2);\n\t\t\t\tcounter.countSegment(p1, p2);\n\t\t\t\tif (counter.isOnSegment()) return counter.getLocation();\n\t\t\t}\n\t\t\treturn counter.getLocation();\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n\t\t\tlet p = arguments[0], ring = arguments[1];\n\t\t\tvar counter = new RayCrossingCounter(p);\n\t\t\tfor (var i = 1; i < ring.length; i++) {\n\t\t\t\tvar p1 = ring[i];\n\t\t\t\tvar p2 = ring[i - 1];\n\t\t\t\tcounter.countSegment(p1, p2);\n\t\t\t\tif (counter.isOnSegment()) return counter.getLocation();\n\t\t\t}\n\t\t\treturn counter.getLocation();\n\t\t}\n\t}\n\tcountSegment(p1, p2) {\n\t\tif (p1.x < this._p.x && p2.x < this._p.x) return null;\n\t\tif (this._p.x === p2.x && this._p.y === p2.y) {\n\t\t\tthis._isPointOnSegment = true;\n\t\t\treturn null;\n\t\t}\n\t\tif (p1.y === this._p.y && p2.y === this._p.y) {\n\t\t\tvar minx = p1.x;\n\t\t\tvar maxx = p2.x;\n\t\t\tif (minx > maxx) {\n\t\t\t\tminx = p2.x;\n\t\t\t\tmaxx = p1.x;\n\t\t\t}\n\t\t\tif (this._p.x >= minx && this._p.x <= maxx) {\n\t\t\t\tthis._isPointOnSegment = true;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tif (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {\n\t\t\tvar orient = Orientation.index(p1, p2, this._p);\n\t\t\tif (orient === Orientation.COLLINEAR) {\n\t\t\t\tthis._isPointOnSegment = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (p2.y < p1.y) {\n\t\t\t\torient = -orient;\n\t\t\t}\n\t\t\tif (orient === Orientation.LEFT) {\n\t\t\t\tthis._crossingCount++;\n\t\t\t}\n\t\t}\n\t}\n\tisPointInPolygon() {\n\t\treturn this.getLocation() !== Location.EXTERIOR;\n\t}\n\tgetLocation() {\n\t\tif (this._isPointOnSegment) return Location.BOUNDARY;\n\t\tif (this._crossingCount % 2 === 1) {\n\t\t\treturn Location.INTERIOR;\n\t\t}\n\t\treturn Location.EXTERIOR;\n\t}\n\tisOnSegment() {\n\t\treturn this._isPointOnSegment;\n\t}\n\tgetClass() {\n\t\treturn RayCrossingCounter;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRayCrossingCounter.constructor_ = function () {\n\tthis._p = null;\n\tthis._crossingCount = 0;\n\tthis._isPointOnSegment = false;\n\tlet p = arguments[0];\n\tthis._p = p;\n};\n","import Location from '../geom/Location';\nimport hasInterface from '../../../../hasInterface';\nimport Coordinate from '../geom/Coordinate';\nimport CoordinateSequence from '../geom/CoordinateSequence';\nimport RobustLineIntersector from './RobustLineIntersector';\nimport RayCrossingCounter from './RayCrossingCounter';\nexport default class PointLocation {\n\tconstructor() {\n\t\tPointLocation.constructor_.apply(this, arguments);\n\t}\n\tstatic isOnLine() {\n\t\tif (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n\t\t\tlet p = arguments[0], line = arguments[1];\n\t\t\tvar lineIntersector = new RobustLineIntersector();\n\t\t\tvar p0 = new Coordinate();\n\t\t\tvar p1 = new Coordinate();\n\t\t\tvar n = line.size();\n\t\t\tfor (var i = 1; i < n; i++) {\n\t\t\t\tline.getCoordinate(i - 1, p0);\n\t\t\t\tline.getCoordinate(i, p1);\n\t\t\t\tlineIntersector.computeIntersection(p, p0, p1);\n\t\t\t\tif (lineIntersector.hasIntersection()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n\t\t\tlet p = arguments[0], line = arguments[1];\n\t\t\tvar lineIntersector = new RobustLineIntersector();\n\t\t\tfor (var i = 1; i < line.length; i++) {\n\t\t\t\tvar p0 = line[i - 1];\n\t\t\t\tvar p1 = line[i];\n\t\t\t\tlineIntersector.computeIntersection(p, p0, p1);\n\t\t\t\tif (lineIntersector.hasIntersection()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\tstatic locateInRing(p, ring) {\n\t\treturn RayCrossingCounter.locatePointInRing(p, ring);\n\t}\n\tstatic isInRing(p, ring) {\n\t\treturn PointLocation.locateInRing(p, ring) !== Location.EXTERIOR;\n\t}\n\tgetClass() {\n\t\treturn PointLocation;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPointLocation.constructor_ = function () {};\n","import Iterator from '../../../../java/util/Iterator';\nimport NoSuchElementException from '../../../../java/util/NoSuchElementException';\nimport GeometryCollection from './GeometryCollection';\nexport default class GeometryCollectionIterator {\n\tconstructor() {\n\t\tGeometryCollectionIterator.constructor_.apply(this, arguments);\n\t}\n\tstatic isAtomic(geom) {\n\t\treturn !(geom instanceof GeometryCollection);\n\t}\n\tnext() {\n\t\tif (this._atStart) {\n\t\t\tthis._atStart = false;\n\t\t\tif (GeometryCollectionIterator.isAtomic(this._parent)) this._index++;\n\t\t\treturn this._parent;\n\t\t}\n\t\tif (this._subcollectionIterator !== null) {\n\t\t\tif (this._subcollectionIterator.hasNext()) {\n\t\t\t\treturn this._subcollectionIterator.next();\n\t\t\t} else {\n\t\t\t\tthis._subcollectionIterator = null;\n\t\t\t}\n\t\t}\n\t\tif (this._index >= this._max) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tvar obj = this._parent.getGeometryN(this._index++);\n\t\tif (obj instanceof GeometryCollection) {\n\t\t\tthis._subcollectionIterator = new GeometryCollectionIterator(obj);\n\t\t\treturn this._subcollectionIterator.next();\n\t\t}\n\t\treturn obj;\n\t}\n\tremove() {\n\t\tthrow new UnsupportedOperationException(this.getClass().getName());\n\t}\n\thasNext() {\n\t\tif (this._atStart) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this._subcollectionIterator !== null) {\n\t\t\tif (this._subcollectionIterator.hasNext()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tthis._subcollectionIterator = null;\n\t\t}\n\t\tif (this._index >= this._max) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tgetClass() {\n\t\treturn GeometryCollectionIterator;\n\t}\n\tget interfaces_() {\n\t\treturn [Iterator];\n\t}\n}\nGeometryCollectionIterator.constructor_ = function () {\n\tthis._parent = null;\n\tthis._atStart = null;\n\tthis._max = null;\n\tthis._index = null;\n\tthis._subcollectionIterator = null;\n\tlet parent = arguments[0];\n\tthis._parent = parent;\n\tthis._atStart = true;\n\tthis._index = 0;\n\tthis._max = parent.getNumGeometries();\n};\n","import Location from '../geom/Location';\nimport LineString from '../geom/LineString';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Point from '../geom/Point';\nimport Polygon from '../geom/Polygon';\nimport PointLocation from './PointLocation';\nimport BoundaryNodeRule from './BoundaryNodeRule';\nimport MultiPolygon from '../geom/MultiPolygon';\nimport GeometryCollectionIterator from '../geom/GeometryCollectionIterator';\nimport GeometryCollection from '../geom/GeometryCollection';\nimport MultiLineString from '../geom/MultiLineString';\nexport default class PointLocator {\n\tconstructor() {\n\t\tPointLocator.constructor_.apply(this, arguments);\n\t}\n\tlocateInPolygonRing(p, ring) {\n\t\tif (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n\t\treturn PointLocation.locateInRing(p, ring.getCoordinates());\n\t}\n\tintersects(p, geom) {\n\t\treturn this.locate(p, geom) !== Location.EXTERIOR;\n\t}\n\tupdateLocationInfo(loc) {\n\t\tif (loc === Location.INTERIOR) this._isIn = true;\n\t\tif (loc === Location.BOUNDARY) this._numBoundaries++;\n\t}\n\tcomputeLocation(p, geom) {\n\t\tif (geom instanceof Point) {\n\t\t\tthis.updateLocationInfo(this.locateOnPoint(p, geom));\n\t\t}\n\t\tif (geom instanceof LineString) {\n\t\t\tthis.updateLocationInfo(this.locateOnLineString(p, geom));\n\t\t} else if (geom instanceof Polygon) {\n\t\t\tthis.updateLocationInfo(this.locateInPolygon(p, geom));\n\t\t} else if (geom instanceof MultiLineString) {\n\t\t\tvar ml = geom;\n\t\t\tfor (var i = 0; i < ml.getNumGeometries(); i++) {\n\t\t\t\tvar l = ml.getGeometryN(i);\n\t\t\t\tthis.updateLocationInfo(this.locateOnLineString(p, l));\n\t\t\t}\n\t\t} else if (geom instanceof MultiPolygon) {\n\t\t\tvar mpoly = geom;\n\t\t\tfor (var i = 0; i < mpoly.getNumGeometries(); i++) {\n\t\t\t\tvar poly = mpoly.getGeometryN(i);\n\t\t\t\tthis.updateLocationInfo(this.locateInPolygon(p, poly));\n\t\t\t}\n\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\tvar geomi = new GeometryCollectionIterator(geom);\n\t\t\twhile (geomi.hasNext()) {\n\t\t\t\tvar g2 = geomi.next();\n\t\t\t\tif (g2 !== geom) this.computeLocation(p, g2);\n\t\t\t}\n\t\t}\n\t}\n\tlocateOnPoint(p, pt) {\n\t\tvar ptCoord = pt.getCoordinate();\n\t\tif (ptCoord.equals2D(p)) return Location.INTERIOR;\n\t\treturn Location.EXTERIOR;\n\t}\n\tlocateOnLineString(p, l) {\n\t\tif (!l.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n\t\tvar seq = l.getCoordinateSequence();\n\t\tif (!l.isClosed()) {\n\t\t\tif (p.equals(seq.getCoordinate(0)) || p.equals(seq.getCoordinate(seq.size() - 1))) {\n\t\t\t\treturn Location.BOUNDARY;\n\t\t\t}\n\t\t}\n\t\tif (PointLocation.isOnLine(p, seq)) {\n\t\t\treturn Location.INTERIOR;\n\t\t}\n\t\treturn Location.EXTERIOR;\n\t}\n\tlocateInPolygon(p, poly) {\n\t\tif (poly.isEmpty()) return Location.EXTERIOR;\n\t\tvar shell = poly.getExteriorRing();\n\t\tvar shellLoc = this.locateInPolygonRing(p, shell);\n\t\tif (shellLoc === Location.EXTERIOR) return Location.EXTERIOR;\n\t\tif (shellLoc === Location.BOUNDARY) return Location.BOUNDARY;\n\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n\t\t\tvar hole = poly.getInteriorRingN(i);\n\t\t\tvar holeLoc = this.locateInPolygonRing(p, hole);\n\t\t\tif (holeLoc === Location.INTERIOR) return Location.EXTERIOR;\n\t\t\tif (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;\n\t\t}\n\t\treturn Location.INTERIOR;\n\t}\n\tlocate(p, geom) {\n\t\tif (geom.isEmpty()) return Location.EXTERIOR;\n\t\tif (geom instanceof LineString) {\n\t\t\treturn this.locateOnLineString(p, geom);\n\t\t} else if (geom instanceof Polygon) {\n\t\t\treturn this.locateInPolygon(p, geom);\n\t\t}\n\t\tthis._isIn = false;\n\t\tthis._numBoundaries = 0;\n\t\tthis.computeLocation(p, geom);\n\t\tif (this._boundaryRule.isInBoundary(this._numBoundaries)) return Location.BOUNDARY;\n\t\tif (this._numBoundaries > 0 || this._isIn) return Location.INTERIOR;\n\t\treturn Location.EXTERIOR;\n\t}\n\tgetClass() {\n\t\treturn PointLocator;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPointLocator.constructor_ = function () {\n\tthis._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n\tthis._isIn = null;\n\tthis._numBoundaries = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet boundaryRule = arguments[0];\n\t\tif (boundaryRule === null) throw new IllegalArgumentException(\"Rule must be non-null\");\n\t\tthis._boundaryRule = boundaryRule;\n\t}\n};\n","import Location from './Location';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Dimension from './Dimension';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport StringBuilder from '../../../../java/lang/StringBuilder';\nexport default class IntersectionMatrix {\n\tconstructor() {\n\t\tIntersectionMatrix.constructor_.apply(this, arguments);\n\t}\n\tstatic matches() {\n\t\tif (Number.isInteger(arguments[0]) && typeof arguments[1] === \"string\") {\n\t\t\tlet actualDimensionValue = arguments[0], requiredDimensionSymbol = arguments[1];\n\t\t\tif (requiredDimensionSymbol === Dimension.SYM_DONTCARE) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (requiredDimensionSymbol === Dimension.SYM_TRUE && (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (requiredDimensionSymbol === Dimension.SYM_FALSE && actualDimensionValue === Dimension.FALSE) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (requiredDimensionSymbol === Dimension.SYM_P && actualDimensionValue === Dimension.P) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (requiredDimensionSymbol === Dimension.SYM_L && actualDimensionValue === Dimension.L) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (requiredDimensionSymbol === Dimension.SYM_A && actualDimensionValue === Dimension.A) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (typeof arguments[0] === \"string\" && typeof arguments[1] === \"string\") {\n\t\t\tlet actualDimensionSymbols = arguments[0], requiredDimensionSymbols = arguments[1];\n\t\t\tvar m = new IntersectionMatrix(actualDimensionSymbols);\n\t\t\treturn m.matches(requiredDimensionSymbols);\n\t\t}\n\t}\n\tstatic isTrue(actualDimensionValue) {\n\t\tif (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tisIntersects() {\n\t\treturn !this.isDisjoint();\n\t}\n\tisCovers() {\n\t\tvar hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);\n\t\treturn hasPointInCommon && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n\t}\n\tisCoveredBy() {\n\t\tvar hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);\n\t\treturn hasPointInCommon && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n\t}\n\tset() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet dimensionSymbols = arguments[0];\n\t\t\tfor (var i = 0; i < dimensionSymbols.length; i++) {\n\t\t\t\tvar row = Math.trunc(i / 3);\n\t\t\t\tvar col = i % 3;\n\t\t\t\tthis._matrix[row][col] = Dimension.toDimensionValue(dimensionSymbols.charAt(i));\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet row = arguments[0], column = arguments[1], dimensionValue = arguments[2];\n\t\t\tthis._matrix[row][column] = dimensionValue;\n\t\t}\n\t}\n\tisContains() {\n\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n\t}\n\tsetAtLeast() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet minimumDimensionSymbols = arguments[0];\n\t\t\tfor (var i = 0; i < minimumDimensionSymbols.length; i++) {\n\t\t\t\tvar row = Math.trunc(i / 3);\n\t\t\t\tvar col = i % 3;\n\t\t\t\tthis.setAtLeast(row, col, Dimension.toDimensionValue(minimumDimensionSymbols.charAt(i)));\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet row = arguments[0], column = arguments[1], minimumDimensionValue = arguments[2];\n\t\t\tif (this._matrix[row][column] < minimumDimensionValue) {\n\t\t\t\tthis._matrix[row][column] = minimumDimensionValue;\n\t\t\t}\n\t\t}\n\t}\n\tsetAtLeastIfValid(row, column, minimumDimensionValue) {\n\t\tif (row >= 0 && column >= 0) {\n\t\t\tthis.setAtLeast(row, column, minimumDimensionValue);\n\t\t}\n\t}\n\tisWithin() {\n\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n\t}\n\tisTouches(dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA > dimensionOfGeometryB) {\n\t\t\treturn this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && (IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]));\n\t\t}\n\t\treturn false;\n\t}\n\tisOverlaps(dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A) {\n\t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === 1 && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n\t\t}\n\t\treturn false;\n\t}\n\tisEquals(dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA !== dimensionOfGeometryB) {\n\t\t\treturn false;\n\t\t}\n\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n\t}\n\ttoString() {\n\t\tvar builder = new StringBuilder(\"123456789\");\n\t\tfor (var ai = 0; ai < 3; ai++) {\n\t\t\tfor (var bi = 0; bi < 3; bi++) {\n\t\t\t\tbuilder.setCharAt(3 * ai + bi, Dimension.toDimensionSymbol(this._matrix[ai][bi]));\n\t\t\t}\n\t\t}\n\t\treturn builder.toString();\n\t}\n\tsetAll(dimensionValue) {\n\t\tfor (var ai = 0; ai < 3; ai++) {\n\t\t\tfor (var bi = 0; bi < 3; bi++) {\n\t\t\t\tthis._matrix[ai][bi] = dimensionValue;\n\t\t\t}\n\t\t}\n\t}\n\tget(row, column) {\n\t\treturn this._matrix[row][column];\n\t}\n\ttranspose() {\n\t\tvar temp = this._matrix[1][0];\n\t\tthis._matrix[1][0] = this._matrix[0][1];\n\t\tthis._matrix[0][1] = temp;\n\t\ttemp = this._matrix[2][0];\n\t\tthis._matrix[2][0] = this._matrix[0][2];\n\t\tthis._matrix[0][2] = temp;\n\t\ttemp = this._matrix[2][1];\n\t\tthis._matrix[2][1] = this._matrix[1][2];\n\t\tthis._matrix[1][2] = temp;\n\t\treturn this;\n\t}\n\tmatches(requiredDimensionSymbols) {\n\t\tif (requiredDimensionSymbols.length !== 9) {\n\t\t\tthrow new IllegalArgumentException(\"Should be length 9: \" + requiredDimensionSymbols);\n\t\t}\n\t\tfor (var ai = 0; ai < 3; ai++) {\n\t\t\tfor (var bi = 0; bi < 3; bi++) {\n\t\t\t\tif (!IntersectionMatrix.matches(this._matrix[ai][bi], requiredDimensionSymbols.charAt(3 * ai + bi))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tadd(im) {\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\tfor (var j = 0; j < 3; j++) {\n\t\t\t\tthis.setAtLeast(i, j, im.get(i, j));\n\t\t\t}\n\t\t}\n\t}\n\tisDisjoint() {\n\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.INTERIOR][Location.BOUNDARY] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.BOUNDARY] === Dimension.FALSE;\n\t}\n\tisCrosses(dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A) {\n\t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === 0;\n\t\t}\n\t\treturn false;\n\t}\n\tgetClass() {\n\t\treturn IntersectionMatrix;\n\t}\n\tget interfaces_() {\n\t\treturn [Cloneable];\n\t}\n}\nIntersectionMatrix.constructor_ = function () {\n\tthis._matrix = null;\n\tif (arguments.length === 0) {\n\t\tthis._matrix = Array(3).fill().map(() => Array(3));\n\t\tthis.setAll(Dimension.FALSE);\n\t} else if (arguments.length === 1) {\n\t\tif (typeof arguments[0] === \"string\") {\n\t\t\tlet elements = arguments[0];\n\t\t\tIntersectionMatrix.constructor_.call(this);\n\t\t\tthis.set(elements);\n\t\t} else if (arguments[0] instanceof IntersectionMatrix) {\n\t\t\tlet other = arguments[0];\n\t\t\tIntersectionMatrix.constructor_.call(this);\n\t\t\tthis._matrix[Location.INTERIOR][Location.INTERIOR] = other._matrix[Location.INTERIOR][Location.INTERIOR];\n\t\t\tthis._matrix[Location.INTERIOR][Location.BOUNDARY] = other._matrix[Location.INTERIOR][Location.BOUNDARY];\n\t\t\tthis._matrix[Location.INTERIOR][Location.EXTERIOR] = other._matrix[Location.INTERIOR][Location.EXTERIOR];\n\t\t\tthis._matrix[Location.BOUNDARY][Location.INTERIOR] = other._matrix[Location.BOUNDARY][Location.INTERIOR];\n\t\t\tthis._matrix[Location.BOUNDARY][Location.BOUNDARY] = other._matrix[Location.BOUNDARY][Location.BOUNDARY];\n\t\t\tthis._matrix[Location.BOUNDARY][Location.EXTERIOR] = other._matrix[Location.BOUNDARY][Location.EXTERIOR];\n\t\t\tthis._matrix[Location.EXTERIOR][Location.INTERIOR] = other._matrix[Location.EXTERIOR][Location.INTERIOR];\n\t\t\tthis._matrix[Location.EXTERIOR][Location.BOUNDARY] = other._matrix[Location.EXTERIOR][Location.BOUNDARY];\n\t\t\tthis._matrix[Location.EXTERIOR][Location.EXTERIOR] = other._matrix[Location.EXTERIOR][Location.EXTERIOR];\n\t\t}\n\t}\n};\n","import Coordinate from '../geom/Coordinate';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nexport default class Quadrant {\n\tconstructor() {\n\t\tQuadrant.constructor_.apply(this, arguments);\n\t}\n\tstatic isNorthern(quad) {\n\t\treturn quad === Quadrant.NE || quad === Quadrant.NW;\n\t}\n\tstatic isOpposite(quad1, quad2) {\n\t\tif (quad1 === quad2) return false;\n\t\tvar diff = (quad1 - quad2 + 4) % 4;\n\t\tif (diff === 2) return true;\n\t\treturn false;\n\t}\n\tstatic commonHalfPlane(quad1, quad2) {\n\t\tif (quad1 === quad2) return quad1;\n\t\tvar diff = (quad1 - quad2 + 4) % 4;\n\t\tif (diff === 2) return -1;\n\t\tvar min = quad1 < quad2 ? quad1 : quad2;\n\t\tvar max = quad1 > quad2 ? quad1 : quad2;\n\t\tif (min === 0 && max === 3) return 3;\n\t\treturn min;\n\t}\n\tstatic isInHalfPlane(quad, halfPlane) {\n\t\tif (halfPlane === Quadrant.SE) {\n\t\t\treturn quad === Quadrant.SE || quad === Quadrant.SW;\n\t\t}\n\t\treturn quad === halfPlane || quad === halfPlane + 1;\n\t}\n\tstatic quadrant() {\n\t\tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\t\tlet dx = arguments[0], dy = arguments[1];\n\t\t\tif (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the quadrant for point ( \" + dx + \", \" + dy + \" )\");\n\t\t\tif (dx >= 0.0) {\n\t\t\t\tif (dy >= 0.0) return Quadrant.NE; else return Quadrant.SE;\n\t\t\t} else {\n\t\t\t\tif (dy >= 0.0) return Quadrant.NW; else return Quadrant.SW;\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\t\tif (p1.x === p0.x && p1.y === p0.y) throw new IllegalArgumentException(\"Cannot compute the quadrant for two identical points \" + p0);\n\t\t\tif (p1.x >= p0.x) {\n\t\t\t\tif (p1.y >= p0.y) return Quadrant.NE; else return Quadrant.SE;\n\t\t\t} else {\n\t\t\t\tif (p1.y >= p0.y) return Quadrant.NW; else return Quadrant.SW;\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn Quadrant;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nQuadrant.constructor_ = function () {};\nQuadrant.NE = 0;\nQuadrant.NW = 1;\nQuadrant.SW = 2;\nQuadrant.SE = 3;\n","import Orientation from '../algorithm/Orientation';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Quadrant from './Quadrant';\nimport Assert from '../util/Assert';\nexport default class EdgeEnd {\n\tconstructor() {\n\t\tEdgeEnd.constructor_.apply(this, arguments);\n\t}\n\tcompareDirection(e) {\n\t\tif (this._dx === e._dx && this._dy === e._dy) return 0;\n\t\tif (this._quadrant > e._quadrant) return 1;\n\t\tif (this._quadrant < e._quadrant) return -1;\n\t\treturn Orientation.index(e._p0, e._p1, this._p1);\n\t}\n\tgetDy() {\n\t\treturn this._dy;\n\t}\n\tgetCoordinate() {\n\t\treturn this._p0;\n\t}\n\tsetNode(node) {\n\t\tthis._node = node;\n\t}\n\tprint(out) {\n\t\tvar angle = Math.atan2(this._dy, this._dx);\n\t\tvar className = this.getClass().getName();\n\t\tvar lastDotPos = className.lastIndexOf('.');\n\t\tvar name = className.substring(lastDotPos + 1);\n\t\tout.print(\"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + angle + \"   \" + this._label);\n\t}\n\tcompareTo(obj) {\n\t\tvar e = obj;\n\t\treturn this.compareDirection(e);\n\t}\n\tgetDirectedCoordinate() {\n\t\treturn this._p1;\n\t}\n\tgetDx() {\n\t\treturn this._dx;\n\t}\n\tgetLabel() {\n\t\treturn this._label;\n\t}\n\tgetEdge() {\n\t\treturn this._edge;\n\t}\n\tgetQuadrant() {\n\t\treturn this._quadrant;\n\t}\n\tgetNode() {\n\t\treturn this._node;\n\t}\n\ttoString() {\n\t\tvar angle = Math.atan2(this._dy, this._dx);\n\t\tvar className = this.getClass().getName();\n\t\tvar lastDotPos = className.lastIndexOf('.');\n\t\tvar name = className.substring(lastDotPos + 1);\n\t\treturn \"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + angle + \"   \" + this._label;\n\t}\n\tcomputeLabel(boundaryNodeRule) {}\n\tinit(p0, p1) {\n\t\tthis._p0 = p0;\n\t\tthis._p1 = p1;\n\t\tthis._dx = p1.x - p0.x;\n\t\tthis._dy = p1.y - p0.y;\n\t\tthis._quadrant = Quadrant.quadrant(this._dx, this._dy);\n\t\tAssert.isTrue(!(this._dx === 0 && this._dy === 0), \"EdgeEnd with identical endpoints found\");\n\t}\n\tgetClass() {\n\t\treturn EdgeEnd;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparable];\n\t}\n}\nEdgeEnd.constructor_ = function () {\n\tthis._edge = null;\n\tthis._label = null;\n\tthis._node = null;\n\tthis._p0 = null;\n\tthis._p1 = null;\n\tthis._dx = null;\n\tthis._dy = null;\n\tthis._quadrant = null;\n\tif (arguments.length === 1) {\n\t\tlet edge = arguments[0];\n\t\tthis._edge = edge;\n\t} else if (arguments.length === 3) {\n\t\tlet edge = arguments[0], p0 = arguments[1], p1 = arguments[2];\n\t\tEdgeEnd.constructor_.call(this, edge, p0, p1, null);\n\t} else if (arguments.length === 4) {\n\t\tlet edge = arguments[0], p0 = arguments[1], p1 = arguments[2], label = arguments[3];\n\t\tEdgeEnd.constructor_.call(this, edge);\n\t\tthis.init(p0, p1);\n\t\tthis._label = label;\n\t}\n};\n","export default class Position {\n\tconstructor() {\n\t\tPosition.constructor_.apply(this, arguments);\n\t}\n\tstatic opposite(position) {\n\t\tif (position === Position.LEFT) return Position.RIGHT;\n\t\tif (position === Position.RIGHT) return Position.LEFT;\n\t\treturn position;\n\t}\n\tgetClass() {\n\t\treturn Position;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPosition.constructor_ = function () {};\nPosition.ON = 0;\nPosition.LEFT = 1;\nPosition.RIGHT = 2;\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Location from '../geom/Location';\nimport Position from './Position';\nexport default class TopologyLocation {\n\tconstructor() {\n\t\tTopologyLocation.constructor_.apply(this, arguments);\n\t}\n\tsetAllLocations(locValue) {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tthis.location[i] = locValue;\n\t\t}\n\t}\n\tisNull() {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] !== Location.NONE) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tsetAllLocationsIfNull(locValue) {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] === Location.NONE) this.location[i] = locValue;\n\t\t}\n\t}\n\tisLine() {\n\t\treturn this.location.length === 1;\n\t}\n\tmerge(gl) {\n\t\tif (gl.location.length > this.location.length) {\n\t\t\tvar newLoc = new Array(3).fill(null);\n\t\t\tnewLoc[Position.ON] = this.location[Position.ON];\n\t\t\tnewLoc[Position.LEFT] = Location.NONE;\n\t\t\tnewLoc[Position.RIGHT] = Location.NONE;\n\t\t\tthis.location = newLoc;\n\t\t}\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] === Location.NONE && i < gl.location.length) this.location[i] = gl.location[i];\n\t\t}\n\t}\n\tgetLocations() {\n\t\treturn this.location;\n\t}\n\tflip() {\n\t\tif (this.location.length <= 1) return null;\n\t\tvar temp = this.location[Position.LEFT];\n\t\tthis.location[Position.LEFT] = this.location[Position.RIGHT];\n\t\tthis.location[Position.RIGHT] = temp;\n\t}\n\ttoString() {\n\t\tvar buf = new StringBuffer();\n\t\tif (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.LEFT]));\n\t\tbuf.append(Location.toLocationSymbol(this.location[Position.ON]));\n\t\tif (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]));\n\t\treturn buf.toString();\n\t}\n\tsetLocations(on, left, right) {\n\t\tthis.location[Position.ON] = on;\n\t\tthis.location[Position.LEFT] = left;\n\t\tthis.location[Position.RIGHT] = right;\n\t}\n\tget(posIndex) {\n\t\tif (posIndex < this.location.length) return this.location[posIndex];\n\t\treturn Location.NONE;\n\t}\n\tisArea() {\n\t\treturn this.location.length > 1;\n\t}\n\tisAnyNull() {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] === Location.NONE) return true;\n\t\t}\n\t\treturn false;\n\t}\n\tsetLocation() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet locValue = arguments[0];\n\t\t\tthis.setLocation(Position.ON, locValue);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet locIndex = arguments[0], locValue = arguments[1];\n\t\t\tthis.location[locIndex] = locValue;\n\t\t}\n\t}\n\tinit(size) {\n\t\tthis.location = new Array(size).fill(null);\n\t\tthis.setAllLocations(Location.NONE);\n\t}\n\tisEqualOnSide(le, locIndex) {\n\t\treturn this.location[locIndex] === le.location[locIndex];\n\t}\n\tallPositionsEqual(loc) {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] !== loc) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tgetClass() {\n\t\treturn TopologyLocation;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nTopologyLocation.constructor_ = function () {\n\tthis.location = null;\n\tif (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tlet location = arguments[0];\n\t\t\tthis.init(location.length);\n\t\t} else if (Number.isInteger(arguments[0])) {\n\t\t\tlet on = arguments[0];\n\t\t\tthis.init(1);\n\t\t\tthis.location[Position.ON] = on;\n\t\t} else if (arguments[0] instanceof TopologyLocation) {\n\t\t\tlet gl = arguments[0];\n\t\t\tthis.init(gl.location.length);\n\t\t\tif (gl !== null) {\n\t\t\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\t\t\tthis.location[i] = gl.location[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (arguments.length === 3) {\n\t\tlet on = arguments[0], left = arguments[1], right = arguments[2];\n\t\tthis.init(3);\n\t\tthis.location[Position.ON] = on;\n\t\tthis.location[Position.LEFT] = left;\n\t\tthis.location[Position.RIGHT] = right;\n\t}\n};\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Location from '../geom/Location';\nimport Position from './Position';\nimport TopologyLocation from './TopologyLocation';\nexport default class Label {\n\tconstructor() {\n\t\tLabel.constructor_.apply(this, arguments);\n\t}\n\tstatic toLineLabel(label) {\n\t\tvar lineLabel = new Label(Location.NONE);\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tlineLabel.setLocation(i, label.getLocation(i));\n\t\t}\n\t\treturn lineLabel;\n\t}\n\tgetGeometryCount() {\n\t\tvar count = 0;\n\t\tif (!this.elt[0].isNull()) count++;\n\t\tif (!this.elt[1].isNull()) count++;\n\t\treturn count;\n\t}\n\tsetAllLocations(geomIndex, location) {\n\t\tthis.elt[geomIndex].setAllLocations(location);\n\t}\n\tisNull(geomIndex) {\n\t\treturn this.elt[geomIndex].isNull();\n\t}\n\tsetAllLocationsIfNull() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet location = arguments[0];\n\t\t\tthis.setAllLocationsIfNull(0, location);\n\t\t\tthis.setAllLocationsIfNull(1, location);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], location = arguments[1];\n\t\t\tthis.elt[geomIndex].setAllLocationsIfNull(location);\n\t\t}\n\t}\n\tisLine(geomIndex) {\n\t\treturn this.elt[geomIndex].isLine();\n\t}\n\tmerge(lbl) {\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (this.elt[i] === null && lbl.elt[i] !== null) {\n\t\t\t\tthis.elt[i] = new TopologyLocation(lbl.elt[i]);\n\t\t\t} else {\n\t\t\t\tthis.elt[i].merge(lbl.elt[i]);\n\t\t\t}\n\t\t}\n\t}\n\tflip() {\n\t\tthis.elt[0].flip();\n\t\tthis.elt[1].flip();\n\t}\n\tgetLocation() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet geomIndex = arguments[0];\n\t\t\treturn this.elt[geomIndex].get(Position.ON);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1];\n\t\t\treturn this.elt[geomIndex].get(posIndex);\n\t\t}\n\t}\n\ttoString() {\n\t\tvar buf = new StringBuffer();\n\t\tif (this.elt[0] !== null) {\n\t\t\tbuf.append(\"A:\");\n\t\t\tbuf.append(this.elt[0].toString());\n\t\t}\n\t\tif (this.elt[1] !== null) {\n\t\t\tbuf.append(\" B:\");\n\t\t\tbuf.append(this.elt[1].toString());\n\t\t}\n\t\treturn buf.toString();\n\t}\n\tisArea() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.elt[0].isArea() || this.elt[1].isArea();\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet geomIndex = arguments[0];\n\t\t\treturn this.elt[geomIndex].isArea();\n\t\t}\n\t}\n\tisAnyNull(geomIndex) {\n\t\treturn this.elt[geomIndex].isAnyNull();\n\t}\n\tsetLocation() {\n\t\tif (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], location = arguments[1];\n\t\t\tthis.elt[geomIndex].setLocation(Position.ON, location);\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2];\n\t\t\tthis.elt[geomIndex].setLocation(posIndex, location);\n\t\t}\n\t}\n\tisEqualOnSide(lbl, side) {\n\t\treturn this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);\n\t}\n\tallPositionsEqual(geomIndex, loc) {\n\t\treturn this.elt[geomIndex].allPositionsEqual(loc);\n\t}\n\ttoLine(geomIndex) {\n\t\tif (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]);\n\t}\n\tgetClass() {\n\t\treturn Label;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nLabel.constructor_ = function () {\n\tthis.elt = new Array(2).fill(null);\n\tif (arguments.length === 1) {\n\t\tif (Number.isInteger(arguments[0])) {\n\t\t\tlet onLoc = arguments[0];\n\t\t\tthis.elt[0] = new TopologyLocation(onLoc);\n\t\t\tthis.elt[1] = new TopologyLocation(onLoc);\n\t\t} else if (arguments[0] instanceof Label) {\n\t\t\tlet lbl = arguments[0];\n\t\t\tthis.elt[0] = new TopologyLocation(lbl.elt[0]);\n\t\t\tthis.elt[1] = new TopologyLocation(lbl.elt[1]);\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet geomIndex = arguments[0], onLoc = arguments[1];\n\t\tthis.elt[0] = new TopologyLocation(Location.NONE);\n\t\tthis.elt[1] = new TopologyLocation(Location.NONE);\n\t\tthis.elt[geomIndex].setLocation(onLoc);\n\t} else if (arguments.length === 3) {\n\t\tlet onLoc = arguments[0], leftLoc = arguments[1], rightLoc = arguments[2];\n\t\tthis.elt[0] = new TopologyLocation(onLoc, leftLoc, rightLoc);\n\t\tthis.elt[1] = new TopologyLocation(onLoc, leftLoc, rightLoc);\n\t} else if (arguments.length === 4) {\n\t\tlet geomIndex = arguments[0], onLoc = arguments[1], leftLoc = arguments[2], rightLoc = arguments[3];\n\t\tthis.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n\t\tthis.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n\t\tthis.elt[geomIndex].setLocations(onLoc, leftLoc, rightLoc);\n\t}\n};\n","import EdgeEnd from '../../geomgraph/EdgeEnd';\nimport Label from '../../geomgraph/Label';\nimport ArrayList from '../../../../../java/util/ArrayList';\nexport default class EdgeEndBuilder {\n\tconstructor() {\n\t\tEdgeEndBuilder.constructor_.apply(this, arguments);\n\t}\n\tcreateEdgeEndForNext(edge, l, eiCurr, eiNext) {\n\t\tvar iNext = eiCurr.segmentIndex + 1;\n\t\tif (iNext >= edge.getNumPoints() && eiNext === null) return null;\n\t\tvar pNext = edge.getCoordinate(iNext);\n\t\tif (eiNext !== null && eiNext.segmentIndex === eiCurr.segmentIndex) pNext = eiNext.coord;\n\t\tvar e = new EdgeEnd(edge, eiCurr.coord, pNext, new Label(edge.getLabel()));\n\t\tl.add(e);\n\t}\n\tcreateEdgeEndForPrev(edge, l, eiCurr, eiPrev) {\n\t\tvar iPrev = eiCurr.segmentIndex;\n\t\tif (eiCurr.dist === 0.0) {\n\t\t\tif (iPrev === 0) return null;\n\t\t\tiPrev--;\n\t\t}\n\t\tvar pPrev = edge.getCoordinate(iPrev);\n\t\tif (eiPrev !== null && eiPrev.segmentIndex >= iPrev) pPrev = eiPrev.coord;\n\t\tvar label = new Label(edge.getLabel());\n\t\tlabel.flip();\n\t\tvar e = new EdgeEnd(edge, eiCurr.coord, pPrev, label);\n\t\tl.add(e);\n\t}\n\tcomputeEdgeEnds() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet edges = arguments[0];\n\t\t\tvar l = new ArrayList();\n\t\t\tfor (var i = edges; i.hasNext(); ) {\n\t\t\t\tvar e = i.next();\n\t\t\t\tthis.computeEdgeEnds(e, l);\n\t\t\t}\n\t\t\treturn l;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet edge = arguments[0], l = arguments[1];\n\t\t\tvar eiList = edge.getEdgeIntersectionList();\n\t\t\teiList.addEndpoints();\n\t\t\tvar it = eiList.iterator();\n\t\t\tvar eiPrev = null;\n\t\t\tvar eiCurr = null;\n\t\t\tif (!it.hasNext()) return null;\n\t\t\tvar eiNext = it.next();\n\t\t\tdo {\n\t\t\t\teiPrev = eiCurr;\n\t\t\t\teiCurr = eiNext;\n\t\t\t\teiNext = null;\n\t\t\t\tif (it.hasNext()) eiNext = it.next();\n\t\t\t\tif (eiCurr !== null) {\n\t\t\t\t\tthis.createEdgeEndForPrev(edge, l, eiCurr, eiPrev);\n\t\t\t\t\tthis.createEdgeEndForNext(edge, l, eiCurr, eiNext);\n\t\t\t\t}\n\t\t\t} while (eiCurr !== null);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn EdgeEndBuilder;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdgeEndBuilder.constructor_ = function () {};\n","import Assert from '../util/Assert';\nexport default class GraphComponent {\n\tconstructor() {\n\t\tGraphComponent.constructor_.apply(this, arguments);\n\t}\n\tsetVisited(isVisited) {\n\t\tthis._isVisited = isVisited;\n\t}\n\tsetInResult(isInResult) {\n\t\tthis._isInResult = isInResult;\n\t}\n\tisCovered() {\n\t\treturn this._isCovered;\n\t}\n\tisCoveredSet() {\n\t\treturn this._isCoveredSet;\n\t}\n\tsetLabel(label) {\n\t\tthis._label = label;\n\t}\n\tgetLabel() {\n\t\treturn this._label;\n\t}\n\tsetCovered(isCovered) {\n\t\tthis._isCovered = isCovered;\n\t\tthis._isCoveredSet = true;\n\t}\n\tupdateIM(im) {\n\t\tAssert.isTrue(this._label.getGeometryCount() >= 2, \"found partial label\");\n\t\tthis.computeIM(im);\n\t}\n\tisInResult() {\n\t\treturn this._isInResult;\n\t}\n\tisVisited() {\n\t\treturn this._isVisited;\n\t}\n\tgetClass() {\n\t\treturn GraphComponent;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGraphComponent.constructor_ = function () {\n\tthis._label = null;\n\tthis._isInResult = false;\n\tthis._isCovered = false;\n\tthis._isCoveredSet = false;\n\tthis._isVisited = false;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet label = arguments[0];\n\t\tthis._label = label;\n\t}\n};\n","import Location from '../geom/Location';\nimport Label from './Label';\nimport GraphComponent from './GraphComponent';\nexport default class Node extends GraphComponent {\n\tconstructor() {\n\t\tsuper();\n\t\tNode.constructor_.apply(this, arguments);\n\t}\n\tisIncidentEdgeInResult() {\n\t\tfor (var it = this.getEdges().getEdges().iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.getEdge().isInResult()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\tisIsolated() {\n\t\treturn this._label.getGeometryCount() === 1;\n\t}\n\tgetCoordinate() {\n\t\treturn this._coord;\n\t}\n\tprint(out) {\n\t\tout.println(\"node \" + this._coord + \" lbl: \" + this._label);\n\t}\n\tcomputeIM(im) {}\n\tcomputeMergedLocation(label2, eltIndex) {\n\t\tvar loc = Location.NONE;\n\t\tloc = this._label.getLocation(eltIndex);\n\t\tif (!label2.isNull(eltIndex)) {\n\t\t\tvar nLoc = label2.getLocation(eltIndex);\n\t\t\tif (loc !== Location.BOUNDARY) loc = nLoc;\n\t\t}\n\t\treturn loc;\n\t}\n\tsetLabel() {\n\t\tif (arguments.length === 2 && (Number.isInteger(arguments[1]) && Number.isInteger(arguments[0]))) {\n\t\t\tlet argIndex = arguments[0], onLocation = arguments[1];\n\t\t\tif (this._label === null) {\n\t\t\t\tthis._label = new Label(argIndex, onLocation);\n\t\t\t} else this._label.setLocation(argIndex, onLocation);\n\t\t} else return super.setLabel.apply(this, arguments);\n\t}\n\tgetEdges() {\n\t\treturn this._edges;\n\t}\n\tmergeLabel() {\n\t\tif (arguments[0] instanceof Node) {\n\t\t\tlet n = arguments[0];\n\t\t\tthis.mergeLabel(n._label);\n\t\t} else if (arguments[0] instanceof Label) {\n\t\t\tlet label2 = arguments[0];\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tvar loc = this.computeMergedLocation(label2, i);\n\t\t\t\tvar thisLoc = this._label.getLocation(i);\n\t\t\t\tif (thisLoc === Location.NONE) this._label.setLocation(i, loc);\n\t\t\t}\n\t\t}\n\t}\n\tadd(e) {\n\t\tthis._edges.insert(e);\n\t\te.setNode(this);\n\t}\n\tsetLabelBoundary(argIndex) {\n\t\tif (this._label === null) return null;\n\t\tvar loc = Location.NONE;\n\t\tif (this._label !== null) loc = this._label.getLocation(argIndex);\n\t\tvar newLoc = null;\n\t\tswitch (loc) {\n\t\t\tcase Location.BOUNDARY:\n\t\t\t\tnewLoc = Location.INTERIOR;\n\t\t\t\tbreak;\n\t\t\tcase Location.INTERIOR:\n\t\t\t\tnewLoc = Location.BOUNDARY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnewLoc = Location.BOUNDARY;\n\t\t\t\tbreak;\n\t\t}\n\t\tthis._label.setLocation(argIndex, newLoc);\n\t}\n\tgetClass() {\n\t\treturn Node;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nNode.constructor_ = function () {\n\tthis._coord = null;\n\tthis._edges = null;\n\tlet coord = arguments[0], edges = arguments[1];\n\tthis._coord = coord;\n\tthis._edges = edges;\n\tthis._label = new Label(0, Location.NONE);\n};\n","import Location from '../geom/Location';\nimport Coordinate from '../geom/Coordinate';\nimport Node from './Node';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default class NodeMap {\n\tconstructor() {\n\t\tNodeMap.constructor_.apply(this, arguments);\n\t}\n\tfind(coord) {\n\t\treturn this.nodeMap.get(coord);\n\t}\n\taddNode() {\n\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\tlet coord = arguments[0];\n\t\t\tvar node = this.nodeMap.get(coord);\n\t\t\tif (node === null) {\n\t\t\t\tnode = this.nodeFact.createNode(coord);\n\t\t\t\tthis.nodeMap.put(coord, node);\n\t\t\t}\n\t\t\treturn node;\n\t\t} else if (arguments[0] instanceof Node) {\n\t\t\tlet n = arguments[0];\n\t\t\tvar node = this.nodeMap.get(n.getCoordinate());\n\t\t\tif (node === null) {\n\t\t\t\tthis.nodeMap.put(n.getCoordinate(), n);\n\t\t\t\treturn n;\n\t\t\t}\n\t\t\tnode.mergeLabel(n);\n\t\t\treturn node;\n\t\t}\n\t}\n\tprint(out) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar n = it.next();\n\t\t\tn.print(out);\n\t\t}\n\t}\n\titerator() {\n\t\treturn this.nodeMap.values().iterator();\n\t}\n\tvalues() {\n\t\treturn this.nodeMap.values();\n\t}\n\tgetBoundaryNodes(geomIndex) {\n\t\tvar bdyNodes = new ArrayList();\n\t\tfor (var i = this.iterator(); i.hasNext(); ) {\n\t\t\tvar node = i.next();\n\t\t\tif (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) bdyNodes.add(node);\n\t\t}\n\t\treturn bdyNodes;\n\t}\n\tadd(e) {\n\t\tvar p = e.getCoordinate();\n\t\tvar n = this.addNode(p);\n\t\tn.add(e);\n\t}\n\tgetClass() {\n\t\treturn NodeMap;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nNodeMap.constructor_ = function () {\n\tthis.nodeMap = new TreeMap();\n\tthis.nodeFact = null;\n\tlet nodeFact = arguments[0];\n\tthis.nodeFact = nodeFact;\n};\n","import Coordinate from './Coordinate';\nimport RuntimeException from '../../../../java/lang/RuntimeException';\nexport default class TopologyException extends RuntimeException {\n\tconstructor() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet msg = arguments[0];\n\t\t\tsuper(msg)\n\t\t\tRuntimeException.call(this, msg);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet msg = arguments[0], pt = arguments[1];\n\t\t\tsuper(TopologyException.msgWithCoord(msg, pt))\n\t\t\tthis.name = 'TopologyException';\n\t\t\tthis.pt = new Coordinate(pt);\n\t\t}\n\t}\n\tgetCoordinate() {\n\t\treturn this.pt;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n\tgetClass() {\n\t\treturn TopologyException;\n\t}\n\tstatic msgWithCoord (msg, pt) {\n\t\tif (pt !== null) return msg + \" [ \" + pt + \" ]\";\n\t\treturn msg;\n\t}\n}","export default class PointOnGeometryLocator {\n\tconstructor() {\n\t\tPointOnGeometryLocator.constructor_.apply(this, arguments);\n\t}\n\tlocate(p) {}\n\tgetClass() {\n\t\treturn PointOnGeometryLocator;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPointOnGeometryLocator.constructor_ = function () {};\n","import Location from '../../geom/Location';\nimport Polygon from '../../geom/Polygon';\nimport PointLocation from '../PointLocation';\nimport PointOnGeometryLocator from './PointOnGeometryLocator';\nimport GeometryCollectionIterator from '../../geom/GeometryCollectionIterator';\nimport GeometryCollection from '../../geom/GeometryCollection';\nexport default class SimplePointInAreaLocator {\n\tconstructor() {\n\t\tSimplePointInAreaLocator.constructor_.apply(this, arguments);\n\t}\n\tstatic locatePointInPolygon(p, poly) {\n\t\tif (poly.isEmpty()) return Location.EXTERIOR;\n\t\tvar shell = poly.getExteriorRing();\n\t\tvar shellLoc = SimplePointInAreaLocator.locatePointInRing(p, shell);\n\t\tif (shellLoc !== Location.INTERIOR) return shellLoc;\n\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n\t\t\tvar hole = poly.getInteriorRingN(i);\n\t\t\tvar holeLoc = SimplePointInAreaLocator.locatePointInRing(p, hole);\n\t\t\tif (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;\n\t\t\tif (holeLoc === Location.INTERIOR) return Location.EXTERIOR;\n\t\t}\n\t\treturn Location.INTERIOR;\n\t}\n\tstatic locatePointInRing(p, ring) {\n\t\tif (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n\t\treturn PointLocation.locateInRing(p, ring.getCoordinates());\n\t}\n\tstatic containsPointInPolygon(p, poly) {\n\t\treturn Location.EXTERIOR !== SimplePointInAreaLocator.locatePointInPolygon(p, poly);\n\t}\n\tstatic locateInGeometry(p, geom) {\n\t\tif (geom instanceof Polygon) {\n\t\t\treturn SimplePointInAreaLocator.locatePointInPolygon(p, geom);\n\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\tvar geomi = new GeometryCollectionIterator(geom);\n\t\t\twhile (geomi.hasNext()) {\n\t\t\t\tvar g2 = geomi.next();\n\t\t\t\tif (g2 !== geom) {\n\t\t\t\t\tvar loc = SimplePointInAreaLocator.locateInGeometry(p, g2);\n\t\t\t\t\tif (loc !== Location.EXTERIOR) return loc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Location.EXTERIOR;\n\t}\n\tstatic locate(p, geom) {\n\t\tif (geom.isEmpty()) return Location.EXTERIOR;\n\t\treturn SimplePointInAreaLocator.locateInGeometry(p, geom);\n\t}\n\tlocate(p) {\n\t\treturn SimplePointInAreaLocator.locate(p, this._geom);\n\t}\n\tgetClass() {\n\t\treturn SimplePointInAreaLocator;\n\t}\n\tget interfaces_() {\n\t\treturn [PointOnGeometryLocator];\n\t}\n}\nSimplePointInAreaLocator.constructor_ = function () {\n\tthis._geom = null;\n\tlet geom = arguments[0];\n\tthis._geom = geom;\n};\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Location from '../geom/Location';\nimport Position from './Position';\nimport TopologyException from '../geom/TopologyException';\nimport System from '../../../../java/lang/System';\nimport SimplePointInAreaLocator from '../algorithm/locate/SimplePointInAreaLocator';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Assert from '../util/Assert';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default class EdgeEndStar {\n\tconstructor() {\n\t\tEdgeEndStar.constructor_.apply(this, arguments);\n\t}\n\tgetNextCW(ee) {\n\t\tthis.getEdges();\n\t\tvar i = this._edgeList.indexOf(ee);\n\t\tvar iNextCW = i - 1;\n\t\tif (i === 0) iNextCW = this._edgeList.size() - 1;\n\t\treturn this._edgeList.get(iNextCW);\n\t}\n\tpropagateSideLabels(geomIndex) {\n\t\tvar startLoc = Location.NONE;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tif (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) startLoc = label.getLocation(geomIndex, Position.LEFT);\n\t\t}\n\t\tif (startLoc === Location.NONE) return null;\n\t\tvar currLoc = startLoc;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tif (label.getLocation(geomIndex, Position.ON) === Location.NONE) label.setLocation(geomIndex, Position.ON, currLoc);\n\t\t\tif (label.isArea(geomIndex)) {\n\t\t\t\tvar leftLoc = label.getLocation(geomIndex, Position.LEFT);\n\t\t\t\tvar rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n\t\t\t\tif (rightLoc !== Location.NONE) {\n\t\t\t\t\tif (rightLoc !== currLoc) throw new TopologyException(\"side location conflict\", e.getCoordinate());\n\t\t\t\t\tif (leftLoc === Location.NONE) {\n\t\t\t\t\t\tAssert.shouldNeverReachHere(\"found single null side (at \" + e.getCoordinate() + \")\");\n\t\t\t\t\t}\n\t\t\t\t\tcurrLoc = leftLoc;\n\t\t\t\t} else {\n\t\t\t\t\tAssert.isTrue(label.getLocation(geomIndex, Position.LEFT) === Location.NONE, \"found single null side\");\n\t\t\t\t\tlabel.setLocation(geomIndex, Position.RIGHT, currLoc);\n\t\t\t\t\tlabel.setLocation(geomIndex, Position.LEFT, currLoc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgetCoordinate() {\n\t\tvar it = this.iterator();\n\t\tif (!it.hasNext()) return null;\n\t\tvar e = it.next();\n\t\treturn e.getCoordinate();\n\t}\n\tprint(out) {\n\t\tSystem.out.println(\"EdgeEndStar:   \" + this.getCoordinate());\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\te.print(out);\n\t\t}\n\t}\n\tisAreaLabelsConsistent(geomGraph) {\n\t\tthis.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());\n\t\treturn this.checkAreaLabelsConsistent(0);\n\t}\n\tcheckAreaLabelsConsistent(geomIndex) {\n\t\tvar edges = this.getEdges();\n\t\tif (edges.size() <= 0) return true;\n\t\tvar lastEdgeIndex = edges.size() - 1;\n\t\tvar startLabel = edges.get(lastEdgeIndex).getLabel();\n\t\tvar startLoc = startLabel.getLocation(geomIndex, Position.LEFT);\n\t\tAssert.isTrue(startLoc !== Location.NONE, \"Found unlabelled area edge\");\n\t\tvar currLoc = startLoc;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tAssert.isTrue(label.isArea(geomIndex), \"Found non-area edge\");\n\t\t\tvar leftLoc = label.getLocation(geomIndex, Position.LEFT);\n\t\t\tvar rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n\t\t\tif (leftLoc === rightLoc) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rightLoc !== currLoc) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcurrLoc = leftLoc;\n\t\t}\n\t\treturn true;\n\t}\n\tfindIndex(eSearch) {\n\t\tthis.iterator();\n\t\tfor (var i = 0; i < this._edgeList.size(); i++) {\n\t\t\tvar e = this._edgeList.get(i);\n\t\t\tif (e === eSearch) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\titerator() {\n\t\treturn this.getEdges().iterator();\n\t}\n\tgetEdges() {\n\t\tif (this._edgeList === null) {\n\t\t\tthis._edgeList = new ArrayList(this._edgeMap.values());\n\t\t}\n\t\treturn this._edgeList;\n\t}\n\tgetLocation(geomIndex, p, geom) {\n\t\tif (this._ptInAreaLocation[geomIndex] === Location.NONE) {\n\t\t\tthis._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());\n\t\t}\n\t\treturn this._ptInAreaLocation[geomIndex];\n\t}\n\ttoString() {\n\t\tvar buf = new StringBuffer();\n\t\tbuf.append(\"EdgeEndStar:   \" + this.getCoordinate());\n\t\tbuf.append(\"\\n\");\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tbuf.append(e);\n\t\t\tbuf.append(\"\\n\");\n\t\t}\n\t\treturn buf.toString();\n\t}\n\tcomputeEdgeEndLabels(boundaryNodeRule) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ee = it.next();\n\t\t\tee.computeLabel(boundaryNodeRule);\n\t\t}\n\t}\n\tcomputeLabelling(geomGraph) {\n\t\tthis.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());\n\t\tthis.propagateSideLabels(0);\n\t\tthis.propagateSideLabels(1);\n\t\tvar hasDimensionalCollapseEdge = [false, false];\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tfor (var geomi = 0; geomi < 2; geomi++) {\n\t\t\t\tif (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) hasDimensionalCollapseEdge[geomi] = true;\n\t\t\t}\n\t\t}\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tfor (var geomi = 0; geomi < 2; geomi++) {\n\t\t\t\tif (label.isAnyNull(geomi)) {\n\t\t\t\t\tvar loc = Location.NONE;\n\t\t\t\t\tif (hasDimensionalCollapseEdge[geomi]) {\n\t\t\t\t\t\tloc = Location.EXTERIOR;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar p = e.getCoordinate();\n\t\t\t\t\t\tloc = this.getLocation(geomi, p, geomGraph);\n\t\t\t\t\t}\n\t\t\t\t\tlabel.setAllLocationsIfNull(geomi, loc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgetDegree() {\n\t\treturn this._edgeMap.size();\n\t}\n\tinsertEdgeEnd(e, obj) {\n\t\tthis._edgeMap.put(e, obj);\n\t\tthis._edgeList = null;\n\t}\n\tgetClass() {\n\t\treturn EdgeEndStar;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdgeEndStar.constructor_ = function () {\n\tthis._edgeMap = new TreeMap();\n\tthis._edgeList = null;\n\tthis._ptInAreaLocation = [Location.NONE, Location.NONE];\n};\n","export default class MonotoneChain {\n\tconstructor() {\n\t\tMonotoneChain.constructor_.apply(this, arguments);\n\t}\n\tcomputeIntersections(mc, si) {\n\t\tthis.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);\n\t}\n\tgetClass() {\n\t\treturn MonotoneChain;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nMonotoneChain.constructor_ = function () {\n\tthis.mce = null;\n\tthis.chainIndex = null;\n\tlet mce = arguments[0], chainIndex = arguments[1];\n\tthis.mce = mce;\n\tthis.chainIndex = chainIndex;\n};\n","import Comparable from '../../../../../java/lang/Comparable';\nexport default class SweepLineEvent {\n\tconstructor() {\n\t\tSweepLineEvent.constructor_.apply(this, arguments);\n\t}\n\tisDelete() {\n\t\treturn this._eventType === SweepLineEvent.DELETE;\n\t}\n\tsetDeleteEventIndex(deleteEventIndex) {\n\t\tthis._deleteEventIndex = deleteEventIndex;\n\t}\n\tgetObject() {\n\t\treturn this._obj;\n\t}\n\tcompareTo(o) {\n\t\tvar pe = o;\n\t\tif (this._xValue < pe._xValue) return -1;\n\t\tif (this._xValue > pe._xValue) return 1;\n\t\tif (this._eventType < pe._eventType) return -1;\n\t\tif (this._eventType > pe._eventType) return 1;\n\t\treturn 0;\n\t}\n\tgetInsertEvent() {\n\t\treturn this._insertEvent;\n\t}\n\tisInsert() {\n\t\treturn this._eventType === SweepLineEvent.INSERT;\n\t}\n\tisSameLabel(ev) {\n\t\tif (this._label === null) return false;\n\t\treturn this._label === ev._label;\n\t}\n\tgetDeleteEventIndex() {\n\t\treturn this._deleteEventIndex;\n\t}\n\tgetClass() {\n\t\treturn SweepLineEvent;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparable];\n\t}\n}\nSweepLineEvent.constructor_ = function () {\n\tthis._label = null;\n\tthis._xValue = null;\n\tthis._eventType = null;\n\tthis._insertEvent = null;\n\tthis._deleteEventIndex = null;\n\tthis._obj = null;\n\tif (arguments.length === 2) {\n\t\tlet x = arguments[0], insertEvent = arguments[1];\n\t\tthis._eventType = SweepLineEvent.DELETE;\n\t\tthis._xValue = x;\n\t\tthis._insertEvent = insertEvent;\n\t} else if (arguments.length === 3) {\n\t\tlet label = arguments[0], x = arguments[1], obj = arguments[2];\n\t\tthis._eventType = SweepLineEvent.INSERT;\n\t\tthis._label = label;\n\t\tthis._xValue = x;\n\t\tthis._obj = obj;\n\t}\n};\nSweepLineEvent.INSERT = 1;\nSweepLineEvent.DELETE = 2;\n","export default class EdgeSetIntersector {\n\tconstructor() {\n\t\tEdgeSetIntersector.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn EdgeSetIntersector;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdgeSetIntersector.constructor_ = function () {};\n","import Arrays from './Arrays'\nimport ArrayList from './ArrayList'\n\nconst Collections = {\n  reverseOrder: function () {\n    return {\n      compare (a, b) {\n        return b.compareTo(a)\n      }\n    }\n  },\n  min: function (l) {\n    Collections.sort(l)\n    return l.get(0)\n  },\n  sort: function (l, c) {\n    const a = l.toArray()\n    if (c) {\n      Arrays.sort(a, c)\n    } else {\n      Arrays.sort(a)\n    }\n    const i = l.iterator()\n    for (let pos = 0, alen = a.length; pos < alen; pos++) {\n      i.next()\n      i.set(a[pos])\n    }\n  },\n  singletonList: function (o) {\n    const arrayList = new ArrayList()\n    arrayList.add(o)\n    return arrayList\n  }\n}\n\nexport default Collections\n","export default class SegmentIntersector {\n\tconstructor() {\n\t\tSegmentIntersector.constructor_.apply(this, arguments);\n\t}\n\tstatic isAdjacentSegments(i1, i2) {\n\t\treturn Math.abs(i1 - i2) === 1;\n\t}\n\tisTrivialIntersection(e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1) {\n\t\t\tif (this._li.getIntersectionNum() === 1) {\n\t\t\t\tif (SegmentIntersector.isAdjacentSegments(segIndex0, segIndex1)) return true;\n\t\t\t\tif (e0.isClosed()) {\n\t\t\t\t\tvar maxSegIndex = e0.getNumPoints() - 1;\n\t\t\t\t\tif (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tgetProperIntersectionPoint() {\n\t\treturn this._properIntersectionPoint;\n\t}\n\tsetIsDoneIfProperInt(isDoneWhenProperInt) {\n\t\tthis._isDoneWhenProperInt = isDoneWhenProperInt;\n\t}\n\thasProperInteriorIntersection() {\n\t\treturn this._hasProperInterior;\n\t}\n\tisBoundaryPointInternal(li, bdyNodes) {\n\t\tfor (var i = bdyNodes.iterator(); i.hasNext(); ) {\n\t\t\tvar node = i.next();\n\t\t\tvar pt = node.getCoordinate();\n\t\t\tif (li.isIntersection(pt)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\thasProperIntersection() {\n\t\treturn this._hasProper;\n\t}\n\thasIntersection() {\n\t\treturn this._hasIntersection;\n\t}\n\tisDone() {\n\t\treturn this._isDone;\n\t}\n\tisBoundaryPoint(li, bdyNodes) {\n\t\tif (bdyNodes === null) return false;\n\t\tif (this.isBoundaryPointInternal(li, bdyNodes[0])) return true;\n\t\tif (this.isBoundaryPointInternal(li, bdyNodes[1])) return true;\n\t\treturn false;\n\t}\n\tsetBoundaryNodes(bdyNodes0, bdyNodes1) {\n\t\tthis._bdyNodes = new Array(2).fill(null);\n\t\tthis._bdyNodes[0] = bdyNodes0;\n\t\tthis._bdyNodes[1] = bdyNodes1;\n\t}\n\taddIntersections(e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n\t\tthis.numTests++;\n\t\tvar p00 = e0.getCoordinates()[segIndex0];\n\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n\t\tvar p10 = e1.getCoordinates()[segIndex1];\n\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n\t\tthis._li.computeIntersection(p00, p01, p10, p11);\n\t\tif (this._li.hasIntersection()) {\n\t\t\tif (this._recordIsolated) {\n\t\t\t\te0.setIsolated(false);\n\t\t\t\te1.setIsolated(false);\n\t\t\t}\n\t\t\tthis._numIntersections++;\n\t\t\tif (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n\t\t\t\tthis._hasIntersection = true;\n\t\t\t\tif (this._includeProper || !this._li.isProper()) {\n\t\t\t\t\te0.addIntersections(this._li, segIndex0, 0);\n\t\t\t\t\te1.addIntersections(this._li, segIndex1, 1);\n\t\t\t\t}\n\t\t\t\tif (this._li.isProper()) {\n\t\t\t\t\tthis._properIntersectionPoint = this._li.getIntersection(0).copy();\n\t\t\t\t\tthis._hasProper = true;\n\t\t\t\t\tif (this._isDoneWhenProperInt) {\n\t\t\t\t\t\tthis._isDone = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!this.isBoundaryPoint(this._li, this._bdyNodes)) this._hasProperInterior = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn SegmentIntersector;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nSegmentIntersector.constructor_ = function () {\n\tthis._hasIntersection = false;\n\tthis._hasProper = false;\n\tthis._hasProperInterior = false;\n\tthis._properIntersectionPoint = null;\n\tthis._li = null;\n\tthis._includeProper = null;\n\tthis._recordIsolated = null;\n\tthis._isSelfIntersection = null;\n\tthis._numIntersections = 0;\n\tthis.numTests = 0;\n\tthis._bdyNodes = null;\n\tthis._isDone = false;\n\tthis._isDoneWhenProperInt = false;\n\tlet li = arguments[0], includeProper = arguments[1], recordIsolated = arguments[2];\n\tthis._li = li;\n\tthis._includeProper = includeProper;\n\tthis._recordIsolated = recordIsolated;\n};\n","import hasInterface from '../../../../../hasInterface';\nimport MonotoneChain from './MonotoneChain';\nimport SweepLineEvent from './SweepLineEvent';\nimport EdgeSetIntersector from './EdgeSetIntersector';\nimport Collections from '../../../../../java/util/Collections';\nimport SegmentIntersector from './SegmentIntersector';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport List from '../../../../../java/util/List';\nexport default class SimpleMCSweepLineIntersector extends EdgeSetIntersector {\n\tconstructor() {\n\t\tsuper();\n\t\tSimpleMCSweepLineIntersector.constructor_.apply(this, arguments);\n\t}\n\tprepareEvents() {\n\t\tCollections.sort(this.events);\n\t\tfor (var i = 0; i < this.events.size(); i++) {\n\t\t\tvar ev = this.events.get(i);\n\t\t\tif (ev.isDelete()) {\n\t\t\t\tev.getInsertEvent().setDeleteEventIndex(i);\n\t\t\t}\n\t\t}\n\t}\n\tcomputeIntersections() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet si = arguments[0];\n\t\t\tthis.nOverlaps = 0;\n\t\t\tthis.prepareEvents();\n\t\t\tfor (var i = 0; i < this.events.size(); i++) {\n\t\t\t\tvar ev = this.events.get(i);\n\t\t\t\tif (ev.isInsert()) {\n\t\t\t\t\tthis.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);\n\t\t\t\t}\n\t\t\t\tif (si.isDone()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (arguments[2] instanceof SegmentIntersector && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {\n\t\t\t\tlet edges0 = arguments[0], edges1 = arguments[1], si = arguments[2];\n\t\t\t\tthis.addEdges(edges0, edges0);\n\t\t\t\tthis.addEdges(edges1, edges1);\n\t\t\t\tthis.computeIntersections(si);\n\t\t\t} else if (typeof arguments[2] === \"boolean\" && (hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector)) {\n\t\t\t\tlet edges = arguments[0], si = arguments[1], testAllSegments = arguments[2];\n\t\t\t\tif (testAllSegments) this.addEdges(edges, null); else this.addEdges(edges);\n\t\t\t\tthis.computeIntersections(si);\n\t\t\t}\n\t\t}\n\t}\n\taddEdge(edge, edgeSet) {\n\t\tvar mce = edge.getMonotoneChainEdge();\n\t\tvar startIndex = mce.getStartIndexes();\n\t\tfor (var i = 0; i < startIndex.length - 1; i++) {\n\t\t\tvar mc = new MonotoneChain(mce, i);\n\t\t\tvar insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);\n\t\t\tthis.events.add(insertEvent);\n\t\t\tthis.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));\n\t\t}\n\t}\n\tprocessOverlaps(start, end, ev0, si) {\n\t\tvar mc0 = ev0.getObject();\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar ev1 = this.events.get(i);\n\t\t\tif (ev1.isInsert()) {\n\t\t\t\tvar mc1 = ev1.getObject();\n\t\t\t\tif (!ev0.isSameLabel(ev1)) {\n\t\t\t\t\tmc0.computeIntersections(mc1, si);\n\t\t\t\t\tthis.nOverlaps++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taddEdges() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet edges = arguments[0];\n\t\t\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\t\t\tvar edge = i.next();\n\t\t\t\tthis.addEdge(edge, edge);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet edges = arguments[0], edgeSet = arguments[1];\n\t\t\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\t\t\tvar edge = i.next();\n\t\t\t\tthis.addEdge(edge, edgeSet);\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn SimpleMCSweepLineIntersector;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nSimpleMCSweepLineIntersector.constructor_ = function () {\n\tthis.events = new ArrayList();\n\tthis.nOverlaps = null;\n};\n","export default class ItemVisitor {\n\tconstructor() {\n\t\tItemVisitor.constructor_.apply(this, arguments);\n\t}\n\tvisitItem(item) {}\n\tgetClass() {\n\t\treturn ItemVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nItemVisitor.constructor_ = function () {};\n","import WKTWriter from '../../io/WKTWriter';\nimport Coordinate from '../../geom/Coordinate';\nimport Double from '../../../../../java/lang/Double';\nimport Comparator from '../../../../../java/util/Comparator';\nexport default class IntervalRTreeNode {\n\tconstructor() {\n\t\tIntervalRTreeNode.constructor_.apply(this, arguments);\n\t}\n\tgetMin() {\n\t\treturn this._min;\n\t}\n\tintersects(queryMin, queryMax) {\n\t\tif (this._min > queryMax || this._max < queryMin) return false;\n\t\treturn true;\n\t}\n\tgetMax() {\n\t\treturn this._max;\n\t}\n\ttoString() {\n\t\treturn WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0));\n\t}\n\tgetClass() {\n\t\treturn IntervalRTreeNode;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nclass NodeComparator {\n\tconstructor() {\n\t\tNodeComparator.constructor_.apply(this, arguments);\n\t}\n\tcompare(o1, o2) {\n\t\tvar n1 = o1;\n\t\tvar n2 = o2;\n\t\tvar mid1 = (n1._min + n1._max) / 2;\n\t\tvar mid2 = (n2._min + n2._max) / 2;\n\t\tif (mid1 < mid2) return -1;\n\t\tif (mid1 > mid2) return 1;\n\t\treturn 0;\n\t}\n\tgetClass() {\n\t\treturn NodeComparator;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparator];\n\t}\n}\nNodeComparator.constructor_ = function () {};\nIntervalRTreeNode.NodeComparator = NodeComparator;\nIntervalRTreeNode.constructor_ = function () {\n\tthis._min = Double.POSITIVE_INFINITY;\n\tthis._max = Double.NEGATIVE_INFINITY;\n};\n","import IntervalRTreeNode from './IntervalRTreeNode';\nexport default class IntervalRTreeLeafNode extends IntervalRTreeNode {\n\tconstructor() {\n\t\tsuper();\n\t\tIntervalRTreeLeafNode.constructor_.apply(this, arguments);\n\t}\n\tquery(queryMin, queryMax, visitor) {\n\t\tif (!this.intersects(queryMin, queryMax)) return null;\n\t\tvisitor.visitItem(this._item);\n\t}\n\tgetClass() {\n\t\treturn IntervalRTreeLeafNode;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nIntervalRTreeLeafNode.constructor_ = function () {\n\tthis._item = null;\n\tlet min = arguments[0], max = arguments[1], item = arguments[2];\n\tthis._min = min;\n\tthis._max = max;\n\tthis._item = item;\n};\n","import IntervalRTreeNode from './IntervalRTreeNode';\nexport default class IntervalRTreeBranchNode extends IntervalRTreeNode {\n\tconstructor() {\n\t\tsuper();\n\t\tIntervalRTreeBranchNode.constructor_.apply(this, arguments);\n\t}\n\tbuildExtent(n1, n2) {\n\t\tthis._min = Math.min(n1._min, n2._min);\n\t\tthis._max = Math.max(n1._max, n2._max);\n\t}\n\tquery(queryMin, queryMax, visitor) {\n\t\tif (!this.intersects(queryMin, queryMax)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this._node1 !== null) this._node1.query(queryMin, queryMax, visitor);\n\t\tif (this._node2 !== null) this._node2.query(queryMin, queryMax, visitor);\n\t}\n\tgetClass() {\n\t\treturn IntervalRTreeBranchNode;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nIntervalRTreeBranchNode.constructor_ = function () {\n\tthis._node1 = null;\n\tthis._node2 = null;\n\tlet n1 = arguments[0], n2 = arguments[1];\n\tthis._node1 = n1;\n\tthis._node2 = n2;\n\tthis.buildExtent(this._node1, this._node2);\n};\n","import WKTWriter from '../../io/WKTWriter';\nimport Coordinate from '../../geom/Coordinate';\nimport IntervalRTreeLeafNode from './IntervalRTreeLeafNode';\nimport IntervalRTreeNode from './IntervalRTreeNode';\nimport Collections from '../../../../../java/util/Collections';\nimport System from '../../../../../java/lang/System';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport IntervalRTreeBranchNode from './IntervalRTreeBranchNode';\nexport default class SortedPackedIntervalRTree {\n\tconstructor() {\n\t\tSortedPackedIntervalRTree.constructor_.apply(this, arguments);\n\t}\n\tbuildTree() {\n\t\tCollections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());\n\t\tvar src = this._leaves;\n\t\tvar temp = null;\n\t\tvar dest = new ArrayList();\n\t\twhile (true) {\n\t\t\tthis.buildLevel(src, dest);\n\t\t\tif (dest.size() === 1) return dest.get(0);\n\t\t\ttemp = src;\n\t\t\tsrc = dest;\n\t\t\tdest = temp;\n\t\t}\n\t}\n\tinsert(min, max, item) {\n\t\tif (this._root !== null) throw new IllegalStateException(\"Index cannot be added to once it has been queried\");\n\t\tthis._leaves.add(new IntervalRTreeLeafNode(min, max, item));\n\t}\n\tquery(min, max, visitor) {\n\t\tthis.init();\n\t\tthis._root.query(min, max, visitor);\n\t}\n\tbuildRoot() {\n\t\tif (this._root !== null) return null;\n\t\tthis._root = this.buildTree();\n\t}\n\tprintNode(node) {\n\t\tSystem.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));\n\t}\n\tinit() {\n\t\tif (this._root !== null) return null;\n\t\tthis.buildRoot();\n\t}\n\tbuildLevel(src, dest) {\n\t\tthis._level++;\n\t\tdest.clear();\n\t\tfor (var i = 0; i < src.size(); i += 2) {\n\t\t\tvar n1 = src.get(i);\n\t\t\tvar n2 = i + 1 < src.size() ? src.get(i) : null;\n\t\t\tif (n2 === null) {\n\t\t\t\tdest.add(n1);\n\t\t\t} else {\n\t\t\t\tvar node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));\n\t\t\t\tdest.add(node);\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn SortedPackedIntervalRTree;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nSortedPackedIntervalRTree.constructor_ = function () {\n\tthis._leaves = new ArrayList();\n\tthis._root = null;\n\tthis._level = 0;\n};\n","import NotRepresentableException from '../algorithm/NotRepresentableException';\nimport Coordinate from './Coordinate';\nimport Double from '../../../../java/lang/Double';\nimport Orientation from '../algorithm/Orientation';\nimport Comparable from '../../../../java/lang/Comparable';\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector';\nimport HCoordinate from '../algorithm/HCoordinate';\nimport Serializable from '../../../../java/io/Serializable';\nimport Distance from '../algorithm/Distance';\nexport default class LineSegment {\n\tconstructor() {\n\t\tLineSegment.constructor_.apply(this, arguments);\n\t}\n\tstatic midPoint(p0, p1) {\n\t\treturn new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);\n\t}\n\tminX() {\n\t\treturn Math.min(this.p0.x, this.p1.x);\n\t}\n\torientationIndex() {\n\t\tif (arguments[0] instanceof LineSegment) {\n\t\t\tlet seg = arguments[0];\n\t\t\tvar orient0 = Orientation.index(this.p0, this.p1, seg.p0);\n\t\t\tvar orient1 = Orientation.index(this.p0, this.p1, seg.p1);\n\t\t\tif (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1);\n\t\t\tif (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1);\n\t\t\treturn 0;\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\treturn Orientation.index(this.p0, this.p1, p);\n\t\t}\n\t}\n\ttoGeometry(geomFactory) {\n\t\treturn geomFactory.createLineString([this.p0, this.p1]);\n\t}\n\tisVertical() {\n\t\treturn this.p0.x === this.p1.x;\n\t}\n\tequals(o) {\n\t\tif (!(o instanceof LineSegment)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar other = o;\n\t\treturn this.p0.equals(other.p0) && this.p1.equals(other.p1);\n\t}\n\tintersection(line) {\n\t\tvar li = new RobustLineIntersector();\n\t\tli.computeIntersection(this.p0, this.p1, line.p0, line.p1);\n\t\tif (li.hasIntersection()) return li.getIntersection(0);\n\t\treturn null;\n\t}\n\tproject() {\n\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\tif (p.equals(this.p0) || p.equals(this.p1)) return new Coordinate(p);\n\t\t\tvar r = this.projectionFactor(p);\n\t\t\tvar coord = new Coordinate();\n\t\t\tcoord.x = this.p0.x + r * (this.p1.x - this.p0.x);\n\t\t\tcoord.y = this.p0.y + r * (this.p1.y - this.p0.y);\n\t\t\treturn coord;\n\t\t} else if (arguments[0] instanceof LineSegment) {\n\t\t\tlet seg = arguments[0];\n\t\t\tvar pf0 = this.projectionFactor(seg.p0);\n\t\t\tvar pf1 = this.projectionFactor(seg.p1);\n\t\t\tif (pf0 >= 1.0 && pf1 >= 1.0) return null;\n\t\t\tif (pf0 <= 0.0 && pf1 <= 0.0) return null;\n\t\t\tvar newp0 = this.project(seg.p0);\n\t\t\tif (pf0 < 0.0) newp0 = this.p0;\n\t\t\tif (pf0 > 1.0) newp0 = this.p1;\n\t\t\tvar newp1 = this.project(seg.p1);\n\t\t\tif (pf1 < 0.0) newp1 = this.p0;\n\t\t\tif (pf1 > 1.0) newp1 = this.p1;\n\t\t\treturn new LineSegment(newp0, newp1);\n\t\t}\n\t}\n\tnormalize() {\n\t\tif (this.p1.compareTo(this.p0) < 0) this.reverse();\n\t}\n\tangle() {\n\t\treturn Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);\n\t}\n\tgetCoordinate(i) {\n\t\tif (i === 0) return this.p0;\n\t\treturn this.p1;\n\t}\n\tdistancePerpendicular(p) {\n\t\treturn Distance.pointToLinePerpendicular(p, this.p0, this.p1);\n\t}\n\tminY() {\n\t\treturn Math.min(this.p0.y, this.p1.y);\n\t}\n\tmidPoint() {\n\t\treturn LineSegment.midPoint(this.p0, this.p1);\n\t}\n\tprojectionFactor(p) {\n\t\tif (p.equals(this.p0)) return 0.0;\n\t\tif (p.equals(this.p1)) return 1.0;\n\t\tvar dx = this.p1.x - this.p0.x;\n\t\tvar dy = this.p1.y - this.p0.y;\n\t\tvar len = dx * dx + dy * dy;\n\t\tif (len <= 0.0) return Double.NaN;\n\t\tvar r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;\n\t\treturn r;\n\t}\n\tclosestPoints(line) {\n\t\tvar intPt = this.intersection(line);\n\t\tif (intPt !== null) {\n\t\t\treturn [intPt, intPt];\n\t\t}\n\t\tvar closestPt = new Array(2).fill(null);\n\t\tvar minDistance = Double.MAX_VALUE;\n\t\tvar dist = null;\n\t\tvar close00 = this.closestPoint(line.p0);\n\t\tminDistance = close00.distance(line.p0);\n\t\tclosestPt[0] = close00;\n\t\tclosestPt[1] = line.p0;\n\t\tvar close01 = this.closestPoint(line.p1);\n\t\tdist = close01.distance(line.p1);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t\tclosestPt[0] = close01;\n\t\t\tclosestPt[1] = line.p1;\n\t\t}\n\t\tvar close10 = line.closestPoint(this.p0);\n\t\tdist = close10.distance(this.p0);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t\tclosestPt[0] = this.p0;\n\t\t\tclosestPt[1] = close10;\n\t\t}\n\t\tvar close11 = line.closestPoint(this.p1);\n\t\tdist = close11.distance(this.p1);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t\tclosestPt[0] = this.p1;\n\t\t\tclosestPt[1] = close11;\n\t\t}\n\t\treturn closestPt;\n\t}\n\tclosestPoint(p) {\n\t\tvar factor = this.projectionFactor(p);\n\t\tif (factor > 0 && factor < 1) {\n\t\t\treturn this.project(p);\n\t\t}\n\t\tvar dist0 = this.p0.distance(p);\n\t\tvar dist1 = this.p1.distance(p);\n\t\tif (dist0 < dist1) return this.p0;\n\t\treturn this.p1;\n\t}\n\tmaxX() {\n\t\treturn Math.max(this.p0.x, this.p1.x);\n\t}\n\tgetLength() {\n\t\treturn this.p0.distance(this.p1);\n\t}\n\tcompareTo(o) {\n\t\tvar other = o;\n\t\tvar comp0 = this.p0.compareTo(other.p0);\n\t\tif (comp0 !== 0) return comp0;\n\t\treturn this.p1.compareTo(other.p1);\n\t}\n\treverse() {\n\t\tvar temp = this.p0;\n\t\tthis.p0 = this.p1;\n\t\tthis.p1 = temp;\n\t}\n\tequalsTopo(other) {\n\t\treturn this.p0.equals(other.p0) && this.p1.equals(other.p1) || this.p0.equals(other.p1) && this.p1.equals(other.p0);\n\t}\n\tlineIntersection(line) {\n\t\ttry {\n\t\t\tvar intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);\n\t\t\treturn intPt;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof NotRepresentableException) {} else throw ex;\n\t\t} finally {}\n\t\treturn null;\n\t}\n\tmaxY() {\n\t\treturn Math.max(this.p0.y, this.p1.y);\n\t}\n\tpointAlongOffset(segmentLengthFraction, offsetDistance) {\n\t\tvar segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n\t\tvar segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n\t\tvar dx = this.p1.x - this.p0.x;\n\t\tvar dy = this.p1.y - this.p0.y;\n\t\tvar len = Math.sqrt(dx * dx + dy * dy);\n\t\tvar ux = 0.0;\n\t\tvar uy = 0.0;\n\t\tif (offsetDistance !== 0.0) {\n\t\t\tif (len <= 0.0) throw new IllegalStateException(\"Cannot compute offset from zero-length line segment\");\n\t\t\tux = offsetDistance * dx / len;\n\t\t\tuy = offsetDistance * dy / len;\n\t\t}\n\t\tvar offsetx = segx - uy;\n\t\tvar offsety = segy + ux;\n\t\tvar coord = new Coordinate(offsetx, offsety);\n\t\treturn coord;\n\t}\n\tsetCoordinates() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet ls = arguments[0];\n\t\t\tthis.setCoordinates(ls.p0, ls.p1);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\t\tthis.p0.x = p0.x;\n\t\t\tthis.p0.y = p0.y;\n\t\t\tthis.p1.x = p1.x;\n\t\t\tthis.p1.y = p1.y;\n\t\t}\n\t}\n\tsegmentFraction(inputPt) {\n\t\tvar segFrac = this.projectionFactor(inputPt);\n\t\tif (segFrac < 0.0) segFrac = 0.0; else if (segFrac > 1.0 || Double.isNaN(segFrac)) segFrac = 1.0;\n\t\treturn segFrac;\n\t}\n\ttoString() {\n\t\treturn \"LINESTRING( \" + this.p0.x + \" \" + this.p0.y + \", \" + this.p1.x + \" \" + this.p1.y + \")\";\n\t}\n\tisHorizontal() {\n\t\treturn this.p0.y === this.p1.y;\n\t}\n\tdistance() {\n\t\tif (arguments[0] instanceof LineSegment) {\n\t\t\tlet ls = arguments[0];\n\t\t\treturn Distance.segmentToSegment(this.p0, this.p1, ls.p0, ls.p1);\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\treturn Distance.pointToSegment(p, this.p0, this.p1);\n\t\t}\n\t}\n\tpointAlong(segmentLengthFraction) {\n\t\tvar coord = new Coordinate();\n\t\tcoord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n\t\tcoord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n\t\treturn coord;\n\t}\n\thashCode() {\n\t\tvar bits0 = java.lang.Double.doubleToLongBits(this.p0.x);\n\t\tbits0 ^= java.lang.Double.doubleToLongBits(this.p0.y) * 31;\n\t\tvar hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);\n\t\tvar bits1 = java.lang.Double.doubleToLongBits(this.p1.x);\n\t\tbits1 ^= java.lang.Double.doubleToLongBits(this.p1.y) * 31;\n\t\tvar hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);\n\t\treturn hash0 ^ hash1;\n\t}\n\tgetClass() {\n\t\treturn LineSegment;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparable, Serializable];\n\t}\n}\nLineSegment.constructor_ = function () {\n\tthis.p0 = null;\n\tthis.p1 = null;\n\tif (arguments.length === 0) {\n\t\tLineSegment.constructor_.call(this, new Coordinate(), new Coordinate());\n\t} else if (arguments.length === 1) {\n\t\tlet ls = arguments[0];\n\t\tLineSegment.constructor_.call(this, ls.p0, ls.p1);\n\t} else if (arguments.length === 2) {\n\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\tthis.p0 = p0;\n\t\tthis.p1 = p1;\n\t} else if (arguments.length === 4) {\n\t\tlet x0 = arguments[0], y0 = arguments[1], x1 = arguments[2], y1 = arguments[3];\n\t\tLineSegment.constructor_.call(this, new Coordinate(x0, y0), new Coordinate(x1, y1));\n\t}\n};\nLineSegment.serialVersionUID = 3252005833466256227;\n","import LineString from '../LineString';\nimport Geometry from '../Geometry';\nimport hasInterface from '../../../../../hasInterface';\nimport Collection from '../../../../../java/util/Collection';\nimport LinearRing from '../LinearRing';\nimport GeometryComponentFilter from '../GeometryComponentFilter';\nimport ArrayList from '../../../../../java/util/ArrayList';\nexport default class LinearComponentExtracter {\n\tconstructor() {\n\t\tLinearComponentExtracter.constructor_.apply(this, arguments);\n\t}\n\tstatic getGeometry() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet geom = arguments[0];\n\t\t\treturn geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet geom = arguments[0], forceToLineString = arguments[1];\n\t\t\treturn geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom, forceToLineString));\n\t\t}\n\t}\n\tstatic getLines() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet geom = arguments[0];\n\t\t\treturn LinearComponentExtracter.getLines(geom, false);\n\t\t} else if (arguments.length === 2) {\n\t\t\tif (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n\t\t\t\tlet geoms = arguments[0], lines = arguments[1];\n\t\t\t\tfor (var i = geoms.iterator(); i.hasNext(); ) {\n\t\t\t\t\tvar g = i.next();\n\t\t\t\t\tLinearComponentExtracter.getLines(g, lines);\n\t\t\t\t}\n\t\t\t\treturn lines;\n\t\t\t} else if (arguments[0] instanceof Geometry && typeof arguments[1] === \"boolean\") {\n\t\t\t\tlet geom = arguments[0], forceToLineString = arguments[1];\n\t\t\t\tvar lines = new ArrayList();\n\t\t\t\tgeom.apply(new LinearComponentExtracter(lines, forceToLineString));\n\t\t\t\treturn lines;\n\t\t\t} else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n\t\t\t\tlet geom = arguments[0], lines = arguments[1];\n\t\t\t\tif (geom instanceof LineString) {\n\t\t\t\t\tlines.add(geom);\n\t\t\t\t} else {\n\t\t\t\t\tgeom.apply(new LinearComponentExtracter(lines));\n\t\t\t\t}\n\t\t\t\treturn lines;\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (typeof arguments[2] === \"boolean\" && (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection))) {\n\t\t\t\tlet geoms = arguments[0], lines = arguments[1], forceToLineString = arguments[2];\n\t\t\t\tfor (var i = geoms.iterator(); i.hasNext(); ) {\n\t\t\t\t\tvar g = i.next();\n\t\t\t\t\tLinearComponentExtracter.getLines(g, lines, forceToLineString);\n\t\t\t\t}\n\t\t\t\treturn lines;\n\t\t\t} else if (typeof arguments[2] === \"boolean\" && (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection))) {\n\t\t\t\tlet geom = arguments[0], lines = arguments[1], forceToLineString = arguments[2];\n\t\t\t\tgeom.apply(new LinearComponentExtracter(lines, forceToLineString));\n\t\t\t\treturn lines;\n\t\t\t}\n\t\t}\n\t}\n\tfilter(geom) {\n\t\tif (this._isForcedToLineString && geom instanceof LinearRing) {\n\t\t\tvar line = geom.getFactory().createLineString(geom.getCoordinateSequence());\n\t\t\tthis._lines.add(line);\n\t\t\treturn null;\n\t\t}\n\t\tif (geom instanceof LineString) this._lines.add(geom);\n\t}\n\tsetForceToLineString(isForcedToLineString) {\n\t\tthis._isForcedToLineString = isForcedToLineString;\n\t}\n\tgetClass() {\n\t\treturn LinearComponentExtracter;\n\t}\n\tget interfaces_() {\n\t\treturn [GeometryComponentFilter];\n\t}\n}\nLinearComponentExtracter.constructor_ = function () {\n\tthis._lines = null;\n\tthis._isForcedToLineString = false;\n\tif (arguments.length === 1) {\n\t\tlet lines = arguments[0];\n\t\tthis._lines = lines;\n\t} else if (arguments.length === 2) {\n\t\tlet lines = arguments[0], isForcedToLineString = arguments[1];\n\t\tthis._lines = lines;\n\t\tthis._isForcedToLineString = isForcedToLineString;\n\t}\n};\n","import ItemVisitor from './ItemVisitor';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default class ArrayListVisitor {\n\tconstructor() {\n\t\tArrayListVisitor.constructor_.apply(this, arguments);\n\t}\n\tvisitItem(item) {\n\t\tthis._items.add(item);\n\t}\n\tgetItems() {\n\t\treturn this._items;\n\t}\n\tgetClass() {\n\t\treturn ArrayListVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [ItemVisitor];\n\t}\n}\nArrayListVisitor.constructor_ = function () {\n\tthis._items = new ArrayList();\n};\n","import hasInterface from '../../../../../hasInterface';\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport ItemVisitor from '../../index/ItemVisitor';\nimport PointOnGeometryLocator from './PointOnGeometryLocator';\nimport LinearRing from '../../geom/LinearRing';\nimport SortedPackedIntervalRTree from '../../index/intervalrtree/SortedPackedIntervalRTree';\nimport LineSegment from '../../geom/LineSegment';\nimport Polygonal from '../../geom/Polygonal';\nimport LinearComponentExtracter from '../../geom/util/LinearComponentExtracter';\nimport ArrayListVisitor from '../../index/ArrayListVisitor';\nimport RayCrossingCounter from '../RayCrossingCounter';\nexport default class IndexedPointInAreaLocator {\n\tconstructor() {\n\t\tIndexedPointInAreaLocator.constructor_.apply(this, arguments);\n\t}\n\tlocate(p) {\n\t\tvar rcc = new RayCrossingCounter(p);\n\t\tvar visitor = new SegmentVisitor(rcc);\n\t\tthis._index.query(p.y, p.y, visitor);\n\t\treturn rcc.getLocation();\n\t}\n\tgetClass() {\n\t\treturn IndexedPointInAreaLocator;\n\t}\n\tget interfaces_() {\n\t\treturn [PointOnGeometryLocator];\n\t}\n}\nclass SegmentVisitor {\n\tconstructor() {\n\t\tSegmentVisitor.constructor_.apply(this, arguments);\n\t}\n\tvisitItem(item) {\n\t\tvar seg = item;\n\t\tthis._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));\n\t}\n\tgetClass() {\n\t\treturn SegmentVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [ItemVisitor];\n\t}\n}\nSegmentVisitor.constructor_ = function () {\n\tthis._counter = null;\n\tlet counter = arguments[0];\n\tthis._counter = counter;\n};\nclass IntervalIndexedGeometry {\n\tconstructor() {\n\t\tIntervalIndexedGeometry.constructor_.apply(this, arguments);\n\t}\n\tinit(geom) {\n\t\tvar lines = LinearComponentExtracter.getLines(geom);\n\t\tfor (var i = lines.iterator(); i.hasNext(); ) {\n\t\t\tvar line = i.next();\n\t\t\tvar pts = line.getCoordinates();\n\t\t\tthis.addLine(pts);\n\t\t}\n\t}\n\taddLine(pts) {\n\t\tfor (var i = 1; i < pts.length; i++) {\n\t\t\tvar seg = new LineSegment(pts[i - 1], pts[i]);\n\t\t\tvar min = Math.min(seg.p0.y, seg.p1.y);\n\t\t\tvar max = Math.max(seg.p0.y, seg.p1.y);\n\t\t\tthis._index.insert(min, max, seg);\n\t\t}\n\t}\n\tquery() {\n\t\tif (arguments.length === 2) {\n\t\t\tlet min = arguments[0], max = arguments[1];\n\t\t\tvar visitor = new ArrayListVisitor();\n\t\t\tthis._index.query(min, max, visitor);\n\t\t\treturn visitor.getItems();\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet min = arguments[0], max = arguments[1], visitor = arguments[2];\n\t\t\tthis._index.query(min, max, visitor);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn IntervalIndexedGeometry;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nIntervalIndexedGeometry.constructor_ = function () {\n\tthis._index = new SortedPackedIntervalRTree();\n\tlet geom = arguments[0];\n\tthis.init(geom);\n};\nIndexedPointInAreaLocator.SegmentVisitor = SegmentVisitor;\nIndexedPointInAreaLocator.IntervalIndexedGeometry = IntervalIndexedGeometry;\nIndexedPointInAreaLocator.constructor_ = function () {\n\tthis._index = null;\n\tlet g = arguments[0];\n\tif (!(hasInterface(g, Polygonal) || g instanceof LinearRing)) throw new IllegalArgumentException(\"Argument must be Polygonal or LinearRing\");\n\tthis._index = new IntervalIndexedGeometry(g);\n};\n","import Coordinate from '../geom/Coordinate';\nimport Comparable from '../../../../java/lang/Comparable';\nexport default class EdgeIntersection {\n\tconstructor() {\n\t\tEdgeIntersection.constructor_.apply(this, arguments);\n\t}\n\tgetSegmentIndex() {\n\t\treturn this.segmentIndex;\n\t}\n\tgetCoordinate() {\n\t\treturn this.coord;\n\t}\n\tprint(out) {\n\t\tout.print(this.coord);\n\t\tout.print(\" seg # = \" + this.segmentIndex);\n\t\tout.println(\" dist = \" + this.dist);\n\t}\n\tcompareTo(obj) {\n\t\tvar other = obj;\n\t\treturn this.compare(other.segmentIndex, other.dist);\n\t}\n\tisEndPoint(maxSegmentIndex) {\n\t\tif (this.segmentIndex === 0 && this.dist === 0.0) return true;\n\t\tif (this.segmentIndex === maxSegmentIndex) return true;\n\t\treturn false;\n\t}\n\ttoString() {\n\t\treturn this.coord + \" seg # = \" + this.segmentIndex + \" dist = \" + this.dist;\n\t}\n\tgetDistance() {\n\t\treturn this.dist;\n\t}\n\tcompare(segmentIndex, dist) {\n\t\tif (this.segmentIndex < segmentIndex) return -1;\n\t\tif (this.segmentIndex > segmentIndex) return 1;\n\t\tif (this.dist < dist) return -1;\n\t\tif (this.dist > dist) return 1;\n\t\treturn 0;\n\t}\n\tgetClass() {\n\t\treturn EdgeIntersection;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparable];\n\t}\n}\nEdgeIntersection.constructor_ = function () {\n\tthis.coord = null;\n\tthis.segmentIndex = null;\n\tthis.dist = null;\n\tlet coord = arguments[0], segmentIndex = arguments[1], dist = arguments[2];\n\tthis.coord = new Coordinate(coord);\n\tthis.segmentIndex = segmentIndex;\n\tthis.dist = dist;\n};\n","import EdgeIntersection from './EdgeIntersection';\nimport Coordinate from '../geom/Coordinate';\nimport Label from './Label';\nimport Edge from './Edge';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default class EdgeIntersectionList {\n\tconstructor() {\n\t\tEdgeIntersectionList.constructor_.apply(this, arguments);\n\t}\n\tprint(out) {\n\t\tout.println(\"Intersections:\");\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ei = it.next();\n\t\t\tei.print(out);\n\t\t}\n\t}\n\titerator() {\n\t\treturn this._nodeMap.values().iterator();\n\t}\n\taddSplitEdges(edgeList) {\n\t\tthis.addEndpoints();\n\t\tvar it = this.iterator();\n\t\tvar eiPrev = it.next();\n\t\twhile (it.hasNext()) {\n\t\t\tvar ei = it.next();\n\t\t\tvar newEdge = this.createSplitEdge(eiPrev, ei);\n\t\t\tedgeList.add(newEdge);\n\t\t\teiPrev = ei;\n\t\t}\n\t}\n\taddEndpoints() {\n\t\tvar maxSegIndex = this.edge.pts.length - 1;\n\t\tthis.add(this.edge.pts[0], 0, 0.0);\n\t\tthis.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);\n\t}\n\tcreateSplitEdge(ei0, ei1) {\n\t\tvar npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n\t\tvar lastSegStartPt = this.edge.pts[ei1.segmentIndex];\n\t\tvar useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);\n\t\tif (!useIntPt1) {\n\t\t\tnpts--;\n\t\t}\n\t\tvar pts = new Array(npts).fill(null);\n\t\tvar ipt = 0;\n\t\tpts[ipt++] = new Coordinate(ei0.coord);\n\t\tfor (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n\t\t\tpts[ipt++] = this.edge.pts[i];\n\t\t}\n\t\tif (useIntPt1) pts[ipt] = ei1.coord;\n\t\treturn new Edge(pts, new Label(this.edge._label));\n\t}\n\tadd(intPt, segmentIndex, dist) {\n\t\tvar eiNew = new EdgeIntersection(intPt, segmentIndex, dist);\n\t\tvar ei = this._nodeMap.get(eiNew);\n\t\tif (ei !== null) {\n\t\t\treturn ei;\n\t\t}\n\t\tthis._nodeMap.put(eiNew, eiNew);\n\t\treturn eiNew;\n\t}\n\tisIntersection(pt) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ei = it.next();\n\t\t\tif (ei.coord.equals(pt)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\tgetClass() {\n\t\treturn EdgeIntersectionList;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdgeIntersectionList.constructor_ = function () {\n\tthis._nodeMap = new TreeMap();\n\tthis.edge = null;\n\tlet edge = arguments[0];\n\tthis.edge = edge;\n};\n","import Integer from '../../../../../java/lang/Integer';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Quadrant from '../Quadrant';\nexport default class MonotoneChainIndexer {\n\tconstructor() {\n\t\tMonotoneChainIndexer.constructor_.apply(this, arguments);\n\t}\n\tstatic toIntArray(list) {\n\t\tvar array = new Array(list.size()).fill(null);\n\t\tfor (var i = 0; i < array.length; i++) {\n\t\t\tarray[i] = list.get(i).intValue();\n\t\t}\n\t\treturn array;\n\t}\n\tgetChainStartIndices(pts) {\n\t\tvar start = 0;\n\t\tvar startIndexList = new ArrayList();\n\t\tstartIndexList.add(new Integer(start));\n\t\tdo {\n\t\t\tvar last = this.findChainEnd(pts, start);\n\t\t\tstartIndexList.add(new Integer(last));\n\t\t\tstart = last;\n\t\t} while (start < pts.length - 1);\n\t\tvar startIndex = MonotoneChainIndexer.toIntArray(startIndexList);\n\t\treturn startIndex;\n\t}\n\tfindChainEnd(pts, start) {\n\t\tvar chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);\n\t\tvar last = start + 1;\n\t\twhile (last < pts.length) {\n\t\t\tvar quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n\t\t\tif (quad !== chainQuad) break;\n\t\t\tlast++;\n\t\t}\n\t\treturn last - 1;\n\t}\n\tgetClass() {\n\t\treturn MonotoneChainIndexer;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nMonotoneChainIndexer.constructor_ = function () {};\n","import MonotoneChainIndexer from './MonotoneChainIndexer';\nimport Envelope from '../../geom/Envelope';\nexport default class MonotoneChainEdge {\n\tconstructor() {\n\t\tMonotoneChainEdge.constructor_.apply(this, arguments);\n\t}\n\tgetCoordinates() {\n\t\treturn this.pts;\n\t}\n\tgetMaxX(chainIndex) {\n\t\tvar x1 = this.pts[this.startIndex[chainIndex]].x;\n\t\tvar x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n\t\treturn x1 > x2 ? x1 : x2;\n\t}\n\tgetMinX(chainIndex) {\n\t\tvar x1 = this.pts[this.startIndex[chainIndex]].x;\n\t\tvar x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n\t\treturn x1 < x2 ? x1 : x2;\n\t}\n\tcomputeIntersectsForChain() {\n\t\tif (arguments.length === 4) {\n\t\t\tlet chainIndex0 = arguments[0], mce = arguments[1], chainIndex1 = arguments[2], si = arguments[3];\n\t\t\tthis.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);\n\t\t} else if (arguments.length === 6) {\n\t\t\tlet start0 = arguments[0], end0 = arguments[1], mce = arguments[2], start1 = arguments[3], end1 = arguments[4], ei = arguments[5];\n\t\t\tif (end0 - start0 === 1 && end1 - start1 === 1) {\n\t\t\t\tei.addIntersections(this.e, start0, mce.e, start1);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!this.overlaps(start0, end0, mce, start1, end1)) return null;\n\t\t\tvar mid0 = Math.trunc((start0 + end0) / 2);\n\t\t\tvar mid1 = Math.trunc((start1 + end1) / 2);\n\t\t\tif (start0 < mid0) {\n\t\t\t\tif (start1 < mid1) this.computeIntersectsForChain(start0, mid0, mce, start1, mid1, ei);\n\t\t\t\tif (mid1 < end1) this.computeIntersectsForChain(start0, mid0, mce, mid1, end1, ei);\n\t\t\t}\n\t\t\tif (mid0 < end0) {\n\t\t\t\tif (start1 < mid1) this.computeIntersectsForChain(mid0, end0, mce, start1, mid1, ei);\n\t\t\t\tif (mid1 < end1) this.computeIntersectsForChain(mid0, end0, mce, mid1, end1, ei);\n\t\t\t}\n\t\t}\n\t}\n\toverlaps(start0, end0, mce, start1, end1) {\n\t\treturn Envelope.intersects(this.pts[start0], this.pts[end0], mce.pts[start1], mce.pts[end1]);\n\t}\n\tgetStartIndexes() {\n\t\treturn this.startIndex;\n\t}\n\tcomputeIntersects(mce, si) {\n\t\tfor (var i = 0; i < this.startIndex.length - 1; i++) {\n\t\t\tfor (var j = 0; j < mce.startIndex.length - 1; j++) {\n\t\t\t\tthis.computeIntersectsForChain(i, mce, j, si);\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn MonotoneChainEdge;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nMonotoneChainEdge.constructor_ = function () {\n\tthis.e = null;\n\tthis.pts = null;\n\tthis.startIndex = null;\n\tlet e = arguments[0];\n\tthis.e = e;\n\tthis.pts = e.getCoordinates();\n\tvar mcb = new MonotoneChainIndexer();\n\tthis.startIndex = mcb.getChainStartIndices(this.pts);\n};\n","import Location from '../geom/Location';\nimport Position from './Position';\nexport default class Depth {\n\tconstructor() {\n\t\tDepth.constructor_.apply(this, arguments);\n\t}\n\tstatic depthAtLocation(location) {\n\t\tif (location === Location.EXTERIOR) return 0;\n\t\tif (location === Location.INTERIOR) return 1;\n\t\treturn Depth.NULL_VALUE;\n\t}\n\tgetDepth(geomIndex, posIndex) {\n\t\treturn this._depth[geomIndex][posIndex];\n\t}\n\tsetDepth(geomIndex, posIndex, depthValue) {\n\t\tthis._depth[geomIndex][posIndex] = depthValue;\n\t}\n\tisNull() {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tfor (var j = 0; j < 3; j++) {\n\t\t\t\t\tif (this._depth[i][j] !== Depth.NULL_VALUE) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet geomIndex = arguments[0];\n\t\t\treturn this._depth[geomIndex][1] === Depth.NULL_VALUE;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1];\n\t\t\treturn this._depth[geomIndex][posIndex] === Depth.NULL_VALUE;\n\t\t}\n\t}\n\tnormalize() {\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (!this.isNull(i)) {\n\t\t\t\tvar minDepth = this._depth[i][1];\n\t\t\t\tif (this._depth[i][2] < minDepth) minDepth = this._depth[i][2];\n\t\t\t\tif (minDepth < 0) minDepth = 0;\n\t\t\t\tfor (var j = 1; j < 3; j++) {\n\t\t\t\t\tvar newValue = 0;\n\t\t\t\t\tif (this._depth[i][j] > minDepth) newValue = 1;\n\t\t\t\t\tthis._depth[i][j] = newValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgetDelta(geomIndex) {\n\t\treturn this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT];\n\t}\n\tgetLocation(geomIndex, posIndex) {\n\t\tif (this._depth[geomIndex][posIndex] <= 0) return Location.EXTERIOR;\n\t\treturn Location.INTERIOR;\n\t}\n\ttoString() {\n\t\treturn \"A: \" + this._depth[0][1] + \",\" + this._depth[0][2] + \" B: \" + this._depth[1][1] + \",\" + this._depth[1][2];\n\t}\n\tadd() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet lbl = arguments[0];\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tfor (var j = 1; j < 3; j++) {\n\t\t\t\t\tvar loc = lbl.getLocation(i, j);\n\t\t\t\t\tif (loc === Location.EXTERIOR || loc === Location.INTERIOR) {\n\t\t\t\t\t\tif (this.isNull(i, j)) {\n\t\t\t\t\t\t\tthis._depth[i][j] = Depth.depthAtLocation(loc);\n\t\t\t\t\t\t} else this._depth[i][j] += Depth.depthAtLocation(loc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2];\n\t\t\tif (location === Location.INTERIOR) this._depth[geomIndex][posIndex]++;\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn Depth;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nDepth.constructor_ = function () {\n\tthis._depth = Array(2).fill().map(() => Array(3));\n\tfor (var i = 0; i < 2; i++) {\n\t\tfor (var j = 0; j < 3; j++) {\n\t\t\tthis._depth[i][j] = Depth.NULL_VALUE;\n\t\t}\n\t}\n};\nDepth.NULL_VALUE = -1;\n","import EdgeIntersectionList from './EdgeIntersectionList';\nimport IntersectionMatrix from '../geom/IntersectionMatrix';\nimport MonotoneChainEdge from './index/MonotoneChainEdge';\nimport Position from './Position';\nimport Coordinate from '../geom/Coordinate';\nimport Label from './Label';\nimport Envelope from '../geom/Envelope';\nimport StringBuilder from '../../../../java/lang/StringBuilder';\nimport Depth from './Depth';\nimport GraphComponent from './GraphComponent';\nexport default class Edge extends GraphComponent {\n\tconstructor() {\n\t\tsuper();\n\t\tEdge.constructor_.apply(this, arguments);\n\t}\n\tstatic updateIM() {\n\t\tif (arguments.length === 2 && (arguments[1] instanceof IntersectionMatrix && arguments[0] instanceof Label)) {\n\t\t\tlet label = arguments[0], im = arguments[1];\n\t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);\n\t\t\tif (label.isArea()) {\n\t\t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);\n\t\t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);\n\t\t\t}\n\t\t} else return super.updateIM.apply(this, arguments);\n\t}\n\tgetDepth() {\n\t\treturn this._depth;\n\t}\n\tgetCollapsedEdge() {\n\t\tvar newPts = new Array(2).fill(null);\n\t\tnewPts[0] = this.pts[0];\n\t\tnewPts[1] = this.pts[1];\n\t\tvar newe = new Edge(newPts, Label.toLineLabel(this._label));\n\t\treturn newe;\n\t}\n\tisIsolated() {\n\t\treturn this._isIsolated;\n\t}\n\tgetCoordinates() {\n\t\treturn this.pts;\n\t}\n\tsetIsolated(isIsolated) {\n\t\tthis._isIsolated = isIsolated;\n\t}\n\tsetName(name) {\n\t\tthis._name = name;\n\t}\n\tequals(o) {\n\t\tif (!(o instanceof Edge)) return false;\n\t\tvar e = o;\n\t\tif (this.pts.length !== e.pts.length) return false;\n\t\tvar isEqualForward = true;\n\t\tvar isEqualReverse = true;\n\t\tvar iRev = this.pts.length;\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (!this.pts[i].equals2D(e.pts[i])) {\n\t\t\t\tisEqualForward = false;\n\t\t\t}\n\t\t\tif (!this.pts[i].equals2D(e.pts[-- iRev])) {\n\t\t\t\tisEqualReverse = false;\n\t\t\t}\n\t\t\tif (!isEqualForward && !isEqualReverse) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tgetCoordinate() {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.pts.length > 0) return this.pts[0];\n\t\t\treturn null;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet i = arguments[0];\n\t\t\treturn this.pts[i];\n\t\t}\n\t}\n\tprint(out) {\n\t\tout.print(\"edge \" + this._name + \": \");\n\t\tout.print(\"LINESTRING (\");\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (i > 0) out.print(\",\");\n\t\t\tout.print(this.pts[i].x + \" \" + this.pts[i].y);\n\t\t}\n\t\tout.print(\")  \" + this._label + \" \" + this._depthDelta);\n\t}\n\tcomputeIM(im) {\n\t\tEdge.updateIM(this._label, im);\n\t}\n\tisCollapsed() {\n\t\tif (!this._label.isArea()) return false;\n\t\tif (this.pts.length !== 3) return false;\n\t\tif (this.pts[0].equals(this.pts[2])) return true;\n\t\treturn false;\n\t}\n\tisClosed() {\n\t\treturn this.pts[0].equals(this.pts[this.pts.length - 1]);\n\t}\n\tgetMaximumSegmentIndex() {\n\t\treturn this.pts.length - 1;\n\t}\n\tgetDepthDelta() {\n\t\treturn this._depthDelta;\n\t}\n\tgetNumPoints() {\n\t\treturn this.pts.length;\n\t}\n\tprintReverse(out) {\n\t\tout.print(\"edge \" + this._name + \": \");\n\t\tfor (var i = this.pts.length - 1; i >= 0; i--) {\n\t\t\tout.print(this.pts[i] + \" \");\n\t\t}\n\t\tout.println(\"\");\n\t}\n\tgetMonotoneChainEdge() {\n\t\tif (this._mce === null) this._mce = new MonotoneChainEdge(this);\n\t\treturn this._mce;\n\t}\n\tgetEnvelope() {\n\t\tif (this._env === null) {\n\t\t\tthis._env = new Envelope();\n\t\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\t\tthis._env.expandToInclude(this.pts[i]);\n\t\t\t}\n\t\t}\n\t\treturn this._env;\n\t}\n\taddIntersection(li, segmentIndex, geomIndex, intIndex) {\n\t\tvar intPt = new Coordinate(li.getIntersection(intIndex));\n\t\tvar normalizedSegmentIndex = segmentIndex;\n\t\tvar dist = li.getEdgeDistance(geomIndex, intIndex);\n\t\tvar nextSegIndex = normalizedSegmentIndex + 1;\n\t\tif (nextSegIndex < this.pts.length) {\n\t\t\tvar nextPt = this.pts[nextSegIndex];\n\t\t\tif (intPt.equals2D(nextPt)) {\n\t\t\t\tnormalizedSegmentIndex = nextSegIndex;\n\t\t\t\tdist = 0.0;\n\t\t\t}\n\t\t}\n\t\tvar ei = this.eiList.add(intPt, normalizedSegmentIndex, dist);\n\t}\n\ttoString() {\n\t\tvar builder = new StringBuilder();\n\t\tbuilder.append(\"edge \" + this._name + \": \");\n\t\tbuilder.append(\"LINESTRING (\");\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (i > 0) builder.append(\",\");\n\t\t\tbuilder.append(this.pts[i].x + \" \" + this.pts[i].y);\n\t\t}\n\t\tbuilder.append(\")  \" + this._label + \" \" + this._depthDelta);\n\t\treturn builder.toString();\n\t}\n\tisPointwiseEqual(e) {\n\t\tif (this.pts.length !== e.pts.length) return false;\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (!this.pts[i].equals2D(e.pts[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tsetDepthDelta(depthDelta) {\n\t\tthis._depthDelta = depthDelta;\n\t}\n\tgetEdgeIntersectionList() {\n\t\treturn this.eiList;\n\t}\n\taddIntersections(li, segmentIndex, geomIndex) {\n\t\tfor (var i = 0; i < li.getIntersectionNum(); i++) {\n\t\t\tthis.addIntersection(li, segmentIndex, geomIndex, i);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn Edge;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdge.constructor_ = function () {\n\tthis.pts = null;\n\tthis._env = null;\n\tthis.eiList = new EdgeIntersectionList(this);\n\tthis._name = null;\n\tthis._mce = null;\n\tthis._isIsolated = true;\n\tthis._depth = new Depth();\n\tthis._depthDelta = 0;\n\tif (arguments.length === 1) {\n\t\tlet pts = arguments[0];\n\t\tEdge.constructor_.call(this, pts, null);\n\t} else if (arguments.length === 2) {\n\t\tlet pts = arguments[0], label = arguments[1];\n\t\tthis.pts = pts;\n\t\tthis._label = label;\n\t}\n};\n","import Location from '../geom/Location';\nimport EdgeEnd from './EdgeEnd';\nimport Position from './Position';\nimport TopologyException from '../geom/TopologyException';\nimport Label from './Label';\nexport default class DirectedEdge extends EdgeEnd {\n\tconstructor() {\n\t\tsuper();\n\t\tDirectedEdge.constructor_.apply(this, arguments);\n\t}\n\tstatic depthFactor(currLocation, nextLocation) {\n\t\tif (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) return 1; else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) return -1;\n\t\treturn 0;\n\t}\n\tgetNextMin() {\n\t\treturn this._nextMin;\n\t}\n\tgetDepth(position) {\n\t\treturn this._depth[position];\n\t}\n\tsetVisited(isVisited) {\n\t\tthis._isVisited = isVisited;\n\t}\n\tcomputeDirectedLabel() {\n\t\tthis._label = new Label(this._edge.getLabel());\n\t\tif (!this._isForward) this._label.flip();\n\t}\n\tgetNext() {\n\t\treturn this._next;\n\t}\n\tsetDepth(position, depthVal) {\n\t\tif (this._depth[position] !== -999) {\n\t\t\tif (this._depth[position] !== depthVal) throw new TopologyException(\"assigned depths do not match\", this.getCoordinate());\n\t\t}\n\t\tthis._depth[position] = depthVal;\n\t}\n\tisInteriorAreaEdge() {\n\t\tvar isInteriorAreaEdge = true;\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (!(this._label.isArea(i) && this._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {\n\t\t\t\tisInteriorAreaEdge = false;\n\t\t\t}\n\t\t}\n\t\treturn isInteriorAreaEdge;\n\t}\n\tsetNextMin(nextMin) {\n\t\tthis._nextMin = nextMin;\n\t}\n\tprint(out) {\n\t\tsuper.print.call(this, out);\n\t\tout.print(\" \" + this._depth[Position.LEFT] + \"/\" + this._depth[Position.RIGHT]);\n\t\tout.print(\" (\" + this.getDepthDelta() + \")\");\n\t\tif (this._isInResult) out.print(\" inResult\");\n\t}\n\tsetMinEdgeRing(minEdgeRing) {\n\t\tthis._minEdgeRing = minEdgeRing;\n\t}\n\tisLineEdge() {\n\t\tvar isLine = this._label.isLine(0) || this._label.isLine(1);\n\t\tvar isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);\n\t\tvar isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);\n\t\treturn isLine && isExteriorIfArea0 && isExteriorIfArea1;\n\t}\n\tsetEdgeRing(edgeRing) {\n\t\tthis._edgeRing = edgeRing;\n\t}\n\tgetMinEdgeRing() {\n\t\treturn this._minEdgeRing;\n\t}\n\tgetDepthDelta() {\n\t\tvar depthDelta = this._edge.getDepthDelta();\n\t\tif (!this._isForward) depthDelta = -depthDelta;\n\t\treturn depthDelta;\n\t}\n\tsetInResult(isInResult) {\n\t\tthis._isInResult = isInResult;\n\t}\n\tgetSym() {\n\t\treturn this._sym;\n\t}\n\tisForward() {\n\t\treturn this._isForward;\n\t}\n\tgetEdge() {\n\t\treturn this._edge;\n\t}\n\tprintEdge(out) {\n\t\tthis.print(out);\n\t\tout.print(\" \");\n\t\tif (this._isForward) this._edge.print(out); else this._edge.printReverse(out);\n\t}\n\tsetSym(de) {\n\t\tthis._sym = de;\n\t}\n\tsetVisitedEdge(isVisited) {\n\t\tthis.setVisited(isVisited);\n\t\tthis._sym.setVisited(isVisited);\n\t}\n\tsetEdgeDepths(position, depth) {\n\t\tvar depthDelta = this.getEdge().getDepthDelta();\n\t\tif (!this._isForward) depthDelta = -depthDelta;\n\t\tvar directionFactor = 1;\n\t\tif (position === Position.LEFT) directionFactor = -1;\n\t\tvar oppositePos = Position.opposite(position);\n\t\tvar delta = depthDelta * directionFactor;\n\t\tvar oppositeDepth = depth + delta;\n\t\tthis.setDepth(position, depth);\n\t\tthis.setDepth(oppositePos, oppositeDepth);\n\t}\n\tgetEdgeRing() {\n\t\treturn this._edgeRing;\n\t}\n\tisInResult() {\n\t\treturn this._isInResult;\n\t}\n\tsetNext(next) {\n\t\tthis._next = next;\n\t}\n\tisVisited() {\n\t\treturn this._isVisited;\n\t}\n\tgetClass() {\n\t\treturn DirectedEdge;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nDirectedEdge.constructor_ = function () {\n\tthis._isForward = null;\n\tthis._isInResult = false;\n\tthis._isVisited = false;\n\tthis._sym = null;\n\tthis._next = null;\n\tthis._nextMin = null;\n\tthis._edgeRing = null;\n\tthis._minEdgeRing = null;\n\tthis._depth = [0, -999, -999];\n\tlet edge = arguments[0], isForward = arguments[1];\n\tEdgeEnd.constructor_.call(this, edge);\n\tthis._isForward = isForward;\n\tif (isForward) {\n\t\tthis.init(edge.getCoordinate(0), edge.getCoordinate(1));\n\t} else {\n\t\tvar n = edge.getNumPoints() - 1;\n\t\tthis.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));\n\t}\n\tthis.computeDirectedLabel();\n};\n","import Node from './Node';\nexport default class NodeFactory {\n\tconstructor() {\n\t\tNodeFactory.constructor_.apply(this, arguments);\n\t}\n\tcreateNode(coord) {\n\t\treturn new Node(coord, null);\n\t}\n\tgetClass() {\n\t\treturn NodeFactory;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nNodeFactory.constructor_ = function () {};\n","import Location from '../geom/Location';\nimport Coordinate from '../geom/Coordinate';\nimport Node from './Node';\nimport NodeMap from './NodeMap';\nimport Orientation from '../algorithm/Orientation';\nimport DirectedEdge from './DirectedEdge';\nimport System from '../../../../java/lang/System';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Quadrant from './Quadrant';\nimport NodeFactory from './NodeFactory';\nexport default class PlanarGraph {\n\tconstructor() {\n\t\tPlanarGraph.constructor_.apply(this, arguments);\n\t}\n\tstatic linkResultDirectedEdges(nodes) {\n\t\tfor (var nodeit = nodes.iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().linkResultDirectedEdges();\n\t\t}\n\t}\n\tprintEdges(out) {\n\t\tout.println(\"Edges:\");\n\t\tfor (var i = 0; i < this._edges.size(); i++) {\n\t\t\tout.println(\"edge \" + i + \":\");\n\t\t\tvar e = this._edges.get(i);\n\t\t\te.print(out);\n\t\t\te.eiList.print(out);\n\t\t}\n\t}\n\tfind(coord) {\n\t\treturn this._nodes.find(coord);\n\t}\n\taddNode() {\n\t\tif (arguments[0] instanceof Node) {\n\t\t\tlet node = arguments[0];\n\t\t\treturn this._nodes.addNode(node);\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet coord = arguments[0];\n\t\t\treturn this._nodes.addNode(coord);\n\t\t}\n\t}\n\tgetNodeIterator() {\n\t\treturn this._nodes.iterator();\n\t}\n\tlinkResultDirectedEdges() {\n\t\tfor (var nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().linkResultDirectedEdges();\n\t\t}\n\t}\n\tdebugPrintln(o) {\n\t\tSystem.out.println(o);\n\t}\n\tisBoundaryNode(geomIndex, coord) {\n\t\tvar node = this._nodes.find(coord);\n\t\tif (node === null) return false;\n\t\tvar label = node.getLabel();\n\t\tif (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) return true;\n\t\treturn false;\n\t}\n\tlinkAllDirectedEdges() {\n\t\tfor (var nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().linkAllDirectedEdges();\n\t\t}\n\t}\n\tmatchInSameDirection(p0, p1, ep0, ep1) {\n\t\tif (!p0.equals(ep0)) return false;\n\t\tif (Orientation.index(p0, p1, ep1) === Orientation.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) return true;\n\t\treturn false;\n\t}\n\tgetEdgeEnds() {\n\t\treturn this._edgeEndList;\n\t}\n\tdebugPrint(o) {\n\t\tSystem.out.print(o);\n\t}\n\tgetEdgeIterator() {\n\t\treturn this._edges.iterator();\n\t}\n\tfindEdgeInSameDirection(p0, p1) {\n\t\tfor (var i = 0; i < this._edges.size(); i++) {\n\t\t\tvar e = this._edges.get(i);\n\t\t\tvar eCoord = e.getCoordinates();\n\t\t\tif (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e;\n\t\t\tif (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e;\n\t\t}\n\t\treturn null;\n\t}\n\tinsertEdge(e) {\n\t\tthis._edges.add(e);\n\t}\n\tfindEdgeEnd(e) {\n\t\tfor (var i = this.getEdgeEnds().iterator(); i.hasNext(); ) {\n\t\t\tvar ee = i.next();\n\t\t\tif (ee.getEdge() === e) return ee;\n\t\t}\n\t\treturn null;\n\t}\n\taddEdges(edgesToAdd) {\n\t\tfor (var it = edgesToAdd.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tthis._edges.add(e);\n\t\t\tvar de1 = new DirectedEdge(e, true);\n\t\t\tvar de2 = new DirectedEdge(e, false);\n\t\t\tde1.setSym(de2);\n\t\t\tde2.setSym(de1);\n\t\t\tthis.add(de1);\n\t\t\tthis.add(de2);\n\t\t}\n\t}\n\tadd(e) {\n\t\tthis._nodes.add(e);\n\t\tthis._edgeEndList.add(e);\n\t}\n\tgetNodes() {\n\t\treturn this._nodes.values();\n\t}\n\tfindEdge(p0, p1) {\n\t\tfor (var i = 0; i < this._edges.size(); i++) {\n\t\t\tvar e = this._edges.get(i);\n\t\t\tvar eCoord = e.getCoordinates();\n\t\t\tif (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e;\n\t\t}\n\t\treturn null;\n\t}\n\tgetClass() {\n\t\treturn PlanarGraph;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPlanarGraph.constructor_ = function () {\n\tthis._edges = new ArrayList();\n\tthis._nodes = null;\n\tthis._edgeEndList = new ArrayList();\n\tif (arguments.length === 0) {\n\t\tthis._nodes = new NodeMap(new NodeFactory());\n\t} else if (arguments.length === 1) {\n\t\tlet nodeFact = arguments[0];\n\t\tthis._nodes = new NodeMap(nodeFact);\n\t}\n};\n","import PointLocator from '../algorithm/PointLocator';\nimport Location from '../geom/Location';\nimport LineString from '../geom/LineString';\nimport HashMap from '../../../../java/util/HashMap';\nimport Geometry from '../geom/Geometry';\nimport hasInterface from '../../../../hasInterface';\nimport Position from './Position';\nimport Coordinate from '../geom/Coordinate';\nimport Point from '../geom/Point';\nimport Polygon from '../geom/Polygon';\nimport MultiPoint from '../geom/MultiPoint';\nimport SimpleMCSweepLineIntersector from './index/SimpleMCSweepLineIntersector';\nimport LinearRing from '../geom/LinearRing';\nimport BoundaryNodeRule from '../algorithm/BoundaryNodeRule';\nimport Orientation from '../algorithm/Orientation';\nimport SegmentIntersector from './index/SegmentIntersector';\nimport MultiPolygon from '../geom/MultiPolygon';\nimport Label from './Label';\nimport GeometryCollection from '../geom/GeometryCollection';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nimport Polygonal from '../geom/Polygonal';\nimport IndexedPointInAreaLocator from '../algorithm/locate/IndexedPointInAreaLocator';\nimport Assert from '../util/Assert';\nimport Edge from './Edge';\nimport MultiLineString from '../geom/MultiLineString';\nimport PlanarGraph from './PlanarGraph';\nexport default class GeometryGraph extends PlanarGraph {\n\tconstructor() {\n\t\tsuper();\n\t\tGeometryGraph.constructor_.apply(this, arguments);\n\t}\n\tstatic determineBoundary(boundaryNodeRule, boundaryCount) {\n\t\treturn boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR;\n\t}\n\tinsertBoundaryPoint(argIndex, coord) {\n\t\tvar n = this._nodes.addNode(coord);\n\t\tvar lbl = n.getLabel();\n\t\tvar boundaryCount = 1;\n\t\tvar loc = Location.NONE;\n\t\tloc = lbl.getLocation(argIndex, Position.ON);\n\t\tif (loc === Location.BOUNDARY) boundaryCount++;\n\t\tvar newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);\n\t\tlbl.setLocation(argIndex, newLoc);\n\t}\n\tcomputeSelfNodes() {\n\t\tif (arguments.length === 2) {\n\t\t\tlet li = arguments[0], computeRingSelfNodes = arguments[1];\n\t\t\treturn this.computeSelfNodes(li, computeRingSelfNodes, false);\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet li = arguments[0], computeRingSelfNodes = arguments[1], isDoneIfProperInt = arguments[2];\n\t\t\tvar si = new SegmentIntersector(li, true, false);\n\t\t\tsi.setIsDoneIfProperInt(isDoneIfProperInt);\n\t\t\tvar esi = this.createEdgeSetIntersector();\n\t\t\tvar isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;\n\t\t\tvar computeAllSegments = computeRingSelfNodes || !isRings;\n\t\t\tesi.computeIntersections(this._edges, si, computeAllSegments);\n\t\t\tthis.addSelfIntersectionNodes(this._argIndex);\n\t\t\treturn si;\n\t\t}\n\t}\n\tcomputeSplitEdges(edgelist) {\n\t\tfor (var i = this._edges.iterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\te.eiList.addSplitEdges(edgelist);\n\t\t}\n\t}\n\tcomputeEdgeIntersections(g, li, includeProper) {\n\t\tvar si = new SegmentIntersector(li, includeProper, true);\n\t\tsi.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());\n\t\tvar esi = this.createEdgeSetIntersector();\n\t\tesi.computeIntersections(this._edges, g._edges, si);\n\t\treturn si;\n\t}\n\tgetGeometry() {\n\t\treturn this._parentGeom;\n\t}\n\tgetBoundaryNodeRule() {\n\t\treturn this._boundaryNodeRule;\n\t}\n\thasTooFewPoints() {\n\t\treturn this._hasTooFewPoints;\n\t}\n\taddPoint() {\n\t\tif (arguments[0] instanceof Point) {\n\t\t\tlet p = arguments[0];\n\t\t\tvar coord = p.getCoordinate();\n\t\t\tthis.insertPoint(this._argIndex, coord, Location.INTERIOR);\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet pt = arguments[0];\n\t\t\tthis.insertPoint(this._argIndex, pt, Location.INTERIOR);\n\t\t}\n\t}\n\taddPolygon(p) {\n\t\tthis.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);\n\t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n\t\t\tvar hole = p.getInteriorRingN(i);\n\t\t\tthis.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);\n\t\t}\n\t}\n\taddEdge(e) {\n\t\tthis.insertEdge(e);\n\t\tvar coord = e.getCoordinates();\n\t\tthis.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n\t\tthis.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);\n\t}\n\taddLineString(line) {\n\t\tvar coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n\t\tif (coord.length < 2) {\n\t\t\tthis._hasTooFewPoints = true;\n\t\t\tthis._invalidPoint = coord[0];\n\t\t\treturn null;\n\t\t}\n\t\tvar e = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));\n\t\tthis._lineEdgeMap.put(line, e);\n\t\tthis.insertEdge(e);\n\t\tAssert.isTrue(coord.length >= 2, \"found LineString with single point\");\n\t\tthis.insertBoundaryPoint(this._argIndex, coord[0]);\n\t\tthis.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);\n\t}\n\tgetInvalidPoint() {\n\t\treturn this._invalidPoint;\n\t}\n\tgetBoundaryPoints() {\n\t\tvar coll = this.getBoundaryNodes();\n\t\tvar pts = new Array(coll.size()).fill(null);\n\t\tvar i = 0;\n\t\tfor (var it = coll.iterator(); it.hasNext(); ) {\n\t\t\tvar node = it.next();\n\t\t\tpts[i++] = node.getCoordinate().copy();\n\t\t}\n\t\treturn pts;\n\t}\n\tgetBoundaryNodes() {\n\t\tif (this._boundaryNodes === null) this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);\n\t\treturn this._boundaryNodes;\n\t}\n\taddSelfIntersectionNode(argIndex, coord, loc) {\n\t\tif (this.isBoundaryNode(argIndex, coord)) return null;\n\t\tif (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) this.insertBoundaryPoint(argIndex, coord); else this.insertPoint(argIndex, coord, loc);\n\t}\n\taddPolygonRing(lr, cwLeft, cwRight) {\n\t\tif (lr.isEmpty()) return null;\n\t\tvar coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());\n\t\tif (coord.length < 4) {\n\t\t\tthis._hasTooFewPoints = true;\n\t\t\tthis._invalidPoint = coord[0];\n\t\t\treturn null;\n\t\t}\n\t\tvar left = cwLeft;\n\t\tvar right = cwRight;\n\t\tif (Orientation.isCCW(coord)) {\n\t\t\tleft = cwRight;\n\t\t\tright = cwLeft;\n\t\t}\n\t\tvar e = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));\n\t\tthis._lineEdgeMap.put(lr, e);\n\t\tthis.insertEdge(e);\n\t\tthis.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n\t}\n\tinsertPoint(argIndex, coord, onLocation) {\n\t\tvar n = this._nodes.addNode(coord);\n\t\tvar lbl = n.getLabel();\n\t\tif (lbl === null) {\n\t\t\tn._label = new Label(argIndex, onLocation);\n\t\t} else lbl.setLocation(argIndex, onLocation);\n\t}\n\tcreateEdgeSetIntersector() {\n\t\treturn new SimpleMCSweepLineIntersector();\n\t}\n\taddSelfIntersectionNodes(argIndex) {\n\t\tfor (var i = this._edges.iterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n\t\t\tfor (var eiIt = e.eiList.iterator(); eiIt.hasNext(); ) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tthis.addSelfIntersectionNode(argIndex, ei.coord, eLoc);\n\t\t\t}\n\t\t}\n\t}\n\tadd() {\n\t\tif (arguments.length === 1 && arguments[0] instanceof Geometry) {\n\t\t\tlet g = arguments[0];\n\t\t\tif (g.isEmpty()) return null;\n\t\t\tif (g instanceof MultiPolygon) this._useBoundaryDeterminationRule = false;\n\t\t\tif (g instanceof Polygon) this.addPolygon(g); else if (g instanceof LineString) this.addLineString(g); else if (g instanceof Point) this.addPoint(g); else if (g instanceof MultiPoint) this.addCollection(g); else if (g instanceof MultiLineString) this.addCollection(g); else if (g instanceof MultiPolygon) this.addCollection(g); else if (g instanceof GeometryCollection) this.addCollection(g); else throw new UnsupportedOperationException(g.getClass().getName());\n\t\t} else return super.add.apply(this, arguments);\n\t}\n\taddCollection(gc) {\n\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\tvar g = gc.getGeometryN(i);\n\t\t\tthis.add(g);\n\t\t}\n\t}\n\tlocate(pt) {\n\t\tif (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {\n\t\t\tif (this._areaPtLocator === null) {\n\t\t\t\tthis._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);\n\t\t\t}\n\t\t\treturn this._areaPtLocator.locate(pt);\n\t\t}\n\t\treturn this._ptLocator.locate(pt, this._parentGeom);\n\t}\n\tfindEdge() {\n\t\tif (arguments.length === 1 && arguments[0] instanceof LineString) {\n\t\t\tlet line = arguments[0];\n\t\t\treturn this._lineEdgeMap.get(line);\n\t\t} else return super.findEdge.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn GeometryGraph;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGeometryGraph.constructor_ = function () {\n\tthis._parentGeom = null;\n\tthis._lineEdgeMap = new HashMap();\n\tthis._boundaryNodeRule = null;\n\tthis._useBoundaryDeterminationRule = true;\n\tthis._argIndex = null;\n\tthis._boundaryNodes = null;\n\tthis._hasTooFewPoints = false;\n\tthis._invalidPoint = null;\n\tthis._areaPtLocator = null;\n\tthis._ptLocator = new PointLocator();\n\tif (arguments.length === 2) {\n\t\tlet argIndex = arguments[0], parentGeom = arguments[1];\n\t\tGeometryGraph.constructor_.call(this, argIndex, parentGeom, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n\t} else if (arguments.length === 3) {\n\t\tlet argIndex = arguments[0], parentGeom = arguments[1], boundaryNodeRule = arguments[2];\n\t\tthis._argIndex = argIndex;\n\t\tthis._parentGeom = parentGeom;\n\t\tthis._boundaryNodeRule = boundaryNodeRule;\n\t\tif (parentGeom !== null) {\n\t\t\tthis.add(parentGeom);\n\t\t}\n\t}\n};\n","import Location from '../../geom/Location';\nimport EdgeEnd from '../../geomgraph/EdgeEnd';\nimport Position from '../../geomgraph/Position';\nimport GeometryGraph from '../../geomgraph/GeometryGraph';\nimport Label from '../../geomgraph/Label';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Edge from '../../geomgraph/Edge';\nexport default class EdgeEndBundle extends EdgeEnd {\n\tconstructor() {\n\t\tsuper();\n\t\tEdgeEndBundle.constructor_.apply(this, arguments);\n\t}\n\tinsert(e) {\n\t\tthis._edgeEnds.add(e);\n\t}\n\tprint(out) {\n\t\tout.println(\"EdgeEndBundle--> Label: \" + this._label);\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ee = it.next();\n\t\t\tee.print(out);\n\t\t\tout.println();\n\t\t}\n\t}\n\titerator() {\n\t\treturn this._edgeEnds.iterator();\n\t}\n\tgetEdgeEnds() {\n\t\treturn this._edgeEnds;\n\t}\n\tcomputeLabelOn(geomIndex, boundaryNodeRule) {\n\t\tvar boundaryCount = 0;\n\t\tvar foundInterior = false;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar loc = e.getLabel().getLocation(geomIndex);\n\t\t\tif (loc === Location.BOUNDARY) boundaryCount++;\n\t\t\tif (loc === Location.INTERIOR) foundInterior = true;\n\t\t}\n\t\tvar loc = Location.NONE;\n\t\tif (foundInterior) loc = Location.INTERIOR;\n\t\tif (boundaryCount > 0) {\n\t\t\tloc = GeometryGraph.determineBoundary(boundaryNodeRule, boundaryCount);\n\t\t}\n\t\tthis._label.setLocation(geomIndex, loc);\n\t}\n\tcomputeLabelSide(geomIndex, side) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tif (e.getLabel().isArea()) {\n\t\t\t\tvar loc = e.getLabel().getLocation(geomIndex, side);\n\t\t\t\tif (loc === Location.INTERIOR) {\n\t\t\t\t\tthis._label.setLocation(geomIndex, side, Location.INTERIOR);\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (loc === Location.EXTERIOR) this._label.setLocation(geomIndex, side, Location.EXTERIOR);\n\t\t\t}\n\t\t}\n\t}\n\tgetLabel() {\n\t\treturn this._label;\n\t}\n\tcomputeLabelSides(geomIndex) {\n\t\tthis.computeLabelSide(geomIndex, Position.LEFT);\n\t\tthis.computeLabelSide(geomIndex, Position.RIGHT);\n\t}\n\tupdateIM(im) {\n\t\tEdge.updateIM(this._label, im);\n\t}\n\tcomputeLabel(boundaryNodeRule) {\n\t\tvar isArea = false;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tif (e.getLabel().isArea()) isArea = true;\n\t\t}\n\t\tif (isArea) this._label = new Label(Location.NONE, Location.NONE, Location.NONE); else this._label = new Label(Location.NONE);\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tthis.computeLabelOn(i, boundaryNodeRule);\n\t\t\tif (isArea) this.computeLabelSides(i);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn EdgeEndBundle;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdgeEndBundle.constructor_ = function () {\n\tthis._edgeEnds = new ArrayList();\n\tif (arguments.length === 1) {\n\t\tlet e = arguments[0];\n\t\tEdgeEndBundle.constructor_.call(this, null, e);\n\t} else if (arguments.length === 2) {\n\t\tlet boundaryNodeRule = arguments[0], e = arguments[1];\n\t\tEdgeEnd.constructor_.call(this, e.getEdge(), e.getCoordinate(), e.getDirectedCoordinate(), new Label(e.getLabel()));\n\t\tthis.insert(e);\n\t}\n};\n","import EdgeEndStar from '../../geomgraph/EdgeEndStar';\nimport EdgeEndBundle from './EdgeEndBundle';\nexport default class EdgeEndBundleStar extends EdgeEndStar {\n\tconstructor() {\n\t\tsuper();\n\t\tEdgeEndBundleStar.constructor_.apply(this, arguments);\n\t}\n\tupdateIM(im) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar esb = it.next();\n\t\t\tesb.updateIM(im);\n\t\t}\n\t}\n\tinsert(e) {\n\t\tvar eb = this._edgeMap.get(e);\n\t\tif (eb === null) {\n\t\t\teb = new EdgeEndBundle(e);\n\t\t\tthis.insertEdgeEnd(e, eb);\n\t\t} else {\n\t\t\teb.insert(e);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn EdgeEndBundleStar;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdgeEndBundleStar.constructor_ = function () {};\n","import Node from '../../geomgraph/Node';\nexport default class RelateNode extends Node {\n\tconstructor() {\n\t\tsuper();\n\t\tRelateNode.constructor_.apply(this, arguments);\n\t}\n\tupdateIMFromEdges(im) {\n\t\tthis._edges.updateIM(im);\n\t}\n\tcomputeIM(im) {\n\t\tim.setAtLeastIfValid(this._label.getLocation(0), this._label.getLocation(1), 0);\n\t}\n\tgetClass() {\n\t\treturn RelateNode;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRelateNode.constructor_ = function () {\n\tlet coord = arguments[0], edges = arguments[1];\n\tNode.constructor_.call(this, coord, edges);\n};\n","import EdgeEndBundleStar from './EdgeEndBundleStar';\nimport RelateNode from './RelateNode';\nimport NodeFactory from '../../geomgraph/NodeFactory';\nexport default class RelateNodeFactory extends NodeFactory {\n\tconstructor() {\n\t\tsuper();\n\t\tRelateNodeFactory.constructor_.apply(this, arguments);\n\t}\n\tcreateNode(coord) {\n\t\treturn new RelateNode(coord, new EdgeEndBundleStar());\n\t}\n\tgetClass() {\n\t\treturn RelateNodeFactory;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRelateNodeFactory.constructor_ = function () {};\n","import PointLocator from '../../algorithm/PointLocator';\nimport Location from '../../geom/Location';\nimport IntersectionMatrix from '../../geom/IntersectionMatrix';\nimport EdgeEndBuilder from './EdgeEndBuilder';\nimport NodeMap from '../../geomgraph/NodeMap';\nimport RelateNodeFactory from './RelateNodeFactory';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport RobustLineIntersector from '../../algorithm/RobustLineIntersector';\nimport Assert from '../../util/Assert';\nexport default class RelateComputer {\n\tconstructor() {\n\t\tRelateComputer.constructor_.apply(this, arguments);\n\t}\n\tinsertEdgeEnds(ee) {\n\t\tfor (var i = ee.iterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tthis._nodes.add(e);\n\t\t}\n\t}\n\tcomputeProperIntersectionIM(intersector, im) {\n\t\tvar dimA = this._arg[0].getGeometry().getDimension();\n\t\tvar dimB = this._arg[1].getGeometry().getDimension();\n\t\tvar hasProper = intersector.hasProperIntersection();\n\t\tvar hasProperInterior = intersector.hasProperInteriorIntersection();\n\t\tif (dimA === 2 && dimB === 2) {\n\t\t\tif (hasProper) im.setAtLeast(\"212101212\");\n\t\t} else if (dimA === 2 && dimB === 1) {\n\t\t\tif (hasProper) im.setAtLeast(\"FFF0FFFF2\");\n\t\t\tif (hasProperInterior) im.setAtLeast(\"1FFFFF1FF\");\n\t\t} else if (dimA === 1 && dimB === 2) {\n\t\t\tif (hasProper) im.setAtLeast(\"F0FFFFFF2\");\n\t\t\tif (hasProperInterior) im.setAtLeast(\"1F1FFFFFF\");\n\t\t} else if (dimA === 1 && dimB === 1) {\n\t\t\tif (hasProperInterior) im.setAtLeast(\"0FFFFFFFF\");\n\t\t}\n\t}\n\tlabelIsolatedEdges(thisIndex, targetIndex) {\n\t\tfor (var ei = this._arg[thisIndex].getEdgeIterator(); ei.hasNext(); ) {\n\t\t\tvar e = ei.next();\n\t\t\tif (e.isIsolated()) {\n\t\t\t\tthis.labelIsolatedEdge(e, targetIndex, this._arg[targetIndex].getGeometry());\n\t\t\t\tthis._isolatedEdges.add(e);\n\t\t\t}\n\t\t}\n\t}\n\tlabelIsolatedEdge(e, targetIndex, target) {\n\t\tif (target.getDimension() > 0) {\n\t\t\tvar loc = this._ptLocator.locate(e.getCoordinate(), target);\n\t\t\te.getLabel().setAllLocations(targetIndex, loc);\n\t\t} else {\n\t\t\te.getLabel().setAllLocations(targetIndex, Location.EXTERIOR);\n\t\t}\n\t}\n\tcomputeIM() {\n\t\tvar im = new IntersectionMatrix();\n\t\tim.set(Location.EXTERIOR, Location.EXTERIOR, 2);\n\t\tif (!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal())) {\n\t\t\tthis.computeDisjointIM(im);\n\t\t\treturn im;\n\t\t}\n\t\tthis._arg[0].computeSelfNodes(this._li, false);\n\t\tthis._arg[1].computeSelfNodes(this._li, false);\n\t\tvar intersector = this._arg[0].computeEdgeIntersections(this._arg[1], this._li, false);\n\t\tthis.computeIntersectionNodes(0);\n\t\tthis.computeIntersectionNodes(1);\n\t\tthis.copyNodesAndLabels(0);\n\t\tthis.copyNodesAndLabels(1);\n\t\tthis.labelIsolatedNodes();\n\t\tthis.computeProperIntersectionIM(intersector, im);\n\t\tvar eeBuilder = new EdgeEndBuilder();\n\t\tvar ee0 = eeBuilder.computeEdgeEnds(this._arg[0].getEdgeIterator());\n\t\tthis.insertEdgeEnds(ee0);\n\t\tvar ee1 = eeBuilder.computeEdgeEnds(this._arg[1].getEdgeIterator());\n\t\tthis.insertEdgeEnds(ee1);\n\t\tthis.labelNodeEdges();\n\t\tthis.labelIsolatedEdges(0, 1);\n\t\tthis.labelIsolatedEdges(1, 0);\n\t\tthis.updateIM(im);\n\t\treturn im;\n\t}\n\tlabelNodeEdges() {\n\t\tfor (var ni = this._nodes.iterator(); ni.hasNext(); ) {\n\t\t\tvar node = ni.next();\n\t\t\tnode.getEdges().computeLabelling(this._arg);\n\t\t}\n\t}\n\tcopyNodesAndLabels(argIndex) {\n\t\tfor (var i = this._arg[argIndex].getNodeIterator(); i.hasNext(); ) {\n\t\t\tvar graphNode = i.next();\n\t\t\tvar newNode = this._nodes.addNode(graphNode.getCoordinate());\n\t\t\tnewNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n\t\t}\n\t}\n\tlabelIntersectionNodes(argIndex) {\n\t\tfor (var i = this._arg[argIndex].getEdgeIterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n\t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext(); ) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tvar n = this._nodes.find(ei.coord);\n\t\t\t\tif (n.getLabel().isNull(argIndex)) {\n\t\t\t\t\tif (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex); else n.setLabel(argIndex, Location.INTERIOR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlabelIsolatedNode(n, targetIndex) {\n\t\tvar loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());\n\t\tn.getLabel().setAllLocations(targetIndex, loc);\n\t}\n\tcomputeIntersectionNodes(argIndex) {\n\t\tfor (var i = this._arg[argIndex].getEdgeIterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n\t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext(); ) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tvar n = this._nodes.addNode(ei.coord);\n\t\t\t\tif (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex); else {\n\t\t\t\t\tif (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, Location.INTERIOR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlabelIsolatedNodes() {\n\t\tfor (var ni = this._nodes.iterator(); ni.hasNext(); ) {\n\t\t\tvar n = ni.next();\n\t\t\tvar label = n.getLabel();\n\t\t\tAssert.isTrue(label.getGeometryCount() > 0, \"node with empty label found\");\n\t\t\tif (n.isIsolated()) {\n\t\t\t\tif (label.isNull(0)) this.labelIsolatedNode(n, 0); else this.labelIsolatedNode(n, 1);\n\t\t\t}\n\t\t}\n\t}\n\tupdateIM(im) {\n\t\tfor (var ei = this._isolatedEdges.iterator(); ei.hasNext(); ) {\n\t\t\tvar e = ei.next();\n\t\t\te.updateIM(im);\n\t\t}\n\t\tfor (var ni = this._nodes.iterator(); ni.hasNext(); ) {\n\t\t\tvar node = ni.next();\n\t\t\tnode.updateIM(im);\n\t\t\tnode.updateIMFromEdges(im);\n\t\t}\n\t}\n\tcomputeDisjointIM(im) {\n\t\tvar ga = this._arg[0].getGeometry();\n\t\tif (!ga.isEmpty()) {\n\t\t\tim.set(Location.INTERIOR, Location.EXTERIOR, ga.getDimension());\n\t\t\tim.set(Location.BOUNDARY, Location.EXTERIOR, ga.getBoundaryDimension());\n\t\t}\n\t\tvar gb = this._arg[1].getGeometry();\n\t\tif (!gb.isEmpty()) {\n\t\t\tim.set(Location.EXTERIOR, Location.INTERIOR, gb.getDimension());\n\t\t\tim.set(Location.EXTERIOR, Location.BOUNDARY, gb.getBoundaryDimension());\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn RelateComputer;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRelateComputer.constructor_ = function () {\n\tthis._li = new RobustLineIntersector();\n\tthis._ptLocator = new PointLocator();\n\tthis._arg = null;\n\tthis._nodes = new NodeMap(new RelateNodeFactory());\n\tthis._im = null;\n\tthis._isolatedEdges = new ArrayList();\n\tthis._invalidPoint = null;\n\tlet arg = arguments[0];\n\tthis._arg = arg;\n};\n","import BoundaryNodeRule from '../algorithm/BoundaryNodeRule';\nimport GeometryGraph from '../geomgraph/GeometryGraph';\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector';\nexport default class GeometryGraphOperation {\n\tconstructor() {\n\t\tGeometryGraphOperation.constructor_.apply(this, arguments);\n\t}\n\tgetArgGeometry(i) {\n\t\treturn this._arg[i].getGeometry();\n\t}\n\tsetComputationPrecision(pm) {\n\t\tthis._resultPrecisionModel = pm;\n\t\tthis._li.setPrecisionModel(this._resultPrecisionModel);\n\t}\n\tgetClass() {\n\t\treturn GeometryGraphOperation;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGeometryGraphOperation.constructor_ = function () {\n\tthis._li = new RobustLineIntersector();\n\tthis._resultPrecisionModel = null;\n\tthis._arg = null;\n\tif (arguments.length === 1) {\n\t\tlet g0 = arguments[0];\n\t\tthis.setComputationPrecision(g0.getPrecisionModel());\n\t\tthis._arg = new Array(1).fill(null);\n\t\tthis._arg[0] = new GeometryGraph(0, g0);\n\t\t;\n\t} else if (arguments.length === 2) {\n\t\tlet g0 = arguments[0], g1 = arguments[1];\n\t\tGeometryGraphOperation.constructor_.call(this, g0, g1, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n\t} else if (arguments.length === 3) {\n\t\tlet g0 = arguments[0], g1 = arguments[1], boundaryNodeRule = arguments[2];\n\t\tif (g0.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) this.setComputationPrecision(g0.getPrecisionModel()); else this.setComputationPrecision(g1.getPrecisionModel());\n\t\tthis._arg = new Array(2).fill(null);\n\t\tthis._arg[0] = new GeometryGraph(0, g0, boundaryNodeRule);\n\t\tthis._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);\n\t}\n};\n","import LineString from '../../geom/LineString';\nimport Coordinate from '../../geom/Coordinate';\nimport Point from '../../geom/Point';\nimport Polygon from '../../geom/Polygon';\nexport default class RectangleContains {\n\tconstructor() {\n\t\tRectangleContains.constructor_.apply(this, arguments);\n\t}\n\tstatic contains(rectangle, b) {\n\t\tvar rc = new RectangleContains(rectangle);\n\t\treturn rc.contains(b);\n\t}\n\tisContainedInBoundary(geom) {\n\t\tif (geom instanceof Polygon) return false;\n\t\tif (geom instanceof Point) return this.isPointContainedInBoundary(geom);\n\t\tif (geom instanceof LineString) return this.isLineStringContainedInBoundary(geom);\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar comp = geom.getGeometryN(i);\n\t\t\tif (!this.isContainedInBoundary(comp)) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tisLineSegmentContainedInBoundary(p0, p1) {\n\t\tif (p0.equals(p1)) return this.isPointContainedInBoundary(p0);\n\t\tif (p0.x === p1.x) {\n\t\t\tif (p0.x === this._rectEnv.getMinX() || p0.x === this._rectEnv.getMaxX()) return true;\n\t\t} else if (p0.y === p1.y) {\n\t\t\tif (p0.y === this._rectEnv.getMinY() || p0.y === this._rectEnv.getMaxY()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\tisLineStringContainedInBoundary(line) {\n\t\tvar seq = line.getCoordinateSequence();\n\t\tvar p0 = new Coordinate();\n\t\tvar p1 = new Coordinate();\n\t\tfor (var i = 0; i < seq.size() - 1; i++) {\n\t\t\tseq.getCoordinate(i, p0);\n\t\t\tseq.getCoordinate(i + 1, p1);\n\t\t\tif (!this.isLineSegmentContainedInBoundary(p0, p1)) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tisPointContainedInBoundary() {\n\t\tif (arguments[0] instanceof Point) {\n\t\t\tlet point = arguments[0];\n\t\t\treturn this.isPointContainedInBoundary(point.getCoordinate());\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet pt = arguments[0];\n\t\t\treturn pt.x === this._rectEnv.getMinX() || pt.x === this._rectEnv.getMaxX() || pt.y === this._rectEnv.getMinY() || pt.y === this._rectEnv.getMaxY();\n\t\t}\n\t}\n\tcontains(geom) {\n\t\tif (!this._rectEnv.contains(geom.getEnvelopeInternal())) return false;\n\t\tif (this.isContainedInBoundary(geom)) return false;\n\t\treturn true;\n\t}\n\tgetClass() {\n\t\treturn RectangleContains;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRectangleContains.constructor_ = function () {\n\tthis._rectEnv = null;\n\tlet rectangle = arguments[0];\n\tthis._rectEnv = rectangle.getEnvelopeInternal();\n};\n","import Coordinate from '../geom/Coordinate';\nimport RobustLineIntersector from './RobustLineIntersector';\nimport Envelope from '../geom/Envelope';\nexport default class RectangleLineIntersector {\n\tconstructor() {\n\t\tRectangleLineIntersector.constructor_.apply(this, arguments);\n\t}\n\tintersects(p0, p1) {\n\t\tvar segEnv = new Envelope(p0, p1);\n\t\tif (!this._rectEnv.intersects(segEnv)) return false;\n\t\tif (this._rectEnv.intersects(p0)) return true;\n\t\tif (this._rectEnv.intersects(p1)) return true;\n\t\tif (p0.compareTo(p1) > 0) {\n\t\t\tvar tmp = p0;\n\t\t\tp0 = p1;\n\t\t\tp1 = tmp;\n\t\t}\n\t\tvar isSegUpwards = false;\n\t\tif (p1.y > p0.y) isSegUpwards = true;\n\t\tif (isSegUpwards) {\n\t\t\tthis._li.computeIntersection(p0, p1, this._diagDown0, this._diagDown1);\n\t\t} else {\n\t\t\tthis._li.computeIntersection(p0, p1, this._diagUp0, this._diagUp1);\n\t\t}\n\t\tif (this._li.hasIntersection()) return true;\n\t\treturn false;\n\t}\n\tgetClass() {\n\t\treturn RectangleLineIntersector;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRectangleLineIntersector.constructor_ = function () {\n\tthis._li = new RobustLineIntersector();\n\tthis._rectEnv = null;\n\tthis._diagUp0 = null;\n\tthis._diagUp1 = null;\n\tthis._diagDown0 = null;\n\tthis._diagDown1 = null;\n\tlet rectEnv = arguments[0];\n\tthis._rectEnv = rectEnv;\n\tthis._diagUp0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMinY());\n\tthis._diagUp1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMaxY());\n\tthis._diagDown0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMaxY());\n\tthis._diagDown1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMinY());\n};\n","import GeometryCollection from '../GeometryCollection';\nexport default class ShortCircuitedGeometryVisitor {\n\tconstructor() {\n\t\tShortCircuitedGeometryVisitor.constructor_.apply(this, arguments);\n\t}\n\tapplyTo(geom) {\n\t\tfor (var i = 0; i < geom.getNumGeometries() && !this._isDone; i++) {\n\t\t\tvar element = geom.getGeometryN(i);\n\t\t\tif (!(element instanceof GeometryCollection)) {\n\t\t\t\tthis.visit(element);\n\t\t\t\tif (this.isDone()) {\n\t\t\t\t\tthis._isDone = true;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else this.applyTo(element);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn ShortCircuitedGeometryVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nShortCircuitedGeometryVisitor.constructor_ = function () {\n\tthis._isDone = false;\n};\n","import Coordinate from '../../geom/Coordinate';\nimport Polygon from '../../geom/Polygon';\nimport RectangleLineIntersector from '../../algorithm/RectangleLineIntersector';\nimport ShortCircuitedGeometryVisitor from '../../geom/util/ShortCircuitedGeometryVisitor';\nimport SimplePointInAreaLocator from '../../algorithm/locate/SimplePointInAreaLocator';\nimport LinearComponentExtracter from '../../geom/util/LinearComponentExtracter';\nexport default class RectangleIntersects {\n\tconstructor() {\n\t\tRectangleIntersects.constructor_.apply(this, arguments);\n\t}\n\tstatic intersects(rectangle, b) {\n\t\tvar rp = new RectangleIntersects(rectangle);\n\t\treturn rp.intersects(b);\n\t}\n\tintersects(geom) {\n\t\tif (!this._rectEnv.intersects(geom.getEnvelopeInternal())) return false;\n\t\tvar visitor = new EnvelopeIntersectsVisitor(this._rectEnv);\n\t\tvisitor.applyTo(geom);\n\t\tif (visitor.intersects()) return true;\n\t\tvar ecpVisitor = new GeometryContainsPointVisitor(this._rectangle);\n\t\tecpVisitor.applyTo(geom);\n\t\tif (ecpVisitor.containsPoint()) return true;\n\t\tvar riVisitor = new RectangleIntersectsSegmentVisitor(this._rectangle);\n\t\triVisitor.applyTo(geom);\n\t\tif (riVisitor.intersects()) return true;\n\t\treturn false;\n\t}\n\tgetClass() {\n\t\treturn RectangleIntersects;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRectangleIntersects.constructor_ = function () {\n\tthis._rectangle = null;\n\tthis._rectEnv = null;\n\tlet rectangle = arguments[0];\n\tthis._rectangle = rectangle;\n\tthis._rectEnv = rectangle.getEnvelopeInternal();\n};\nclass EnvelopeIntersectsVisitor extends ShortCircuitedGeometryVisitor {\n\tconstructor() {\n\t\tsuper();\n\t\tEnvelopeIntersectsVisitor.constructor_.apply(this, arguments);\n\t}\n\tisDone() {\n\t\treturn this._intersects === true;\n\t}\n\tvisit(element) {\n\t\tvar elementEnv = element.getEnvelopeInternal();\n\t\tif (!this._rectEnv.intersects(elementEnv)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this._rectEnv.contains(elementEnv)) {\n\t\t\tthis._intersects = true;\n\t\t\treturn null;\n\t\t}\n\t\tif (elementEnv.getMinX() >= this._rectEnv.getMinX() && elementEnv.getMaxX() <= this._rectEnv.getMaxX()) {\n\t\t\tthis._intersects = true;\n\t\t\treturn null;\n\t\t}\n\t\tif (elementEnv.getMinY() >= this._rectEnv.getMinY() && elementEnv.getMaxY() <= this._rectEnv.getMaxY()) {\n\t\t\tthis._intersects = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\tintersects() {\n\t\treturn this._intersects;\n\t}\n\tgetClass() {\n\t\treturn EnvelopeIntersectsVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEnvelopeIntersectsVisitor.constructor_ = function () {\n\tthis._rectEnv = null;\n\tthis._intersects = false;\n\tlet rectEnv = arguments[0];\n\tthis._rectEnv = rectEnv;\n};\nclass GeometryContainsPointVisitor extends ShortCircuitedGeometryVisitor {\n\tconstructor() {\n\t\tsuper();\n\t\tGeometryContainsPointVisitor.constructor_.apply(this, arguments);\n\t}\n\tisDone() {\n\t\treturn this._containsPoint === true;\n\t}\n\tvisit(geom) {\n\t\tif (!(geom instanceof Polygon)) return null;\n\t\tvar elementEnv = geom.getEnvelopeInternal();\n\t\tif (!this._rectEnv.intersects(elementEnv)) return null;\n\t\tvar rectPt = new Coordinate();\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tthis._rectSeq.getCoordinate(i, rectPt);\n\t\t\tif (!elementEnv.contains(rectPt)) continue;\n\t\t\tif (SimplePointInAreaLocator.containsPointInPolygon(rectPt, geom)) {\n\t\t\t\tthis._containsPoint = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\tcontainsPoint() {\n\t\treturn this._containsPoint;\n\t}\n\tgetClass() {\n\t\treturn GeometryContainsPointVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGeometryContainsPointVisitor.constructor_ = function () {\n\tthis._rectSeq = null;\n\tthis._rectEnv = null;\n\tthis._containsPoint = false;\n\tlet rectangle = arguments[0];\n\tthis._rectSeq = rectangle.getExteriorRing().getCoordinateSequence();\n\tthis._rectEnv = rectangle.getEnvelopeInternal();\n};\nclass RectangleIntersectsSegmentVisitor extends ShortCircuitedGeometryVisitor {\n\tconstructor() {\n\t\tsuper();\n\t\tRectangleIntersectsSegmentVisitor.constructor_.apply(this, arguments);\n\t}\n\tintersects() {\n\t\treturn this._hasIntersection;\n\t}\n\tisDone() {\n\t\treturn this._hasIntersection === true;\n\t}\n\tvisit(geom) {\n\t\tvar elementEnv = geom.getEnvelopeInternal();\n\t\tif (!this._rectEnv.intersects(elementEnv)) return null;\n\t\tvar lines = LinearComponentExtracter.getLines(geom);\n\t\tthis.checkIntersectionWithLineStrings(lines);\n\t}\n\tcheckIntersectionWithLineStrings(lines) {\n\t\tfor (var i = lines.iterator(); i.hasNext(); ) {\n\t\t\tvar testLine = i.next();\n\t\t\tthis.checkIntersectionWithSegments(testLine);\n\t\t\tif (this._hasIntersection) return null;\n\t\t}\n\t}\n\tcheckIntersectionWithSegments(testLine) {\n\t\tvar seq1 = testLine.getCoordinateSequence();\n\t\tfor (var j = 1; j < seq1.size(); j++) {\n\t\t\tseq1.getCoordinate(j - 1, this._p0);\n\t\t\tseq1.getCoordinate(j, this._p1);\n\t\t\tif (this._rectIntersector.intersects(this._p0, this._p1)) {\n\t\t\t\tthis._hasIntersection = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn RectangleIntersectsSegmentVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRectangleIntersectsSegmentVisitor.constructor_ = function () {\n\tthis._rectEnv = null;\n\tthis._rectIntersector = null;\n\tthis._hasIntersection = false;\n\tthis._p0 = new Coordinate();\n\tthis._p1 = new Coordinate();\n\tlet rectangle = arguments[0];\n\tthis._rectEnv = rectangle.getEnvelopeInternal();\n\tthis._rectIntersector = new RectangleLineIntersector(this._rectEnv);\n};\n","import RelateComputer from './RelateComputer';\nimport GeometryGraphOperation from '../GeometryGraphOperation';\nimport RectangleContains from '../predicate/RectangleContains';\nimport RectangleIntersects from '../predicate/RectangleIntersects';\nexport default class RelateOp extends GeometryGraphOperation {\n\tconstructor() {\n\t\tsuper();\n\t\tRelateOp.constructor_.apply(this, arguments);\n\t}\n\tstatic covers(g1, g2) {\n\t\tif (g2.getDimension() === 2 && g1.getDimension() < 2) {\n\t\t\treturn false;\n\t\t}\n\t\tif (g2.getDimension() === 1 && g1.getDimension() < 1 && g2.getLength() > 0.0) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!g1.getEnvelopeInternal().covers(g2.getEnvelopeInternal())) return false;\n\t\tif (g1.isRectangle()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn new RelateOp(g1, g2).getIntersectionMatrix().isCovers();\n\t}\n\tstatic intersects(g1, g2) {\n\t\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\t\tif (g1.isRectangle()) {\n\t\t\treturn RectangleIntersects.intersects(g1, g2);\n\t\t}\n\t\tif (g2.isRectangle()) {\n\t\t\treturn RectangleIntersects.intersects(g2, g1);\n\t\t}\n\t\tif (g1.isGeometryCollection() || g2.isGeometryCollection()) {\n\t\t\tvar r = false;\n\t\t\tfor (var i = 0; i < g1.getNumGeometries(); i++) {\n\t\t\t\tfor (var j = 0; j < g2.getNumGeometries(); j++) {\n\t\t\t\t\tif (g1.getGeometryN(i).intersects(g2.getGeometryN(j))) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn new RelateOp(g1, g2).getIntersectionMatrix().isIntersects();\n\t}\n\tstatic touches(g1, g2) {\n\t\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\t\treturn new RelateOp(g1, g2).getIntersectionMatrix().isTouches(g1.getDimension(), g2.getDimension());\n\t}\n\tstatic relate() {\n\t\tif (arguments.length === 2) {\n\t\t\tlet a = arguments[0], b = arguments[1];\n\t\t\tvar relOp = new RelateOp(a, b);\n\t\t\tvar im = relOp.getIntersectionMatrix();\n\t\t\treturn im;\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet a = arguments[0], b = arguments[1], boundaryNodeRule = arguments[2];\n\t\t\tvar relOp = new RelateOp(a, b, boundaryNodeRule);\n\t\t\tvar im = relOp.getIntersectionMatrix();\n\t\t\treturn im;\n\t\t}\n\t}\n\tstatic overlaps(g1, g2) {\n\t\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\t\treturn new RelateOp(g1, g2).getIntersectionMatrix().isOverlaps(g1.getDimension(), g2.getDimension());\n\t}\n\tstatic crosses(g1, g2) {\n\t\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\t\treturn new RelateOp(g1, g2).getIntersectionMatrix().isCrosses(g1.getDimension(), g2.getDimension());\n\t}\n\tstatic contains(g1, g2) {\n\t\tif (g2.getDimension() === 2 && g1.getDimension() < 2) {\n\t\t\treturn false;\n\t\t}\n\t\tif (g2.getDimension() === 1 && g1.getDimension() < 1 && g2.getLength() > 0.0) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!g1.getEnvelopeInternal().contains(g2.getEnvelopeInternal())) return false;\n\t\tif (g1.isRectangle()) {\n\t\t\treturn RectangleContains.contains(g1, g2);\n\t\t}\n\t\treturn new RelateOp(g1, g2).getIntersectionMatrix().isContains();\n\t}\n\tgetIntersectionMatrix() {\n\t\treturn this._relate.computeIM();\n\t}\n\tgetClass() {\n\t\treturn RelateOp;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRelateOp.constructor_ = function () {\n\tthis._relate = null;\n\tif (arguments.length === 2) {\n\t\tlet g0 = arguments[0], g1 = arguments[1];\n\t\tGeometryGraphOperation.constructor_.call(this, g0, g1);\n\t\tthis._relate = new RelateComputer(this._arg);\n\t} else if (arguments.length === 3) {\n\t\tlet g0 = arguments[0], g1 = arguments[1], boundaryNodeRule = arguments[2];\n\t\tGeometryGraphOperation.constructor_.call(this, g0, g1, boundaryNodeRule);\n\t\tthis._relate = new RelateComputer(this._arg);\n\t}\n};\n","import { GeoJSONReader } from 'jsts/org/locationtech/jts/io';\nimport RelateOp from 'jsts/org/locationtech/jts/operation/relate/RelateOp';\n\n/**\n * @classdesc\n * @api\n */\nclass Base {\n  /**\n   * This function get a function filter\n   *\n   * @public\n   * @protected\n   * @function\n   */\n  getFunctionFilter() {}\n\n  /**\n   * This function execute a function filter\n   *\n   * @protected\n   * @param {Array<M.Feature>} features - Features on which the filter runs\n   * @function\n   */\n  execute(features) {}\n\n  /**\n   * This function execute a function filter\n   *\n   * @protected\n   * @param {Array<M.Feature>} features - Features on which the filter runs\n   * @return {Array<M.Feature>} Result of execute\n   * @function\n   */\n  toCQL() {}\n}\n\n/**\n * @classdesc\n * @api\n */\nclass Function extends Base {\n  /**\n   * Creates a Filter Function to filter features\n   *\n   * @param {function} filterFunction - Function to execute\n   * @api\n   */\n  constructor(filterFunction, options = {}) {\n    super();\n    /**\n     * Function to execute\n     * @private\n     * @type {function}\n     */\n    this.filterFunction_ = filterFunction;\n\n    /**\n     * Filter CQL\n     * @private\n     * @type {String}\n     */\n    this.cqlFilter_ = '';\n    if (!M.utils.isNullOrEmpty(options.cqlFilter)) {\n      this.cqlFilter_ = options.cqlFilter;\n    }\n  }\n\n  /**\n   * This function set a function filter\n   *\n   * @public\n   * @function\n   * @api\n   */\n  setFunction(filterFunction) {\n    this.filterFunction_ = filterFunction;\n  }\n\n  /**\n   * This function get a function filter\n   *\n   * @public\n   * @function\n   * @return {M.filter.Function} filter to execute\n   * @api\n   */\n  getFunctionFilter() {\n    return this.filterFunction_;\n  }\n\n  /**\n   * This function execute a function filter\n   *\n   * @public\n   * @function\n   * @param {Array<M.Feature>} features - Features on which the filter runs\n   * @return {Array<M.Feature>} features to passed filter\n   * @api\n   */\n  execute(features) {\n    return features.filter(this.filterFunction_);\n  }\n\n  /**\n   * This function return CQL\n   *\n   * @public\n   * @function\n   * @api\n   * @return {string} CQL\n   */\n  toCQL() {\n    return this.cqlFilter_;\n  }\n}\n\n/**\n * @classdesc\n * @api\n */\nclass Spatial extends Function {\n  /**\n   * Creates a Filter Spatial to filter features\n   *\n   * @api\n   */\n  constructor(FunctionParam, options) {\n    const filterFunction = (feature, index) => {\n      let geometry = null;\n      if (!M.utils.isNullOrEmpty(feature)) {\n        geometry = feature.getGeometry();\n      }\n      return FunctionParam(geometry, index);\n    };\n    super(filterFunction, options);\n  }\n}\n\n/**\n * @function\n * @api\n */\nexport const parseParamToGeometries = (paramParameter) => {\n  let param = paramParameter;\n  let geometries = [];\n  if (param instanceof M.layer.Vector) {\n    geometries = [...param.getFeatures().map(feature => feature.getGeometry())];\n  } else {\n    if (!M.utils.isArray(param)) {\n      param = [param];\n    }\n    geometries = param.map((p) => {\n      let geom;\n      if (p instanceof M.Feature) {\n        geom = p.getGeometry();\n      } else if (M.isObject(p)) {\n        geom = p;\n      }\n      return geom;\n    });\n  }\n\n  return geometries;\n};\n\n/**\n * @private\n * @function\n */\nconst toCQLFilter = (operation, geometries) => {\n  let cqlFilter = '';\n  const wktFormat = new M.format.WKT();\n  geometries.forEach((value, index) => {\n    if (index !== 0) {\n      // es un OR porque se hace una interseccion completa con todas\n      // las geometries\n      cqlFilter += ' OR ';\n    }\n    const geometry = new M.Feature('filtered_geom', {\n      type: 'Feature',\n      geometry: value,\n    });\n    const formatedGeometry = wktFormat.write(geometry);\n    cqlFilter += `${operation}({{geometryName}}, ${formatedGeometry})`;\n  });\n  return cqlFilter;\n};\n\n/**\n * This function creates a spatial filter to know which features intersects\n * another feature or layer\n *\n * @function\n * @api\n */\nexport const intersect = (param) => {\n  const geometries = parseParamToGeometries(param);\n  return new Spatial((geometryToFilter, index) => {\n    const geojsonParser = new GeoJSONReader();\n    const jtsGeomToFilter = geojsonParser.read(geometryToFilter);\n    return geometries.some((geom) => {\n      const jtsGeom = geojsonParser.read(geom);\n      return RelateOp.intersects(jtsGeomToFilter, jtsGeom);\n    });\n  }, {\n    cqlFilter: toCQLFilter('INTERSECTS', geometries),\n  });\n};\n","/**\n * @module M/plugin/Attributions\n */\nimport '../assets/css/attributions';\nimport AttributionsImpl from '../../impl/ol/js/attributions';\nimport AttributionsControl from './attributionscontrol';\nimport { intersect } from './filter';\n\nconst MODES = {\n  mapAttributions: 1, // Map attributions from vector layer\n  layerAttributions: 2, // Attributions layer from its capabilities wms service\n  mixed: 3, // Mixed mode ( 1 + 2)\n};\n\n/**\n * @typedef {AttributionsOptions}\n *\n * The mode according to which the plugin will consult the attributions.\n * @param {mode}\n * @type {number}\n *\n *\n * @param {url}\n * @type {URLLike}\n */\n\n/**\n * Class of attributions plugin\n * @param {object}\n * @classdesc\n */\nexport default class Attributions extends M.Plugin {\n  /**\n   * @constructor\n   * @extends {M.Plugin}\n   * @param {AttributionsOptions} options\n   * @api\n   */\n  constructor(options = {}) {\n    super();\n\n    if (M.utils.isNullOrEmpty(options.mode) || !Object.values(MODES).includes(options.mode)) {\n      throw new Error('Options mode is bad setted. Tip: {mode: 1 | 2 | 3}, ...');\n    }\n\n    if (options.mode === MODES.mapAttributions && !M.utils.isNullOrEmpty(options.url)) {\n      if (M.utils.isNullOrEmpty(options.type)) {\n        throw new Error('Missing \"type\" options. When \"url\" option is setted the plugin needs \"type\" option. Values = geojson | kml | topojson');\n      }\n    }\n\n    if (options.mode === MODES.mapAttributions && !M.utils.isNullOrEmpty(options.layerName)) {\n      if (M.utils.isNullOrEmpty(options.type)) {\n        throw new Error('Missing \"layerName\" options. When \"url\" option is setted the plugin needs \"layerName\" option.');\n      }\n    }\n\n    /**\n     * Facade of the map\n     *\n     * @private\n     * @type {M.Map}\n     */\n    this.map_ = null;\n\n    /**\n     * Array of controls\n     *\n     * @private\n     * @type {Array<M.Control>}\n     */\n    this.controls_ = [];\n\n    /**\n     * Mode of the plugin\n     *\n     * @private\n     * @type {number}\n     */\n    this.mode_ = Number.parseInt(options.mode, 10);\n\n    /**\n     * Vectorial service attributions\n     *\n     * @private\n     * @type {URLLike}\n     */\n    this.url_ = options.url || M.config.attributions.url; // 'https://componentes.ign.es/NucleoVisualizador/vectorial_examples/atribucionPNOA.kml';\n\n    /**\n     * Type of the data url\n     *\n     * @private\n     * @type {string}\n     */\n    this.type_ = options.type || M.config.attributions.type; // 'kml';\n\n    /**\n     * The name of the vector layer hat contains the attribution information.\n     *\n     * @private\n     * @type {string}\n     */\n    this.layerName_ = options.layerName || 'attributions';\n\n    /**\n     * Layer of Mapea with attributions\n     *\n     * @private\n     * @type {M.layer.GeoJSON | M.layer.KML}\n     */\n    this.layer_ = options.layer;\n\n    /**\n     * Zoom from which attributions are displayed\n     *\n     * @private\n     * @type {number}\n     */\n    this.scale_ = Number.parseInt(options.scale, 10) || 10000;\n\n    /**\n     * Parameter of the features of the layer that contains the information of the attributions.\n     *\n     * @private\n     * @type {string}\n     */\n    this.attributionParam_ = options.attributionParam || 'atribucion';\n\n    /**\n     * Parameter of the features of the layer that contains the information of the URL.\n     * @private\n     * @type {URLLike}\n     */\n    this.urlParam_ = options.urlParam || 'url';\n\n    /**\n     * Minimum width of the view control\n     * @private\n     * @type {string}\n     */\n    this.minWidth_ = options.minWidth || '100px';\n\n    /**\n     * Minimum width of the view control\n     * @private\n     * @type {string}\n     */\n    this.maxWidth_ = options.maxWidth || '200px';\n\n    /**\n     * Position of the view control\n     * @private\n     * @type {string}\n     */\n    this.position_ = options.position || 'BL';\n\n    /**\n     * Default text attribution\n     *\n     * @private\n     * @type {string}\n     */\n    // eslint-disable-next-line max-len\n    this.defaultAttribution_ = M.config.attributions.defaultAttribution; // options.defaultAttribution;\n\n    /**\n     * Default url attribution\n     *\n     * @private\n     * @type {string}\n     */\n    this.defaultURL_ = M.config.attributions.defaultURL; // options.defaultURL;\n\n    /**\n     * Tooltip of the UI Plugin\n     *\n     * @private\n     * @type {string}\n     */\n    this.tooltip_ = options.tooltip || 'Reconocimientos';\n\n    window.addEventListener('resize', e => this.setCollapsiblePanel(e));\n  }\n\n  /**\n   * This function adds this plugin into the map\n   *\n   * @public\n   * @function\n   * @param {M.Map} map the map to add the plugin\n   * @api stable\n   */\n  addTo(map) {\n    this.map_ = map;\n    this.impl_ = new AttributionsImpl(map);\n    this.control_ = new AttributionsControl(this.position_, this.closePanel);\n    this.controls_.push(this.control_);\n\n    this.panel_ = new M.ui.Panel('Attributions', {\n      collapsible: window.innerWidth < 769,\n      position: M.ui.position[this.position_],\n      className: 'm-panel-attributions',\n      collapsedButtonClass: 'g-cartografia-info',\n      tooltip: this.tooltip_,\n    });\n\n    this.panel_.addControls(this.control_);\n\n    this.map_.addPanels(this.panel_);\n    this.initMode();\n\n    this.onMoveEnd(() => {\n      this.changeAttributions();\n    });\n  }\n\n  /**\n   * @public\n   * @function\n   */\n  initMode() {\n    if (this.mode_ === MODES.mapAttributions) {\n      if (!(this.layer_ instanceof M.layer.Vector)) {\n        const optionsLayer = {\n          name: this.layerName_,\n          url: this.url_,\n        };\n\n        if (this.type_ === 'geojson') {\n          this.layer_ = new M.layer.GeoJSON(optionsLayer, { displayInLayerSwitcher: false });\n        } else if (this.type_ === 'kml') {\n          this.layer_ = new M.layer.KML(optionsLayer, { displayInLayerSwitcher: false });\n        } else if (this.type === 'topojson') {\n          // TODO: Implement in Mapea M.layer.TopoJSON\n        }\n      }\n\n      if (this.map_.getLayers({ name: this.layer_ }).length < 1) {\n        this.map_.addLayers(this.layer_);\n        this.layer_.displayInLayerSwitcher = false;\n        this.layer_.setVisible(false);\n      }\n    }\n  }\n\n\n  /**\n   * This method shows the layer attributions\n   *\n   * @function\n   * @public\n   */\n  changeAttributions() {\n    this.clearContent();\n    if (this.map_.getScale() <= this.scale_) {\n      this.setVisible(true);\n      let mapAttributions = [];\n      if (this.mode_ === MODES.mapAttributions) {\n        mapAttributions = this.getMapAttributions();\n      } else if (this.mode_ === MODES.layerAttributions) {\n        // TODO:\n      } else if (this.mode === MODES.mixed) {\n        // TODO:\n      }\n\n      this.addContent(mapAttributions);\n    } else if (typeof this.defaultAttribution_ !== 'string') {\n      this.setVisible(false);\n    } else {\n      this.addContent([{\n        attribution: this.defaultAttribution_,\n        url: this.defaultURL_,\n      }]);\n    }\n  }\n\n  /**\n   * This method adds the text content to the view attribution\n   *\n   * @function\n   * @public\n   */\n  addContent(attributions) {\n    const html = this.control_.getElement();\n    const links = attributions.map((attrOpt, index, arr) => {\n      const link = document.createElement('a');\n      link.target = '_blank';\n      link.href = attrOpt.url;\n      link.innerHTML = attrOpt.attribution;\n      link.innerHTML += arr.length - 1 === index ? '' : ',';\n      return link;\n    });\n    const div = document.createElement('div');\n    links.forEach((link) => {\n      div.append(link);\n    });\n    html.append(div);\n  }\n\n  /**\n   * This method adds the text content to the view attribution\n   *\n   * @function\n   * @public\n   */\n  clearContent() {\n    const html = this.control_.getElement();\n    html.querySelectorAll('div').forEach(child => html.removeChild(child));\n  }\n\n  /**\n   * This method toggle de visibility of the view attribution\n   */\n  setVisible(visibility) {\n    const html = this.control_.getElement();\n    html.style.display = visibility === false ? 'none' : '';\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  getMapAttributions() {\n    this.updateBBoxFeature();\n    const featuresAttributions = this.layer_.getFeatures();\n    const interFilter = intersect(this.bboxFeature_);\n    const filteredFeatures = interFilter.execute(featuresAttributions);\n    return filteredFeatures.map((feature) => {\n      return {\n        attribution: feature.getAttribute(this.attributionParam_),\n        url: feature.getAttribute(this.urlParam_) || this.defaultURL_,\n      };\n    }).filter((element, index, array) => // remove repeat elements\n      array.map(e => e.attribution).indexOf(element.attribution) === index);\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  getLayerAttributions() {\n    // TODO:\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  closePanel() {\n    this.getPanel().collapse();\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  changeContentAttribution(content) {\n    this.control_.changeContent(content);\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  updateBBoxFeature() {\n    const { x, y } = this.map_.getBbox();\n    this.bboxFeature_ = new M.Feature('bbox_feature', {\n      type: 'Feature',\n      properties: {},\n      geometry: {\n        type: 'Polygon',\n        coordinates: [\n          [\n            [x.min, y.min],\n            [x.min, y.max],\n            [x.max, y.max],\n            [x.max, y.min],\n            [x.min, y.min],\n          ],\n        ],\n      },\n    });\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  setCollapsiblePanel(e) {\n    if (this.getPanel() && this.getPanel().getTemplatePanel()) {\n      if (e.target.innerWidth < 769) {\n        this.getPanel().getTemplatePanel().classList.remove('no-collapsible');\n        this.closePanel();\n      } else {\n        this.getPanel().getTemplatePanel().classList.add('no-collapsible');\n        this.getPanel().getTemplatePanel().classList.remove('collapsed');\n      }\n    }\n  }\n  /**\n   * @function\n   * @public\n   */\n  onMoveEnd(callback) {\n    this.impl_.registerEvent('moveend', e => callback(e));\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  getPanel() {\n    return this.panel_;\n  }\n\n  /**\n   * Name of the plugin\n   *\n   * @getter\n   * @function\n   */\n  get name() {\n    return 'attributions';\n  }\n\n  /**\n   * Mode of the plugin\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get mode() {\n    return this.mode_;\n  }\n\n  /**\n   * Scale of the plugin\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get scale() {\n    return this.scale_;\n  }\n\n  /**\n   * Attribution of the plugin\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get defaultAttribution() {\n    return this.defaultAttribution_;\n  }\n\n  /**\n   * Default url of the plugin\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get defaultURL() {\n    return this.defaultURL_;\n  }\n\n  /**\n   * Get the API REST Parameters of the plugin\n   *\n   * @function\n   * @public\n   * @api\n   */\n  getAPIRest() {\n    return `${this.name}=${this.mode}*${this.scale}*${this.defaultAttribution}*${this.defaultURL}`;\n  }\n}\n","import M$plugin$Attributions from './/facade/js/attributions';\nimport M$control$AttributionsControl from './/facade/js/attributionscontrol';\nimport M$impl$control$AttributionsControl from './/impl/ol/js/attributionscontrol';\n\nif (!window.M.plugin) window.M.plugin = {};\nif (!window.M.control) window.M.control = {};\nif (!window.M.impl) window.M.impl = {};\nif (!window.M.impl.control) window.M.impl.control = {};\nwindow.M.plugin.Attributions = M$plugin$Attributions;\nwindow.M.control.AttributionsControl = M$control$AttributionsControl;\nwindow.M.impl.control.AttributionsControl = M$impl$control$AttributionsControl;\n"],"sourceRoot":""}