{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/templates/attributions.html","webpack:///./src/impl/ol/js/attributions.js","webpack:///./src/impl/ol/js/attributionscontrol.js","webpack:///./src/facade/js/i18n/language.js","webpack:///./node_modules/jsts/java/lang/Double.js","webpack:///./src/facade/js/attributionscontrol.js","webpack:///./node_modules/jsts/hasInterface.js","webpack:///./node_modules/jsts/java/lang/Cloneable.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequence.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequenceFactory.js","webpack:///./node_modules/jsts/java/lang/IllegalArgumentException.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryComponentFilter.js","webpack:///./node_modules/jsts/java/lang/Comparable.js","webpack:///./node_modules/jsts/java/io/Serializable.js","webpack:///./node_modules/jsts/org/locationtech/jts/util/NumberUtil.js","webpack:///./node_modules/jsts/java/lang/Long.js","webpack:///./node_modules/jsts/java/util/Comparator.js","webpack:///./node_modules/jsts/java/lang/RuntimeException.js","webpack:///./node_modules/jsts/org/locationtech/jts/util/AssertionFailedException.js","webpack:///./node_modules/jsts/org/locationtech/jts/util/Assert.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Coordinate.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Envelope.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Geometry.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateFilter.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/BoundaryNodeRule.js","webpack:///./node_modules/jsts/java/util/Iterator.js","webpack:///./node_modules/jsts/java/util/Collection.js","webpack:///./node_modules/jsts/java/util/IndexOutOfBoundsException.js","webpack:///./node_modules/jsts/java/util/List.js","webpack:///./node_modules/jsts/java/util/NoSuchElementException.js","webpack:///./node_modules/jsts/java/util/OperationNotSupported.js","webpack:///./node_modules/jsts/java/util/ArrayList.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateList.js","webpack:///./node_modules/jsts/org/locationtech/jts/math/MathUtil.js","webpack:///./node_modules/jsts/java/lang/System.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateArrays.js","webpack:///./node_modules/jsts/java/util/Map.js","webpack:///./node_modules/jsts/java/util/SortedMap.js","webpack:///./node_modules/jsts/java/util/Set.js","webpack:///./node_modules/jsts/java/util/HashSet.js","webpack:///./node_modules/jsts/java/util/TreeMap.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Lineal.js","webpack:///./node_modules/jsts/java/util/SortedSet.js","webpack:///./node_modules/jsts/java/util/TreeSet.js","webpack:///./node_modules/jsts/Map.js","webpack:///./node_modules/jsts/java/util/Arrays.js","webpack:///./node_modules/jsts/java/lang/Character.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Dimension.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryFilter.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequenceFilter.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryCollection.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/MultiLineString.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/BoundaryOp.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/Length.js","webpack:///./node_modules/jsts/java/io/PrintStream.js","webpack:///./node_modules/jsts/java/io/StringReader.js","webpack:///./node_modules/jsts/java/io/ByteArrayOutputStream.js","webpack:///./node_modules/jsts/java/io/IOException.js","webpack:///./node_modules/jsts/java/io/LineNumberReader.js","webpack:///./node_modules/jsts/org/locationtech/jts/util/StringUtil.js","webpack:///./node_modules/jsts/java/lang/StringBuilder.js","webpack:///./node_modules/jsts/java/text/DecimalFormat.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/CoordinateSequences.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/LineString.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Puntal.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Point.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/Area.js","webpack:///./node_modules/jsts/java/lang/StringBuffer.js","webpack:///./node_modules/jsts/java/lang/Integer.js","webpack:///./node_modules/jsts/org/locationtech/jts/math/DD.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/CGAlgorithmsDD.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/Orientation.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Polygonal.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Polygon.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/MultiPoint.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/LinearRing.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/MultiPolygon.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/util/GeometryEditor.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/impl/CoordinateArraySequence.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/impl/CoordinateArraySequenceFactory.js","webpack:///./node_modules/jsts/java/util/HashMap.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/PrecisionModel.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryFactory.js","webpack:///./node_modules/jsts/org/locationtech/jts/io/GeoJSONParser.js","webpack:///./node_modules/jsts/org/locationtech/jts/io/GeoJSONReader.js","webpack:///./node_modules/jsts/org/locationtech/jts/io/WKTParser.js","webpack:///./node_modules/jsts/org/locationtech/jts/io/WKTWriter.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/Location.js","webpack:///./node_modules/jsts/java/lang/Exception.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/NotRepresentableException.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/HCoordinate.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/Distance.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/LineIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/RobustLineIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/RayCrossingCounter.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/PointLocation.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/GeometryCollectionIterator.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/PointLocator.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/IntersectionMatrix.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Quadrant.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeEnd.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Position.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/TopologyLocation.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Label.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/EdgeEndBuilder.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/GraphComponent.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Node.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/NodeMap.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/TopologyException.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/locate/PointOnGeometryLocator.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/locate/SimplePointInAreaLocator.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeEndStar.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChain.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/SweepLineEvent.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/EdgeSetIntersector.js","webpack:///./node_modules/jsts/java/util/Collections.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/SegmentIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/SimpleMCSweepLineIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/ItemVisitor.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/intervalrtree/IntervalRTreeNode.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/intervalrtree/IntervalRTreeLeafNode.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/intervalrtree/IntervalRTreeBranchNode.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/intervalrtree/SortedPackedIntervalRTree.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/LineSegment.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/util/LinearComponentExtracter.js","webpack:///./node_modules/jsts/org/locationtech/jts/index/ArrayListVisitor.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/locate/IndexedPointInAreaLocator.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeIntersection.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeIntersectionList.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChainIndexer.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChainEdge.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Depth.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/Edge.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/DirectedEdge.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/NodeFactory.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/PlanarGraph.js","webpack:///./node_modules/jsts/org/locationtech/jts/geomgraph/GeometryGraph.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/EdgeEndBundle.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/EdgeEndBundleStar.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/RelateNode.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/RelateNodeFactory.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/RelateComputer.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/GeometryGraphOperation.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/predicate/RectangleContains.js","webpack:///./node_modules/jsts/org/locationtech/jts/algorithm/RectangleLineIntersector.js","webpack:///./node_modules/jsts/org/locationtech/jts/geom/util/ShortCircuitedGeometryVisitor.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/predicate/RectangleIntersects.js","webpack:///./node_modules/jsts/org/locationtech/jts/operation/relate/RelateOp.js","webpack:///./src/facade/js/filter.js","webpack:///./src/facade/js/attributions.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Attributions","map","_this","_classCallCheck","this","_possibleConstructorReturn","_getPrototypeOf","map_","M","type","callback","getMapImpl","on","AttributionsControl","impl","Control","html","getInteractions","forEach","interaction","ol","DoubleClickZoom","dblClickInteraction_","_get","attributionscontrol_getPrototypeOf","facadeMap_","removeControl","translations","en","es","getValue","keyPath","res","lang","arguments","length","undefined","language","getLang","translation","getTranslation","attributions","utils","isNullOrEmpty","console","warn","concat","split","reduce","prev","current","log2","floor","pow","MAX_REL_BITS_INTEGER","f64buf","i32buf","position","closePanel","js_attributionscontrol_classCallCheck","isUndefined","AttributionsImplControl","exception","js_attributionscontrol_possibleConstructorReturn","js_attributionscontrol_getPrototypeOf","_this2","Promise","success","fail","template","compileSync","vars","icon","querySelector","addEventListener","html_","control","getImpl","destroy","hasInterface","interfaces_","indexOf","Clonable","CoordinateSequence_CoordinateSequence","[object Object]","constructor_","apply","index","ordinateIndex","env","X","Y","Z","CoordinateSequenceFactory_CoordinateSequenceFactory","Array","IllegalArgumentException","message","GeometryComponentFilter","geom","Comparable","Serializable","NumberUtil","x1","x2","tolerance","Math","abs","Long","high","low","Double","Comparator","RuntimeException","stack","Error","toBinaryString","result","mask","isNaN","Number","isInfinite","isFinite","MAX_VALUE","Float64Array","Int32Array","buffer","doubleToLongBits","longBitsToDouble","bits","x","y","f","skip","sign","exp","NEGATIVE_INFINITY","Infinity","fract","BIAS","NaN","constructor","AssertionFailedException_AssertionFailedException","super","Assert_Assert","shouldNeverReachHere","assertion","isTrue","expectedValue","actualValue","equals","Coordinate_Coordinate","trunc","z","other","equalsWithTolerance","equals2D","e","CloneNotSupportedException","dx","dy","dz","sqrt","hashCode","Coordinate_DimensionalComparator","a","b","o1","o2","c1","c2","compX","compare","compY","_dimensionsToTest","dimensionsToTest","DimensionalComparator","NULL_ORDINATE","serialVersionUID","Envelope_Envelope","p1","p2","q","q1","q2","minq","min","maxq","max","minp","maxp","getWidth","getHeight","otherEnvelope","isNull","_maxx","getMaxX","_maxy","getMaxY","_minx","getMinX","_miny","getMinY","intersects","intMinX","intMinY","intMaxX","intMaxY","covers","expandToInclude","w","h","transX","transY","init","distance","expandBy","deltaX","deltaY","setToNull","y1","y2","Geometry_Geometry","getTypeCode","TYPECODE_GEOMETRYCOLLECTION","_factory","g","equalsTopo","equalsExact","geometryChangedFilter","_envelope","norm","isEmpty","compareToSameClass","comp","_userData","_SRID","getFactory","toGeometry","getEnvelopeInternal","copy","normalize","getPrecisionModel","computeEnvelopeInternal","SRID","userData","iterator","j","hasNext","aElement","next","bElement","comparison","compareTo","TYPECODE_MULTIPOINT","TYPECODE_MULTILINESTRING","TYPECODE_MULTIPOLYGON","geometries","array","factory","getSRID","TYPECODE_POINT","TYPECODE_LINESTRING","TYPECODE_LINEARRING","TYPECODE_POLYGON","TYPENAME_POINT","TYPENAME_MULTIPOINT","TYPENAME_LINESTRING","TYPENAME_LINEARRING","TYPENAME_MULTILINESTRING","TYPENAME_POLYGON","TYPENAME_MULTIPOLYGON","TYPENAME_GEOMETRYCOLLECTION","geometryChangedAction","CoordinateFilter","coord","BoundaryNodeRule","boundaryCount","Mod2BoundaryNodeRule","EndPointBoundaryNodeRule","MultiValentEndPointBoundaryNodeRule","MonoValentEndPointBoundaryNodeRule","Iterator","Collection","IndexOutOfBoundsException","List","NoSuchElementException","OperationNotSupported","ArrayList","array_","addAll","MOD2_BOUNDARY_RULE","ENDPOINT_BOUNDARY_RULE","MULTIVALENT_ENDPOINT_BOUNDARY_RULE","MONOVALENT_ENDPOINT_BOUNDARY_RULE","OGC_SFS_BOUNDARY_RULE","remove","add","size","toArray","set","ensureCapacity","push","splice","clear","element","oldElement","Iterator_","len","found","removeAll","arrayList","arrayList_","position_","CoordinateList_CoordinateList","coll","allowRepeated","isChanged","clone","coordArrayType","obj","isInteger","start","end","inc","fill","MathUtil_MathUtil","ln","log","LOG_10","v1","v2","v3","v4","System","arraycopy","src","srcPos","dest","destPos","getProperty","line.separator","CoordinateArrays_CoordinateArrays","pts","testPts","testPt","coordinates","firstCoordinate","newCoordinates","coord1","coord2","coordinateComparator","coordList","toCoordinateArray","hasRepeatedPoints","last","mid","tmp","nonNull","newCoord","srcStart","destStart","pts1","pts2","coordinate","minCoord","clamp","npts","extractPts","iPts","CoordinateArrays_ForwardComparator","CoordinateArrays_BidirectionalComparator","forwardComp","isEqualReversed","dir1","increasingDirection","dir2","i1","i2","comparePt","Map_Map","SortedMap","Set","HashSet","ForwardComparator","BidirectionalComparator","put","values","entrySet","contains","javascript","util","HashSet_Iterator_","hashSet","hashSet_","BLACK","colorOf","color","parentOf","parent","setColor","leftOf","left","rightOf","right","TreeMap","root_","size_","cmp","oldValue","fixAfterInsertion","rotateLeft","rotateRight","getFirstEntry","successor","ch","containsKey","Lineal","SortedSet","TreeSet","TreeSet_Iterator_","Map_i","treeSet","treeSet_","Arrays","Character","sort","comparator","slice","asList","isWhitespace","toUpperCase","Dimension_Dimension","dimensionValue","FALSE","SYM_FALSE","TRUE","SYM_TRUE","DONTCARE","SYM_DONTCARE","P","SYM_P","L","SYM_L","A","SYM_A","dimensionSymbol","GeometryFilter","CoordinateSequenceFilter","seq","GeometryCollection_GeometryCollection","envelope","_geometries","getNumPoints","k","childCoordinates","getCoordinates","area","getArea","isEquivalentClass","otherCollection","getCoordinate","dimension","getBoundaryDimension","getDimension","sum","getLength","numPoints","revGeoms","reverse","createGeometryCollection","theseElements","otherElements","gc","n1","getNumGeometries","n2","thisGeom","getGeometryN","otherGeom","holeComp","filter","isDone","isGeometryChanged","geometryChanged","checkNotGeometryCollection","hasNullElements","MultiLineString_MultiLineString","isClosed","nLines","revLines","createMultiLineString","BoundaryOp_BoundaryOp","getBoundary","lineStrings","bnRule","mLine","_geom","getEmptyMultiPoint","bdyPts","computeBoundaryCoordinates","_geomFact","createPoint","createMultiPointFromCoords","LineString_LineString","boundaryLineString","boundaryMultiLineString","line","_bnRule","isInBoundary","getStartPoint","createMultiPoint","getEndPoint","_endpointMap","addEndpoint","getCoordinateN","it","entry","valence","count","getKey","pt","counter","Counter","Length_Length","x0","y0","PrintStream","StringReader","ByteArrayOutputStream","IOException","LineNumberReader","StringUtil_StringUtil","String","os","ps","printStackTrace","toString","depth","stackTrace","lineNumberReader","getStackTrace","readLine","NEWLINE","separator","separatorlen","tokenList","tmpString","pos","token","substring","SIMPLE_ORDINATE_FORMAT","format","chars","StringBuilder","str","append","setCharAt","substr","CoordinateSequences_CoordinateSequences","minDim","dim","setOrdinate","getOrdinate","cs1","cs2","cs1Size","fact","newseq","swap","copyCoord","cs","builder","createClosedRing","_points","expandEnvelope","isSimple","otherLineString","equal","getPointN","ofLine","createLineString","points","getCoordinateSequenceFactory","Puntal","Point_Point","_coordinates","getX","getY","IllegalStateException","point","Area_Area","ring","ofRingSigned","p0","StringBuffer","Integer","intValue","DD_DD","valueOf","selfMultiply","parse","strlen","charAt","isNegative","signCh","val","numDigits","numBeforeDec","isDigit","TEN","selfAdd","expStr","parseInt","ex","NumberFormatException","val2","numDecPlaces","scale","divide","multiply","negate","dd","xAbs","xLog10","xMag","buf","_hi","_lo","insertDecimalPoint","magnitude","mag","gt","lt","ONE","decimalPointPos","MAX_PRINT_DIGITS","digit","rebiasBy10","digitChar","subtract","continueExtractingDigits","remMag","isZero","le","selfDivide","yhi","ylo","tc","ty","C","U","hc","hy","u","SPLIT","createNaN","sqr","reciprocal","fhi","ceil","flo","ge","ax","axdd","d2","H","S","T","zhi","zlo","tx","hx","toStandardNotation","toSciNotation","specialStr","getSpecialNumberString","sigDigits","extractSignificantDigits","num","stringOfChar","numZeroes","SCI_NOT_ZERO","digits","SCI_NOT_EXPONENT_CHAR","trailingDigits","digitsWithDecimal","hi","lo","isPositive","PI","TWO_PI","PI_2","E","EPS","CGAlgorithmsDD_CGAlgorithmsDD","orientationIndexFilter","dx1","dy1","dx2","dy2","selfSubtract","signum","denom1","denom2","denom","numx1","numx2","fracP","doubleValue","numy1","numy2","fracQ","pa","pb","pc","detsum","detleft","detright","det","errbound","DP_SAFE_EPSILON","Orientation_Orientation","orientationIndex","nPts","hiPt","hiIndex","iPrev","iNext","disc","CLOCKWISE","RIGHT","COUNTERCLOCKWISE","LEFT","COLLINEAR","STRAIGHT","Polygonal","Polygon_Polygon","_shell","shellCoordinates","_holes","ofRing","getCoordinateSequence","getNumInteriorRing","prevX","prevY","otherPolygon","thisShell","otherPolygonShell","clockwise","uniqueCoordinates","minCoordinate","scroll","isCCW","poly","getExteriorRing","convexHull","otherShell","shellComp","nHole1","nHole2","thisHole","getInteriorRingN","otherHole","rings","createLinearRing","shellCopy","holeCopies","shell","holes","hasNonEmptyElements","MultiPoint_MultiPoint","LinearRing_LinearRing","MINIMUM_VALID_SIZE","GeometryFactory_GeometryFactory","validateConstruction","MultiPolygon_MultiPolygon","createMultiPolygon","allRings","allRingsArray","polygons","GeometryEditor_GeometryEditor","isUserDataCopied","_isUserDataCopied","geometry","operation","editInternal","setUserData","getUserData","editGeometryCollection","editPolygon","edit","getClass","getName","collection","collectionForType","polygon","newPolygon","createPolygon","hole","GeometryEditorOperation","NoOpGeometryOperation","GeometryEditor_CoordinateOperation","GeometryEditor_CoordinateSequenceOperation","CoordinateOperation","CoordinateSequenceOperation","CoordinateArraySequence_CoordinateArraySequence","_dimension","cloneCoordinates","strBuilder","coordSeq","getCoordinateCopy","CoordinateArraySequenceFactory_CoordinateArraySequenceFactory","instanceObject","instance","jsts_Map","proto","objectOnly","_keys","_values","_itp","sharedSize","delete","has","list","TypeError","keys","sharedIterator","entries","context","done","itp","array2","v","MapImpl","Map","HashMap","PrecisionModel_PrecisionModel","pm1","pm2","otherPrecisionModel","_modelType","_scale","getMaximumSignificantDigits","otherSigDigits","FLOATING","FLOATING_SINGLE","description","FIXED","getScale","round","makePrecise","maxSigDigits","PrecisionModel_Type","nameToTypeMap","_name","Type","modelType","setScale","pm","maximumPreciseValue","multiPolygons","multiPolygonArray","geometryArray","multiLineStrings","multiLineStringArray","lineStringArray","multiPoints","multiPointArray","linearRings","linearRingArray","pointArray","polygonArray","exemplar","geomList","geomClass","isHeterogeneous","hasGeometryCollection","partClass","toGeometryArray","geom0","toPolygonArray","toLineStringArray","toPointArray","_coordinateSequenceFactory","GeometryFactory_CloneOp","_precisionModel","ptSeq","coordinateSequenceFactory","CloneOp","precisionModel","getDefaultCoordinateSequenceFactory","geometryTypes","GeoJSONParser_GeoJSONParser","geometryFactory","json","JSON","getGeometryType","extract","Feature","feature","read","bbox","FeatureCollection","featureCollection","features","sub","Point","MultiPoint","LineString","MultiLineString","Polygon","linearRing","MultiPolygon","GeometryCollection","multipoint","geoJson","linestring","multilinestring","shellGeoJson","holeGeoJson","multipolygon","GeoJSONReader_GeoJSONReader","parser","regExes","typeStr","emptyTypeStr","spaces","parenComma","doubleParenComma","trimParens","WKTParser_WKTParser","wkt","replace","matches","exec","search","toLowerCase","WKTParser_parse","extractGeometry","WKTParser_extract","wktType","join","linearring","coords","trim","parseFloat","components","lines","wktArray","WKTWriter_WKTWriter","write","Location_Location","locationValue","EXTERIOR","BOUNDARY","INTERIOR","NONE","Exception","NotRepresentableException_NotRepresentableException","HCoordinate_HCoordinate","px","py","pw","qx","qy","qw","xInt","yInt","_x","_y","_w","Distance_Distance","B","D","pointToSegment","noIntersection","r_num","len2","minDistance","dist","LineIntersector_LineIntersector","pdx","pdy","segmentIndex","intIndex","computeIntLineIndex","_intLineIndex","catBuilder","isEndPoint","_isProper","isCollinear","p3","p4","_inputLines","_result","computeIntersect","getEdgeDistance","hasIntersection","isInteriorIntersection","inputLineIndex","_intPt","NO_INTERSECTION","computeEdgeDistance","COLLINEAR_INTERSECTION","toLineString","getTopologySummary","ptIndex","_pa","_pb","DONT_INTERSECT","DO_INTERSECT","POINT_INTERSECTION","RobustLineIntersector_RobustLineIntersector","nearestPt","minDist","intPt","env0","env1","computeIntersection","n3","n4","normPt","smallestInAbsValue","intersection","nearestEndpoint","intersectionWithNormalization","isInSegmentEnvelopes","x3","x4","xabs","intPtDD","isIn","out","println","normalizeToEnvCentre","safeHCoordinateIntersection","p1q1p2","p1q2p2","q1p1q2","q1p2q2","n00","n01","n10","n11","minX0","minY0","maxX0","maxY0","minX1","minY1","maxX1","maxY1","intMidX","intMidY","Pq1","Pq2","Qp1","Qp2","computeCollinearIntersection","RayCrossingCounter_RayCrossingCounter","countSegment","isOnSegment","getLocation","_p","_isPointOnSegment","minx","maxx","orient","_crossingCount","PointLocation_PointLocation","lineIntersector","locatePointInRing","locateInRing","GeometryCollectionIterator_GeometryCollectionIterator","_atStart","isAtomic","_parent","_index","_subcollectionIterator","_max","UnsupportedOperationException","PointLocator_PointLocator","locate","loc","_isIn","_numBoundaries","updateLocationInfo","locateOnPoint","locateOnLineString","locateInPolygon","ml","mpoly","geomi","g2","computeLocation","isOnLine","shellLoc","locateInPolygonRing","holeLoc","_boundaryRule","boundaryRule","IntersectionMatrix_IntersectionMatrix","actualDimensionValue","requiredDimensionSymbol","actualDimensionSymbols","requiredDimensionSymbols","isDisjoint","_matrix","dimensionSymbols","row","col","toDimensionValue","column","minimumDimensionSymbols","setAtLeast","minimumDimensionValue","dimensionOfGeometryA","dimensionOfGeometryB","isTouches","ai","bi","toDimensionSymbol","temp","im","setAll","elements","Quadrant_Quadrant","quad","NE","NW","quad1","quad2","halfPlane","SE","SW","EdgeEnd_EdgeEnd","_dx","_dy","_quadrant","_p0","_p1","node","_node","angle","atan2","className","lastDotPos","lastIndexOf","print","_label","compareDirection","_edge","boundaryNodeRule","quadrant","edge","label","Position","ON","TopologyLocation_TopologyLocation","locValue","location","gl","newLoc","toLocationSymbol","posIndex","setLocation","locIndex","setAllLocations","Label_Label","lineLabel","elt","geomIndex","setAllLocationsIfNull","isLine","lbl","merge","flip","isArea","isAnyNull","side","isEqualOnSide","allPositionsEqual","onLoc","leftLoc","rightLoc","setLocations","EdgeEndBuilder_EdgeEndBuilder","eiCurr","eiNext","pNext","getLabel","eiPrev","pPrev","edges","computeEdgeEnds","eiList","getEdgeIntersectionList","addEndpoints","createEdgeEndForPrev","createEdgeEndForNext","GraphComponent_GraphComponent","isVisited","_isVisited","isInResult","_isInResult","_isCovered","_isCoveredSet","isCovered","getGeometryCount","computeIM","Node_Node","getEdges","getEdge","_coord","label2","eltIndex","nLoc","setLabel","argIndex","onLocation","_edges","mergeLabel","computeMergedLocation","insert","setNode","NodeMap_NodeMap","nodeMap","nodeFact","createNode","bdyNodes","addNode","TopologyException_TopologyException","msg","msgWithCoord","PointOnGeometryLocator","SimplePointInAreaLocator_SimplePointInAreaLocator","locatePointInPolygon","locateInGeometry","EdgeEndStar_EdgeEndStar","ee","_edgeList","iNextCW","startLoc","currLoc","geomGraph","computeEdgeEndLabels","getBoundaryNodeRule","checkAreaLabelsConsistent","lastEdgeIndex","eSearch","_edgeMap","_ptInAreaLocation","getGeometry","computeLabel","propagateSideLabels","hasDimensionalCollapseEdge","MonotoneChain","mc","si","mce","computeIntersectsForChain","chainIndex","SweepLineEvent_SweepLineEvent","_eventType","DELETE","deleteEventIndex","_deleteEventIndex","_obj","pe","_xValue","_insertEvent","INSERT","ev","insertEvent","EdgeSetIntersector","Collections","reverseOrder","alen","singletonList","util_Collections","SegmentIntersector","e0","segIndex0","e1","segIndex1","_li","getIntersectionNum","isAdjacentSegments","maxSegIndex","_properIntersectionPoint","isDoneWhenProperInt","_isDoneWhenProperInt","_hasProperInterior","li","isIntersection","_hasProper","_hasIntersection","_isDone","isBoundaryPointInternal","bdyNodes0","bdyNodes1","_bdyNodes","numTests","p00","p01","p10","p11","_recordIsolated","setIsolated","_numIntersections","isTrivialIntersection","_includeProper","isProper","addIntersections","getIntersection","isBoundaryPoint","_isSelfIntersection","includeProper","recordIsolated","SimpleMCSweepLineIntersector_SimpleMCSweepLineIntersector","events","isDelete","getInsertEvent","setDeleteEventIndex","nOverlaps","prepareEvents","isInsert","processOverlaps","getDeleteEventIndex","edges0","edges1","addEdges","computeIntersections","edgeSet","getMonotoneChainEdge","startIndex","getStartIndexes","ev0","mc0","getObject","ev1","mc1","isSameLabel","addEdge","ItemVisitor","item","IntervalRTreeNode_IntervalRTreeNode","_min","queryMin","queryMax","IntervalRTreeNode_NodeComparator","mid1","mid2","NodeComparator","POSITIVE_INFINITY","IntervalRTreeLeafNode_IntervalRTreeLeafNode","visitor","visitItem","_item","IntervalRTreeBranchNode_IntervalRTreeBranchNode","_node1","query","_node2","buildExtent","SortedPackedIntervalRTree_SortedPackedIntervalRTree","_leaves","buildLevel","_root","buildTree","_level","buildRoot","LineSegment_LineSegment","seg","orient0","orient1","geomFactory","projectionFactor","pf0","pf1","newp0","project","newp1","pointToLinePerpendicular","midPoint","closestPt","close00","closestPoint","close01","close10","close11","factor","comp0","segmentLengthFraction","offsetDistance","segx","segy","ux","uy","ls","setCoordinates","inputPt","segFrac","segmentToSegment","bits0","java","hash0","bits1","LinearComponentExtracter_LinearComponentExtracter","buildGeometry","getLines","forceToLineString","geoms","_isForcedToLineString","_lines","isForcedToLineString","ArrayListVisitor_ArrayListVisitor","_items","IndexedPointInAreaLocator_IndexedPointInAreaLocator","rcc","IndexedPointInAreaLocator_SegmentVisitor","_counter","IndexedPointInAreaLocator_IntervalIndexedGeometry","addLine","getItems","SegmentVisitor","IntervalIndexedGeometry","EdgeIntersection_EdgeIntersection","maxSegmentIndex","EdgeIntersectionList_EdgeIntersectionList","_nodeMap","edgeList","ei","newEdge","createSplitEdge","ei0","ei1","lastSegStartPt","useIntPt1","ipt","Edge_Edge","eiNew","MonotoneChainIndexer_MonotoneChainIndexer","startIndexList","findChainEnd","toIntArray","chainQuad","MonotoneChainEdge_MonotoneChainEdge","chainIndex0","chainIndex1","start0","end0","start1","end1","overlaps","mid0","mcb","getChainStartIndices","Depth_Depth","NULL_VALUE","_depth","depthValue","minDepth","newValue","depthAtLocation","updateIM","setAtLeastIfValid","newPts","toLineLabel","_isIsolated","isIsolated","isEqualForward","isEqualReverse","iRev","_depthDelta","_mce","_env","normalizedSegmentIndex","nextSegIndex","nextPt","depthDelta","addIntersection","DirectedEdge_DirectedEdge","currLocation","nextLocation","_nextMin","_isForward","_next","depthVal","isInteriorAreaEdge","nextMin","getDepthDelta","minEdgeRing","_minEdgeRing","isExteriorIfArea0","isExteriorIfArea1","edgeRing","_edgeRing","_sym","printReverse","de","setVisited","directionFactor","oppositePos","opposite","oppositeDepth","setDepth","isForward","computeDirectedLabel","NodeFactory_NodeFactory","PlanarGraph_PlanarGraph","nodes","nodeit","linkResultDirectedEdges","_nodes","find","linkAllDirectedEdges","ep0","ep1","_edgeEndList","eCoord","matchInSameDirection","getEdgeEnds","edgesToAdd","de1","de2","setSym","GeometryGraph_GeometryGraph","determineBoundary","_boundaryNodeRule","computeRingSelfNodes","computeSelfNodes","isDoneIfProperInt","setIsDoneIfProperInt","esi","createEdgeSetIntersector","isRings","_parentGeom","computeAllSegments","addSelfIntersectionNodes","_argIndex","edgelist","addSplitEdges","setBoundaryNodes","getBoundaryNodes","_hasTooFewPoints","insertPoint","addPolygonRing","insertEdge","removeRepeatedPoints","_invalidPoint","_lineEdgeMap","insertBoundaryPoint","_boundaryNodes","isBoundaryNode","_useBoundaryDeterminationRule","lr","cwLeft","cwRight","eLoc","eiIt","addSelfIntersectionNode","addPolygon","addLineString","addPoint","addCollection","_areaPtLocator","_ptLocator","findEdge","parentGeom","EdgeEndBundle_EdgeEndBundle","_edgeEnds","foundInterior","computeLabelSide","computeLabelOn","computeLabelSides","getDirectedCoordinate","EdgeEndBundleStar_EdgeEndBundleStar","eb","insertEdgeEnd","RelateNode_RelateNode","RelateNodeFactory_RelateNodeFactory","RelateComputer_RelateComputer","intersector","dimA","_arg","dimB","hasProper","hasProperIntersection","hasProperInterior","hasProperInteriorIntersection","thisIndex","targetIndex","getEdgeIterator","labelIsolatedEdge","_isolatedEdges","target","computeDisjointIM","computeEdgeIntersections","computeIntersectionNodes","copyNodesAndLabels","labelIsolatedNodes","computeProperIntersectionIM","eeBuilder","ee0","insertEdgeEnds","ee1","labelNodeEdges","labelIsolatedEdges","ni","computeLabelling","getNodeIterator","graphNode","setLabelBoundary","labelIsolatedNode","updateIMFromEdges","ga","gb","_im","arg","GeometryGraphOperation","_resultPrecisionModel","setPrecisionModel","g0","setComputationPrecision","g1","RectangleContains_RectangleContains","rectangle","isPointContainedInBoundary","isLineStringContainedInBoundary","isContainedInBoundary","_rectEnv","isLineSegmentContainedInBoundary","RectangleLineIntersector_RectangleLineIntersector","segEnv","isSegUpwards","_diagDown0","_diagDown1","_diagUp0","_diagUp1","rectEnv","ShortCircuitedGeometryVisitor_ShortCircuitedGeometryVisitor","applyTo","visit","RectangleIntersects","RectangleIntersects_EnvelopeIntersectsVisitor","ecpVisitor","RectangleIntersects_GeometryContainsPointVisitor","_rectangle","containsPoint","riVisitor","RectangleIntersects_RectangleIntersectsSegmentVisitor","_intersects","elementEnv","_containsPoint","rectPt","_rectSeq","containsPointInPolygon","checkIntersectionWithLineStrings","testLine","checkIntersectionWithSegments","seq1","_rectIntersector","RelateOp_RelateOp","isRectangle","getIntersectionMatrix","isCovers","isGeometryCollection","isIntersects","isOverlaps","isCrosses","isContains","_relate","Base","Function","filterFunction","options","filter_classCallCheck","filter_possibleConstructorReturn","filter_getPrototypeOf","filterFunction_","cqlFilter_","cqlFilter","Spatial","FunctionParam","toCQLFilter","wktFormat","WKT","formatedGeometry","intersect","param","paramParameter","layer","Vector","_toConsumableArray","getFeatures","isArray","isObject","parseParamToGeometries","geometryToFilter","geojsonParser","GeoJSONReader","jtsGeomToFilter","some","jtsGeom","RelateOp","MODES","mapAttributions","layerAttributions","mixed","attributions_classCallCheck","attributions_possibleConstructorReturn","attributions_getPrototypeOf","includes","url","layerName","controls_","mode_","url_","config","type_","layerName_","layer_","scale_","attributionParam_","attributionParam","urlParam_","urlParam","minWidth_","minWidth","maxWidth_","maxWidth","defaultAttribution_","defaultAttribution","defaultURL_","defaultURL","tooltip_","tooltip","urlAttribute","window","setCollapsiblePanel","Plugin","impl_","AttributionsImpl","control_","panel_","ui","Panel","collapsible","innerWidth","collapsedButtonClass","addControls","addPanels","initMode","onMoveEnd","changeAttributions","removeControls","optionsLayer","GeoJSON","displayInLayerSwitcher","KML","getLayers","addLayers","setVisible","clearContent","getMapAttributions","zoom","getZoom","baseLayer","getBaseLayers","isHybrid","attribution","addContent","_this3","getElement","links","attrOpt","arr","link","document","createElement","href","innerHTML","attributeURL","div","querySelectorAll","child","removeChild","visibility","style","display","_this4","updateBBoxFeature","featuresAttributions","bboxFeature_","execute","getAttribute","getPanel","collapse","content","changeContent","_this$map_$getBbox","getBbox","properties","getTemplatePanel","classList","registerEvent","plugin","M$plugin$Attributions","M$control$AttributionsControl","M$impl$control$AttributionsControl"],"mappings":"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","file":"attributions.ol.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = \"<div id=\\\"m-attributions-container\\\" class=\\\"m-control m-container m-attributions\\\">\\n    <button id='close-button' class=\\\"{{icon}}\\\"></button>\\n</div>\";","/**\n * @classdesc\n */\nclass Attributions extends M.Object {\n  /**\n   * @constructor\n   */\n  constructor(map) {\n    super();\n\n    /**\n     * Map of the plugin\n     * @private\n     * @type {M.Map}\n     */\n    this.map_ = map;\n  }\n\n  /**\n   * Register events in ol.Map of M.Map\n   * @public\n   * @function\n   */\n  registerEvent(type, callback) {\n    const olMap = this.map_.getMapImpl();\n\n    olMap.on(type, callback);\n  }\n}\n\nexport default Attributions;\n","/**\n * @module M/impl/control/AttributionsControl\n */\nexport default class AttributionsControl extends M.impl.Control {\n  /**\n   * This function adds the control to the specified map\n   *\n   * @public\n   * @function\n   * @param {M.Map} map to add the plugin\n   * @param {HTMLElement} html of the plugin\n   * @api stable\n   */\n  addTo(map, html) {\n    const olMap = map.getMapImpl();\n    olMap.getInteractions().forEach((interaction) => {\n      if (interaction instanceof ol.interaction.DoubleClickZoom) {\n        this.dblClickInteraction_ = interaction;\n      }\n    });\n    // super addTo - don't delete\n    super.addTo(map, html);\n  }\n\n  /**\n   * This function destroys this control, cleaning the HTML\n   * and unregistering all events\n   *\n   * @public\n   * @function\n   * @api\n   * @export\n   */\n  destroy() {\n    this.facadeMap_.getMapImpl().removeControl(this);\n    this.facadeMap_ = null;\n  }\n}\n","import en from './en';\nimport es from './es';\n\n/**\n * Default object with es and en translate.\n *\n * @const\n * @type {object}\n */\nconst translations = {\n  en,\n  es,\n};\n\nconst getLang = () => {\n  let res = 'es';\n  if (typeof M.language.getLang === 'function') {\n    res = M.language.getLang();\n  }\n\n  return res;\n};\n\n/**\n * This function sets a new language translate.\n * @param {string} lang\n * @param {JSON} json\n * @public\n * @api\n */\nexport const addTranslation = (lang, json) => {\n  translations[lang] = json;\n};\n\n/**\n * This function gets a language translate.\n *\n * @param {string} lang\n * @return {JSON}\n * @public\n * @api\n */\nexport const getTranslation = (lang) => {\n  if (lang === 'es' || lang === 'en') {\n    return translations[lang];\n  }\n  return M.language.getTranslation(lang).attributions;\n};\n\n/**\n * This function gets a language value from key\n *\n * @public\n * @param {string}\n * @param {string}\n * @return {string}\n * @public\n * @api\n */\nexport const getValue = (keyPath, lang = getLang()) => {\n  const translation = getTranslation(lang);\n  let value = '';\n  if (M.utils.isNullOrEmpty(translation)) {\n    console.warn(`The translation '${lang}' has not been defined.`);\n  } else {\n    value = keyPath.split('.').reduce((prev, current) => prev[current], translation);\n  }\n  return value;\n};\n","import Long from './Long';\n\nexport default function Double () {}\n\nDouble.isNaN = n => Number.isNaN(n)\nDouble.isInfinite = n => !Number.isFinite(n)\nDouble.MAX_VALUE = Number.MAX_VALUE\n\nif (typeof Float64Array == 'function' &&\n\t  typeof Int32Array == 'function') {\n\t// Simple and fast conversion between double and long bits\n\t// using TypedArrays and ArrayViewBuffers.\n\t(function() {\n\t\tvar EXP_BIT_MASK = 0x7ff00000;\n\t\tvar SIGNIF_BIT_MASK = 0xFFFFF;\n\t\tvar f64buf = new Float64Array(1);\n\t\tvar i32buf = new Int32Array(f64buf.buffer);\n\t\tDouble.doubleToLongBits = function (value) {\n\t\t\tf64buf[0] = value;\n\t\t\tvar low = i32buf[0] | 0;\n\t\t\tvar high = i32buf[1] | 0;\n\t\t\t// Check for NaN based on values of bit fields, maximum\n\t\t\t// exponent and nonzero significand.\n\t\t\tif (((high & EXP_BIT_MASK) === EXP_BIT_MASK) &&\n\t\t\t\t((high & SIGNIF_BIT_MASK) !== 0) &&\n\t\t\t\t(low !== 0)) {\n\t\t\t\tlow = 0 | 0;\n\t\t\t\thigh = 0x7ff80000 | 0;\n\t\t\t}\n\t\t\treturn new Long(high, low);\n\t\t};\n\t\tDouble.longBitsToDouble = function (bits) {\n\t\t\ti32buf[0] = bits.low;\n\t\t\ti32buf[1] = bits.high;\n\t\t\treturn f64buf[0];\n\t\t};\n\t})();\n} else {\n\t// More complex and slower fallback implementation using \n\t// math and the divide-by-two and multiply-by-two algorithms.\n\t(function() {\n\t\tvar BIAS = 1023;\n\t\tvar log2 = Math.log2;\n\t\tvar floor = Math.floor;\n\t\tvar pow = Math.pow;\n\t\tvar MAX_REL_BITS_INTEGER = (function () {\n\t\t\tfor (var i = 53; i > 0; i--) {\n\t\t\t\tvar bits = pow(2, i) - 1;\n\t\t\t\tif (floor(log2(bits)) + 1 === i) {\n\t\t\t\t\treturn bits;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t})();\n\t\tDouble.doubleToLongBits = function (value) {\n\t\t\tvar x, y, f, bits, skip;\n\t\t\tvar sign, exp, high, low;\n\t\n\t\t\t// Get the sign bit and absolute value.\n\t\t\tif (value < 0 || 1 / value === Number.NEGATIVE_INFINITY) {\n\t\t\t\tsign = (1 << 31);\n\t\t\t\tvalue = (-value);\n\t\t\t} else {\n\t\t\t\tsign = 0;\n\t\t\t}\n\t\n\t\t\t// Handle some special values.\n\t\t\tif (value === 0) {\n\t\t\t\t// Handle zeros (+/-0).\n\t\t\t\tlow = 0 | 0;\n\t\t\t\thigh = sign; // exponent: 00..00, significand: 00..00\n\t\t\t\treturn new Long(high, low);\n\t\t\t}\n\t\n\t\t\tif (value === Infinity) {\n\t\t\t\t// Handle infinity (only positive values for value possible).\n\t\t\t\tlow = 0 | 0;\n\t\t\t\thigh = sign | 0x7ff00000; // exponent: 11..11, significand: 00..00\n\t\t\t\treturn new Long(high, low);\n\t\t\t}\n\t\n\t\t\tif (value !== value) {\n\t\t\t\t// Handle NaNs (boiled down to only one distinct NaN).\n\t\t\t\tlow = 0 | 0;\n\t\t\t\thigh = 0x7ff80000; // exponent: 11..11, significand: 10..00\n\t\t\t\treturn new Long(high, low);\n\t\t\t}\n\t\n\t\t\t// Preinitialize variables, that are not neccessarily set by\n\t\t\t// the algorithm.\n\t\t\tbits = 0;\n\t\t\tlow = 0 | 0;\n\t\n\t\t\t// Get the (always positive) integer part of value.\n\t\t\tx = floor(value);\n\t\n\t\t\t// Process the integer part if it's greater than 1. Zero requires\n\t\t\t// no bits at all, 1 represents the implicit (hidden) leading bit,\n\t\t\t// which must not be written as well.\n\t\t\tif (x > 1) {\n\t\t\t\t// If we can reliably determine the number of bits required for\n\t\t\t\t// the integer part,\n\t\t\t\tif (x <= MAX_REL_BITS_INTEGER) {\n\t\t\t\t\t// get the number of bits required to represent it minus 1\n\t\t\t\t\tbits = floor(log2(x)) /* + 1 - 1*/ ;\n\t\t\t\t\t// and simply copy/shift the integer bits into low and high.\n\t\t\t\t\t// That's much faster than the divide-by-two algorithm (saves\n\t\t\t\t\t// up to ~60%).\n\t\t\t\t\t// We always need to mask out the most significant bit, which\n\t\t\t\t\t// is the implicit (aka hidden) bit.\n\t\t\t\t\tif (bits <= 20) {\n\t\t\t\t\t\t// The simple case in which the integer fits into the\n\t\t\t\t\t\t// lower 20 bits of the high word is worth to be handled\n\t\t\t\t\t\t// separately (saves ~25%).\n\t\t\t\t\t\tlow = 0 | 0;\n\t\t\t\t\t\thigh = (x << (20 - bits)) & 0xfffff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Here, the integer part is split into low and high.\n\t\t\t\t\t\t// Since its value may require more than 32 bits, we\n\t\t\t\t\t\t// cannot use bitwise operators (which implicitly cast\n\t\t\t\t\t\t// to Int32), but use arithmetic operators % and / to\n\t\t\t\t\t\t// get low and high parts. The uppper 20 bits go to high,\n\t\t\t\t\t\t// the remaining bits (in f) to low.\n\t\t\t\t\t\tf = bits - 20;\n\t\t\t\t\t\t// Like (1 << f) but safe with even more than 32 bits.\n\t\t\t\t\t\ty = pow(2, f);\n\t\t\t\t\t\tlow = (x % y) << (32 - f);\n\t\t\t\t\t\thigh = (x / y) & 0xfffff;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// For greater values, we must use the much slower divide-by-two\n\t\t\t\t\t// algorithm. Bits are generated from right to left, that is from\n\t\t\t\t\t// least to most significant bit. For each bit, we left-shift both\n\t\t\t\t\t// low and high by one and carry bit #0 from high to #31 in low.\n\t\t\t\t\t// The next bit is then copied into bit #19 in high, the leftmost\n\t\t\t\t\t// bit of the double's significand.\n\t\n\t\t\t\t\t// Preserve x for later user, so work with f.\n\t\t\t\t\tf = x;\n\t\t\t\t\tlow = 0 | 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\ty = f / 2;\n\t\t\t\t\t\tf = floor(y);\n\t\t\t\t\t\tif (f === 0) {\n\t\t\t\t\t\t\t// We just found the most signigicant (1-)bit, which\n\t\t\t\t\t\t\t// is the implicit bit and so, not stored in the double\n\t\t\t\t\t\t\t// value. So, it's time to leave the loop.\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Count this bit, shift low and carry bit #0 from high.\n\t\t\t\t\t\tbits++;\n\t\t\t\t\t\tlow >>>= 1;\n\t\t\t\t\t\tlow |= (high & 0x1) << 31;\n\t\t\t\t\t\t// Shift high.\n\t\t\t\t\t\thigh >>>= 1;\n\t\t\t\t\t\tif (y !== f) {\n\t\t\t\t\t\t\t// Copy the new bit into bit #19 in high (only required if 1).\n\t\t\t\t\t\t\thigh |= 0x80000;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Bias the exponent.\n\t\t\texp = bits + BIAS;\n\t\n\t\t\t// If the integer part is zero, we've not yet seen the implicit\n\t\t\t// leading bit. Variable skip is later used while processing the \n\t\t\t// fractional part (if any).\n\t\t\tskip = (x === 0);\n\t\n\t\t\t// Get fraction only into x.\n\t\t\tx = value - x;\n\t\n\t\t\t// If some significand bits are still left to be filled and\n\t\t\t// the fractional part is not zero, convert the fraction using\n\t\t\t// the multiply-by-2 algorithm.\n\t\t\tif (bits < 52 && x !== 0) {\n\t\n\t\t\t\t// Initialize 'buffer' f, into which newly created bits get\n\t\t\t\t// shifted from right to left.\n\t\t\t\tf = 0;\n\t\n\t\t\t\twhile (true) {\n\t\t\t\t\ty = x * 2;\n\t\t\t\t\tif (y >= 1) {\n\t\t\t\t\t\t// This is a new 1-bit. Add and count this bit, if not\n\t\t\t\t\t\t// prohibited by skip.\n\t\t\t\t\t\tx = y - 1;\n\t\t\t\t\t\tif (!skip) {\n\t\t\t\t\t\t\tf <<= 1;\n\t\t\t\t\t\t\tf |= 1;\n\t\t\t\t\t\t\tbits++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Otherwise, decrement the exponent and unset\n\t\t\t\t\t\t\t// skip, so that all following bits get written.\n\t\t\t\t\t\t\texp--;\n\t\t\t\t\t\t\tskip = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// This is a new 0-bit. Add and count this bit, if not\n\t\t\t\t\t\t// prohibited by skip.\n\t\t\t\t\t\tx = y;\n\t\t\t\t\t\tif (!skip) {\n\t\t\t\t\t\t\tf <<= 1;\n\t\t\t\t\t\t\tbits++;\n\t\t\t\t\t\t} else if (--exp === 0) {\n\t\t\t\t\t\t\t// Otherwise we've just decremented the exponent. If the\n\t\t\t\t\t\t\t// biased exponent is zero now (-1023), we process a\n\t\t\t\t\t\t\t// subnormal number, which has no impled leading 1-bit.\n\t\t\t\t\t\t\t// So, count this 0-bit and unset skip to write out\n\t\t\t\t\t\t\t// all the following bits.\n\t\t\t\t\t\t\tbits++;\n\t\t\t\t\t\t\tskip = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (bits === 20) {\n\t\t\t\t\t\t// When 20 bits have been created in total, we're done with\n\t\t\t\t\t\t// the high word. Copy the bits from 'buffer' f into high\n\t\t\t\t\t\t// and reset 'buffer' f. Following bits will end up in the\n\t\t\t\t\t\t// low word.\n\t\t\t\t\t\thigh |= f;\n\t\t\t\t\t\tf = 0;\n\t\t\t\t\t} else if (bits === 52) {\n\t\t\t\t\t\t// When 52 bits have been created in total, we're done with\n\t\t\t\t\t\t// low word as well. Copy the bits from 'buffer' f into low\n\t\t\t\t\t\t// and exit the loop.\n\t\t\t\t\t\tlow |= f;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (y === 1) {\n\t\t\t\t\t\t// When y is exactly 1, there is no remainder and the process\n\t\t\t\t\t\t// is complete (the number is finite). Copy the bits from\n\t\t\t\t\t\t// 'buffer' f into either low or high and exit the loop.\n\t\t\t\t\t\tif (bits < 20) {\n\t\t\t\t\t\t\thigh |= (f << (20 - bits));\n\t\t\t\t\t\t} else if (bits < 52) {\n\t\t\t\t\t\t\tlow |= (f << (52 - bits));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Copy/shift the exponent and sign bits into the high word.\n\t\t\thigh |= (exp << 20);\n\t\t\thigh |= sign;\n\t\n\t\t\treturn new Long(high, low);\n\t\t};\n\t\tDouble.longBitsToDouble = function (bits) {\n\t\t\tvar x, sign, exp, fract;\n\t\t\tvar high = bits.high;\n\t\t\tvar low = bits.low;\n\t\n\t\t\t// Extract the sign.\n\t\t\tsign = (high & (1 << 31)) ? -1 : 1;\n\t\n\t\t\t// Extract the unbiased exponent.\n\t\t\texp = ((high & 0x7ff00000) >> 20) - BIAS;\n\t\n\t\t\t// Calculate the fraction from left to right. Start\n\t\t\t// off with the 20 lower bits from the high word.\n\t\t\tfract = 0;\n\t\t\tx = (1 << 19);\n\t\t\tfor (var i = 1; i <= 20; i++) {\n\t\t\t\tif (high & x) {\n\t\t\t\t\tfract += pow(2, -i);\n\t\t\t\t}\n\t\t\t\tx >>>= 1;\n\t\t\t}\n\t\t\t// Continue with all 32 bits from the low word.\n\t\t\tx = (1 << 31);\n\t\t\tfor (var i = 21; i <= 52; i++) {\n\t\t\t\tif (low & x) {\n\t\t\t\t\tfract += pow(2, -i);\n\t\t\t\t}\n\t\t\t\tx >>>= 1;\n\t\t\t}\n\t\n\t\t\t// Handle special values.\n\t\t\t// Check for zero and subnormal values.\n\t\t\tif (exp === -BIAS) {\n\t\t\t\tif (fract === 0) {\n\t\t\t\t\t// +/-1.0 * 0.0 => +/-0.0\n\t\t\t\t\treturn sign * 0;\n\t\t\t\t}\n\t\t\t\texp = -1022;\n\t\t\t}\n\t\t\t// Check for +/-Infinity or NaN.\n\t\t\telse if (exp === BIAS + 1) {\n\t\t\t\tif (fract === 0) {\n\t\t\t\t\t// +/-1.0 / 0.0 => +/-Infinity\n\t\t\t\t\treturn sign / 0;\n\t\t\t\t}\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// Nothing special? Seems to be a normal number.\n\t\t\telse {\n\t\t\t\t// Add the implicit leading bit (1*2^0).\n\t\t\t\tfract += 1;\n\t\t\t}\n\t\n\t\t\treturn sign * fract * pow(2, exp);\n\t\t};\n\t})();\n}","/**\n * @module M/control/AttributionsControl\n */\nimport AttributionsImplControl from '../../impl/ol/js/attributionscontrol';\nimport template from '../../templates/attributions';\nimport { getValue } from './i18n/language';\n\n/**\n * @classdesc\n * Main constructor of the class. Creates a PluginControl\n * control\n */\nexport default class AttributionsControl extends M.Control {\n  /**\n   * @constructor\n   * @extends {M.Control}\n   * @api\n   */\n  constructor(position, closePanel) {\n    if (M.utils.isUndefined(AttributionsImplControl)) {\n      M.exception(getValue('exception.impl'));\n    }\n    const impl = new AttributionsImplControl();\n    super(impl, 'Attributions');\n    this.position = position;\n    this.closePanel = closePanel;\n  }\n\n  /**\n   * This function creates the view\n   *\n   * @public\n   * @function\n   * @param {M.Map} map to add the control\n   * @api\n   */\n  createView(map) {\n    this.map = map;\n    return new Promise((success, fail) => {\n      const html = M.template.compileSync(template, {\n        vars: {\n          icon: this.position === 'BR' || this.position === 'TR' ?\n            'g-cartografia-flecha-derecha' : 'g-cartografia-flecha-izquierda',\n        },\n      });\n      html.querySelector('#close-button').addEventListener('click', () => this.closePanel());\n      this.html_ = html;\n\n      success(html);\n    });\n  }\n\n  /**\n   * This function compares controls\n   *\n   * @public\n   * @function\n   * @param {M.Control} control to compare\n   * @api\n   */\n  equals(control) {\n    return control instanceof AttributionsControl;\n  }\n\n  destroy() {\n    this.getImpl().destroy();\n  }\n}\n","export default function (o, i) {\n  return o.interfaces_ && o.interfaces_.indexOf(i) > -1\n}\n","export default function Clonable () {}\n","import Cloneable from '../../../../java/lang/Cloneable';\nexport default class CoordinateSequence {\n\tconstructor() {\n\t\tCoordinateSequence.constructor_.apply(this, arguments);\n\t}\n\tsetOrdinate(index, ordinateIndex, value) {}\n\tsize() {}\n\tgetOrdinate(index, ordinateIndex) {}\n\tgetCoordinate() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet i = arguments[0];\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet index = arguments[0], coord = arguments[1];\n\t\t}\n\t}\n\tgetCoordinateCopy(i) {}\n\tgetDimension() {}\n\tgetX(index) {}\n\texpandEnvelope(env) {}\n\tcopy() {}\n\tgetY(index) {}\n\ttoCoordinateArray() {}\n\tgetClass() {\n\t\treturn CoordinateSequence;\n\t}\n\tget interfaces_() {\n\t\treturn [Cloneable];\n\t}\n}\nCoordinateSequence.constructor_ = function () {};\nCoordinateSequence.X = 0;\nCoordinateSequence.Y = 1;\nCoordinateSequence.Z = 2;\nCoordinateSequence.M = 3;\n","import hasInterface from '../../../../hasInterface';\nimport CoordinateSequence from './CoordinateSequence';\nexport default class CoordinateSequenceFactory {\n\tconstructor() {\n\t\tCoordinateSequenceFactory.constructor_.apply(this, arguments);\n\t}\n\tcreate() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordSeq = arguments[0];\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet size = arguments[0], dimension = arguments[1];\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn CoordinateSequenceFactory;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCoordinateSequenceFactory.constructor_ = function () {};\n","export default function IllegalArgumentException (message) {\n  this.message = message\n}\n","export default class GeometryComponentFilter {\n\tconstructor() {\n\t\tGeometryComponentFilter.constructor_.apply(this, arguments);\n\t}\n\tfilter(geom) {}\n\tgetClass() {\n\t\treturn GeometryComponentFilter;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGeometryComponentFilter.constructor_ = function () {};\n","export default function Comparable () {}\n","export default function Serializable () {}\n","export default class NumberUtil {\n\tconstructor() {\n\t\tNumberUtil.constructor_.apply(this, arguments);\n\t}\n\tstatic equalsWithTolerance(x1, x2, tolerance) {\n\t\treturn Math.abs(x1 - x2) <= tolerance;\n\t}\n\tgetClass() {\n\t\treturn NumberUtil;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nNumberUtil.constructor_ = function () {};\n","export default function Long(high, low) {\n  this.low = low | 0\n  this.high = high | 0\n}\n\nLong.toBinaryString = function (i) {\n  var result = ''\n  for (var mask = 0x80000000; mask > 0; mask >>>= 1)\n    result += (i.high & mask) === mask ? '1' : '0'\n  for (var mask = 0x80000000; mask > 0; mask >>>= 1)\n    result += (i.low & mask) === mask ? '1' : '0'\n  return result\n}","export default function Comparator () {}\n","export default function RuntimeException (message) {\n  this.name = 'RuntimeException'\n  this.message = message\n  this.stack = (new Error()).stack\n  Error.call(this, message)\n}\n\nRuntimeException.prototype = Object.create(Error.prototype)\nRuntimeException.prototype.constructor = Error\n","import RuntimeException from '../../../../java/lang/RuntimeException';\nexport default class AssertionFailedException extends RuntimeException {\n\tconstructor() {\n\t\tsuper();\n\t\tAssertionFailedException.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn AssertionFailedException;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nAssertionFailedException.constructor_ = function () {\n\tif (arguments.length === 0) {\n\t\tRuntimeException.constructor_.call(this);\n\t} else if (arguments.length === 1) {\n\t\tlet message = arguments[0];\n\t\tRuntimeException.constructor_.call(this, message);\n\t}\n};\n","import AssertionFailedException from './AssertionFailedException';\nexport default class Assert {\n\tconstructor() {\n\t\tAssert.constructor_.apply(this, arguments);\n\t}\n\tstatic shouldNeverReachHere() {\n\t\tif (arguments.length === 0) {\n\t\t\tAssert.shouldNeverReachHere(null);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet message = arguments[0];\n\t\t\tthrow new AssertionFailedException(\"Should never reach here\" + (message !== null ? \": \" + message : \"\"));\n\t\t}\n\t}\n\tstatic isTrue() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet assertion = arguments[0];\n\t\t\tAssert.isTrue(assertion, null);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet assertion = arguments[0], message = arguments[1];\n\t\t\tif (!assertion) {\n\t\t\t\tif (message === null) {\n\t\t\t\t\tthrow new AssertionFailedException();\n\t\t\t\t} else {\n\t\t\t\t\tthrow new AssertionFailedException(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic equals() {\n\t\tif (arguments.length === 2) {\n\t\t\tlet expectedValue = arguments[0], actualValue = arguments[1];\n\t\t\tAssert.equals(expectedValue, actualValue, null);\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet expectedValue = arguments[0], actualValue = arguments[1], message = arguments[2];\n\t\t\tif (!actualValue.equals(expectedValue)) {\n\t\t\t\tthrow new AssertionFailedException(\"Expected \" + expectedValue + \" but encountered \" + actualValue + (message !== null ? \": \" + message : \"\"));\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn Assert;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nAssert.constructor_ = function () {};\n","import NumberUtil from '../util/NumberUtil';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Double from '../../../../java/lang/Double';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport Comparator from '../../../../java/util/Comparator';\nimport Serializable from '../../../../java/io/Serializable';\nimport Assert from '../util/Assert';\nexport default class Coordinate {\n\tconstructor() {\n\t\tCoordinate.constructor_.apply(this, arguments);\n\t}\n\tstatic hashCode() {\n\t\tif (arguments.length === 1 && typeof arguments[0] === \"number\") {\n\t\t\tlet x = arguments[0];\n\t\t\tvar f = Double.doubleToLongBits(x);\n\t\t\treturn Math.trunc(f ^ f >>> 32);\n\t\t}\n\t}\n\tsetOrdinate(ordinateIndex, value) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase Coordinate.X:\n\t\t\t\tthis.x = value;\n\t\t\t\tbreak;\n\t\t\tcase Coordinate.Y:\n\t\t\t\tthis.y = value;\n\t\t\t\tbreak;\n\t\t\tcase Coordinate.Z:\n\t\t\t\tthis.z = value;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n\t\t}\n\t}\n\tequals2D() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet other = arguments[0];\n\t\t\tif (this.x !== other.x) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.y !== other.y) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet c = arguments[0], tolerance = arguments[1];\n\t\t\tif (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tgetOrdinate(ordinateIndex) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase Coordinate.X:\n\t\t\t\treturn this.x;\n\t\t\tcase Coordinate.Y:\n\t\t\t\treturn this.y;\n\t\t\tcase Coordinate.Z:\n\t\t\t\treturn this.z;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n\t}\n\tequals3D(other) {\n\t\treturn this.x === other.x && this.y === other.y && (this.z === other.z || Double.isNaN(this.z) && Double.isNaN(other.z));\n\t}\n\tequals(other) {\n\t\tif (!(other instanceof Coordinate)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.equals2D(other);\n\t}\n\tequalInZ(c, tolerance) {\n\t\treturn NumberUtil.equalsWithTolerance(this.z, c.z, tolerance);\n\t}\n\tcompareTo(o) {\n\t\tvar other = o;\n\t\tif (this.x < other.x) return -1;\n\t\tif (this.x > other.x) return 1;\n\t\tif (this.y < other.y) return -1;\n\t\tif (this.y > other.y) return 1;\n\t\treturn 0;\n\t}\n\tclone() {\n\t\ttry {\n\t\t\tvar coord = null;\n\t\t\treturn coord;\n\t\t} catch (e) {\n\t\t\tif (e instanceof CloneNotSupportedException) {\n\t\t\t\tAssert.shouldNeverReachHere(\"this shouldn't happen because this class is Cloneable\");\n\t\t\t\treturn null;\n\t\t\t} else throw e;\n\t\t} finally {}\n\t}\n\tcopy() {\n\t\treturn new Coordinate(this);\n\t}\n\ttoString() {\n\t\treturn \"(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\n\t}\n\tdistance3D(c) {\n\t\tvar dx = this.x - c.x;\n\t\tvar dy = this.y - c.y;\n\t\tvar dz = this.z - c.z;\n\t\treturn Math.sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n\tdistance(c) {\n\t\tvar dx = this.x - c.x;\n\t\tvar dy = this.y - c.y;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\thashCode() {\n\t\tvar result = 17;\n\t\tresult = 37 * result + Coordinate.hashCode(this.x);\n\t\tresult = 37 * result + Coordinate.hashCode(this.y);\n\t\treturn result;\n\t}\n\tsetCoordinate(other) {\n\t\tthis.x = other.x;\n\t\tthis.y = other.y;\n\t\tthis.z = other.z;\n\t}\n\tgetClass() {\n\t\treturn Coordinate;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparable, Cloneable, Serializable];\n\t}\n}\nclass DimensionalComparator {\n\tconstructor() {\n\t\tDimensionalComparator.constructor_.apply(this, arguments);\n\t}\n\tstatic compare(a, b) {\n\t\tif (a < b) return -1;\n\t\tif (a > b) return 1;\n\t\tif (Double.isNaN(a)) {\n\t\t\tif (Double.isNaN(b)) return 0;\n\t\t\treturn -1;\n\t\t}\n\t\tif (Double.isNaN(b)) return 1;\n\t\treturn 0;\n\t}\n\tcompare(o1, o2) {\n\t\tvar c1 = o1;\n\t\tvar c2 = o2;\n\t\tvar compX = DimensionalComparator.compare(c1.x, c2.x);\n\t\tif (compX !== 0) return compX;\n\t\tvar compY = DimensionalComparator.compare(c1.y, c2.y);\n\t\tif (compY !== 0) return compY;\n\t\tif (this._dimensionsToTest <= 2) return 0;\n\t\tvar compZ = DimensionalComparator.compare(c1.z, c2.z);\n\t\treturn compZ;\n\t}\n\tgetClass() {\n\t\treturn DimensionalComparator;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparator];\n\t}\n}\nDimensionalComparator.constructor_ = function () {\n\tthis._dimensionsToTest = 2;\n\tif (arguments.length === 0) {\n\t\tDimensionalComparator.constructor_.call(this, 2);\n\t} else if (arguments.length === 1) {\n\t\tlet dimensionsToTest = arguments[0];\n\t\tif (dimensionsToTest !== 2 && dimensionsToTest !== 3) throw new IllegalArgumentException(\"only 2 or 3 dimensions may be specified\");\n\t\tthis._dimensionsToTest = dimensionsToTest;\n\t}\n};\nCoordinate.DimensionalComparator = DimensionalComparator;\nCoordinate.constructor_ = function () {\n\tthis.x = null;\n\tthis.y = null;\n\tthis.z = null;\n\tif (arguments.length === 0) {\n\t\tCoordinate.constructor_.call(this, 0.0, 0.0);\n\t} else if (arguments.length === 1) {\n\t\tlet c = arguments[0];\n\t\tCoordinate.constructor_.call(this, c.x, c.y, c.z);\n\t} else if (arguments.length === 2) {\n\t\tlet x = arguments[0], y = arguments[1];\n\t\tCoordinate.constructor_.call(this, x, y, Coordinate.NULL_ORDINATE);\n\t} else if (arguments.length === 3) {\n\t\tlet x = arguments[0], y = arguments[1], z = arguments[2];\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t}\n};\nCoordinate.serialVersionUID = 6683108902428366910;\nCoordinate.NULL_ORDINATE = Double.NaN;\nCoordinate.X = 0;\nCoordinate.Y = 1;\nCoordinate.Z = 2;\n","import Coordinate from './Coordinate';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Serializable from '../../../../java/io/Serializable';\nexport default class Envelope {\n\tconstructor() {\n\t\tEnvelope.constructor_.apply(this, arguments);\n\t}\n\tstatic intersects() {\n\t\tif (arguments.length === 3) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1], q = arguments[2];\n\t\t\tif (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && (q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3];\n\t\t\tvar minq = Math.min(q1.x, q2.x);\n\t\t\tvar maxq = Math.max(q1.x, q2.x);\n\t\t\tvar minp = Math.min(p1.x, p2.x);\n\t\t\tvar maxp = Math.max(p1.x, p2.x);\n\t\t\tif (minp > maxq) return false;\n\t\t\tif (maxp < minq) return false;\n\t\t\tminq = Math.min(q1.y, q2.y);\n\t\t\tmaxq = Math.max(q1.y, q2.y);\n\t\t\tminp = Math.min(p1.y, p2.y);\n\t\t\tmaxp = Math.max(p1.y, p2.y);\n\t\t\tif (minp > maxq) return false;\n\t\t\tif (maxp < minq) return false;\n\t\t\treturn true;\n\t\t}\n\t}\n\tgetArea() {\n\t\treturn this.getWidth() * this.getHeight();\n\t}\n\tequals(other) {\n\t\tif (!(other instanceof Envelope)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar otherEnvelope = other;\n\t\tif (this.isNull()) {\n\t\t\treturn otherEnvelope.isNull();\n\t\t}\n\t\treturn this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY();\n\t}\n\tintersection(env) {\n\t\tif (this.isNull() || env.isNull() || !this.intersects(env)) return new Envelope();\n\t\tvar intMinX = this._minx > env._minx ? this._minx : env._minx;\n\t\tvar intMinY = this._miny > env._miny ? this._miny : env._miny;\n\t\tvar intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;\n\t\tvar intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;\n\t\treturn new Envelope(intMinX, intMaxX, intMinY, intMaxY);\n\t}\n\tisNull() {\n\t\treturn this._maxx < this._minx;\n\t}\n\tgetMaxX() {\n\t\treturn this._maxx;\n\t}\n\tcovers() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\treturn this.covers(p.x, p.y);\n\t\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\tif (this.isNull() || other.isNull()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\tif (this.isNull()) return false;\n\t\t\treturn x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy;\n\t\t}\n\t}\n\tintersects() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\tif (this.isNull() || other.isNull()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny);\n\t\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\treturn this.intersects(p.x, p.y);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tif (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\t\t\tlet a = arguments[0], b = arguments[1];\n\t\t\t\tif (this.isNull()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tvar envminx = a.x < b.x ? a.x : b.x;\n\t\t\t\tif (envminx > this._maxx) return false;\n\t\t\t\tvar envmaxx = a.x > b.x ? a.x : b.x;\n\t\t\t\tif (envmaxx < this._minx) return false;\n\t\t\t\tvar envminy = a.y < b.y ? a.y : b.y;\n\t\t\t\tif (envminy > this._maxy) return false;\n\t\t\t\tvar envmaxy = a.y > b.y ? a.y : b.y;\n\t\t\t\tif (envmaxy < this._miny) return false;\n\t\t\t\treturn true;\n\t\t\t} else if (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\t\tif (this.isNull()) return false;\n\t\t\t\treturn !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny);\n\t\t\t}\n\t\t}\n\t}\n\tgetMinY() {\n\t\treturn this._miny;\n\t}\n\tgetMinX() {\n\t\treturn this._minx;\n\t}\n\texpandToInclude() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\tthis.expandToInclude(p.x, p.y);\n\t\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\tif (other.isNull()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (this.isNull()) {\n\t\t\t\t\tthis._minx = other.getMinX();\n\t\t\t\t\tthis._maxx = other.getMaxX();\n\t\t\t\t\tthis._miny = other.getMinY();\n\t\t\t\t\tthis._maxy = other.getMaxY();\n\t\t\t\t} else {\n\t\t\t\t\tif (other._minx < this._minx) {\n\t\t\t\t\t\tthis._minx = other._minx;\n\t\t\t\t\t}\n\t\t\t\t\tif (other._maxx > this._maxx) {\n\t\t\t\t\t\tthis._maxx = other._maxx;\n\t\t\t\t\t}\n\t\t\t\t\tif (other._miny < this._miny) {\n\t\t\t\t\t\tthis._miny = other._miny;\n\t\t\t\t\t}\n\t\t\t\t\tif (other._maxy > this._maxy) {\n\t\t\t\t\t\tthis._maxy = other._maxy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\tif (this.isNull()) {\n\t\t\t\tthis._minx = x;\n\t\t\t\tthis._maxx = x;\n\t\t\t\tthis._miny = y;\n\t\t\t\tthis._maxy = y;\n\t\t\t} else {\n\t\t\t\tif (x < this._minx) {\n\t\t\t\t\tthis._minx = x;\n\t\t\t\t}\n\t\t\t\tif (x > this._maxx) {\n\t\t\t\t\tthis._maxx = x;\n\t\t\t\t}\n\t\t\t\tif (y < this._miny) {\n\t\t\t\t\tthis._miny = y;\n\t\t\t\t}\n\t\t\t\tif (y > this._maxy) {\n\t\t\t\t\tthis._maxy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tminExtent() {\n\t\tif (this.isNull()) return 0.0;\n\t\tvar w = this.getWidth();\n\t\tvar h = this.getHeight();\n\t\tif (w < h) return w;\n\t\treturn h;\n\t}\n\tgetWidth() {\n\t\tif (this.isNull()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._maxx - this._minx;\n\t}\n\tcompareTo(o) {\n\t\tvar env = o;\n\t\tif (this.isNull()) {\n\t\t\tif (env.isNull()) return 0;\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tif (env.isNull()) return 1;\n\t\t}\n\t\tif (this._minx < env._minx) return -1;\n\t\tif (this._minx > env._minx) return 1;\n\t\tif (this._miny < env._miny) return -1;\n\t\tif (this._miny > env._miny) return 1;\n\t\tif (this._maxx < env._maxx) return -1;\n\t\tif (this._maxx > env._maxx) return 1;\n\t\tif (this._maxy < env._maxy) return -1;\n\t\tif (this._maxy > env._maxy) return 1;\n\t\treturn 0;\n\t}\n\ttranslate(transX, transY) {\n\t\tif (this.isNull()) {\n\t\t\treturn null;\n\t\t}\n\t\tthis.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);\n\t}\n\ttoString() {\n\t\treturn \"Env[\" + this._minx + \" : \" + this._maxx + \", \" + this._miny + \" : \" + this._maxy + \"]\";\n\t}\n\tsetToNull() {\n\t\tthis._minx = 0;\n\t\tthis._maxx = -1;\n\t\tthis._miny = 0;\n\t\tthis._maxy = -1;\n\t}\n\tgetHeight() {\n\t\tif (this.isNull()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._maxy - this._miny;\n\t}\n\tmaxExtent() {\n\t\tif (this.isNull()) return 0.0;\n\t\tvar w = this.getWidth();\n\t\tvar h = this.getHeight();\n\t\tif (w > h) return w;\n\t\treturn h;\n\t}\n\texpandBy() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet distance = arguments[0];\n\t\t\tthis.expandBy(distance, distance);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet deltaX = arguments[0], deltaY = arguments[1];\n\t\t\tif (this.isNull()) return null;\n\t\t\tthis._minx -= deltaX;\n\t\t\tthis._maxx += deltaX;\n\t\t\tthis._miny -= deltaY;\n\t\t\tthis._maxy += deltaY;\n\t\t\tif (this._minx > this._maxx || this._miny > this._maxy) this.setToNull();\n\t\t}\n\t}\n\tcontains() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\treturn this.covers(other);\n\t\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\treturn this.covers(p);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\treturn this.covers(x, y);\n\t\t}\n\t}\n\tcentre() {\n\t\tif (this.isNull()) return null;\n\t\treturn new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0);\n\t}\n\tinit() {\n\t\tif (arguments.length === 0) {\n\t\t\tthis.setToNull();\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\tthis.init(p.x, p.x, p.y, p.y);\n\t\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\t\tlet env = arguments[0];\n\t\t\t\tthis._minx = env._minx;\n\t\t\t\tthis._maxx = env._maxx;\n\t\t\t\tthis._miny = env._miny;\n\t\t\t\tthis._maxy = env._maxy;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\t\tthis.init(p1.x, p2.x, p1.y, p2.y);\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet x1 = arguments[0], x2 = arguments[1], y1 = arguments[2], y2 = arguments[3];\n\t\t\tif (x1 < x2) {\n\t\t\t\tthis._minx = x1;\n\t\t\t\tthis._maxx = x2;\n\t\t\t} else {\n\t\t\t\tthis._minx = x2;\n\t\t\t\tthis._maxx = x1;\n\t\t\t}\n\t\t\tif (y1 < y2) {\n\t\t\t\tthis._miny = y1;\n\t\t\t\tthis._maxy = y2;\n\t\t\t} else {\n\t\t\t\tthis._miny = y2;\n\t\t\t\tthis._maxy = y1;\n\t\t\t}\n\t\t}\n\t}\n\tgetMaxY() {\n\t\treturn this._maxy;\n\t}\n\tdistance(env) {\n\t\tif (this.intersects(env)) return 0;\n\t\tvar dx = 0.0;\n\t\tif (this._maxx < env._minx) dx = env._minx - this._maxx; else if (this._minx > env._maxx) dx = this._minx - env._maxx;\n\t\tvar dy = 0.0;\n\t\tif (this._maxy < env._miny) dy = env._miny - this._maxy; else if (this._miny > env._maxy) dy = this._miny - env._maxy;\n\t\tif (dx === 0.0) return dy;\n\t\tif (dy === 0.0) return dx;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\thashCode() {\n\t\tvar result = 17;\n\t\tresult = 37 * result + Coordinate.hashCode(this._minx);\n\t\tresult = 37 * result + Coordinate.hashCode(this._maxx);\n\t\tresult = 37 * result + Coordinate.hashCode(this._miny);\n\t\tresult = 37 * result + Coordinate.hashCode(this._maxy);\n\t\treturn result;\n\t}\n\tgetClass() {\n\t\treturn Envelope;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparable, Serializable];\n\t}\n}\nEnvelope.constructor_ = function () {\n\tthis._minx = null;\n\tthis._maxx = null;\n\tthis._miny = null;\n\tthis._maxy = null;\n\tif (arguments.length === 0) {\n\t\tthis.init();\n\t} else if (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\tthis.init(p.x, p.x, p.y, p.y);\n\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\tlet env = arguments[0];\n\t\t\tthis.init(env);\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\tthis.init(p1.x, p2.x, p1.y, p2.y);\n\t} else if (arguments.length === 4) {\n\t\tlet x1 = arguments[0], x2 = arguments[1], y1 = arguments[2], y2 = arguments[3];\n\t\tthis.init(x1, x2, y1, y2);\n\t}\n};\nEnvelope.serialVersionUID = 5873921885273102420;\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport Serializable from '../../../../java/io/Serializable';\nimport Envelope from './Envelope';\nexport default class Geometry {\n\tconstructor() {\n\t\tGeometry.constructor_.apply(this, arguments);\n\t}\n\tisGeometryCollection() {\n\t\treturn this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION;\n\t}\n\tgetFactory() {\n\t\treturn this._factory;\n\t}\n\tgetGeometryN(n) {\n\t\treturn this;\n\t}\n\tgetArea() {\n\t\treturn 0.0;\n\t}\n\tisRectangle() {\n\t\treturn false;\n\t}\n\tequals() {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tlet g = arguments[0];\n\t\t\tif (g === null) return false;\n\t\t\treturn this.equalsTopo(g);\n\t\t} else if (arguments[0] instanceof Object) {\n\t\t\tlet o = arguments[0];\n\t\t\tif (!(o instanceof Geometry)) return false;\n\t\t\tvar g = o;\n\t\t\treturn this.equalsExact(g);\n\t\t}\n\t}\n\tequalsExact(other) {\n\t\treturn this === other || this.equalsExact(other, 0);\n\t}\n\tgeometryChanged() {\n\t\tthis.apply(Geometry.geometryChangedFilter);\n\t}\n\tgeometryChangedAction() {\n\t\tthis._envelope = null;\n\t}\n\tequalsNorm(g) {\n\t\tif (g === null) return false;\n\t\treturn this.norm().equalsExact(g.norm());\n\t}\n\tgetLength() {\n\t\treturn 0.0;\n\t}\n\tgetNumGeometries() {\n\t\treturn 1;\n\t}\n\tcompareTo() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar other = o;\n\t\t\tif (this.getTypeCode() !== other.getTypeCode()) {\n\t\t\t\treturn this.getTypeCode() - other.getTypeCode();\n\t\t\t}\n\t\t\tif (this.isEmpty() && other.isEmpty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (other.isEmpty()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn this.compareToSameClass(o);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar other = o;\n\t\t\tif (this.getTypeCode() !== other.getTypeCode()) {\n\t\t\t\treturn this.getTypeCode() - other.getTypeCode();\n\t\t\t}\n\t\t\tif (this.isEmpty() && other.isEmpty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (other.isEmpty()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn this.compareToSameClass(o, comp);\n\t\t}\n\t}\n\tgetUserData() {\n\t\treturn this._userData;\n\t}\n\tgetSRID() {\n\t\treturn this._SRID;\n\t}\n\tgetEnvelope() {\n\t\treturn this.getFactory().toGeometry(this.getEnvelopeInternal());\n\t}\n\tcheckNotGeometryCollection(g) {\n\t\tif (g.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION) {\n\t\t\tthrow new IllegalArgumentException(\"This method does not support GeometryCollection arguments\");\n\t\t}\n\t}\n\tequal(a, b, tolerance) {\n\t\tif (tolerance === 0) {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\treturn a.distance(b) <= tolerance;\n\t}\n\tnorm() {\n\t\tvar copy = this.copy();\n\t\tcopy.normalize();\n\t\treturn copy;\n\t}\n\tgetPrecisionModel() {\n\t\treturn this._factory.getPrecisionModel();\n\t}\n\tgetEnvelopeInternal() {\n\t\tif (this._envelope === null) {\n\t\t\tthis._envelope = this.computeEnvelopeInternal();\n\t\t}\n\t\treturn new Envelope(this._envelope);\n\t}\n\tsetSRID(SRID) {\n\t\tthis._SRID = SRID;\n\t}\n\tsetUserData(userData) {\n\t\tthis._userData = userData;\n\t}\n\tcompare(a, b) {\n\t\tvar i = a.iterator();\n\t\tvar j = b.iterator();\n\t\twhile (i.hasNext() && j.hasNext()) {\n\t\t\tvar aElement = i.next();\n\t\t\tvar bElement = j.next();\n\t\t\tvar comparison = aElement.compareTo(bElement);\n\t\t\tif (comparison !== 0) {\n\t\t\t\treturn comparison;\n\t\t\t}\n\t\t}\n\t\tif (i.hasNext()) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (j.hasNext()) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\thashCode() {\n\t\treturn this.getEnvelopeInternal().hashCode();\n\t}\n\tisGeometryCollectionOrDerived() {\n\t\tif (this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === Geometry.TYPECODE_MULTIPOINT || this.getTypeCode() === Geometry.TYPECODE_MULTILINESTRING || this.getTypeCode() === Geometry.TYPECODE_MULTIPOLYGON) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tget interfaces_() {\n\t\treturn [Cloneable, Comparable, Serializable];\n\t}\n\tgetClass() {\n\t\treturn Geometry;\n\t}\n\tstatic hasNonEmptyElements(geometries) {\n\t\tfor (var i = 0; i < geometries.length; i++) {\n\t\t\tif (!geometries[i].isEmpty()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tstatic hasNullElements(array) {\n\t\tfor (var i = 0; i < array.length; i++) {\n\t\t\tif (array[i] === null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\nGeometry.constructor_ = function (factory) {\n\tif (!factory)\n\t\treturn;\n\tthis._envelope = null;\n\tthis._userData = null;\n\tthis._factory = factory;\n\tthis._SRID = factory.getSRID();\n};\nGeometry.serialVersionUID = 8763622679187376702;\nGeometry.TYPECODE_POINT = 0;\nGeometry.TYPECODE_MULTIPOINT = 1;\nGeometry.TYPECODE_LINESTRING = 2;\nGeometry.TYPECODE_LINEARRING = 3;\nGeometry.TYPECODE_MULTILINESTRING = 4;\nGeometry.TYPECODE_POLYGON = 5;\nGeometry.TYPECODE_MULTIPOLYGON = 6;\nGeometry.TYPECODE_GEOMETRYCOLLECTION = 7;\nGeometry.TYPENAME_POINT = \"Point\";\nGeometry.TYPENAME_MULTIPOINT = \"MultiPoint\";\nGeometry.TYPENAME_LINESTRING = \"LineString\";\nGeometry.TYPENAME_LINEARRING = \"LinearRing\";\nGeometry.TYPENAME_MULTILINESTRING = \"MultiLineString\";\nGeometry.TYPENAME_POLYGON = \"Polygon\";\nGeometry.TYPENAME_MULTIPOLYGON = \"MultiPolygon\";\nGeometry.TYPENAME_GEOMETRYCOLLECTION = \"GeometryCollection\";\nGeometry.geometryChangedFilter = {\n\tget interfaces_() {\n\t\treturn [GeometryComponentFilter];\n\t},\n\tfilter(geom) {\n\t\tgeom.geometryChangedAction();\n\t}\n};\n","export default class CoordinateFilter {\n\tconstructor() {\n\t\tCoordinateFilter.constructor_.apply(this, arguments);\n\t}\n\tfilter(coord) {}\n\tgetClass() {\n\t\treturn CoordinateFilter;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCoordinateFilter.constructor_ = function () {};\n","export default class BoundaryNodeRule {\n\tconstructor() {\n\t\tBoundaryNodeRule.constructor_.apply(this, arguments);\n\t}\n\tisInBoundary(boundaryCount) {}\n\tgetClass() {\n\t\treturn BoundaryNodeRule;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nclass Mod2BoundaryNodeRule {\n\tconstructor() {\n\t\tMod2BoundaryNodeRule.constructor_.apply(this, arguments);\n\t}\n\tisInBoundary(boundaryCount) {\n\t\treturn boundaryCount % 2 === 1;\n\t}\n\tgetClass() {\n\t\treturn Mod2BoundaryNodeRule;\n\t}\n\tget interfaces_() {\n\t\treturn [BoundaryNodeRule];\n\t}\n}\nMod2BoundaryNodeRule.constructor_ = function () {};\nclass EndPointBoundaryNodeRule {\n\tconstructor() {\n\t\tEndPointBoundaryNodeRule.constructor_.apply(this, arguments);\n\t}\n\tisInBoundary(boundaryCount) {\n\t\treturn boundaryCount > 0;\n\t}\n\tgetClass() {\n\t\treturn EndPointBoundaryNodeRule;\n\t}\n\tget interfaces_() {\n\t\treturn [BoundaryNodeRule];\n\t}\n}\nEndPointBoundaryNodeRule.constructor_ = function () {};\nclass MultiValentEndPointBoundaryNodeRule {\n\tconstructor() {\n\t\tMultiValentEndPointBoundaryNodeRule.constructor_.apply(this, arguments);\n\t}\n\tisInBoundary(boundaryCount) {\n\t\treturn boundaryCount > 1;\n\t}\n\tgetClass() {\n\t\treturn MultiValentEndPointBoundaryNodeRule;\n\t}\n\tget interfaces_() {\n\t\treturn [BoundaryNodeRule];\n\t}\n}\nMultiValentEndPointBoundaryNodeRule.constructor_ = function () {};\nclass MonoValentEndPointBoundaryNodeRule {\n\tconstructor() {\n\t\tMonoValentEndPointBoundaryNodeRule.constructor_.apply(this, arguments);\n\t}\n\tisInBoundary(boundaryCount) {\n\t\treturn boundaryCount === 1;\n\t}\n\tgetClass() {\n\t\treturn MonoValentEndPointBoundaryNodeRule;\n\t}\n\tget interfaces_() {\n\t\treturn [BoundaryNodeRule];\n\t}\n}\nMonoValentEndPointBoundaryNodeRule.constructor_ = function () {};\nBoundaryNodeRule.Mod2BoundaryNodeRule = Mod2BoundaryNodeRule;\nBoundaryNodeRule.EndPointBoundaryNodeRule = EndPointBoundaryNodeRule;\nBoundaryNodeRule.MultiValentEndPointBoundaryNodeRule = MultiValentEndPointBoundaryNodeRule;\nBoundaryNodeRule.MonoValentEndPointBoundaryNodeRule = MonoValentEndPointBoundaryNodeRule;\nBoundaryNodeRule.constructor_ = function () {};\nBoundaryNodeRule.MOD2_BOUNDARY_RULE = new Mod2BoundaryNodeRule();\nBoundaryNodeRule.ENDPOINT_BOUNDARY_RULE = new EndPointBoundaryNodeRule();\nBoundaryNodeRule.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new MultiValentEndPointBoundaryNodeRule();\nBoundaryNodeRule.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new MonoValentEndPointBoundaryNodeRule();\nBoundaryNodeRule.OGC_SFS_BOUNDARY_RULE = BoundaryNodeRule.MOD2_BOUNDARY_RULE;\n","/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html\n * @constructor\n * @private\n */\nexport default function Iterator() {};\n\n/**\n * Returns true if the iteration has more elements.\n * @return {boolean}\n */\nIterator.prototype.hasNext = function() {};\n\n/**\n * Returns the next element in the iteration.\n * @return {Object}\n */\nIterator.prototype.next = function() {};\n\n/**\n * Removes from the underlying collection the last element returned by the\n * iterator (optional operation).\n */\nIterator.prototype.remove = function() {};\n","import Iterator from './Iterator'\n\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html\n *\n * @constructor\n * @private\n */\nexport default function Collection() {};\n\n/**\n * Ensures that this collection contains the specified element (optional\n * operation).\n * @param {Object} e\n * @return {boolean}\n */\nCollection.prototype.add = function() {};\n\n\n/**\n * Appends all of the elements in the specified collection to the end of this\n * list, in the order that they are returned by the specified collection's\n * iterator (optional operation).\n * @param {javascript.util.Collection} c\n * @return {boolean}\n */\nCollection.prototype.addAll = function() {};\n\n\n/**\n * Returns true if this collection contains no elements.\n * @return {boolean}\n */\nCollection.prototype.isEmpty = function() {};\n\n\n/**\n * Returns an iterator over the elements in this collection.\n * @return {javascript.util.Iterator}\n */\nCollection.prototype.iterator = function() {};\n\n\n/**\n * Returns an iterator over the elements in this collection.\n * @return {number}\n */\nCollection.prototype.size = function() {};\n\n\n/**\n * Returns an array containing all of the elements in this collection.\n * @return {Array}\n */\nCollection.prototype.toArray = function() {};\n\n\n/**\n * Removes a single instance of the specified element from this collection if it\n * is present. (optional)\n * @param {Object} e\n * @return {boolean}\n */\nCollection.prototype.remove = function() {};\n","/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nexport default function IndexOutOfBoundsException(message) {\n  this.message = message || '';\n};\nIndexOutOfBoundsException.prototype = new Error();\n\n/**\n * @type {string}\n */\nIndexOutOfBoundsException.prototype.name = 'IndexOutOfBoundsException';\n","import Collection from './Collection'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html\n *\n * @extends {javascript.util.Collection}\n * @constructor\n * @private\n */\nexport default function List() { };\nList.prototype = Object.create(Collection.prototype);\nList.prototype.constructor = List\n\n/**\n * Returns the element at the specified position in this list.\n * @param {number} index\n * @return {Object}\n */\nList.prototype.get = function() { };\n\n\n/**\n * Replaces the element at the specified position in this list with the\n * specified element (optional operation).\n * @param {number} index\n * @param {Object} e\n * @return {Object}\n */\nList.prototype.set = function() { };\n\n\n/**\n * Returns true if this collection contains no elements.\n * @return {boolean}\n */\nList.prototype.isEmpty = function() { };\n","/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nexport default function NoSuchElementException(message) {\n  this.message = message || '';\n};\nNoSuchElementException.prototype = new Error();\n\n\n/**\n * @type {string}\n */\nNoSuchElementException.prototype.name = 'NoSuchElementException';\n","/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nexport default function OperationNotSupported(message) {\n  this.message = message || '';\n};\nOperationNotSupported.prototype = new Error();\n\n\n/**\n * @type {string}\n */\nOperationNotSupported.prototype.name = 'OperationNotSupported';\n","import Collection from './Collection'\nimport IndexOutOfBoundsException from './IndexOutOfBoundsException'\nimport Iterator from './Iterator'\nimport List from './List'\nimport NoSuchElementException from './NoSuchElementException'\nimport OperationNotSupported from './OperationNotSupported'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html\n *\n * @extends List\n * @private\n */\nexport default function ArrayList () {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n};\nArrayList.prototype = Object.create(List.prototype)\nArrayList.prototype.constructor = ArrayList;\n\nArrayList.prototype.ensureCapacity = function () {}\nArrayList.prototype.interfaces_ = [List, Collection]\n\n/**\n * @override\n */\nArrayList.prototype.add = function(e) {\n  if (arguments.length === 1) {\n    this.array_.push(e)\n  } else {\n    this.array_.splice(arguments[0], 0, arguments[1])\n  }\n  return true\n};\n\nArrayList.prototype.clear = function() {\n  this.array_ = []\n}\n\n/**\n * @override\n */\nArrayList.prototype.addAll = function(c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.add(i.next());\n  }\n  return true;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.set = function(index, element) {\n  var oldElement = this.array_[index];\n  this.array_[index] = element;\n  return oldElement;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.iterator = function() {\n  return new Iterator_(this);\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.get = function(index) {\n  if (index < 0 || index >= this.size()) {\n    throw new IndexOutOfBoundsException();\n  }\n\n  return this.array_[index];\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.isEmpty = function() {\n  return this.array_.length === 0;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.size = function() {\n  return this.array_.length;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.toArray = function() {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.remove = function(o) {\n  var found = false;\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    if (this.array_[i] === o) {\n      this.array_.splice(i, 1);\n      found = true;\n      break;\n    }\n  }\n\n  return found;\n};\n\n\nArrayList.prototype.removeAll = function(c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.remove(i.next());\n  }\n  return true;\n};\n\n\n\n/**\n * @extends {Iterator}\n * @param {ArrayList} arrayList\n * @constructor\n * @private\n */\nvar Iterator_ = function(arrayList) {\n  /**\n   * @type {ArrayList}\n   * @private\n  */\n  this.arrayList_ = arrayList;\n  /**\n   * @type {number}\n   * @private\n  */\n  this.position_ = 0;\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.next = function() {\n  if (this.position_ === this.arrayList_.size()) {\n    throw new NoSuchElementException();\n  }\n  return this.arrayList_.get(this.position_++);\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.hasNext = function() {\n  if (this.position_ < this.arrayList_.size()) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * TODO: should be in ListIterator\n * @override\n */\nIterator_.prototype.set = function(element) {\n  return this.arrayList_.set(this.position_ - 1, element);\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.remove = function() {\n  this.arrayList_.remove(this.arrayList_.get(this.position_));\n};\n","import hasInterface from '../../../../hasInterface';\nimport Collection from '../../../../java/util/Collection';\nimport Coordinate from './Coordinate';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default class CoordinateList extends ArrayList {\n\tconstructor() {\n\t\tsuper();\n\t\tCoordinateList.constructor_.apply(this, arguments);\n\t}\n\tgetCoordinate(i) {\n\t\treturn this.get(i);\n\t}\n\taddAll() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"boolean\" && hasInterface(arguments[0], Collection))) {\n\t\t\tlet coll = arguments[0], allowRepeated = arguments[1];\n\t\t\tvar isChanged = false;\n\t\t\tfor (var i = coll.iterator(); i.hasNext(); ) {\n\t\t\t\tthis.add(i.next(), allowRepeated);\n\t\t\t\tisChanged = true;\n\t\t\t}\n\t\t\treturn isChanged;\n\t\t} else return super.addAll.apply(this, arguments);\n\t}\n\tclone() {\n\t\tvar clone = super.clone.call(this);\n\t\tfor (var i = 0; i < this.size(); i++) {\n\t\t\tclone.add(i, this.get(i).clone());\n\t\t}\n\t\treturn clone;\n\t}\n\ttoCoordinateArray() {\n\t\treturn this.toArray(CoordinateList.coordArrayType);\n\t}\n\tadd() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet coord = arguments[0];\n\t\t\tsuper.add.call(this, coord);\n\t\t} else if (arguments.length === 2) {\n\t\t\tif (arguments[0] instanceof Array && typeof arguments[1] === \"boolean\") {\n\t\t\t\tlet coord = arguments[0], allowRepeated = arguments[1];\n\t\t\t\tthis.add(coord, allowRepeated, true);\n\t\t\t\treturn true;\n\t\t\t} else if (arguments[0] instanceof Coordinate && typeof arguments[1] === \"boolean\") {\n\t\t\t\tlet coord = arguments[0], allowRepeated = arguments[1];\n\t\t\t\tif (!allowRepeated) {\n\t\t\t\t\tif (this.size() >= 1) {\n\t\t\t\t\t\tvar last = this.get(this.size() - 1);\n\t\t\t\t\t\tif (last.equals2D(coord)) return null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsuper.add.call(this, coord);\n\t\t\t} else if (arguments[0] instanceof Object && typeof arguments[1] === \"boolean\") {\n\t\t\t\tlet obj = arguments[0], allowRepeated = arguments[1];\n\t\t\t\tthis.add(obj, allowRepeated);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (typeof arguments[2] === \"boolean\" && (arguments[0] instanceof Array && typeof arguments[1] === \"boolean\")) {\n\t\t\t\tlet coord = arguments[0], allowRepeated = arguments[1], direction = arguments[2];\n\t\t\t\tif (direction) {\n\t\t\t\t\tfor (var i = 0; i < coord.length; i++) {\n\t\t\t\t\t\tthis.add(coord[i], allowRepeated);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i = coord.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tthis.add(coord[i], allowRepeated);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else if (typeof arguments[2] === \"boolean\" && (Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate)) {\n\t\t\t\tlet i = arguments[0], coord = arguments[1], allowRepeated = arguments[2];\n\t\t\t\tif (!allowRepeated) {\n\t\t\t\t\tvar size = this.size();\n\t\t\t\t\tif (size > 0) {\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\tvar prev = this.get(i - 1);\n\t\t\t\t\t\t\tif (prev.equals2D(coord)) return null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i < size) {\n\t\t\t\t\t\t\tvar next = this.get(i);\n\t\t\t\t\t\t\tif (next.equals2D(coord)) return null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsuper.add.call(this, i, coord);\n\t\t\t}\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet coord = arguments[0], allowRepeated = arguments[1], start = arguments[2], end = arguments[3];\n\t\t\tvar inc = 1;\n\t\t\tif (start > end) inc = -1;\n\t\t\tfor (var i = start; i !== end; i += inc) {\n\t\t\t\tthis.add(coord[i], allowRepeated);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tcloseRing() {\n\t\tif (this.size() > 0) this.add(new Coordinate(this.get(0)), false);\n\t}\n\tgetClass() {\n\t\treturn CoordinateList;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCoordinateList.constructor_ = function () {\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet coord = arguments[0];\n\t\tthis.ensureCapacity(coord.length);\n\t\tthis.add(coord, true);\n\t} else if (arguments.length === 2) {\n\t\tlet coord = arguments[0], allowRepeated = arguments[1];\n\t\tthis.ensureCapacity(coord.length);\n\t\tthis.add(coord, allowRepeated);\n\t}\n};\nCoordinateList.coordArrayType = new Array(0).fill(null);\n","import Double from '../../../../java/lang/Double';\nexport default class MathUtil {\n\tconstructor() {\n\t\tMathUtil.constructor_.apply(this, arguments);\n\t}\n\tstatic log10(x) {\n\t\tvar ln = Math.log(x);\n\t\tif (Double.isInfinite(ln)) return ln;\n\t\tif (Double.isNaN(ln)) return ln;\n\t\treturn ln / MathUtil.LOG_10;\n\t}\n\tstatic min(v1, v2, v3, v4) {\n\t\tvar min = v1;\n\t\tif (v2 < min) min = v2;\n\t\tif (v3 < min) min = v3;\n\t\tif (v4 < min) min = v4;\n\t\treturn min;\n\t}\n\tstatic clamp() {\n\t\tif (typeof arguments[2] === \"number\" && (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\")) {\n\t\t\tlet x = arguments[0], min = arguments[1], max = arguments[2];\n\t\t\tif (x < min) return min;\n\t\t\tif (x > max) return max;\n\t\t\treturn x;\n\t\t} else if (Number.isInteger(arguments[2]) && (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))) {\n\t\t\tlet x = arguments[0], min = arguments[1], max = arguments[2];\n\t\t\tif (x < min) return min;\n\t\t\tif (x > max) return max;\n\t\t\treturn x;\n\t\t}\n\t}\n\tstatic wrap(index, max) {\n\t\tif (index < 0) {\n\t\t\treturn max - -index % max;\n\t\t}\n\t\treturn index % max;\n\t}\n\tstatic max() {\n\t\tif (arguments.length === 3) {\n\t\t\tlet v1 = arguments[0], v2 = arguments[1], v3 = arguments[2];\n\t\t\tvar max = v1;\n\t\t\tif (v2 > max) max = v2;\n\t\t\tif (v3 > max) max = v3;\n\t\t\treturn max;\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet v1 = arguments[0], v2 = arguments[1], v3 = arguments[2], v4 = arguments[3];\n\t\t\tvar max = v1;\n\t\t\tif (v2 > max) max = v2;\n\t\t\tif (v3 > max) max = v3;\n\t\t\tif (v4 > max) max = v4;\n\t\t\treturn max;\n\t\t}\n\t}\n\tstatic average(x1, x2) {\n\t\treturn (x1 + x2) / 2.0;\n\t}\n\tgetClass() {\n\t\treturn MathUtil;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nMathUtil.constructor_ = function () {};\nMathUtil.LOG_10 = Math.log(10);\n","export default function System () { }\n\nSystem.arraycopy = (src, srcPos, dest, destPos, len) => {\n  let c = 0\n  for (let i = srcPos; i < srcPos + len; i++) {\n    dest[destPos + c] = src[i]\n    c++\n  }\n}\n\nSystem.getProperty = (name) => {\n  return {\n    'line.separator': '\\n'\n  }[name]\n}\n","import CoordinateList from './CoordinateList';\nimport Coordinate from './Coordinate';\nimport MathUtil from '../math/MathUtil';\nimport System from '../../../../java/lang/System';\nimport Comparator from '../../../../java/util/Comparator';\nimport Envelope from './Envelope';\nexport default class CoordinateArrays {\n\tconstructor() {\n\t\tCoordinateArrays.constructor_.apply(this, arguments);\n\t}\n\tstatic isRing(pts) {\n\t\tif (pts.length < 4) return false;\n\t\tif (!pts[0].equals2D(pts[pts.length - 1])) return false;\n\t\treturn true;\n\t}\n\tstatic ptNotInList(testPts, pts) {\n\t\tfor (var i = 0; i < testPts.length; i++) {\n\t\t\tvar testPt = testPts[i];\n\t\t\tif (CoordinateArrays.indexOf(testPt, pts) < 0) return testPt;\n\t\t}\n\t\treturn null;\n\t}\n\tstatic scroll(coordinates, firstCoordinate) {\n\t\tvar i = CoordinateArrays.indexOf(firstCoordinate, coordinates);\n\t\tif (i < 0) return null;\n\t\tvar newCoordinates = new Array(coordinates.length).fill(null);\n\t\tSystem.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);\n\t\tSystem.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);\n\t\tSystem.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);\n\t}\n\tstatic equals() {\n\t\tif (arguments.length === 2) {\n\t\t\tlet coord1 = arguments[0], coord2 = arguments[1];\n\t\t\tif (coord1 === coord2) return true;\n\t\t\tif (coord1 === null || coord2 === null) return false;\n\t\t\tif (coord1.length !== coord2.length) return false;\n\t\t\tfor (var i = 0; i < coord1.length; i++) {\n\t\t\t\tif (!coord1[i].equals(coord2[i])) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet coord1 = arguments[0], coord2 = arguments[1], coordinateComparator = arguments[2];\n\t\t\tif (coord1 === coord2) return true;\n\t\t\tif (coord1 === null || coord2 === null) return false;\n\t\t\tif (coord1.length !== coord2.length) return false;\n\t\t\tfor (var i = 0; i < coord1.length; i++) {\n\t\t\t\tif (coordinateComparator.compare(coord1[i], coord2[i]) !== 0) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tstatic intersection(coordinates, env) {\n\t\tvar coordList = new CoordinateList();\n\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\tif (env.intersects(coordinates[i])) coordList.add(coordinates[i], true);\n\t\t}\n\t\treturn coordList.toCoordinateArray();\n\t}\n\tstatic hasRepeatedPoints(coord) {\n\t\tfor (var i = 1; i < coord.length; i++) {\n\t\t\tif (coord[i - 1].equals(coord[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tstatic removeRepeatedPoints(coord) {\n\t\tif (!CoordinateArrays.hasRepeatedPoints(coord)) return coord;\n\t\tvar coordList = new CoordinateList(coord, false);\n\t\treturn coordList.toCoordinateArray();\n\t}\n\tstatic reverse(coord) {\n\t\tvar last = coord.length - 1;\n\t\tvar mid = Math.trunc(last / 2);\n\t\tfor (var i = 0; i <= mid; i++) {\n\t\t\tvar tmp = coord[i];\n\t\t\tcoord[i] = coord[last - i];\n\t\t\tcoord[last - i] = tmp;\n\t\t}\n\t}\n\tstatic removeNull(coord) {\n\t\tvar nonNull = 0;\n\t\tfor (var i = 0; i < coord.length; i++) {\n\t\t\tif (coord[i] !== null) nonNull++;\n\t\t}\n\t\tvar newCoord = new Array(nonNull).fill(null);\n\t\tif (nonNull === 0) return newCoord;\n\t\tvar j = 0;\n\t\tfor (var i = 0; i < coord.length; i++) {\n\t\t\tif (coord[i] !== null) newCoord[j++] = coord[i];\n\t\t}\n\t\treturn newCoord;\n\t}\n\tstatic copyDeep() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet coordinates = arguments[0];\n\t\t\tvar copy = new Array(coordinates.length).fill(null);\n\t\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\t\tcopy[i] = new Coordinate(coordinates[i]);\n\t\t\t}\n\t\t\treturn copy;\n\t\t} else if (arguments.length === 5) {\n\t\t\tlet src = arguments[0], srcStart = arguments[1], dest = arguments[2], destStart = arguments[3], length = arguments[4];\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tdest[destStart + i] = new Coordinate(src[srcStart + i]);\n\t\t\t}\n\t\t}\n\t}\n\tstatic isEqualReversed(pts1, pts2) {\n\t\tfor (var i = 0; i < pts1.length; i++) {\n\t\t\tvar p1 = pts1[i];\n\t\t\tvar p2 = pts2[pts1.length - i - 1];\n\t\t\tif (p1.compareTo(p2) !== 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic envelope(coordinates) {\n\t\tvar env = new Envelope();\n\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\tenv.expandToInclude(coordinates[i]);\n\t\t}\n\t\treturn env;\n\t}\n\tstatic toCoordinateArray(coordList) {\n\t\treturn coordList.toArray(CoordinateArrays.coordArrayType);\n\t}\n\tstatic atLeastNCoordinatesOrNothing(n, c) {\n\t\treturn c.length >= n ? c : [];\n\t}\n\tstatic indexOf(coordinate, coordinates) {\n\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\tif (coordinate.equals(coordinates[i])) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tstatic increasingDirection(pts) {\n\t\tfor (var i = 0; i < Math.trunc(pts.length / 2); i++) {\n\t\t\tvar j = pts.length - 1 - i;\n\t\t\tvar comp = pts[i].compareTo(pts[j]);\n\t\t\tif (comp !== 0) return comp;\n\t\t}\n\t\treturn 1;\n\t}\n\tstatic compare(pts1, pts2) {\n\t\tvar i = 0;\n\t\twhile (i < pts1.length && i < pts2.length) {\n\t\t\tvar compare = pts1[i].compareTo(pts2[i]);\n\t\t\tif (compare !== 0) return compare;\n\t\t\ti++;\n\t\t}\n\t\tif (i < pts2.length) return -1;\n\t\tif (i < pts1.length) return 1;\n\t\treturn 0;\n\t}\n\tstatic minCoordinate(coordinates) {\n\t\tvar minCoord = null;\n\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\tif (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {\n\t\t\t\tminCoord = coordinates[i];\n\t\t\t}\n\t\t}\n\t\treturn minCoord;\n\t}\n\tstatic extract(pts, start, end) {\n\t\tstart = MathUtil.clamp(start, 0, pts.length);\n\t\tend = MathUtil.clamp(end, -1, pts.length);\n\t\tvar npts = end - start + 1;\n\t\tif (end < 0) npts = 0;\n\t\tif (start >= pts.length) npts = 0;\n\t\tif (end < start) npts = 0;\n\t\tvar extractPts = new Array(npts).fill(null);\n\t\tif (npts === 0) return extractPts;\n\t\tvar iPts = 0;\n\t\tfor (var i = start; i <= end; i++) {\n\t\t\textractPts[iPts++] = pts[i];\n\t\t}\n\t\treturn extractPts;\n\t}\n\tgetClass() {\n\t\treturn CoordinateArrays;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nclass ForwardComparator {\n\tconstructor() {\n\t\tForwardComparator.constructor_.apply(this, arguments);\n\t}\n\tcompare(o1, o2) {\n\t\tvar pts1 = o1;\n\t\tvar pts2 = o2;\n\t\treturn CoordinateArrays.compare(pts1, pts2);\n\t}\n\tgetClass() {\n\t\treturn ForwardComparator;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparator];\n\t}\n}\nForwardComparator.constructor_ = function () {};\nclass BidirectionalComparator {\n\tconstructor() {\n\t\tBidirectionalComparator.constructor_.apply(this, arguments);\n\t}\n\tcompare(o1, o2) {\n\t\tvar pts1 = o1;\n\t\tvar pts2 = o2;\n\t\tif (pts1.length < pts2.length) return -1;\n\t\tif (pts1.length > pts2.length) return 1;\n\t\tif (pts1.length === 0) return 0;\n\t\tvar forwardComp = CoordinateArrays.compare(pts1, pts2);\n\t\tvar isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);\n\t\tif (isEqualRev) return 0;\n\t\treturn forwardComp;\n\t}\n\tOLDcompare(o1, o2) {\n\t\tvar pts1 = o1;\n\t\tvar pts2 = o2;\n\t\tif (pts1.length < pts2.length) return -1;\n\t\tif (pts1.length > pts2.length) return 1;\n\t\tif (pts1.length === 0) return 0;\n\t\tvar dir1 = CoordinateArrays.increasingDirection(pts1);\n\t\tvar dir2 = CoordinateArrays.increasingDirection(pts2);\n\t\tvar i1 = dir1 > 0 ? 0 : pts1.length - 1;\n\t\tvar i2 = dir2 > 0 ? 0 : pts1.length - 1;\n\t\tfor (var i = 0; i < pts1.length; i++) {\n\t\t\tvar comparePt = pts1[i1].compareTo(pts2[i2]);\n\t\t\tif (comparePt !== 0) return comparePt;\n\t\t\ti1 += dir1;\n\t\t\ti2 += dir2;\n\t\t}\n\t\treturn 0;\n\t}\n\tgetClass() {\n\t\treturn BidirectionalComparator;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparator];\n\t}\n}\nBidirectionalComparator.constructor_ = function () {};\nCoordinateArrays.ForwardComparator = ForwardComparator;\nCoordinateArrays.BidirectionalComparator = BidirectionalComparator;\nCoordinateArrays.constructor_ = function () {};\nCoordinateArrays.coordArrayType = new Array(0).fill(null);\n","/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html\n *\n * @constructor\n * @private\n */\nexport default function Map() {};\n\n\n/**\n * Returns the value to which the specified key is mapped, or null if this map\n * contains no mapping for the key.\n * @param {Object} key\n * @return {Object}\n */\nMap.prototype.get = function() {};\n\n\n/**\n * Associates the specified value with the specified key in this map (optional\n * operation).\n * @param {Object} key\n * @param {Object} value\n * @return {Object}\n */\nMap.prototype.put = function() {};\n\n\n/**\n * Returns the number of key-value mappings in this map.\n * @return {number}\n */\nMap.prototype.size = function() {};\n\n\n/**\n * Returns a Collection view of the values contained in this map.\n * @return {javascript.util.Collection}\n */\nMap.prototype.values = function() {};\n\n/**\n * Returns a {@link Set} view of the mappings contained in this map.\n * The set is backed by the map, so changes to the map are\n * reflected in the set, and vice-versa.  If the map is modified\n * while an iteration over the set is in progress (except through\n * the iterator's own <tt>remove</tt> operation, or through the\n * <tt>setValue</tt> operation on a map entry returned by the\n * iterator) the results of the iteration are undefined.  The set\n * supports element removal, which removes the corresponding\n * mapping from the map, via the <tt>Iterator.remove</tt>,\n * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and\n * <tt>clear</tt> operations.  It does not support the\n * <tt>add</tt> or <tt>addAll</tt> operations.\n *\n * @return {Set} a set view of the mappings contained in this map\n */\nMap.prototype.entrySet = function() {};\n","import Map from './Map'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html\n *\n * @extends {Map}\n * @constructor\n * @private\n */\nexport default function SortedMap() {};\nSortedMap.prototype = new Map();\n","import Collection from './Collection'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html\n *\n * @extends {Collection}\n * @constructor\n * @private\n */\nexport default function Set() {};\nSet.prototype = new Collection();\n\n\n/**\n * Returns true if this set contains the specified element. More formally,\n * returns true if and only if this set contains an element e such that (o==null ?\n * e==null : o.equals(e)).\n * @param {Object} e\n * @return {boolean}\n */\nSet.prototype.contains = function() {};\n","import Collection from './Collection'\nimport Iterator from './Iterator'\nimport NoSuchElementException from './NoSuchElementException'\nimport OperationNotSupported from './OperationNotSupported'\nimport Set from './Set'\n\n/**\n * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html\n *\n * @extends {javascript.util.Set}\n * @constructor\n * @private\n */\nexport default function HashSet() {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n};\nHashSet.prototype = new Set();\n\n\n/**\n * @override\n */\nHashSet.prototype.contains = function(o) {\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this.array_[i];\n    if (e === o) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.add = function(o) {\n  if (this.contains(o)) {\n    return false;\n  }\n\n  this.array_.push(o);\n\n  return true;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.addAll = function(c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.add(i.next());\n  }\n  return true;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.remove = function(o) {\n  throw new javascript.util.OperationNotSupported();\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.size = function() {\n  return this.array_.length;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.isEmpty = function() {\n  return this.array_.length === 0;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.toArray = function() {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.iterator = function() {\n  return new Iterator_(this);\n};\n\n\n\n/**\n * @extends {Iterator}\n * @param {HashSet} hashSet\n * @constructor\n * @private\n */\nvar Iterator_ = function(hashSet) {\n  /**\n   * @type {HashSet}\n   * @private\n   */\n  this.hashSet_ = hashSet;\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.next = function() {\n  if (this.position_ === this.hashSet_.size()) {\n    throw new NoSuchElementException();\n  }\n  return this.hashSet_.array_[this.position_++];\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.hasNext = function() {\n  if (this.position_ < this.hashSet_.size()) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.remove = function() {\n  throw new OperationNotSupported();\n};\n","import ArrayList from './ArrayList'\nimport SortedMap from './SortedMap'\nimport HashSet from './HashSet'\n\nconst BLACK = 0\nconst RED = 1\nfunction colorOf (p) { return (p == null ? BLACK : p.color) }\nfunction parentOf (p) { return (p == null ? null : p.parent) }\nfunction setColor (p, c) { if (p !== null) p.color = c }\nfunction leftOf (p) { return (p == null ? null : p.left) }\nfunction rightOf (p) { return (p == null ? null : p.right) }\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html\n *\n * @extends {SortedMap}\n * @constructor\n * @private\n */\nexport default function TreeMap() {\n  /**\n   * @type {Object}\n   * @private\n   */\n  this.root_ = null;\n  /**\n   * @type {number}\n   * @private\n  */\n  this.size_ = 0;\n};\nTreeMap.prototype = new SortedMap();\n\n\n/**\n * @override\n */\nTreeMap.prototype.get = function(key) {\n  var p = this.root_;\n  while (p !== null) {\n    var cmp = key['compareTo'](p.key);\n    if (cmp < 0) {\n      p = p.left;\n    } else if (cmp > 0) {\n      p = p.right;\n    } else {\n      return p.value;\n    }\n  }\n  return null;\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.put = function(key, value) {\n  if (this.root_ === null) {\n    this.root_ = {\n      key: key,\n      value: value,\n      left: null,\n      right: null,\n      parent: null,\n      color: BLACK,\n      getValue() { return this.value },\n      getKey() { return this.key }\n    };\n    this.size_ = 1;\n    return null;\n  }\n  var t = this.root_, parent, cmp;\n  do {\n    parent = t;\n    cmp = key['compareTo'](t.key);\n    if (cmp < 0) {\n      t = t.left;\n    } else if (cmp > 0) {\n      t = t.right;\n    } else {\n      var oldValue = t.value;\n      t.value = value;\n      return oldValue;\n    }\n  } while (t !== null);\n  var e = {\n    key: key,\n    left: null,\n    right: null,\n    value: value,\n    parent: parent,\n    color: BLACK,\n    getValue() { return this.value },\n    getKey() { return this.key }\n  };\n  if (cmp < 0) {\n    parent.left = e;\n  } else {\n    parent.right = e;\n  }\n  this.fixAfterInsertion(e);\n  this.size_++;\n  return null;\n};\n\n\n/**\n * @param {Object} x\n */\nTreeMap.prototype.fixAfterInsertion = function(x) {\n  x.color = RED;\n  while (x != null && x != this.root_ && x.parent.color == RED) {\n    if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n      var y = rightOf(parentOf(parentOf(x)));\n      if (colorOf(y) == RED) {\n        setColor(parentOf(x), BLACK);\n        setColor(y, BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        x = parentOf(parentOf(x));\n      } else {\n        if (x == rightOf(parentOf(x))) {\n          x = parentOf(x);\n          this.rotateLeft(x);\n        }\n        setColor(parentOf(x), BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        this.rotateRight(parentOf(parentOf(x)));\n      }\n    } else {\n      var y = leftOf(parentOf(parentOf(x)));\n      if (colorOf(y) == RED) {\n        setColor(parentOf(x), BLACK);\n        setColor(y, BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        x = parentOf(parentOf(x));\n      } else {\n        if (x == leftOf(parentOf(x))) {\n          x = parentOf(x);\n          this.rotateRight(x);\n        }\n        setColor(parentOf(x), BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        this.rotateLeft(parentOf(parentOf(x)));\n      }\n    }\n  }\n  this.root_.color = BLACK;\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.values = function() {\n  var arrayList = new ArrayList();\n  var p = this.getFirstEntry();\n  if (p !== null) {\n    arrayList.add(p.value);\n    while ((p = TreeMap.successor(p)) !== null) {\n      arrayList.add(p.value);\n    }\n  }\n  return arrayList;\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.entrySet = function() {\n  var hashSet = new HashSet();\n  var p = this.getFirstEntry();\n  if (p !== null) {\n    hashSet.add(p);\n    while ((p = TreeMap.successor(p)) !== null) {\n      hashSet.add(p);\n    }\n  }\n  return hashSet;\n};\n\n\n/**\n * @param {Object} p\n */\nTreeMap.prototype.rotateLeft = function(p) {\n  if (p != null) {\n    var r = p.right;\n    p.right = r.left;\n    if (r.left != null)\n      r.left.parent = p;\n    r.parent = p.parent;\n    if (p.parent == null)\n      this.root_ = r;\n    else if (p.parent.left == p)\n      p.parent.left = r;\n    else\n      p.parent.right = r;\n    r.left = p;\n    p.parent = r;\n  }\n};\n\n\n/**\n * @param {Object} p\n */\nTreeMap.prototype.rotateRight = function(p) {\n  if (p != null) {\n    var l = p.left;\n    p.left = l.right;\n    if (l.right != null) l.right.parent = p;\n    l.parent = p.parent;\n    if (p.parent == null)\n      this.root_ = l;\n    else if (p.parent.right == p)\n      p.parent.right = l;\n    else p.parent.left = l;\n    l.right = p;\n    p.parent = l;\n  }\n};\n\n\n/**\n * @return {Object}\n */\nTreeMap.prototype.getFirstEntry = function() {\n  var p = this.root_;\n  if (p != null) {\n    while (p.left != null) {\n      p = p.left;\n    }\n  }\n  return p;\n};\n\n\n/**\n * @param {Object} t\n * @return {Object}\n * @private\n */\nTreeMap.successor = function(t) {\n  if (t === null)\n    return null;\n  else if (t.right !== null) {\n    var p = t.right;\n    while (p.left !== null) {\n      p = p.left;\n    }\n    return p;\n  } else {\n    var p = t.parent;\n    var ch = t;\n    while (p !== null && ch === p.right) {\n      ch = p;\n      p = p.parent;\n    }\n    return p;\n  }\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.size = function() {\n  return this.size_;\n};\n\n\nTreeMap.prototype.containsKey = function(key) {\n  var p = this.root_;\n  while (p !== null) {\n    var cmp = key['compareTo'](p.key);\n    if (cmp < 0) {\n      p = p.left;\n    } else if (cmp > 0) {\n      p = p.right;\n    } else {\n      return true;\n    }\n  }\n  return false;\n};\n","export default class Lineal {\n\tconstructor() {\n\t\tLineal.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn Lineal;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nLineal.constructor_ = function () {};\n","import Set from './Set'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html\n *\n * @extends {Set}\n * @constructor\n * @private\n */\nexport default function SortedSet() {};\nSortedSet.prototype = new Set();\n","import Collection from './Collection'\nimport Iterator from './Iterator'\nimport NoSuchElementException from './NoSuchElementException'\nimport OperationNotSupported from './OperationNotSupported'\nimport SortedSet from './SortedSet'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html\n *\n * @extends {SortedSet}\n * @constructor\n * @private\n */\nexport default function TreeSet() {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n};\nTreeSet.prototype = new SortedSet();\n\n\n/**\n * @override\n */\nTreeSet.prototype.contains = function(o) {\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this.array_[i];\n    if (e['compareTo'](o) === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.add = function(o) {\n  if (this.contains(o)) {\n    return false;\n  }\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this.array_[i];\n    if (e['compareTo'](o) === 1) {\n      this.array_.splice(i, 0, o);\n      return true;\n    }\n  }\n\n  this.array_.push(o);\n\n  return true;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.addAll = function(c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.add(i.next());\n  }\n  return true;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.remove = function(e) {\n  throw new OperationNotSupported();\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.size = function() {\n  return this.array_.length;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.isEmpty = function() {\n  return this.array_.length === 0;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.toArray = function() {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.iterator = function() {\n  return new Iterator_(this);\n};\n\n\n\n/**\n * @extends {javascript.util.Iterator}\n * @param {javascript.util.TreeSet} treeSet\n * @constructor\n * @private\n */\nvar Iterator_ = function(treeSet) {\n  /**\n   * @type {javascript.util.TreeSet}\n   * @private\n   */\n  this.treeSet_ = treeSet;\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.next = function() {\n  if (this.position_ === this.treeSet_.size()) {\n    throw new NoSuchElementException();\n  }\n  return this.treeSet_.array_[this.position_++];\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.hasNext = function() {\n  if (this.position_ < this.treeSet_.size()) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.remove = function() {\n  throw new OperationNotSupported();\n};\n","// shared pointer\nvar i\n// shortcuts\nvar defineProperty = Object.defineProperty\nfunction is (a, b) { return (a === b) || (a !== a && b !== b) } // eslint-disable-line\n\nexport default createCollection({\n  // WeakMap#delete(key:void*):boolean\n  'delete': sharedDelete,\n  // :was Map#get(key:void*[, d3fault:void*]):void*\n  // Map#has(key:void*):boolean\n  has: mapHas,\n  // Map#get(key:void*):boolean\n  get: sharedGet,\n  // Map#set(key:void*, value:void*):void\n  set: sharedSet,\n  // Map#keys(void):Iterator\n  keys: sharedKeys,\n  // Map#values(void):Iterator\n  values: sharedValues,\n  // Map#entries(void):Iterator\n  entries: mapEntries,\n  // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`\n  forEach: sharedForEach,\n  // Map#clear():\n  clear: sharedClear\n})\n\nfunction createCollection (proto, objectOnly) {\n  function Collection (a) {\n    if (!this || this.constructor !== Collection) return new Collection(a)\n    this._keys = []\n    this._values = []\n    this._itp = [] // iteration pointers\n    this.objectOnly = objectOnly\n\n    // parse initial iterable argument passed\n    if (a) init.call(this, a)\n  }\n\n  // define size for non object-only collections\n  if (!objectOnly) {\n    defineProperty(proto, 'size', {\n      get: sharedSize\n    })\n  }\n\n  // set prototype\n  proto.constructor = Collection\n  Collection.prototype = proto\n\n  return Collection\n}\n\nfunction init (a) {\n  // init Set argument, like `[1,2,3,{}]`\n  if (this.add) a.forEach(this.add, this)\n  // init Map argument like `[[1,2], [{}, 4]]`\n  else a.forEach(function (a) { this.set(a[0], a[1]) }, this)\n}\n\nfunction sharedDelete (key) {\n  if (this.has(key)) {\n    this._keys.splice(i, 1)\n    this._values.splice(i, 1)\n    // update iteration pointers\n    this._itp.forEach(function (p) { if (i < p[0]) p[0]-- })\n  }\n  // Aurora here does it while Canary doesn't\n  return i > -1\n}\n\nfunction sharedGet (key) {\n  return this.has(key) ? this._values[i] : undefined\n}\n\nfunction has (list, key) {\n  if (this.objectOnly && key !== Object(key)) throw new TypeError('Invalid value used as weak collection key')\n  // NaN or 0 passed\n  if (key !== key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} // eslint-disable-line\n  else i = list.indexOf(key)\n  return i > -1\n}\n\nfunction mapHas (value) {\n  return has.call(this, this._keys, value)\n}\n\nfunction sharedSet (key, value) {\n  this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value\n  return this\n}\n\nfunction sharedClear () {\n  (this._keys || 0).length =\n    this._values.length = 0\n}\n\nfunction sharedKeys () {\n  return sharedIterator(this._itp, this._keys)\n}\n\nfunction sharedValues () {\n  return sharedIterator(this._itp, this._values)\n}\n\nfunction mapEntries () {\n  return sharedIterator(this._itp, this._keys, this._values)\n}\n\nfunction sharedIterator (itp, array, array2) {\n  var p = [0]\n  var done = false\n  itp.push(p)\n  return {\n    next: function () {\n      var v\n      var k = p[0]\n      if (!done && k < array.length) {\n        v = array2 ? [array[k], array2[k]] : array[k]\n        p[0]++\n      } else {\n        done = true\n        itp.splice(itp.indexOf(p), 1)\n      }\n      return { done: done, value: v }\n    }\n  }\n}\n\nfunction sharedSize () {\n  return this._values.length\n}\n\nfunction sharedForEach (callback, context) {\n  var it = this.entries()\n  for (;;) {\n    var r = it.next()\n    if (r.done) break\n    callback.call(context, r.value[1], r.value[0], this)\n  }\n}\n","import ArrayList from './ArrayList'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html\n *\n * @constructor\n * @private\n */\nexport default function Arrays() {};\n\n/**\n */\nArrays.sort = function() {\n  var a = arguments[0], i, t, comparator, compare;\n  if (arguments.length === 1) {\n    compare = function(a, b) {\n      return a.compareTo(b);\n    }\n    a.sort(compare);\n    return;\n  } else if (arguments.length === 2) {\n    comparator = arguments[1];\n    compare = function(a, b) {\n      return comparator['compare'](a, b);\n    };\n    a.sort(compare);\n  } else if (arguments.length === 3) {\n    t = a.slice(arguments[1], arguments[2]);\n    t.sort();\n    var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n    a.splice(0, a.length);\n    for (i = 0; i < r.length; i++) {\n      a.push(r[i]);\n    }\n    return;\n  } else if (arguments.length === 4) {\n    t = a.slice(arguments[1], arguments[2]);\n    comparator = arguments[3];\n    compare = function(a, b) {\n      return comparator['compare'](a, b);\n    };\n    t.sort(compare);\n    r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n    a.splice(0, a.length);\n    for (i = 0; i < r.length; i++) {\n      a.push(r[i]);\n    }\n    return;\n  }\n};\n\n\n/**\n * @param {Array} array\n * @return {ArrayList}\n */\nArrays.asList = function(array) {\n  var arrayList = new ArrayList();\n  for (var i = 0, len = array.length; i < len; i++) {\n    arrayList.add(array[i]);\n  }\n  return arrayList;\n};\n","export default function Character () {}\nCharacter.isWhitespace = c => ((c <= 32 && c >= 0) || c == 127)\nCharacter.toUpperCase = c => c.toUpperCase()\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Character from '../../../../java/lang/Character';\nexport default class Dimension {\n\tconstructor() {\n\t\tDimension.constructor_.apply(this, arguments);\n\t}\n\tstatic toDimensionSymbol(dimensionValue) {\n\t\tswitch (dimensionValue) {\n\t\t\tcase Dimension.FALSE:\n\t\t\t\treturn Dimension.SYM_FALSE;\n\t\t\tcase Dimension.TRUE:\n\t\t\t\treturn Dimension.SYM_TRUE;\n\t\t\tcase Dimension.DONTCARE:\n\t\t\t\treturn Dimension.SYM_DONTCARE;\n\t\t\tcase Dimension.P:\n\t\t\t\treturn Dimension.SYM_P;\n\t\t\tcase Dimension.L:\n\t\t\t\treturn Dimension.SYM_L;\n\t\t\tcase Dimension.A:\n\t\t\t\treturn Dimension.SYM_A;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Unknown dimension value: \" + dimensionValue);\n\t}\n\tstatic toDimensionValue(dimensionSymbol) {\n\t\tswitch (Character.toUpperCase(dimensionSymbol)) {\n\t\t\tcase Dimension.SYM_FALSE:\n\t\t\t\treturn Dimension.FALSE;\n\t\t\tcase Dimension.SYM_TRUE:\n\t\t\t\treturn Dimension.TRUE;\n\t\t\tcase Dimension.SYM_DONTCARE:\n\t\t\t\treturn Dimension.DONTCARE;\n\t\t\tcase Dimension.SYM_P:\n\t\t\t\treturn Dimension.P;\n\t\t\tcase Dimension.SYM_L:\n\t\t\t\treturn Dimension.L;\n\t\t\tcase Dimension.SYM_A:\n\t\t\t\treturn Dimension.A;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Unknown dimension symbol: \" + dimensionSymbol);\n\t}\n\tgetClass() {\n\t\treturn Dimension;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nDimension.constructor_ = function () {};\nDimension.P = 0;\nDimension.L = 1;\nDimension.A = 2;\nDimension.FALSE = -1;\nDimension.TRUE = -2;\nDimension.DONTCARE = -3;\nDimension.SYM_FALSE = 'F';\nDimension.SYM_TRUE = 'T';\nDimension.SYM_DONTCARE = '*';\nDimension.SYM_P = '0';\nDimension.SYM_L = '1';\nDimension.SYM_A = '2';\n","export default class GeometryFilter {\n\tconstructor() {\n\t\tGeometryFilter.constructor_.apply(this, arguments);\n\t}\n\tfilter(geom) {}\n\tgetClass() {\n\t\treturn GeometryFilter;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGeometryFilter.constructor_ = function () {};\n","export default class CoordinateSequenceFilter {\n\tconstructor() {\n\t\tCoordinateSequenceFilter.constructor_.apply(this, arguments);\n\t}\n\tfilter(seq, i) {}\n\tisDone() {}\n\tisGeometryChanged() {}\n\tgetClass() {\n\t\treturn CoordinateSequenceFilter;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCoordinateSequenceFilter.constructor_ = function () {};\n","import TreeSet from '../../../../java/util/TreeSet';\nimport Geometry from './Geometry';\nimport Arrays from '../../../../java/util/Arrays';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Dimension from './Dimension';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nimport Envelope from './Envelope';\nimport Assert from '../util/Assert';\nexport default class GeometryCollection extends Geometry {\n\tconstructor() {\n\t\tsuper();\n\t\tGeometryCollection.constructor_.apply(this, arguments);\n\t}\n\tcomputeEnvelopeInternal() {\n\t\tvar envelope = new Envelope();\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tenvelope.expandToInclude(this._geometries[i].getEnvelopeInternal());\n\t\t}\n\t\treturn envelope;\n\t}\n\tgetGeometryN(n) {\n\t\treturn this._geometries[n];\n\t}\n\tgetCoordinates() {\n\t\tvar coordinates = new Array(this.getNumPoints()).fill(null);\n\t\tvar k = -1;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tvar childCoordinates = this._geometries[i].getCoordinates();\n\t\t\tfor (var j = 0; j < childCoordinates.length; j++) {\n\t\t\t\tk++;\n\t\t\t\tcoordinates[k] = childCoordinates[j];\n\t\t\t}\n\t\t}\n\t\treturn coordinates;\n\t}\n\tgetArea() {\n\t\tvar area = 0.0;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tarea += this._geometries[i].getArea();\n\t\t}\n\t\treturn area;\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar otherCollection = other;\n\t\t\tif (this._geometries.length !== otherCollection._geometries.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tif (!this._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tnormalize() {\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tthis._geometries[i].normalize();\n\t\t}\n\t\tArrays.sort(this._geometries);\n\t}\n\tgetCoordinate() {\n\t\tif (this.isEmpty()) return null;\n\t\treturn this._geometries[0].getCoordinate();\n\t}\n\tgetBoundaryDimension() {\n\t\tvar dimension = Dimension.FALSE;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tdimension = Math.max(dimension, this._geometries[i].getBoundaryDimension());\n\t\t}\n\t\treturn dimension;\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_GEOMETRYCOLLECTION;\n\t}\n\tgetDimension() {\n\t\tvar dimension = Dimension.FALSE;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tdimension = Math.max(dimension, this._geometries[i].getDimension());\n\t\t}\n\t\treturn dimension;\n\t}\n\tgetLength() {\n\t\tvar sum = 0.0;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tsum += this._geometries[i].getLength();\n\t\t}\n\t\treturn sum;\n\t}\n\tgetNumPoints() {\n\t\tvar numPoints = 0;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tnumPoints += this._geometries[i].getNumPoints();\n\t\t}\n\t\treturn numPoints;\n\t}\n\tgetNumGeometries() {\n\t\treturn this._geometries.length;\n\t}\n\treverse() {\n\t\tvar n = this._geometries.length;\n\t\tvar revGeoms = new Array(n).fill(null);\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\trevGeoms[i] = this._geometries[i].reverse();\n\t\t}\n\t\treturn this.getFactory().createGeometryCollection(revGeoms);\n\t}\n\tcompareToSameClass() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar theseElements = new TreeSet(Arrays.asList(this._geometries));\n\t\t\tvar otherElements = new TreeSet(Arrays.asList(o._geometries));\n\t\t\treturn this.compare(theseElements, otherElements);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar gc = o;\n\t\t\tvar n1 = this.getNumGeometries();\n\t\t\tvar n2 = gc.getNumGeometries();\n\t\t\tvar i = 0;\n\t\t\twhile (i < n1 && i < n2) {\n\t\t\t\tvar thisGeom = this.getGeometryN(i);\n\t\t\t\tvar otherGeom = gc.getGeometryN(i);\n\t\t\t\tvar holeComp = thisGeom.compareToSameClass(otherGeom, comp);\n\t\t\t\tif (holeComp !== 0) return holeComp;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i < n1) return 1;\n\t\t\tif (i < n2) return -1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tapply() {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this._geometries.length === 0) return null;\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t\tif (filter.isDone()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t}\n\t\t}\n\t}\n\tgetBoundary() {\n\t\tthis.checkNotGeometryCollection(this);\n\t\tAssert.shouldNeverReachHere();\n\t\treturn null;\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_GEOMETRYCOLLECTION;\n\t}\n\tcopy() {\n\t\tvar geometries = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < geometries.length; i++) {\n\t\t\tgeometries[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new GeometryCollection(geometries, this._factory);\n\t}\n\tisEmpty() {\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tif (!this._geometries[i].isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tgetClass() {\n\t\treturn GeometryCollection;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGeometryCollection.constructor_ = function () {\n\tthis._geometries = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 2) {\n\t\tlet geometries = arguments[0], factory = arguments[1];\n\t\tGeometry.constructor_.call(this, factory);\n\t\tif (geometries === null) {\n\t\t\tgeometries = [];\n\t\t}\n\t\tif (Geometry.hasNullElements(geometries)) {\n\t\t\tthrow new IllegalArgumentException(\"geometries must not contain null elements\");\n\t\t}\n\t\tthis._geometries = geometries;\n\t}\n};\nGeometryCollection.serialVersionUID = -5694727726395021467;\n","import Geometry from './Geometry';\nimport BoundaryOp from '../operation/BoundaryOp';\nimport Lineal from './Lineal';\nimport GeometryCollection from './GeometryCollection';\nimport Dimension from './Dimension';\nexport default class MultiLineString extends GeometryCollection {\n\tconstructor() {\n\t\tsuper();\n\t\tMultiLineString.constructor_.apply(this, arguments);\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn super.equalsExact.call(this, other, tolerance);\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tgetBoundaryDimension() {\n\t\tif (this.isClosed()) {\n\t\t\treturn Dimension.FALSE;\n\t\t}\n\t\treturn 0;\n\t}\n\tisClosed() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tif (!this._geometries[i].isClosed()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_MULTILINESTRING;\n\t}\n\tgetDimension() {\n\t\treturn 1;\n\t}\n\treverse() {\n\t\tvar nLines = this._geometries.length;\n\t\tvar revLines = new Array(nLines).fill(null);\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\trevLines[nLines - 1 - i] = this._geometries[i].reverse();\n\t\t}\n\t\treturn this.getFactory().createMultiLineString(revLines);\n\t}\n\tgetBoundary() {\n\t\treturn new BoundaryOp(this).getBoundary();\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_MULTILINESTRING;\n\t}\n\tcopy() {\n\t\tvar lineStrings = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < lineStrings.length; i++) {\n\t\t\tlineStrings[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new MultiLineString(lineStrings, this._factory);\n\t}\n\tgetClass() {\n\t\treturn MultiLineString;\n\t}\n\tget interfaces_() {\n\t\treturn [Lineal];\n\t}\n}\nMultiLineString.constructor_ = function () {\n\tlet lineStrings = arguments[0], factory = arguments[1];\n\tGeometryCollection.constructor_.call(this, lineStrings, factory);\n};\nMultiLineString.serialVersionUID = 8166665132445433741;\n","import LineString from '../geom/LineString';\nimport BoundaryNodeRule from '../algorithm/BoundaryNodeRule';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport TreeMap from '../../../../java/util/TreeMap';\nimport MultiLineString from '../geom/MultiLineString';\nexport default class BoundaryOp {\n\tconstructor() {\n\t\tBoundaryOp.constructor_.apply(this, arguments);\n\t}\n\tstatic getBoundary() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet g = arguments[0];\n\t\t\tvar bop = new BoundaryOp(g);\n\t\t\treturn bop.getBoundary();\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet g = arguments[0], bnRule = arguments[1];\n\t\t\tvar bop = new BoundaryOp(g, bnRule);\n\t\t\treturn bop.getBoundary();\n\t\t}\n\t}\n\tboundaryMultiLineString(mLine) {\n\t\tif (this._geom.isEmpty()) {\n\t\t\treturn this.getEmptyMultiPoint();\n\t\t}\n\t\tvar bdyPts = this.computeBoundaryCoordinates(mLine);\n\t\tif (bdyPts.length === 1) {\n\t\t\treturn this._geomFact.createPoint(bdyPts[0]);\n\t\t}\n\t\treturn this._geomFact.createMultiPointFromCoords(bdyPts);\n\t}\n\tgetBoundary() {\n\t\tif (this._geom instanceof LineString) return this.boundaryLineString(this._geom);\n\t\tif (this._geom instanceof MultiLineString) return this.boundaryMultiLineString(this._geom);\n\t\treturn this._geom.getBoundary();\n\t}\n\tboundaryLineString(line) {\n\t\tif (this._geom.isEmpty()) {\n\t\t\treturn this.getEmptyMultiPoint();\n\t\t}\n\t\tif (line.isClosed()) {\n\t\t\tvar closedEndpointOnBoundary = this._bnRule.isInBoundary(2);\n\t\t\tif (closedEndpointOnBoundary) {\n\t\t\t\treturn line.getStartPoint();\n\t\t\t} else {\n\t\t\t\treturn this._geomFact.createMultiPoint();\n\t\t\t}\n\t\t}\n\t\treturn this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()]);\n\t}\n\tgetEmptyMultiPoint() {\n\t\treturn this._geomFact.createMultiPoint();\n\t}\n\tcomputeBoundaryCoordinates(mLine) {\n\t\tvar bdyPts = new ArrayList();\n\t\tthis._endpointMap = new TreeMap();\n\t\tfor (var i = 0; i < mLine.getNumGeometries(); i++) {\n\t\t\tvar line = mLine.getGeometryN(i);\n\t\t\tif (line.getNumPoints() === 0) continue;\n\t\t\tthis.addEndpoint(line.getCoordinateN(0));\n\t\t\tthis.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));\n\t\t}\n\t\tfor (var it = this._endpointMap.entrySet().iterator(); it.hasNext(); ) {\n\t\t\tvar entry = it.next();\n\t\t\tvar counter = entry.getValue();\n\t\t\tvar valence = counter.count;\n\t\t\tif (this._bnRule.isInBoundary(valence)) {\n\t\t\t\tbdyPts.add(entry.getKey());\n\t\t\t}\n\t\t}\n\t\treturn CoordinateArrays.toCoordinateArray(bdyPts);\n\t}\n\taddEndpoint(pt) {\n\t\tvar counter = this._endpointMap.get(pt);\n\t\tif (counter === null) {\n\t\t\tcounter = new Counter();\n\t\t\tthis._endpointMap.put(pt, counter);\n\t\t}\n\t\tcounter.count++;\n\t}\n\tgetClass() {\n\t\treturn BoundaryOp;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nBoundaryOp.constructor_ = function () {\n\tthis._geom = null;\n\tthis._geomFact = null;\n\tthis._bnRule = null;\n\tthis._endpointMap = null;\n\tif (arguments.length === 1) {\n\t\tlet geom = arguments[0];\n\t\tBoundaryOp.constructor_.call(this, geom, BoundaryNodeRule.MOD2_BOUNDARY_RULE);\n\t} else if (arguments.length === 2) {\n\t\tlet geom = arguments[0], bnRule = arguments[1];\n\t\tthis._geom = geom;\n\t\tthis._geomFact = geom.getFactory();\n\t\tthis._bnRule = bnRule;\n\t}\n};\nclass Counter {\n\tconstructor() {\n\t\tCounter.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn Counter;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCounter.constructor_ = function () {\n\tthis.count = null;\n};\n","import Coordinate from '../geom/Coordinate';\nexport default class Length {\n\tconstructor() {\n\t\tLength.constructor_.apply(this, arguments);\n\t}\n\tstatic ofLine(pts) {\n\t\tvar n = pts.size();\n\t\tif (n <= 1) return 0.0;\n\t\tvar len = 0.0;\n\t\tvar p = new Coordinate();\n\t\tpts.getCoordinate(0, p);\n\t\tvar x0 = p.x;\n\t\tvar y0 = p.y;\n\t\tfor (var i = 1; i < n; i++) {\n\t\t\tpts.getCoordinate(i, p);\n\t\t\tvar x1 = p.x;\n\t\t\tvar y1 = p.y;\n\t\t\tvar dx = x1 - x0;\n\t\t\tvar dy = y1 - y0;\n\t\t\tlen += Math.sqrt(dx * dx + dy * dy);\n\t\t\tx0 = x1;\n\t\t\ty0 = y1;\n\t\t}\n\t\treturn len;\n\t}\n\tgetClass() {\n\t\treturn Length;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nLength.constructor_ = function () {};\n","export default function PrintStream () {}\n","export default function StringReader () {}\n","export default function ByteArrayOutputStream () {}\n","export default function IOException () {}\n","export default function LineNumberReader () {}\n","import PrintStream from '../../../../java/io/PrintStream';\nimport StringReader from '../../../../java/io/StringReader';\nimport DecimalFormat from '../../../../java/text/DecimalFormat';\nimport System from '../../../../java/lang/System';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport ByteArrayOutputStream from '../../../../java/io/ByteArrayOutputStream';\nimport Assert from './Assert';\nimport IOException from '../../../../java/io/IOException';\nimport LineNumberReader from '../../../../java/io/LineNumberReader';\nexport default class StringUtil {\n\tconstructor() {\n\t\tStringUtil.constructor_.apply(this, arguments);\n\t}\n\tstatic chars(c, n) {\n\t\tvar ch = new Array(n).fill(null);\n\t\tfor (var i = 0; i < n; i++) {\n\t\t\tch[i] = c;\n\t\t}\n\t\treturn new String(ch);\n\t}\n\tstatic getStackTrace() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet t = arguments[0];\n\t\t\tvar os = new ByteArrayOutputStream();\n\t\t\tvar ps = new PrintStream(os);\n\t\t\tt.printStackTrace(ps);\n\t\t\treturn os.toString();\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet t = arguments[0], depth = arguments[1];\n\t\t\tvar stackTrace = \"\";\n\t\t\tvar stringReader = new StringReader(StringUtil.getStackTrace(t));\n\t\t\tvar lineNumberReader = new LineNumberReader(stringReader);\n\t\t\tfor (var i = 0; i < depth; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tstackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e instanceof IOException) {\n\t\t\t\t\t\tAssert.shouldNeverReachHere();\n\t\t\t\t\t} else throw e;\n\t\t\t\t} finally {}\n\t\t\t}\n\t\t\treturn stackTrace;\n\t\t}\n\t}\n\tstatic split(s, separator) {\n\t\tvar separatorlen = separator.length;\n\t\tvar tokenList = new ArrayList();\n\t\tvar tmpString = \"\" + s;\n\t\tvar pos = tmpString.indexOf(separator);\n\t\twhile (pos >= 0) {\n\t\t\tvar token = tmpString.substring(0, pos);\n\t\t\ttokenList.add(token);\n\t\t\ttmpString = tmpString.substring(pos + separatorlen);\n\t\t\tpos = tmpString.indexOf(separator);\n\t\t}\n\t\tif (tmpString.length > 0) tokenList.add(tmpString);\n\t\tvar res = new Array(tokenList.size()).fill(null);\n\t\tfor (var i = 0; i < res.length; i++) {\n\t\t\tres[i] = tokenList.get(i);\n\t\t}\n\t\treturn res;\n\t}\n\tstatic toString() {\n\t\tif (arguments.length === 1 && typeof arguments[0] === \"number\") {\n\t\t\tlet d = arguments[0];\n\t\t\treturn StringUtil.SIMPLE_ORDINATE_FORMAT.format(d);\n\t\t}\n\t}\n\tstatic spaces(n) {\n\t\treturn StringUtil.chars(' ', n);\n\t}\n\tgetClass() {\n\t\treturn StringUtil;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nStringUtil.constructor_ = function () {};\nStringUtil.NEWLINE = System.getProperty(\"line.separator\");\nStringUtil.SIMPLE_ORDINATE_FORMAT = new DecimalFormat(\"0.#\");\n","export default function StringBuilder (str) {\n    this.str = str\n  }\n  \n  StringBuilder.prototype.append = function (e) {\n    this.str += e\n  }\n  \n  StringBuilder.prototype.setCharAt = function (i, c) {\n    this.str = this.str.substr(0, i) + c + this.str.substr(i + 1)\n  }\n  \n  StringBuilder.prototype.toString = function (e) {\n    return this.str\n  }\n  ","export default function DecimalFormat () {}\n","import hasInterface from '../../../../hasInterface';\nimport StringUtil from '../util/StringUtil';\nimport Double from '../../../../java/lang/Double';\nimport CoordinateSequence from './CoordinateSequence';\nimport StringBuilder from '../../../../java/lang/StringBuilder';\nexport default class CoordinateSequences {\n\tconstructor() {\n\t\tCoordinateSequences.constructor_.apply(this, arguments);\n\t}\n\tstatic copyCoord(src, srcPos, dest, destPos) {\n\t\tvar minDim = Math.min(src.getDimension(), dest.getDimension());\n\t\tfor (var dim = 0; dim < minDim; dim++) {\n\t\t\tdest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));\n\t\t}\n\t}\n\tstatic isRing(seq) {\n\t\tvar n = seq.size();\n\t\tif (n === 0) return true;\n\t\tif (n <= 3) return false;\n\t\treturn seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n\t}\n\tstatic isEqual(cs1, cs2) {\n\t\tvar cs1Size = cs1.size();\n\t\tvar cs2Size = cs2.size();\n\t\tif (cs1Size !== cs2Size) return false;\n\t\tvar dim = Math.min(cs1.getDimension(), cs2.getDimension());\n\t\tfor (var i = 0; i < cs1Size; i++) {\n\t\t\tfor (var d = 0; d < dim; d++) {\n\t\t\t\tvar v1 = cs1.getOrdinate(i, d);\n\t\t\t\tvar v2 = cs2.getOrdinate(i, d);\n\t\t\t\tif (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) continue;\n\t\t\t\tif (Double.isNaN(v1) && Double.isNaN(v2)) continue;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tstatic extend(fact, seq, size) {\n\t\tvar newseq = fact.create(size, seq.getDimension());\n\t\tvar n = seq.size();\n\t\tCoordinateSequences.copy(seq, 0, newseq, 0, n);\n\t\tif (n > 0) {\n\t\t\tfor (var i = n; i < size; i++) CoordinateSequences.copy(seq, n - 1, newseq, i, 1);\n\t\t}\n\t\treturn newseq;\n\t}\n\tstatic reverse(seq) {\n\t\tvar last = seq.size() - 1;\n\t\tvar mid = Math.trunc(last / 2);\n\t\tfor (var i = 0; i <= mid; i++) {\n\t\t\tCoordinateSequences.swap(seq, i, last - i);\n\t\t}\n\t}\n\tstatic swap(seq, i, j) {\n\t\tif (i === j) return null;\n\t\tfor (var dim = 0; dim < seq.getDimension(); dim++) {\n\t\t\tvar tmp = seq.getOrdinate(i, dim);\n\t\t\tseq.setOrdinate(i, dim, seq.getOrdinate(j, dim));\n\t\t\tseq.setOrdinate(j, dim, tmp);\n\t\t}\n\t}\n\tstatic copy(src, srcPos, dest, destPos, length) {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tCoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);\n\t\t}\n\t}\n\tstatic toString() {\n\t\tif (arguments.length === 1 && hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\tlet cs = arguments[0];\n\t\t\tvar size = cs.size();\n\t\t\tif (size === 0) return \"()\";\n\t\t\tvar dim = cs.getDimension();\n\t\t\tvar builder = new StringBuilder();\n\t\t\tbuilder.append('(');\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tif (i > 0) builder.append(\" \");\n\t\t\t\tfor (var d = 0; d < dim; d++) {\n\t\t\t\t\tif (d > 0) builder.append(\",\");\n\t\t\t\t\tbuilder.append(StringUtil.toString(cs.getOrdinate(i, d)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuilder.append(')');\n\t\t\treturn builder.toString();\n\t\t}\n\t}\n\tstatic ensureValidRing(fact, seq) {\n\t\tvar n = seq.size();\n\t\tif (n === 0) return seq;\n\t\tif (n <= 3) return CoordinateSequences.createClosedRing(fact, seq, 4);\n\t\tvar isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n\t\tif (isClosed) return seq;\n\t\treturn CoordinateSequences.createClosedRing(fact, seq, n + 1);\n\t}\n\tstatic createClosedRing(fact, seq, size) {\n\t\tvar newseq = fact.create(size, seq.getDimension());\n\t\tvar n = seq.size();\n\t\tCoordinateSequences.copy(seq, 0, newseq, 0, n);\n\t\tfor (var i = n; i < size; i++) CoordinateSequences.copy(seq, 0, newseq, i, 1);\n\t\treturn newseq;\n\t}\n\tgetClass() {\n\t\treturn CoordinateSequences;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCoordinateSequences.constructor_ = function () {};\n","import Geometry from './Geometry';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport BoundaryOp from '../operation/BoundaryOp';\nimport Length from '../algorithm/Length';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Lineal from './Lineal';\nimport CoordinateSequences from './CoordinateSequences';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Dimension from './Dimension';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nimport Envelope from './Envelope';\nexport default class LineString extends Geometry {\n\tconstructor() {\n\t\tsuper();\n\t\tLineString.constructor_.apply(this, arguments);\n\t}\n\tcomputeEnvelopeInternal() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn new Envelope();\n\t\t}\n\t\treturn this._points.expandEnvelope(new Envelope());\n\t}\n\tisRing() {\n\t\treturn this.isClosed() && this.isSimple();\n\t}\n\tgetCoordinates() {\n\t\treturn this._points.toCoordinateArray();\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar otherLineString = other;\n\t\t\tif (this._points.size() !== otherLineString._points.size()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\t\tif (!this.equal(this._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tnormalize() {\n\t\tfor (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {\n\t\t\tvar j = this._points.size() - 1 - i;\n\t\t\tif (!this._points.getCoordinate(i).equals(this._points.getCoordinate(j))) {\n\t\t\t\tif (this._points.getCoordinate(i).compareTo(this._points.getCoordinate(j)) > 0) {\n\t\t\t\t\tvar copy = this._points.copy();\n\t\t\t\t\tCoordinateSequences.reverse(copy);\n\t\t\t\t\tthis._points = copy;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\tgetCoordinate() {\n\t\tif (this.isEmpty()) return null;\n\t\treturn this._points.getCoordinate(0);\n\t}\n\tgetBoundaryDimension() {\n\t\tif (this.isClosed()) {\n\t\t\treturn Dimension.FALSE;\n\t\t}\n\t\treturn 0;\n\t}\n\tisClosed() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));\n\t}\n\tgetEndPoint() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.getPointN(this.getNumPoints() - 1);\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_LINESTRING;\n\t}\n\tgetDimension() {\n\t\treturn 1;\n\t}\n\tgetLength() {\n\t\treturn Length.ofLine(this._points);\n\t}\n\tgetNumPoints() {\n\t\treturn this._points.size();\n\t}\n\treverse() {\n\t\tvar seq = this._points.copy();\n\t\tCoordinateSequences.reverse(seq);\n\t\tvar revLine = this.getFactory().createLineString(seq);\n\t\treturn revLine;\n\t}\n\tcompareToSameClass() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar line = o;\n\t\t\tvar i = 0;\n\t\t\tvar j = 0;\n\t\t\twhile (i < this._points.size() && j < line._points.size()) {\n\t\t\t\tvar comparison = this._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));\n\t\t\t\tif (comparison !== 0) {\n\t\t\t\t\treturn comparison;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (i < this._points.size()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (j < line._points.size()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar line = o;\n\t\t\treturn comp.compare(this._points, line._points);\n\t\t}\n\t}\n\tapply() {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\t\tfilter.filter(this._points.getCoordinate(i));\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this._points.size() === 0) return null;\n\t\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\t\tfilter.filter(this._points, i);\n\t\t\t\tif (filter.isDone()) break;\n\t\t\t}\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t}\n\t}\n\tgetBoundary() {\n\t\treturn new BoundaryOp(this).getBoundary();\n\t}\n\tisEquivalentClass(other) {\n\t\treturn other instanceof LineString;\n\t}\n\tgetCoordinateN(n) {\n\t\treturn this._points.getCoordinate(n);\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_LINESTRING;\n\t}\n\tcopy() {\n\t\treturn new LineString(this._points.copy(), this._factory);\n\t}\n\tgetCoordinateSequence() {\n\t\treturn this._points;\n\t}\n\tisEmpty() {\n\t\treturn this._points.size() === 0;\n\t}\n\tinit(points) {\n\t\tif (points === null) {\n\t\t\tpoints = this.getFactory().getCoordinateSequenceFactory().create([]);\n\t\t}\n\t\tif (points.size() === 1) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid number of points in LineString (found \" + points.size() + \" - must be 0 or >= 2)\");\n\t\t}\n\t\tthis._points = points;\n\t}\n\tisCoordinate(pt) {\n\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\tif (this._points.getCoordinate(i).equals(pt)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tgetStartPoint() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.getPointN(0);\n\t}\n\tgetPointN(n) {\n\t\treturn this.getFactory().createPoint(this._points.getCoordinate(n));\n\t}\n\tgetClass() {\n\t\treturn LineString;\n\t}\n\tget interfaces_() {\n\t\treturn [Lineal];\n\t}\n}\nLineString.constructor_ = function () {\n\tthis._points = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 2) {\n\t\tlet points = arguments[0], factory = arguments[1];\n\t\tGeometry.constructor_.call(this, factory);\n\t\tthis.init(points);\n\t}\n};\nLineString.serialVersionUID = 3110669828065365560;\n","export default class Puntal {\n\tconstructor() {\n\t\tPuntal.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn Puntal;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPuntal.constructor_ = function () {};\n","import Geometry from './Geometry';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Dimension from './Dimension';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nimport Puntal from './Puntal';\nimport Envelope from './Envelope';\nimport Assert from '../util/Assert';\nexport default class Point extends Geometry {\n\tconstructor() {\n\t\tsuper();\n\t\tPoint.constructor_.apply(this, arguments);\n\t}\n\tcomputeEnvelopeInternal() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn new Envelope();\n\t\t}\n\t\tvar env = new Envelope();\n\t\tenv.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));\n\t\treturn env;\n\t}\n\tgetCoordinates() {\n\t\treturn this.isEmpty() ? [] : [this.getCoordinate()];\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.isEmpty() && other.isEmpty()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (this.isEmpty() !== other.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tnormalize() {}\n\tgetCoordinate() {\n\t\treturn this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;\n\t}\n\tgetBoundaryDimension() {\n\t\treturn Dimension.FALSE;\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_POINT;\n\t}\n\tgetDimension() {\n\t\treturn 0;\n\t}\n\tgetNumPoints() {\n\t\treturn this.isEmpty() ? 0 : 1;\n\t}\n\treverse() {\n\t\treturn this.copy();\n\t}\n\tgetX() {\n\t\tif (this.getCoordinate() === null) {\n\t\t\tthrow new IllegalStateException(\"getX called on empty Point\");\n\t\t}\n\t\treturn this.getCoordinate().x;\n\t}\n\tcompareToSameClass() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet other = arguments[0];\n\t\t\tvar point = other;\n\t\t\treturn this.getCoordinate().compareTo(point.getCoordinate());\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet other = arguments[0], comp = arguments[1];\n\t\t\tvar point = other;\n\t\t\treturn comp.compare(this._coordinates, point._coordinates);\n\t\t}\n\t}\n\tapply() {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfilter.filter(this.getCoordinate());\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this.isEmpty()) return null;\n\t\t\tfilter.filter(this._coordinates, 0);\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t}\n\t}\n\tgetBoundary() {\n\t\treturn this.getFactory().createGeometryCollection();\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_POINT;\n\t}\n\tcopy() {\n\t\treturn new Point(this._coordinates.copy(), this._factory);\n\t}\n\tgetCoordinateSequence() {\n\t\treturn this._coordinates;\n\t}\n\tgetY() {\n\t\tif (this.getCoordinate() === null) {\n\t\t\tthrow new IllegalStateException(\"getY called on empty Point\");\n\t\t}\n\t\treturn this.getCoordinate().y;\n\t}\n\tisEmpty() {\n\t\treturn this._coordinates.size() === 0;\n\t}\n\tinit(coordinates) {\n\t\tif (coordinates === null) {\n\t\t\tcoordinates = this.getFactory().getCoordinateSequenceFactory().create([]);\n\t\t}\n\t\tAssert.isTrue(coordinates.size() <= 1);\n\t\tthis._coordinates = coordinates;\n\t}\n\tisSimple() {\n\t\treturn true;\n\t}\n\tgetClass() {\n\t\treturn Point;\n\t}\n\tget interfaces_() {\n\t\treturn [Puntal];\n\t}\n}\nPoint.constructor_ = function () {\n\tthis._coordinates = null;\n\tlet coordinates = arguments[0], factory = arguments[1];\n\tGeometry.constructor_.call(this, factory);\n\tthis.init(coordinates);\n};\nPoint.serialVersionUID = 4902022702746614570;\n","import hasInterface from '../../../../hasInterface';\nimport Coordinate from '../geom/Coordinate';\nimport CoordinateSequence from '../geom/CoordinateSequence';\nexport default class Area {\n\tconstructor() {\n\t\tArea.constructor_.apply(this, arguments);\n\t}\n\tstatic ofRing() {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tlet ring = arguments[0];\n\t\t\treturn Math.abs(Area.ofRingSigned(ring));\n\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\tlet ring = arguments[0];\n\t\t\treturn Math.abs(Area.ofRingSigned(ring));\n\t\t}\n\t}\n\tstatic ofRingSigned() {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tlet ring = arguments[0];\n\t\t\tif (ring.length < 3) return 0.0;\n\t\t\tvar sum = 0.0;\n\t\t\tvar x0 = ring[0].x;\n\t\t\tfor (var i = 1; i < ring.length - 1; i++) {\n\t\t\t\tvar x = ring[i].x - x0;\n\t\t\t\tvar y1 = ring[i + 1].y;\n\t\t\t\tvar y2 = ring[i - 1].y;\n\t\t\t\tsum += x * (y2 - y1);\n\t\t\t}\n\t\t\treturn sum / 2.0;\n\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\tlet ring = arguments[0];\n\t\t\tvar n = ring.size();\n\t\t\tif (n < 3) return 0.0;\n\t\t\tvar p0 = new Coordinate();\n\t\t\tvar p1 = new Coordinate();\n\t\t\tvar p2 = new Coordinate();\n\t\t\tring.getCoordinate(0, p1);\n\t\t\tring.getCoordinate(1, p2);\n\t\t\tvar x0 = p1.x;\n\t\t\tp2.x -= x0;\n\t\t\tvar sum = 0.0;\n\t\t\tfor (var i = 1; i < n - 1; i++) {\n\t\t\t\tp0.y = p1.y;\n\t\t\t\tp1.x = p2.x;\n\t\t\t\tp1.y = p2.y;\n\t\t\t\tring.getCoordinate(i + 1, p2);\n\t\t\t\tp2.x -= x0;\n\t\t\t\tsum += p1.x * (p0.y - p2.y);\n\t\t\t}\n\t\t\treturn sum / 2.0;\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn Area;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nArea.constructor_ = function () {};\n","export default function StringBuffer (str) {\n  this.str = str\n}\n\nStringBuffer.prototype.append = function (e) {\n  this.str += e\n}\n\nStringBuffer.prototype.setCharAt = function (i, c) {\n  this.str = this.str.substr(0, i) + c + this.str.substr(i + 1)\n}\n\nStringBuffer.prototype.toString = function (e) {\n  return this.str\n}\n","export default function Integer (value) {\n  this.value = value\n}\n\nInteger.prototype.intValue = function () {\n  return this.value\n}\nInteger.prototype.compareTo = function (o) {\n  if (this.value < o) return -1\n  if (this.value > o) return 1\n  return 0\n}\n\nInteger.isNaN = n => Number.isNaN(n)\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Double from '../../../../java/lang/Double';\nimport Integer from '../../../../java/lang/Integer';\nimport Character from '../../../../java/lang/Character';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport Serializable from '../../../../java/io/Serializable';\nexport default class DD {\n\tconstructor() {\n\t\tDD.constructor_.apply(this, arguments);\n\t}\n\tstatic sqr(x) {\n\t\treturn DD.valueOf(x).selfMultiply(x);\n\t}\n\tstatic valueOf() {\n\t\tif (typeof arguments[0] === \"string\") {\n\t\t\tlet str = arguments[0];\n\t\t\treturn DD.parse(str);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet x = arguments[0];\n\t\t\treturn new DD(x);\n\t\t}\n\t}\n\tstatic sqrt(x) {\n\t\treturn DD.valueOf(x).sqrt();\n\t}\n\tstatic parse(str) {\n\t\tvar i = 0;\n\t\tvar strlen = str.length;\n\t\twhile (Character.isWhitespace(str.charAt(i))) i++;\n\t\tvar isNegative = false;\n\t\tif (i < strlen) {\n\t\t\tvar signCh = str.charAt(i);\n\t\t\tif (signCh === '-' || signCh === '+') {\n\t\t\t\ti++;\n\t\t\t\tif (signCh === '-') isNegative = true;\n\t\t\t}\n\t\t}\n\t\tvar val = new DD();\n\t\tvar numDigits = 0;\n\t\tvar numBeforeDec = 0;\n\t\tvar exp = 0;\n\t\twhile (true) {\n\t\t\tif (i >= strlen) break;\n\t\t\tvar ch = str.charAt(i);\n\t\t\ti++;\n\t\t\tif (Character.isDigit(ch)) {\n\t\t\t\tvar d = ch - '0';\n\t\t\t\tval.selfMultiply(DD.TEN);\n\t\t\t\tval.selfAdd(d);\n\t\t\t\tnumDigits++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch === '.') {\n\t\t\t\tnumBeforeDec = numDigits;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch === 'e' || ch === 'E') {\n\t\t\t\tvar expStr = str.substring(i);\n\t\t\t\ttry {\n\t\t\t\t\texp = Integer.parseInt(expStr);\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tif (ex instanceof NumberFormatException) {\n\t\t\t\t\t\tthrow new NumberFormatException(\"Invalid exponent \" + expStr + \" in string \" + str);\n\t\t\t\t\t} else throw ex;\n\t\t\t\t} finally {}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthrow new NumberFormatException(\"Unexpected character '\" + ch + \"' at position \" + i + \" in string \" + str);\n\t\t}\n\t\tvar val2 = val;\n\t\tvar numDecPlaces = numDigits - numBeforeDec - exp;\n\t\tif (numDecPlaces === 0) {\n\t\t\tval2 = val;\n\t\t} else if (numDecPlaces > 0) {\n\t\t\tvar scale = DD.TEN.pow(numDecPlaces);\n\t\t\tval2 = val.divide(scale);\n\t\t} else if (numDecPlaces < 0) {\n\t\t\tvar scale = DD.TEN.pow(-numDecPlaces);\n\t\t\tval2 = val.multiply(scale);\n\t\t}\n\t\tif (isNegative) {\n\t\t\treturn val2.negate();\n\t\t}\n\t\treturn val2;\n\t}\n\tstatic createNaN() {\n\t\treturn new DD(Double.NaN, Double.NaN);\n\t}\n\tstatic copy(dd) {\n\t\treturn new DD(dd);\n\t}\n\tstatic magnitude(x) {\n\t\tvar xAbs = Math.abs(x);\n\t\tvar xLog10 = Math.log(xAbs) / Math.log(10);\n\t\tvar xMag = Math.trunc(Math.floor(xLog10));\n\t\tvar xApprox = Math.pow(10, xMag);\n\t\tif (xApprox * 10 <= xAbs) xMag += 1;\n\t\treturn xMag;\n\t}\n\tstatic stringOfChar(ch, len) {\n\t\tvar buf = new StringBuffer();\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tbuf.append(ch);\n\t\t}\n\t\treturn buf.toString();\n\t}\n\tle(y) {\n\t\treturn this._hi < y._hi || this._hi === y._hi && this._lo <= y._lo;\n\t}\n\textractSignificantDigits(insertDecimalPoint, magnitude) {\n\t\tvar y = this.abs();\n\t\tvar mag = DD.magnitude(y._hi);\n\t\tvar scale = DD.TEN.pow(mag);\n\t\ty = y.divide(scale);\n\t\tif (y.gt(DD.TEN)) {\n\t\t\ty = y.divide(DD.TEN);\n\t\t\tmag += 1;\n\t\t} else if (y.lt(DD.ONE)) {\n\t\t\ty = y.multiply(DD.TEN);\n\t\t\tmag -= 1;\n\t\t}\n\t\tvar decimalPointPos = mag + 1;\n\t\tvar buf = new StringBuffer();\n\t\tvar numDigits = DD.MAX_PRINT_DIGITS - 1;\n\t\tfor (var i = 0; i <= numDigits; i++) {\n\t\t\tif (insertDecimalPoint && i === decimalPointPos) {\n\t\t\t\tbuf.append('.');\n\t\t\t}\n\t\t\tvar digit = Math.trunc(y._hi);\n\t\t\tif (digit < 0 || digit > 9) {}\n\t\t\tif (digit < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar rebiasBy10 = false;\n\t\t\tvar digitChar = 0;\n\t\t\tif (digit > 9) {\n\t\t\t\trebiasBy10 = true;\n\t\t\t\tdigitChar = '9';\n\t\t\t} else {\n\t\t\t\tdigitChar = '0' + digit;\n\t\t\t}\n\t\t\tbuf.append(digitChar);\n\t\t\ty = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);\n\t\t\tif (rebiasBy10) y.selfAdd(DD.TEN);\n\t\t\tvar continueExtractingDigits = true;\n\t\t\tvar remMag = DD.magnitude(y._hi);\n\t\t\tif (remMag < 0 && Math.abs(remMag) >= numDigits - i) continueExtractingDigits = false;\n\t\t\tif (!continueExtractingDigits) break;\n\t\t}\n\t\tmagnitude[0] = mag;\n\t\treturn buf.toString();\n\t}\n\tsqr() {\n\t\treturn this.multiply(this);\n\t}\n\tdoubleValue() {\n\t\treturn this._hi + this._lo;\n\t}\n\tsubtract() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\treturn this.add(y.negate());\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\treturn this.add(-y);\n\t\t}\n\t}\n\tequals() {\n\t\tif (arguments.length === 1 && arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\treturn this._hi === y._hi && this._lo === y._lo;\n\t\t}\n\t}\n\tisZero() {\n\t\treturn this._hi === 0.0 && this._lo === 0.0;\n\t}\n\tselfSubtract() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\tif (this.isNaN()) return this;\n\t\t\treturn this.selfAdd(-y._hi, -y._lo);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\tif (this.isNaN()) return this;\n\t\t\treturn this.selfAdd(-y, 0.0);\n\t\t}\n\t}\n\tgetSpecialNumberString() {\n\t\tif (this.isZero()) return \"0.0\";\n\t\tif (this.isNaN()) return \"NaN \";\n\t\treturn null;\n\t}\n\tmin(x) {\n\t\tif (this.le(x)) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn x;\n\t\t}\n\t}\n\tselfDivide() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof DD) {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfDivide(y._hi, y._lo);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfDivide(y, 0.0);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet yhi = arguments[0], ylo = arguments[1];\n\t\t\tvar hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;\n\t\t\tC = this._hi / yhi;\n\t\t\tc = DD.SPLIT * C;\n\t\t\thc = c - C;\n\t\t\tu = DD.SPLIT * yhi;\n\t\t\thc = c - hc;\n\t\t\ttc = C - hc;\n\t\t\thy = u - yhi;\n\t\t\tU = C * yhi;\n\t\t\thy = u - hy;\n\t\t\tty = yhi - hy;\n\t\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n\t\t\tc = (this._hi - U - u + this._lo - C * ylo) / yhi;\n\t\t\tu = C + c;\n\t\t\tthis._hi = u;\n\t\t\tthis._lo = C - u + c;\n\t\t\treturn this;\n\t\t}\n\t}\n\tdump() {\n\t\treturn \"DD<\" + this._hi + \", \" + this._lo + \">\";\n\t}\n\tdivide() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\tvar hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;\n\t\t\tC = this._hi / y._hi;\n\t\t\tc = DD.SPLIT * C;\n\t\t\thc = c - C;\n\t\t\tu = DD.SPLIT * y._hi;\n\t\t\thc = c - hc;\n\t\t\ttc = C - hc;\n\t\t\thy = u - y._hi;\n\t\t\tU = C * y._hi;\n\t\t\thy = u - hy;\n\t\t\tty = y._hi - hy;\n\t\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n\t\t\tc = (this._hi - U - u + this._lo - C * y._lo) / y._hi;\n\t\t\tu = C + c;\n\t\t\tvar zhi = u;\n\t\t\tvar zlo = C - u + c;\n\t\t\treturn new DD(zhi, zlo);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\tif (Double.isNaN(y)) return DD.createNaN();\n\t\t\treturn DD.copy(this).selfDivide(y, 0.0);\n\t\t}\n\t}\n\tge(y) {\n\t\treturn this._hi > y._hi || this._hi === y._hi && this._lo >= y._lo;\n\t}\n\tpow(exp) {\n\t\tif (exp === 0.0) return DD.valueOf(1.0);\n\t\tvar r = new DD(this);\n\t\tvar s = DD.valueOf(1.0);\n\t\tvar n = Math.abs(exp);\n\t\tif (n > 1) {\n\t\t\twhile (n > 0) {\n\t\t\t\tif (n % 2 === 1) {\n\t\t\t\t\ts.selfMultiply(r);\n\t\t\t\t}\n\t\t\t\tn /= 2;\n\t\t\t\tif (n > 0) r = r.sqr();\n\t\t\t}\n\t\t} else {\n\t\t\ts = r;\n\t\t}\n\t\tif (exp < 0) return s.reciprocal();\n\t\treturn s;\n\t}\n\tceil() {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tvar fhi = Math.ceil(this._hi);\n\t\tvar flo = 0.0;\n\t\tif (fhi === this._hi) {\n\t\t\tflo = Math.ceil(this._lo);\n\t\t}\n\t\treturn new DD(fhi, flo);\n\t}\n\tcompareTo(o) {\n\t\tvar other = o;\n\t\tif (this._hi < other._hi) return -1;\n\t\tif (this._hi > other._hi) return 1;\n\t\tif (this._lo < other._lo) return -1;\n\t\tif (this._lo > other._lo) return 1;\n\t\treturn 0;\n\t}\n\trint() {\n\t\tif (this.isNaN()) return this;\n\t\tvar plus5 = this.add(0.5);\n\t\treturn plus5.floor();\n\t}\n\tsetValue() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet value = arguments[0];\n\t\t\tthis.init(value);\n\t\t\treturn this;\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet value = arguments[0];\n\t\t\tthis.init(value);\n\t\t\treturn this;\n\t\t}\n\t}\n\tmax(x) {\n\t\tif (this.ge(x)) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn x;\n\t\t}\n\t}\n\tsqrt() {\n\t\tif (this.isZero()) return DD.valueOf(0.0);\n\t\tif (this.isNegative()) {\n\t\t\treturn DD.NaN;\n\t\t}\n\t\tvar x = 1.0 / Math.sqrt(this._hi);\n\t\tvar ax = this._hi * x;\n\t\tvar axdd = DD.valueOf(ax);\n\t\tvar diffSq = this.subtract(axdd.sqr());\n\t\tvar d2 = diffSq._hi * (x * 0.5);\n\t\treturn axdd.add(d2);\n\t}\n\tselfAdd() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof DD) {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfAdd(y._hi, y._lo);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\tvar H = null, h = null, S = null, s = null, e = null, f = null;\n\t\t\t\tS = this._hi + y;\n\t\t\t\te = S - this._hi;\n\t\t\t\ts = S - e;\n\t\t\t\ts = y - e + (this._hi - s);\n\t\t\t\tf = s + this._lo;\n\t\t\t\tH = S + f;\n\t\t\t\th = f + (S - H);\n\t\t\t\tthis._hi = H + h;\n\t\t\t\tthis._lo = h + (H - this._hi);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet yhi = arguments[0], ylo = arguments[1];\n\t\t\tvar H = null, h = null, T = null, t = null, S = null, s = null, e = null, f = null;\n\t\t\tS = this._hi + yhi;\n\t\t\tT = this._lo + ylo;\n\t\t\te = S - this._hi;\n\t\t\tf = T - this._lo;\n\t\t\ts = S - e;\n\t\t\tt = T - f;\n\t\t\ts = yhi - e + (this._hi - s);\n\t\t\tt = ylo - f + (this._lo - t);\n\t\t\te = s + T;\n\t\t\tH = S + e;\n\t\t\th = e + (S - H);\n\t\t\te = t + h;\n\t\t\tvar zhi = H + e;\n\t\t\tvar zlo = e + (H - zhi);\n\t\t\tthis._hi = zhi;\n\t\t\tthis._lo = zlo;\n\t\t\treturn this;\n\t\t}\n\t}\n\tselfMultiply() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof DD) {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfMultiply(y._hi, y._lo);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfMultiply(y, 0.0);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet yhi = arguments[0], ylo = arguments[1];\n\t\t\tvar hx = null, tx = null, hy = null, ty = null, C = null, c = null;\n\t\t\tC = DD.SPLIT * this._hi;\n\t\t\thx = C - this._hi;\n\t\t\tc = DD.SPLIT * yhi;\n\t\t\thx = C - hx;\n\t\t\ttx = this._hi - hx;\n\t\t\thy = c - yhi;\n\t\t\tC = this._hi * yhi;\n\t\t\thy = c - hy;\n\t\t\tty = yhi - hy;\n\t\t\tc = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);\n\t\t\tvar zhi = C + c;\n\t\t\thx = C - zhi;\n\t\t\tvar zlo = c + hx;\n\t\t\tthis._hi = zhi;\n\t\t\tthis._lo = zlo;\n\t\t\treturn this;\n\t\t}\n\t}\n\tselfSqr() {\n\t\treturn this.selfMultiply(this);\n\t}\n\tfloor() {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tvar fhi = Math.floor(this._hi);\n\t\tvar flo = 0.0;\n\t\tif (fhi === this._hi) {\n\t\t\tflo = Math.floor(this._lo);\n\t\t}\n\t\treturn new DD(fhi, flo);\n\t}\n\tnegate() {\n\t\tif (this.isNaN()) return this;\n\t\treturn new DD(-this._hi, -this._lo);\n\t}\n\tclone() {\n\t\ttry {\n\t\t\treturn null;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof CloneNotSupportedException) {\n\t\t\t\treturn null;\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t}\n\tmultiply() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\tif (y.isNaN()) return DD.createNaN();\n\t\t\treturn DD.copy(this).selfMultiply(y);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\tif (Double.isNaN(y)) return DD.createNaN();\n\t\t\treturn DD.copy(this).selfMultiply(y, 0.0);\n\t\t}\n\t}\n\tisNaN() {\n\t\treturn Double.isNaN(this._hi);\n\t}\n\tintValue() {\n\t\treturn Math.trunc(this._hi);\n\t}\n\ttoString() {\n\t\tvar mag = DD.magnitude(this._hi);\n\t\tif (mag >= -3 && mag <= 20) return this.toStandardNotation();\n\t\treturn this.toSciNotation();\n\t}\n\ttoStandardNotation() {\n\t\tvar specialStr = this.getSpecialNumberString();\n\t\tif (specialStr !== null) return specialStr;\n\t\tvar magnitude = new Array(1).fill(null);\n\t\tvar sigDigits = this.extractSignificantDigits(true, magnitude);\n\t\tvar decimalPointPos = magnitude[0] + 1;\n\t\tvar num = sigDigits;\n\t\tif (sigDigits.charAt(0) === '.') {\n\t\t\tnum = \"0\" + sigDigits;\n\t\t} else if (decimalPointPos < 0) {\n\t\t\tnum = \"0.\" + DD.stringOfChar('0', -decimalPointPos) + sigDigits;\n\t\t} else if (sigDigits.indexOf('.') === -1) {\n\t\t\tvar numZeroes = decimalPointPos - sigDigits.length;\n\t\t\tvar zeroes = DD.stringOfChar('0', numZeroes);\n\t\t\tnum = sigDigits + zeroes + \".0\";\n\t\t}\n\t\tif (this.isNegative()) return \"-\" + num;\n\t\treturn num;\n\t}\n\treciprocal() {\n\t\tvar hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;\n\t\tC = 1.0 / this._hi;\n\t\tc = DD.SPLIT * C;\n\t\thc = c - C;\n\t\tu = DD.SPLIT * this._hi;\n\t\thc = c - hc;\n\t\ttc = C - hc;\n\t\thy = u - this._hi;\n\t\tU = C * this._hi;\n\t\thy = u - hy;\n\t\tty = this._hi - hy;\n\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n\t\tc = (1.0 - U - u - C * this._lo) / this._hi;\n\t\tvar zhi = C + c;\n\t\tvar zlo = C - zhi + c;\n\t\treturn new DD(zhi, zlo);\n\t}\n\ttoSciNotation() {\n\t\tif (this.isZero()) return DD.SCI_NOT_ZERO;\n\t\tvar specialStr = this.getSpecialNumberString();\n\t\tif (specialStr !== null) return specialStr;\n\t\tvar magnitude = new Array(1).fill(null);\n\t\tvar digits = this.extractSignificantDigits(false, magnitude);\n\t\tvar expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];\n\t\tif (digits.charAt(0) === '0') {\n\t\t\tthrow new IllegalStateException(\"Found leading zero: \" + digits);\n\t\t}\n\t\tvar trailingDigits = \"\";\n\t\tif (digits.length > 1) trailingDigits = digits.substring(1);\n\t\tvar digitsWithDecimal = digits.charAt(0) + \".\" + trailingDigits;\n\t\tif (this.isNegative()) return \"-\" + digitsWithDecimal + expStr;\n\t\treturn digitsWithDecimal + expStr;\n\t}\n\tabs() {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tif (this.isNegative()) return this.negate();\n\t\treturn new DD(this);\n\t}\n\tisPositive() {\n\t\treturn this._hi > 0.0 || this._hi === 0.0 && this._lo > 0.0;\n\t}\n\tlt(y) {\n\t\treturn this._hi < y._hi || this._hi === y._hi && this._lo < y._lo;\n\t}\n\tadd() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\treturn DD.copy(this).selfAdd(y);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\treturn DD.copy(this).selfAdd(y);\n\t\t}\n\t}\n\tinit() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (typeof arguments[0] === \"number\") {\n\t\t\t\tlet x = arguments[0];\n\t\t\t\tthis._hi = x;\n\t\t\t\tthis._lo = 0.0;\n\t\t\t} else if (arguments[0] instanceof DD) {\n\t\t\t\tlet dd = arguments[0];\n\t\t\t\tthis._hi = dd._hi;\n\t\t\t\tthis._lo = dd._lo;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet hi = arguments[0], lo = arguments[1];\n\t\t\tthis._hi = hi;\n\t\t\tthis._lo = lo;\n\t\t}\n\t}\n\tgt(y) {\n\t\treturn this._hi > y._hi || this._hi === y._hi && this._lo > y._lo;\n\t}\n\tisNegative() {\n\t\treturn this._hi < 0.0 || this._hi === 0.0 && this._lo < 0.0;\n\t}\n\ttrunc() {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tif (this.isPositive()) return this.floor(); else return this.ceil();\n\t}\n\tsignum() {\n\t\tif (this._hi > 0) return 1;\n\t\tif (this._hi < 0) return -1;\n\t\tif (this._lo > 0) return 1;\n\t\tif (this._lo < 0) return -1;\n\t\treturn 0;\n\t}\n\tgetClass() {\n\t\treturn DD;\n\t}\n\tget interfaces_() {\n\t\treturn [Serializable, Comparable, Cloneable];\n\t}\n}\nDD.constructor_ = function () {\n\tthis._hi = 0.0;\n\tthis._lo = 0.0;\n\tif (arguments.length === 0) {\n\t\tthis.init(0.0);\n\t} else if (arguments.length === 1) {\n\t\tif (typeof arguments[0] === \"number\") {\n\t\t\tlet x = arguments[0];\n\t\t\tthis.init(x);\n\t\t} else if (arguments[0] instanceof DD) {\n\t\t\tlet dd = arguments[0];\n\t\t\tthis.init(dd);\n\t\t} else if (typeof arguments[0] === \"string\") {\n\t\t\tlet str = arguments[0];\n\t\t\tDD.constructor_.call(this, DD.parse(str));\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet hi = arguments[0], lo = arguments[1];\n\t\tthis.init(hi, lo);\n\t}\n};\nDD.PI = new DD(3.141592653589793116e+00, 1.224646799147353207e-16);\nDD.TWO_PI = new DD(6.283185307179586232e+00, 2.449293598294706414e-16);\nDD.PI_2 = new DD(1.570796326794896558e+00, 6.123233995736766036e-17);\nDD.E = new DD(2.718281828459045091e+00, 1.445646891729250158e-16);\nDD.NaN = new DD(Double.NaN, Double.NaN);\nDD.EPS = 1.23259516440783e-32;\nDD.SPLIT = 134217729.0;\nDD.MAX_PRINT_DIGITS = 32;\nDD.TEN = DD.valueOf(10.0);\nDD.ONE = DD.valueOf(1.0);\nDD.SCI_NOT_EXPONENT_CHAR = \"E\";\nDD.SCI_NOT_ZERO = \"0.0E0\";\n","import Coordinate from '../geom/Coordinate';\nimport DD from '../math/DD';\nexport default class CGAlgorithmsDD {\n\tconstructor() {\n\t\tCGAlgorithmsDD.constructor_.apply(this, arguments);\n\t}\n\tstatic orientationIndex(p1, p2, q) {\n\t\tvar index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);\n\t\tif (index <= 1) return index;\n\t\tvar dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);\n\t\tvar dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);\n\t\tvar dx2 = DD.valueOf(q.x).selfAdd(-p2.x);\n\t\tvar dy2 = DD.valueOf(q.y).selfAdd(-p2.y);\n\t\treturn dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();\n\t}\n\tstatic signOfDet2x2() {\n\t\tif (arguments[3] instanceof DD && (arguments[2] instanceof DD && (arguments[0] instanceof DD && arguments[1] instanceof DD))) {\n\t\t\tlet x1 = arguments[0], y1 = arguments[1], x2 = arguments[2], y2 = arguments[3];\n\t\t\tvar det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n\t\t\treturn det.signum();\n\t\t} else if (typeof arguments[3] === \"number\" && (typeof arguments[2] === \"number\" && (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\"))) {\n\t\t\tlet dx1 = arguments[0], dy1 = arguments[1], dx2 = arguments[2], dy2 = arguments[3];\n\t\t\tvar x1 = DD.valueOf(dx1);\n\t\t\tvar y1 = DD.valueOf(dy1);\n\t\t\tvar x2 = DD.valueOf(dx2);\n\t\t\tvar y2 = DD.valueOf(dy2);\n\t\t\tvar det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n\t\t\treturn det.signum();\n\t\t}\n\t}\n\tstatic intersection(p1, p2, q1, q2) {\n\t\tvar denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));\n\t\tvar denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));\n\t\tvar denom = denom1.subtract(denom2);\n\t\tvar numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n\t\tvar numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n\t\tvar numx = numx1.subtract(numx2);\n\t\tvar fracP = numx.selfDivide(denom).doubleValue();\n\t\tvar x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();\n\t\tvar numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n\t\tvar numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n\t\tvar numy = numy1.subtract(numy2);\n\t\tvar fracQ = numy.selfDivide(denom).doubleValue();\n\t\tvar y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();\n\t\treturn new Coordinate(x, y);\n\t}\n\tstatic orientationIndexFilter(pa, pb, pc) {\n\t\tvar detsum = null;\n\t\tvar detleft = (pa.x - pc.x) * (pb.y - pc.y);\n\t\tvar detright = (pa.y - pc.y) * (pb.x - pc.x);\n\t\tvar det = detleft - detright;\n\t\tif (detleft > 0.0) {\n\t\t\tif (detright <= 0.0) {\n\t\t\t\treturn CGAlgorithmsDD.signum(det);\n\t\t\t} else {\n\t\t\t\tdetsum = detleft + detright;\n\t\t\t}\n\t\t} else if (detleft < 0.0) {\n\t\t\tif (detright >= 0.0) {\n\t\t\t\treturn CGAlgorithmsDD.signum(det);\n\t\t\t} else {\n\t\t\t\tdetsum = -detleft - detright;\n\t\t\t}\n\t\t} else {\n\t\t\treturn CGAlgorithmsDD.signum(det);\n\t\t}\n\t\tvar errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;\n\t\tif (det >= errbound || -det >= errbound) {\n\t\t\treturn CGAlgorithmsDD.signum(det);\n\t\t}\n\t\treturn 2;\n\t}\n\tstatic signum(x) {\n\t\tif (x > 0) return 1;\n\t\tif (x < 0) return -1;\n\t\treturn 0;\n\t}\n\tgetClass() {\n\t\treturn CGAlgorithmsDD;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCGAlgorithmsDD.constructor_ = function () {};\nCGAlgorithmsDD.DP_SAFE_EPSILON = 1e-15;\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport CGAlgorithmsDD from './CGAlgorithmsDD';\nexport default class Orientation {\n\tconstructor() {\n\t\tOrientation.constructor_.apply(this, arguments);\n\t}\n\tstatic index(p1, p2, q) {\n\t\treturn CGAlgorithmsDD.orientationIndex(p1, p2, q);\n\t}\n\tstatic isCCW(ring) {\n\t\tvar nPts = ring.length - 1;\n\t\tif (nPts < 3) throw new IllegalArgumentException(\"Ring has fewer than 4 points, so orientation cannot be determined\");\n\t\tvar hiPt = ring[0];\n\t\tvar hiIndex = 0;\n\t\tfor (var i = 1; i <= nPts; i++) {\n\t\t\tvar p = ring[i];\n\t\t\tif (p.y > hiPt.y) {\n\t\t\t\thiPt = p;\n\t\t\t\thiIndex = i;\n\t\t\t}\n\t\t}\n\t\tvar iPrev = hiIndex;\n\t\tdo {\n\t\t\tiPrev = iPrev - 1;\n\t\t\tif (iPrev < 0) iPrev = nPts;\n\t\t} while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);\n\t\tvar iNext = hiIndex;\n\t\tdo {\n\t\t\tiNext = (iNext + 1) % nPts;\n\t\t} while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);\n\t\tvar prev = ring[iPrev];\n\t\tvar next = ring[iNext];\n\t\tif (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;\n\t\tvar disc = Orientation.index(prev, hiPt, next);\n\t\tvar isCCW = null;\n\t\tif (disc === 0) {\n\t\t\tisCCW = prev.x > next.x;\n\t\t} else {\n\t\t\tisCCW = disc > 0;\n\t\t}\n\t\treturn isCCW;\n\t}\n\tgetClass() {\n\t\treturn Orientation;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nOrientation.constructor_ = function () {};\nOrientation.CLOCKWISE = -1;\nOrientation.RIGHT = Orientation.CLOCKWISE;\nOrientation.COUNTERCLOCKWISE = 1;\nOrientation.LEFT = Orientation.COUNTERCLOCKWISE;\nOrientation.COLLINEAR = 0;\nOrientation.STRAIGHT = Orientation.COLLINEAR;\n","export default class Polygonal {\n\tconstructor() {\n\t\tPolygonal.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn Polygonal;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPolygonal.constructor_ = function () {};\n","import Area from '../algorithm/Area';\nimport Geometry from './Geometry';\nimport Arrays from '../../../../java/util/Arrays';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Orientation from '../algorithm/Orientation';\nimport System from '../../../../java/lang/System';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport CoordinateArrays from './CoordinateArrays';\nimport Polygonal from './Polygonal';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nexport default class Polygon extends Geometry {\n\tconstructor() {\n\t\tsuper();\n\t\tPolygon.constructor_.apply(this, arguments);\n\t}\n\tcomputeEnvelopeInternal() {\n\t\treturn this._shell.getEnvelopeInternal();\n\t}\n\tgetCoordinates() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn [];\n\t\t}\n\t\tvar coordinates = new Array(this.getNumPoints()).fill(null);\n\t\tvar k = -1;\n\t\tvar shellCoordinates = this._shell.getCoordinates();\n\t\tfor (var x = 0; x < shellCoordinates.length; x++) {\n\t\t\tk++;\n\t\t\tcoordinates[k] = shellCoordinates[x];\n\t\t}\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tvar childCoordinates = this._holes[i].getCoordinates();\n\t\t\tfor (var j = 0; j < childCoordinates.length; j++) {\n\t\t\t\tk++;\n\t\t\t\tcoordinates[k] = childCoordinates[j];\n\t\t\t}\n\t\t}\n\t\treturn coordinates;\n\t}\n\tgetArea() {\n\t\tvar area = 0.0;\n\t\tarea += Area.ofRing(this._shell.getCoordinateSequence());\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tarea -= Area.ofRing(this._holes[i].getCoordinateSequence());\n\t\t}\n\t\treturn area;\n\t}\n\tisRectangle() {\n\t\tif (this.getNumInteriorRing() !== 0) return false;\n\t\tif (this._shell === null) return false;\n\t\tif (this._shell.getNumPoints() !== 5) return false;\n\t\tvar seq = this._shell.getCoordinateSequence();\n\t\tvar env = this.getEnvelopeInternal();\n\t\tfor (var i = 0; i < 5; i++) {\n\t\t\tvar x = seq.getX(i);\n\t\t\tif (!(x === env.getMinX() || x === env.getMaxX())) return false;\n\t\t\tvar y = seq.getY(i);\n\t\t\tif (!(y === env.getMinY() || y === env.getMaxY())) return false;\n\t\t}\n\t\tvar prevX = seq.getX(0);\n\t\tvar prevY = seq.getY(0);\n\t\tfor (var i = 1; i <= 4; i++) {\n\t\t\tvar x = seq.getX(i);\n\t\t\tvar y = seq.getY(i);\n\t\t\tvar xChanged = x !== prevX;\n\t\t\tvar yChanged = y !== prevY;\n\t\t\tif (xChanged === yChanged) return false;\n\t\t\tprevX = x;\n\t\t\tprevY = y;\n\t\t}\n\t\treturn true;\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar otherPolygon = other;\n\t\t\tvar thisShell = this._shell;\n\t\t\tvar otherPolygonShell = otherPolygon._shell;\n\t\t\tif (!thisShell.equalsExact(otherPolygonShell, tolerance)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this._holes.length !== otherPolygon._holes.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tif (!this._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tnormalize() {\n\t\tif (arguments.length === 0) {\n\t\t\tthis.normalize(this._shell, true);\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tthis.normalize(this._holes[i], false);\n\t\t\t}\n\t\t\tArrays.sort(this._holes);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet ring = arguments[0], clockwise = arguments[1];\n\t\t\tif (ring.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);\n\t\t\tSystem.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);\n\t\t\tvar minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());\n\t\t\tCoordinateArrays.scroll(uniqueCoordinates, minCoordinate);\n\t\t\tSystem.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);\n\t\t\tring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];\n\t\t\tif (Orientation.isCCW(ring.getCoordinates()) === clockwise) {\n\t\t\t\tCoordinateArrays.reverse(ring.getCoordinates());\n\t\t\t}\n\t\t}\n\t}\n\tgetCoordinate() {\n\t\treturn this._shell.getCoordinate();\n\t}\n\tgetNumInteriorRing() {\n\t\treturn this._holes.length;\n\t}\n\tgetBoundaryDimension() {\n\t\treturn 1;\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_POLYGON;\n\t}\n\tgetDimension() {\n\t\treturn 2;\n\t}\n\tgetLength() {\n\t\tvar len = 0.0;\n\t\tlen += this._shell.getLength();\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tlen += this._holes[i].getLength();\n\t\t}\n\t\treturn len;\n\t}\n\tgetNumPoints() {\n\t\tvar numPoints = this._shell.getNumPoints();\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tnumPoints += this._holes[i].getNumPoints();\n\t\t}\n\t\treturn numPoints;\n\t}\n\treverse() {\n\t\tvar poly = this.copy();\n\t\tpoly._shell = this._shell.copy().reverse();\n\t\tpoly._holes = new Array(this._holes.length).fill(null);\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tpoly._holes[i] = this._holes[i].copy().reverse();\n\t\t}\n\t\treturn poly;\n\t}\n\tconvexHull() {\n\t\treturn this.getExteriorRing().convexHull();\n\t}\n\tcompareToSameClass() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar thisShell = this._shell;\n\t\t\tvar otherShell = o._shell;\n\t\t\treturn thisShell.compareToSameClass(otherShell);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar poly = o;\n\t\t\tvar thisShell = this._shell;\n\t\t\tvar otherShell = poly._shell;\n\t\t\tvar shellComp = thisShell.compareToSameClass(otherShell, comp);\n\t\t\tif (shellComp !== 0) return shellComp;\n\t\t\tvar nHole1 = this.getNumInteriorRing();\n\t\t\tvar nHole2 = poly.getNumInteriorRing();\n\t\t\tvar i = 0;\n\t\t\twhile (i < nHole1 && i < nHole2) {\n\t\t\t\tvar thisHole = this.getInteriorRingN(i);\n\t\t\t\tvar otherHole = poly.getInteriorRingN(i);\n\t\t\t\tvar holeComp = thisHole.compareToSameClass(otherHole, comp);\n\t\t\t\tif (holeComp !== 0) return holeComp;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i < nHole1) return 1;\n\t\t\tif (i < nHole2) return -1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tapply() {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tthis._shell.apply(filter);\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tthis._holes[i].apply(filter);\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tthis._shell.apply(filter);\n\t\t\tif (!filter.isDone()) {\n\t\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\t\tthis._holes[i].apply(filter);\n\t\t\t\t\tif (filter.isDone()) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t\tthis._shell.apply(filter);\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tthis._holes[i].apply(filter);\n\t\t\t}\n\t\t}\n\t}\n\tgetBoundary() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn this.getFactory().createMultiLineString();\n\t\t}\n\t\tvar rings = new Array(this._holes.length + 1).fill(null);\n\t\trings[0] = this._shell;\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\trings[i + 1] = this._holes[i];\n\t\t}\n\t\tif (rings.length <= 1) return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());\n\t\treturn this.getFactory().createMultiLineString(rings);\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_POLYGON;\n\t}\n\tcopy() {\n\t\tvar shellCopy = this._shell.copy();\n\t\tvar holeCopies = new Array(this._holes.length).fill(null);\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tholeCopies[i] = this._holes[i].copy();\n\t\t}\n\t\treturn new Polygon(shellCopy, holeCopies, this._factory);\n\t}\n\tgetExteriorRing() {\n\t\treturn this._shell;\n\t}\n\tisEmpty() {\n\t\treturn this._shell.isEmpty();\n\t}\n\tgetInteriorRingN(n) {\n\t\treturn this._holes[n];\n\t}\n\tgetClass() {\n\t\treturn Polygon;\n\t}\n\tget interfaces_() {\n\t\treturn [Polygonal];\n\t}\n}\nPolygon.constructor_ = function () {\n\tthis._shell = null;\n\tthis._holes = null;\n\tlet shell = arguments[0], holes = arguments[1], factory = arguments[2];\n\tGeometry.constructor_.call(this, factory);\n\tif (shell === null) {\n\t\tshell = this.getFactory().createLinearRing();\n\t}\n\tif (holes === null) {\n\t\tholes = [];\n\t}\n\tif (Geometry.hasNullElements(holes)) {\n\t\tthrow new IllegalArgumentException(\"holes must not contain null elements\");\n\t}\n\tif (shell.isEmpty() && Geometry.hasNonEmptyElements(holes)) {\n\t\tthrow new IllegalArgumentException(\"shell is empty but holes are not\");\n\t}\n\tthis._shell = shell;\n\tthis._holes = holes;\n};\nPolygon.serialVersionUID = -3494792200821764533;\n","import Geometry from './Geometry';\nimport GeometryCollection from './GeometryCollection';\nimport Dimension from './Dimension';\nimport Puntal from './Puntal';\nexport default class MultiPoint extends GeometryCollection {\n\tconstructor() {\n\t\tsuper();\n\t\tMultiPoint.constructor_.apply(this, arguments);\n\t}\n\tisValid() {\n\t\treturn true;\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn super.equalsExact.call(this, other, tolerance);\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tgetCoordinate() {\n\t\tif (arguments.length === 1 && Number.isInteger(arguments[0])) {\n\t\t\tlet n = arguments[0];\n\t\t\treturn this._geometries[n].getCoordinate();\n\t\t} else return super.getCoordinate.apply(this, arguments);\n\t}\n\tgetBoundaryDimension() {\n\t\treturn Dimension.FALSE;\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_MULTIPOINT;\n\t}\n\tgetDimension() {\n\t\treturn 0;\n\t}\n\tgetBoundary() {\n\t\treturn this.getFactory().createGeometryCollection();\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_MULTIPOINT;\n\t}\n\tcopy() {\n\t\tvar points = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < points.length; i++) {\n\t\t\tpoints[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new MultiPoint(points, this._factory);\n\t}\n\tgetClass() {\n\t\treturn MultiPoint;\n\t}\n\tget interfaces_() {\n\t\treturn [Puntal];\n\t}\n}\nMultiPoint.constructor_ = function () {\n\tlet points = arguments[0], factory = arguments[1];\n\tGeometryCollection.constructor_.call(this, points, factory);\n};\nMultiPoint.serialVersionUID = -8048474874175355449;\n","import LineString from './LineString';\nimport Geometry from './Geometry';\nimport hasInterface from '../../../../hasInterface';\nimport GeometryFactory from './GeometryFactory';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport CoordinateSequences from './CoordinateSequences';\nimport CoordinateSequence from './CoordinateSequence';\nimport Dimension from './Dimension';\nexport default class LinearRing extends LineString {\n\tconstructor() {\n\t\tsuper();\n\t\tLinearRing.constructor_.apply(this, arguments);\n\t}\n\tgetBoundaryDimension() {\n\t\treturn Dimension.FALSE;\n\t}\n\tisClosed() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn super.isClosed.call(this);\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_LINEARRING;\n\t}\n\treverse() {\n\t\tvar seq = this._points.copy();\n\t\tCoordinateSequences.reverse(seq);\n\t\tvar rev = this.getFactory().createLinearRing(seq);\n\t\treturn rev;\n\t}\n\tvalidateConstruction() {\n\t\tif (!this.isEmpty() && !super.isClosed.call(this)) {\n\t\t\tthrow new IllegalArgumentException(\"Points of LinearRing do not form a closed linestring\");\n\t\t}\n\t\tif (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid number of points in LinearRing (found \" + this.getCoordinateSequence().size() + \" - must be 0 or >= 4)\");\n\t\t}\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_LINEARRING;\n\t}\n\tcopy() {\n\t\treturn new LinearRing(this._points.copy(), this._factory);\n\t}\n\tgetClass() {\n\t\treturn LinearRing;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nLinearRing.constructor_ = function () {\n\tif (arguments[0] instanceof Array && arguments[1] instanceof GeometryFactory) {\n\t\tlet points = arguments[0], factory = arguments[1];\n\t\tLinearRing.constructor_.call(this, factory.getCoordinateSequenceFactory().create(points), factory);\n\t} else if (hasInterface(arguments[0], CoordinateSequence) && arguments[1] instanceof GeometryFactory) {\n\t\tlet points = arguments[0], factory = arguments[1];\n\t\tLineString.constructor_.call(this, points, factory);\n\t\tthis.validateConstruction();\n\t}\n};\nLinearRing.MINIMUM_VALID_SIZE = 4;\nLinearRing.serialVersionUID = -4261142084085851829;\n","import Geometry from './Geometry';\nimport GeometryCollection from './GeometryCollection';\nimport Polygonal from './Polygonal';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default class MultiPolygon extends GeometryCollection {\n\tconstructor() {\n\t\tsuper();\n\t\tMultiPolygon.constructor_.apply(this, arguments);\n\t}\n\tequalsExact() {\n\t\tif (arguments.length === 2 && (typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry)) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn super.equalsExact.call(this, other, tolerance);\n\t\t} else return super.equalsExact.apply(this, arguments);\n\t}\n\tgetBoundaryDimension() {\n\t\treturn 1;\n\t}\n\tgetTypeCode() {\n\t\treturn Geometry.TYPECODE_MULTIPOLYGON;\n\t}\n\tgetDimension() {\n\t\treturn 2;\n\t}\n\treverse() {\n\t\tvar n = this._geometries.length;\n\t\tvar revGeoms = new Array(n).fill(null);\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\trevGeoms[i] = this._geometries[i].reverse();\n\t\t}\n\t\treturn this.getFactory().createMultiPolygon(revGeoms);\n\t}\n\tgetBoundary() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn this.getFactory().createMultiLineString();\n\t\t}\n\t\tvar allRings = new ArrayList();\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tvar polygon = this._geometries[i];\n\t\t\tvar rings = polygon.getBoundary();\n\t\t\tfor (var j = 0; j < rings.getNumGeometries(); j++) {\n\t\t\t\tallRings.add(rings.getGeometryN(j));\n\t\t\t}\n\t\t}\n\t\tvar allRingsArray = new Array(allRings.size()).fill(null);\n\t\treturn this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));\n\t}\n\tgetGeometryType() {\n\t\treturn Geometry.TYPENAME_MULTIPOLYGON;\n\t}\n\tcopy() {\n\t\tvar polygons = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < polygons.length; i++) {\n\t\t\tpolygons[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new MultiPolygon(polygons, this._factory);\n\t}\n\tgetClass() {\n\t\treturn MultiPolygon;\n\t}\n\tget interfaces_() {\n\t\treturn [Polygonal];\n\t}\n}\nMultiPolygon.constructor_ = function () {\n\tlet polygons = arguments[0], factory = arguments[1];\n\tGeometryCollection.constructor_.call(this, polygons, factory);\n};\nMultiPolygon.serialVersionUID = -551033529766975875;\n","import LineString from '../LineString';\nimport Point from '../Point';\nimport Polygon from '../Polygon';\nimport MultiPoint from '../MultiPoint';\nimport LinearRing from '../LinearRing';\nimport MultiPolygon from '../MultiPolygon';\nimport GeometryCollection from '../GeometryCollection';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Assert from '../../util/Assert';\nimport MultiLineString from '../MultiLineString';\nexport default class GeometryEditor {\n\tconstructor() {\n\t\tGeometryEditor.constructor_.apply(this, arguments);\n\t}\n\tsetCopyUserData(isUserDataCopied) {\n\t\tthis._isUserDataCopied = isUserDataCopied;\n\t}\n\tedit(geometry, operation) {\n\t\tif (geometry === null) return null;\n\t\tvar result = this.editInternal(geometry, operation);\n\t\tif (this._isUserDataCopied) {\n\t\t\tresult.setUserData(geometry.getUserData());\n\t\t}\n\t\treturn result;\n\t}\n\teditInternal(geometry, operation) {\n\t\tif (this._factory === null) this._factory = geometry.getFactory();\n\t\tif (geometry instanceof GeometryCollection) {\n\t\t\treturn this.editGeometryCollection(geometry, operation);\n\t\t}\n\t\tif (geometry instanceof Polygon) {\n\t\t\treturn this.editPolygon(geometry, operation);\n\t\t}\n\t\tif (geometry instanceof Point) {\n\t\t\treturn operation.edit(geometry, this._factory);\n\t\t}\n\t\tif (geometry instanceof LineString) {\n\t\t\treturn operation.edit(geometry, this._factory);\n\t\t}\n\t\tAssert.shouldNeverReachHere(\"Unsupported Geometry class: \" + geometry.getClass().getName());\n\t\treturn null;\n\t}\n\teditGeometryCollection(collection, operation) {\n\t\tvar collectionForType = operation.edit(collection, this._factory);\n\t\tvar geometries = new ArrayList();\n\t\tfor (var i = 0; i < collectionForType.getNumGeometries(); i++) {\n\t\t\tvar geometry = this.edit(collectionForType.getGeometryN(i), operation);\n\t\t\tif (geometry === null || geometry.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgeometries.add(geometry);\n\t\t}\n\t\tif (collectionForType.getClass() === MultiPoint) {\n\t\t\treturn this._factory.createMultiPoint(geometries.toArray([]));\n\t\t}\n\t\tif (collectionForType.getClass() === MultiLineString) {\n\t\t\treturn this._factory.createMultiLineString(geometries.toArray([]));\n\t\t}\n\t\tif (collectionForType.getClass() === MultiPolygon) {\n\t\t\treturn this._factory.createMultiPolygon(geometries.toArray([]));\n\t\t}\n\t\treturn this._factory.createGeometryCollection(geometries.toArray([]));\n\t}\n\teditPolygon(polygon, operation) {\n\t\tvar newPolygon = operation.edit(polygon, this._factory);\n\t\tif (newPolygon === null) newPolygon = this._factory.createPolygon();\n\t\tif (newPolygon.isEmpty()) {\n\t\t\treturn newPolygon;\n\t\t}\n\t\tvar shell = this.edit(newPolygon.getExteriorRing(), operation);\n\t\tif (shell === null || shell.isEmpty()) {\n\t\t\treturn this._factory.createPolygon();\n\t\t}\n\t\tvar holes = new ArrayList();\n\t\tfor (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {\n\t\t\tvar hole = this.edit(newPolygon.getInteriorRingN(i), operation);\n\t\t\tif (hole === null || hole.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tholes.add(hole);\n\t\t}\n\t\treturn this._factory.createPolygon(shell, holes.toArray([]));\n\t}\n\tgetClass() {\n\t\treturn GeometryEditor;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nfunction GeometryEditorOperation() {}\nGeometryEditor.GeometryEditorOperation = GeometryEditorOperation;\nclass NoOpGeometryOperation {\n\tconstructor() {\n\t\tNoOpGeometryOperation.constructor_.apply(this, arguments);\n\t}\n\tedit(geometry, factory) {\n\t\treturn geometry;\n\t}\n\tgetClass() {\n\t\treturn NoOpGeometryOperation;\n\t}\n\tget interfaces_() {\n\t\treturn [GeometryEditorOperation];\n\t}\n}\nNoOpGeometryOperation.constructor_ = function () {};\nclass CoordinateOperation {\n\tconstructor() {\n\t\tCoordinateOperation.constructor_.apply(this, arguments);\n\t}\n\tedit(geometry, factory) {\n\t\tvar coordinates = this.edit(geometry.getCoordinates(), geometry);\n\t\tif (geometry instanceof LinearRing) {\n\t\t\tif (coordinates === null) return factory.createLinearRing(); else return factory.createLinearRing(coordinates);\n\t\t}\n\t\tif (geometry instanceof LineString) {\n\t\t\tif (coordinates === null) return factory.createLineString(); else return factory.createLineString(coordinates);\n\t\t}\n\t\tif (geometry instanceof Point) {\n\t\t\tif (coordinates === null || coordinates.length === 0) return factory.createPoint(); else return factory.createPoint(coordinates[0]);\n\t\t}\n\t\treturn geometry;\n\t}\n\tgetClass() {\n\t\treturn CoordinateOperation;\n\t}\n\tget interfaces_() {\n\t\treturn [GeometryEditorOperation];\n\t}\n}\nCoordinateOperation.constructor_ = function () {};\nclass CoordinateSequenceOperation {\n\tconstructor() {\n\t\tCoordinateSequenceOperation.constructor_.apply(this, arguments);\n\t}\n\tedit(geometry, factory) {\n\t\tif (geometry instanceof LinearRing) {\n\t\t\treturn factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry));\n\t\t}\n\t\tif (geometry instanceof LineString) {\n\t\t\treturn factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry));\n\t\t}\n\t\tif (geometry instanceof Point) {\n\t\t\treturn factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry));\n\t\t}\n\t\treturn geometry;\n\t}\n\tgetClass() {\n\t\treturn CoordinateSequenceOperation;\n\t}\n\tget interfaces_() {\n\t\treturn [GeometryEditorOperation];\n\t}\n}\nCoordinateSequenceOperation.constructor_ = function () {};\nGeometryEditor.NoOpGeometryOperation = NoOpGeometryOperation;\nGeometryEditor.CoordinateOperation = CoordinateOperation;\nGeometryEditor.CoordinateSequenceOperation = CoordinateSequenceOperation;\nGeometryEditor.constructor_ = function () {\n\tthis._factory = null;\n\tthis._isUserDataCopied = false;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet factory = arguments[0];\n\t\tthis._factory = factory;\n\t}\n};\n","import hasInterface from '../../../../../hasInterface';\nimport Coordinate from '../Coordinate';\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport Double from '../../../../../java/lang/Double';\nimport CoordinateSequence from '../CoordinateSequence';\nimport Serializable from '../../../../../java/io/Serializable';\nimport StringBuilder from '../../../../../java/lang/StringBuilder';\nexport default class CoordinateArraySequence {\n\tconstructor() {\n\t\tCoordinateArraySequence.constructor_.apply(this, arguments);\n\t}\n\tsetOrdinate(index, ordinateIndex, value) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase CoordinateSequence.X:\n\t\t\t\tthis._coordinates[index].x = value;\n\t\t\t\tbreak;\n\t\t\tcase CoordinateSequence.Y:\n\t\t\t\tthis._coordinates[index].y = value;\n\t\t\t\tbreak;\n\t\t\tcase CoordinateSequence.Z:\n\t\t\t\tthis._coordinates[index].z = value;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"invalid ordinateIndex\");\n\t\t}\n\t}\n\tsize() {\n\t\treturn this._coordinates.length;\n\t}\n\tgetOrdinate(index, ordinateIndex) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase CoordinateSequence.X:\n\t\t\t\treturn this._coordinates[index].x;\n\t\t\tcase CoordinateSequence.Y:\n\t\t\t\treturn this._coordinates[index].y;\n\t\t\tcase CoordinateSequence.Z:\n\t\t\t\treturn this._coordinates[index].z;\n\t\t}\n\t\treturn Double.NaN;\n\t}\n\tgetCoordinate() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet i = arguments[0];\n\t\t\treturn this._coordinates[i];\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet index = arguments[0], coord = arguments[1];\n\t\t\tcoord.x = this._coordinates[index].x;\n\t\t\tcoord.y = this._coordinates[index].y;\n\t\t\tcoord.z = this._coordinates[index].z;\n\t\t}\n\t}\n\tgetCoordinateCopy(i) {\n\t\treturn new Coordinate(this._coordinates[i]);\n\t}\n\tgetDimension() {\n\t\treturn this._dimension;\n\t}\n\tgetX(index) {\n\t\treturn this._coordinates[index].x;\n\t}\n\texpandEnvelope(env) {\n\t\tfor (var i = 0; i < this._coordinates.length; i++) {\n\t\t\tenv.expandToInclude(this._coordinates[i]);\n\t\t}\n\t\treturn env;\n\t}\n\tcopy() {\n\t\tvar cloneCoordinates = new Array(this.size()).fill(null);\n\t\tfor (var i = 0; i < this._coordinates.length; i++) {\n\t\t\tcloneCoordinates[i] = this._coordinates[i].copy();\n\t\t}\n\t\treturn new CoordinateArraySequence(cloneCoordinates, this._dimension);\n\t}\n\ttoString() {\n\t\tif (this._coordinates.length > 0) {\n\t\t\tvar strBuilder = new StringBuilder(17 * this._coordinates.length);\n\t\t\tstrBuilder.append('(');\n\t\t\tstrBuilder.append(this._coordinates[0]);\n\t\t\tfor (var i = 1; i < this._coordinates.length; i++) {\n\t\t\t\tstrBuilder.append(\", \");\n\t\t\t\tstrBuilder.append(this._coordinates[i]);\n\t\t\t}\n\t\t\tstrBuilder.append(')');\n\t\t\treturn strBuilder.toString();\n\t\t} else {\n\t\t\treturn \"()\";\n\t\t}\n\t}\n\tgetY(index) {\n\t\treturn this._coordinates[index].y;\n\t}\n\ttoCoordinateArray() {\n\t\treturn this._coordinates;\n\t}\n\tgetClass() {\n\t\treturn CoordinateArraySequence;\n\t}\n\tget interfaces_() {\n\t\treturn [CoordinateSequence, Serializable];\n\t}\n}\nCoordinateArraySequence.constructor_ = function () {\n\tthis._dimension = 3;\n\tthis._coordinates = null;\n\tif (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tlet coordinates = arguments[0];\n\t\t\tCoordinateArraySequence.constructor_.call(this, coordinates, 3);\n\t\t} else if (Number.isInteger(arguments[0])) {\n\t\t\tlet size = arguments[0];\n\t\t\tthis._coordinates = new Array(size).fill(null);\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tthis._coordinates[i] = new Coordinate();\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\tlet coordSeq = arguments[0];\n\t\t\tif (coordSeq === null) {\n\t\t\t\tthis._coordinates = new Array(0).fill(null);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis._dimension = coordSeq.getDimension();\n\t\t\tthis._coordinates = new Array(coordSeq.size()).fill(null);\n\t\t\tfor (var i = 0; i < this._coordinates.length; i++) {\n\t\t\t\tthis._coordinates[i] = coordSeq.getCoordinateCopy(i);\n\t\t\t}\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tif (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n\t\t\tlet coordinates = arguments[0], dimension = arguments[1];\n\t\t\tthis._coordinates = coordinates;\n\t\t\tthis._dimension = dimension;\n\t\t\tif (coordinates === null) this._coordinates = new Array(0).fill(null);\n\t\t} else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n\t\t\tlet size = arguments[0], dimension = arguments[1];\n\t\t\tthis._coordinates = new Array(size).fill(null);\n\t\t\tthis._dimension = dimension;\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tthis._coordinates[i] = new Coordinate();\n\t\t\t}\n\t\t}\n\t}\n};\nCoordinateArraySequence.serialVersionUID = -915438501601840650;\n","import CoordinateSequenceFactory from '../CoordinateSequenceFactory';\nimport hasInterface from '../../../../../hasInterface';\nimport CoordinateArraySequence from './CoordinateArraySequence';\nimport CoordinateSequence from '../CoordinateSequence';\nimport Serializable from '../../../../../java/io/Serializable';\nexport default class CoordinateArraySequenceFactory {\n\tconstructor() {\n\t\tCoordinateArraySequenceFactory.constructor_.apply(this, arguments);\n\t}\n\tstatic instance() {\n\t\treturn CoordinateArraySequenceFactory.instanceObject;\n\t}\n\treadResolve() {\n\t\treturn CoordinateArraySequenceFactory.instance();\n\t}\n\tcreate() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new CoordinateArraySequence(coordinates);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordSeq = arguments[0];\n\t\t\t\treturn new CoordinateArraySequence(coordSeq);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet size = arguments[0], dimension = arguments[1];\n\t\t\tif (dimension > 3) dimension = 3;\n\t\t\tif (dimension < 2) return new CoordinateArraySequence(size);\n\t\t\treturn new CoordinateArraySequence(size, dimension);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn CoordinateArraySequenceFactory;\n\t}\n\tget interfaces_() {\n\t\treturn [CoordinateSequenceFactory, Serializable];\n\t}\n}\nCoordinateArraySequenceFactory.constructor_ = function () {};\nCoordinateArraySequenceFactory.serialVersionUID = -4099577099607551657;\nCoordinateArraySequenceFactory.instanceObject = new CoordinateArraySequenceFactory();\n","import ArrayList from './ArrayList'\nimport MapInterface from './Map'\nimport HashSet from './HashSet'\nimport MapPolyfill from '../../Map'\n\nlet MapImpl = typeof Map === 'undefined' || !Map.prototype.values ? MapPolyfill : Map\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html\n *\n * @extends {javascript.util.Map}\n * @constructor\n * @private\n */\nexport default function HashMap () {\n  /**\n   * @type {Object}\n   * @private\n  */\n  this.map_ = new MapImpl()\n}\nHashMap.prototype = new MapInterface()\n\n/**\n * @override\n */\nHashMap.prototype.get = function (key) {\n  return this.map_.get(key) || null\n}\n\n/**\n * @override\n */\nHashMap.prototype.put = function (key, value) {\n  this.map_.set(key, value)\n  return value\n}\n\n/**\n * @override\n */\nHashMap.prototype.values = function () {\n  const arrayList = new ArrayList()\n  const it = this.map_.values()\n  let o = it.next()\n  while (!o.done) {\n    arrayList.add(o.value)\n    o = it.next()\n  }\n  return arrayList\n}\n\n/**\n * @override\n */\nHashMap.prototype.entrySet = function () {\n  const hashSet = new HashSet()\n  this.map_.entries().forEach(entry => hashSet.add(entry))\n  return hashSet\n}\n\n/**\n * @override\n */\nHashMap.prototype.size = function () {\n  return this.map_.size()\n}\n","import HashMap from '../../../../java/util/HashMap';\nimport Coordinate from './Coordinate';\nimport Double from '../../../../java/lang/Double';\nimport Integer from '../../../../java/lang/Integer';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Serializable from '../../../../java/io/Serializable';\nexport default class PrecisionModel {\n\tconstructor() {\n\t\tPrecisionModel.constructor_.apply(this, arguments);\n\t}\n\tstatic mostPrecise(pm1, pm2) {\n\t\tif (pm1.compareTo(pm2) >= 0) return pm1;\n\t\treturn pm2;\n\t}\n\tequals(other) {\n\t\tif (!(other instanceof PrecisionModel)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar otherPrecisionModel = other;\n\t\treturn this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale;\n\t}\n\tcompareTo(o) {\n\t\tvar other = o;\n\t\tvar sigDigits = this.getMaximumSignificantDigits();\n\t\tvar otherSigDigits = other.getMaximumSignificantDigits();\n\t\treturn new Integer(sigDigits).compareTo(new Integer(otherSigDigits));\n\t}\n\tgetScale() {\n\t\treturn this._scale;\n\t}\n\tisFloating() {\n\t\treturn this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE;\n\t}\n\tgetType() {\n\t\treturn this._modelType;\n\t}\n\ttoString() {\n\t\tvar description = \"UNKNOWN\";\n\t\tif (this._modelType === PrecisionModel.FLOATING) {\n\t\t\tdescription = \"Floating\";\n\t\t} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n\t\t\tdescription = \"Floating-Single\";\n\t\t} else if (this._modelType === PrecisionModel.FIXED) {\n\t\t\tdescription = \"Fixed (Scale=\" + this.getScale() + \")\";\n\t\t}\n\t\treturn description;\n\t}\n\tmakePrecise() {\n\t\tif (typeof arguments[0] === \"number\") {\n\t\t\tlet val = arguments[0];\n\t\t\tif (Double.isNaN(val)) return val;\n\t\t\tif (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n\t\t\t\tvar floatSingleVal = val;\n\t\t\t\treturn floatSingleVal;\n\t\t\t}\n\t\t\tif (this._modelType === PrecisionModel.FIXED) {\n\t\t\t\treturn Math.round(val * this._scale) / this._scale;\n\t\t\t}\n\t\t\treturn val;\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet coord = arguments[0];\n\t\t\tif (this._modelType === PrecisionModel.FLOATING) return null;\n\t\t\tcoord.x = this.makePrecise(coord.x);\n\t\t\tcoord.y = this.makePrecise(coord.y);\n\t\t}\n\t}\n\tgetMaximumSignificantDigits() {\n\t\tvar maxSigDigits = 16;\n\t\tif (this._modelType === PrecisionModel.FLOATING) {\n\t\t\tmaxSigDigits = 16;\n\t\t} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n\t\t\tmaxSigDigits = 6;\n\t\t} else if (this._modelType === PrecisionModel.FIXED) {\n\t\t\tmaxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));\n\t\t}\n\t\treturn maxSigDigits;\n\t}\n\tsetScale(scale) {\n\t\tthis._scale = Math.abs(scale);\n\t}\n\tgetClass() {\n\t\treturn PrecisionModel;\n\t}\n\tget interfaces_() {\n\t\treturn [Serializable, Comparable];\n\t}\n}\nclass Type {\n\tconstructor() {\n\t\tType.constructor_.apply(this, arguments);\n\t}\n\treadResolve() {\n\t\treturn Type.nameToTypeMap.get(this._name);\n\t}\n\ttoString() {\n\t\treturn this._name;\n\t}\n\tgetClass() {\n\t\treturn Type;\n\t}\n\tget interfaces_() {\n\t\treturn [Serializable];\n\t}\n}\nType.constructor_ = function () {\n\tthis._name = null;\n\tlet name = arguments[0];\n\tthis._name = name;\n\tType.nameToTypeMap.put(name, this);\n};\nType.serialVersionUID = -5528602631731589822;\nType.nameToTypeMap = new HashMap();\nPrecisionModel.Type = Type;\nPrecisionModel.constructor_ = function () {\n\tthis._modelType = null;\n\tthis._scale = null;\n\tif (arguments.length === 0) {\n\t\tthis._modelType = PrecisionModel.FLOATING;\n\t} else if (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Type) {\n\t\t\tlet modelType = arguments[0];\n\t\t\tthis._modelType = modelType;\n\t\t\tif (modelType === PrecisionModel.FIXED) {\n\t\t\t\tthis.setScale(1.0);\n\t\t\t}\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet scale = arguments[0];\n\t\t\tthis._modelType = PrecisionModel.FIXED;\n\t\t\tthis.setScale(scale);\n\t\t} else if (arguments[0] instanceof PrecisionModel) {\n\t\t\tlet pm = arguments[0];\n\t\t\tthis._modelType = pm._modelType;\n\t\t\tthis._scale = pm._scale;\n\t\t}\n\t}\n};\nPrecisionModel.serialVersionUID = 7777263578777803835;\nPrecisionModel.FIXED = new Type(\"FIXED\");\nPrecisionModel.FLOATING = new Type(\"FLOATING\");\nPrecisionModel.FLOATING_SINGLE = new Type(\"FLOATING SINGLE\");\nPrecisionModel.maximumPreciseValue = 9007199254740992.0;\n","import CoordinateSequenceFactory from './CoordinateSequenceFactory';\nimport LineString from './LineString';\nimport Geometry from './Geometry';\nimport hasInterface from '../../../../hasInterface';\nimport Coordinate from './Coordinate';\nimport Point from './Point';\nimport Polygon from './Polygon';\nimport MultiPoint from './MultiPoint';\nimport GeometryEditor from './util/GeometryEditor';\nimport LinearRing from './LinearRing';\nimport CoordinateArraySequenceFactory from './impl/CoordinateArraySequenceFactory';\nimport MultiPolygon from './MultiPolygon';\nimport CoordinateSequences from './CoordinateSequences';\nimport CoordinateSequence from './CoordinateSequence';\nimport GeometryCollection from './GeometryCollection';\nimport PrecisionModel from './PrecisionModel';\nimport Serializable from '../../../../java/io/Serializable';\nimport Assert from '../util/Assert';\nimport MultiLineString from './MultiLineString';\nexport default class GeometryFactory {\n\tconstructor() {\n\t\tGeometryFactory.constructor_.apply(this, arguments);\n\t}\n\tstatic toMultiPolygonArray(multiPolygons) {\n\t\tvar multiPolygonArray = new Array(multiPolygons.size()).fill(null);\n\t\treturn multiPolygons.toArray(multiPolygonArray);\n\t}\n\tstatic toGeometryArray(geometries) {\n\t\tif (geometries === null) return null;\n\t\tvar geometryArray = new Array(geometries.size()).fill(null);\n\t\treturn geometries.toArray(geometryArray);\n\t}\n\tstatic getDefaultCoordinateSequenceFactory() {\n\t\treturn CoordinateArraySequenceFactory.instance();\n\t}\n\tstatic toMultiLineStringArray(multiLineStrings) {\n\t\tvar multiLineStringArray = new Array(multiLineStrings.size()).fill(null);\n\t\treturn multiLineStrings.toArray(multiLineStringArray);\n\t}\n\tstatic toLineStringArray(lineStrings) {\n\t\tvar lineStringArray = new Array(lineStrings.size()).fill(null);\n\t\treturn lineStrings.toArray(lineStringArray);\n\t}\n\tstatic toMultiPointArray(multiPoints) {\n\t\tvar multiPointArray = new Array(multiPoints.size()).fill(null);\n\t\treturn multiPoints.toArray(multiPointArray);\n\t}\n\tstatic toLinearRingArray(linearRings) {\n\t\tvar linearRingArray = new Array(linearRings.size()).fill(null);\n\t\treturn linearRings.toArray(linearRingArray);\n\t}\n\tstatic toPointArray(points) {\n\t\tvar pointArray = new Array(points.size()).fill(null);\n\t\treturn points.toArray(pointArray);\n\t}\n\tstatic toPolygonArray(polygons) {\n\t\tvar polygonArray = new Array(polygons.size()).fill(null);\n\t\treturn polygons.toArray(polygonArray);\n\t}\n\tstatic createPointFromInternalCoord(coord, exemplar) {\n\t\texemplar.getPrecisionModel().makePrecise(coord);\n\t\treturn exemplar.getFactory().createPoint(coord);\n\t}\n\ttoGeometry(envelope) {\n\t\tif (envelope.isNull()) {\n\t\t\treturn this.createPoint();\n\t\t}\n\t\tif (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {\n\t\t\treturn this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()));\n\t\t}\n\t\tif (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {\n\t\t\treturn this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())]);\n\t\t}\n\t\treturn this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null);\n\t}\n\tcreateLineString() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createLineString(this.getCoordinateSequenceFactory().create([]));\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn this.createLineString(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new LineString(coordinates, this);\n\t\t\t}\n\t\t}\n\t}\n\tcreateMultiLineString() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new MultiLineString(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet lineStrings = arguments[0];\n\t\t\treturn new MultiLineString(lineStrings, this);\n\t\t}\n\t}\n\tbuildGeometry(geomList) {\n\t\tvar geomClass = null;\n\t\tvar isHeterogeneous = false;\n\t\tvar hasGeometryCollection = false;\n\t\tfor (var i = geomList.iterator(); i.hasNext(); ) {\n\t\t\tvar geom = i.next();\n\t\t\tvar partClass = geom.getClass();\n\t\t\tif (geomClass === null) {\n\t\t\t\tgeomClass = partClass;\n\t\t\t}\n\t\t\tif (partClass !== geomClass) {\n\t\t\t\tisHeterogeneous = true;\n\t\t\t}\n\t\t\tif (geom instanceof GeometryCollection) hasGeometryCollection = true;\n\t\t}\n\t\tif (geomClass === null) {\n\t\t\treturn this.createGeometryCollection();\n\t\t}\n\t\tif (isHeterogeneous || hasGeometryCollection) {\n\t\t\treturn this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));\n\t\t}\n\t\tvar geom0 = geomList.iterator().next();\n\t\tvar isCollection = geomList.size() > 1;\n\t\tif (isCollection) {\n\t\t\tif (geom0 instanceof Polygon) {\n\t\t\t\treturn this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));\n\t\t\t} else if (geom0 instanceof LineString) {\n\t\t\t\treturn this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));\n\t\t\t} else if (geom0 instanceof Point) {\n\t\t\t\treturn this.createMultiPoint(GeometryFactory.toPointArray(geomList));\n\t\t\t}\n\t\t\tAssert.shouldNeverReachHere(\"Unhandled class: \" + geom0.getClass().getName());\n\t\t}\n\t\treturn geom0;\n\t}\n\tcreateMultiPointFromCoords(coordinates) {\n\t\treturn this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t}\n\tcreatePoint() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createPoint(this.getCoordinateSequenceFactory().create([]));\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet coordinate = arguments[0];\n\t\t\t\treturn this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new Point(coordinates, this);\n\t\t\t}\n\t\t}\n\t}\n\tgetCoordinateSequenceFactory() {\n\t\treturn this._coordinateSequenceFactory;\n\t}\n\tcreatePolygon() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createPolygon(null, null);\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet shell = arguments[0];\n\t\t\t\treturn this.createPolygon(this.createLinearRing(shell));\n\t\t\t} else if (arguments[0] instanceof Array) {\n\t\t\t\tlet shell = arguments[0];\n\t\t\t\treturn this.createPolygon(this.createLinearRing(shell));\n\t\t\t} else if (arguments[0] instanceof LinearRing) {\n\t\t\t\tlet shell = arguments[0];\n\t\t\t\treturn this.createPolygon(shell, null);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet shell = arguments[0], holes = arguments[1];\n\t\t\treturn new Polygon(shell, holes, this);\n\t\t}\n\t}\n\tgetSRID() {\n\t\treturn this._SRID;\n\t}\n\tcreateGeometryCollection() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new GeometryCollection(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet geometries = arguments[0];\n\t\t\treturn new GeometryCollection(geometries, this);\n\t\t}\n\t}\n\tcreateGeometry(g) {\n\t\tvar editor = new GeometryEditor(this);\n\t\treturn editor.edit(g, new CloneOp(this._coordinateSequenceFactory));\n\t}\n\tgetPrecisionModel() {\n\t\treturn this._precisionModel;\n\t}\n\tcreateLinearRing() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createLinearRing(this.getCoordinateSequenceFactory().create([]));\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new LinearRing(coordinates, this);\n\t\t\t}\n\t\t}\n\t}\n\tcreateMultiPolygon() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new MultiPolygon(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet polygons = arguments[0];\n\t\t\treturn new MultiPolygon(polygons, this);\n\t\t}\n\t}\n\tcreateMultiPoint() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new MultiPoint(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet point = arguments[0];\n\t\t\t\treturn new MultiPoint(point, this);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\tif (coordinates === null) {\n\t\t\t\t\treturn this.createMultiPoint(new Array(0).fill(null));\n\t\t\t\t}\n\t\t\t\tvar points = new Array(coordinates.size()).fill(null);\n\t\t\t\tfor (var i = 0; i < coordinates.size(); i++) {\n\t\t\t\t\tvar ptSeq = this.getCoordinateSequenceFactory().create(1, coordinates.getDimension());\n\t\t\t\t\tCoordinateSequences.copy(coordinates, i, ptSeq, 0, 1);\n\t\t\t\t\tpoints[i] = this.createPoint(ptSeq);\n\t\t\t\t}\n\t\t\t\treturn this.createMultiPoint(points);\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn GeometryFactory;\n\t}\n\tget interfaces_() {\n\t\treturn [Serializable];\n\t}\n}\nclass CloneOp extends GeometryEditor.CoordinateSequenceOperation {\n\tconstructor() {\n\t\tsuper();\n\t\tCloneOp.constructor_.apply(this, arguments);\n\t}\n\tedit() {\n\t\tif (arguments.length === 2 && (arguments[1] instanceof Geometry && hasInterface(arguments[0], CoordinateSequence))) {\n\t\t\tlet coordSeq = arguments[0], geometry = arguments[1];\n\t\t\treturn this.coordinateSequenceFactory.create(coordSeq);\n\t\t} else return super.edit.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn CloneOp;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nCloneOp.constructor_ = function () {\n\tthis.coordinateSequenceFactory = null;\n\tlet coordinateSequenceFactory = arguments[0];\n\tthis.coordinateSequenceFactory = coordinateSequenceFactory;\n};\nGeometryFactory.CloneOp = CloneOp;\nGeometryFactory.constructor_ = function () {\n\tthis._precisionModel = null;\n\tthis._coordinateSequenceFactory = null;\n\tthis._SRID = null;\n\tif (arguments.length === 0) {\n\t\tGeometryFactory.constructor_.call(this, new PrecisionModel(), 0);\n\t} else if (arguments.length === 1) {\n\t\tif (hasInterface(arguments[0], CoordinateSequenceFactory)) {\n\t\t\tlet coordinateSequenceFactory = arguments[0];\n\t\t\tGeometryFactory.constructor_.call(this, new PrecisionModel(), 0, coordinateSequenceFactory);\n\t\t} else if (arguments[0] instanceof PrecisionModel) {\n\t\t\tlet precisionModel = arguments[0];\n\t\t\tGeometryFactory.constructor_.call(this, precisionModel, 0, GeometryFactory.getDefaultCoordinateSequenceFactory());\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet precisionModel = arguments[0], SRID = arguments[1];\n\t\tGeometryFactory.constructor_.call(this, precisionModel, SRID, GeometryFactory.getDefaultCoordinateSequenceFactory());\n\t} else if (arguments.length === 3) {\n\t\tlet precisionModel = arguments[0], SRID = arguments[1], coordinateSequenceFactory = arguments[2];\n\t\tthis._precisionModel = precisionModel;\n\t\tthis._coordinateSequenceFactory = coordinateSequenceFactory;\n\t\tthis._SRID = SRID;\n\t}\n};\nGeometryFactory.serialVersionUID = -6820524753094095635;\n","import Coordinate from '../geom/Coordinate'\nimport GeometryFactory from '../geom/GeometryFactory'\n\nconst geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon']\n\n/**\n * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */\n\n/**\n * Create a new parser for GeoJSON\n *\n * @param {GeometryFactory} geometryFactory\n * @return An instance of GeoJsonParser.\n * @constructor\n * @private\n */\nexport default class GeoJSONParser {\n  constructor(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory()\n  }\n\n  /**\n   * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries\n   *\n   * @param {}\n   *          A GeoJSON object.\n   * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.\n   * @private\n   */\n  read (json) {\n    let obj\n    if (typeof json === 'string')\n      obj = JSON.parse(json)\n    else\n      obj = json\n\n    const type = obj.type\n\n    if (!parse[type])\n      throw new Error('Unknown GeoJSON type: ' + obj.type)\n\n    if (geometryTypes.indexOf(type) !== -1)\n      return parse[type].call(this, obj.coordinates)\n    else if (type === 'GeometryCollection')\n      return parse[type].call(this, obj.geometries)\n\n    // feature or feature collection\n    return parse[type].call(this, obj)\n  }\n\n  /**\n   * Serialize a Geometry object into GeoJSON\n   *\n   * @param {Geometry}\n   *          geometry A Geometry or array of Geometries.\n   * @return {Object} A GeoJSON object represting the input Geometry/Geometries.\n   * @private\n   */\n  write (geometry) {\n    const type = geometry.getGeometryType()\n\n    if (!extract[type])\n      throw new Error('Geometry is not supported')\n\n    return extract[type].call(this, geometry)\n  }\n} \n\nconst parse = {\n  /**\n   * Parse a GeoJSON Feature object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.\n   */\n  Feature: function (obj) {\n    const feature = {}\n\n    for (let key in obj)\n      feature[key] = obj[key]\n\n    if (obj.geometry) {\n      const type = obj.geometry.type\n      if (!parse[type])\n        throw new Error('Unknown GeoJSON type: ' + obj.type)\n      feature.geometry = this.read(obj.geometry)\n    }\n\n    if (obj.bbox)\n      feature.bbox = parse.bbox.call(this, obj.bbox)\n\n    return feature\n  },\n\n  /**\n   * Parse a GeoJSON FeatureCollection object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.\n   */\n  FeatureCollection: function (obj) {\n    const featureCollection = {}\n\n    if (obj.features) {\n      featureCollection.features = []\n\n      for (let i = 0; i < obj.features.length; ++i)\n        featureCollection.features.push(this.read(obj.features[i]))\n    }\n\n    if (obj.bbox)\n      featureCollection.bbox = this.parse.bbox.call(this, obj.bbox)\n\n    return featureCollection\n  },\n\n  /**\n   * Convert the ordinates in an array to an array of Coordinates\n   *\n   * @param {Array}\n   *          array Array with {Number}s.\n   *\n   * @return {Array} Array with Coordinates.\n   */\n  coordinates: function (array) {\n    const coordinates = []\n    for (let i = 0; i < array.length; ++i) {\n      const sub = array[i]\n      coordinates.push(new Coordinate(sub[0], sub[1]))\n    }\n    return coordinates\n  },\n\n  /**\n   * Convert the bbox to a LinearRing\n   *\n   * @param {Array}\n   *          array Array with [xMin, yMin, xMax, yMax].\n   *\n   * @return {Array} Array with Coordinates.\n   */\n  bbox: function (array) {\n    return this.geometryFactory.createLinearRing([\n      new Coordinate(array[0], array[1]),\n      new Coordinate(array[2], array[1]),\n      new Coordinate(array[2], array[3]),\n      new Coordinate(array[0], array[3]),\n      new Coordinate(array[0], array[1])\n    ])\n  },\n\n  /**\n   * Convert an Array with ordinates to a Point\n   *\n   * @param {Array}\n   *          array Array with ordinates.\n   *\n   * @return {Point} Point.\n   */\n  Point: function (array) {\n    const coordinate = new Coordinate(array[0], array[1])\n    return this.geometryFactory.createPoint(coordinate)\n  },\n\n  /**\n   * Convert an Array with coordinates to a MultiPoint\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiPoint} MultiPoint.\n   */\n  MultiPoint: function (array) {\n    const points = []\n    for (let i = 0; i < array.length; ++i)\n      points.push(parse.Point.call(this, array[i]))\n    return this.geometryFactory.createMultiPoint(points)\n  },\n\n  /**\n   * Convert an Array with coordinates to a LineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {LineString} LineString.\n   */\n  LineString: function (array) {\n    const coordinates = parse.coordinates.call(this, array)\n    return this.geometryFactory.createLineString(coordinates)\n  },\n\n  /**\n   * Convert an Array with coordinates to a MultiLineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiLineString} MultiLineString.\n   */\n  MultiLineString: function (array) {\n    const lineStrings = []\n    for (let i = 0; i < array.length; ++i)\n      lineStrings.push(parse.LineString.call(this, array[i]))\n    return this.geometryFactory.createMultiLineString(lineStrings)\n  },\n\n  /**\n   * Convert an Array to a Polygon\n   *\n   * @param {Array}\n   *          array Array with shell and holes.\n   *\n   * @return {Polygon} Polygon.\n   */\n  Polygon: function (array) {\n    const shellCoordinates = parse.coordinates.call(this, array[0])\n    const shell = this.geometryFactory.createLinearRing(shellCoordinates)\n    const holes = []\n    for (let i = 1; i < array.length; ++i) {\n      var hole = array[i]\n      var coordinates = parse.coordinates.call(this, hole)\n      var linearRing = this.geometryFactory.createLinearRing(coordinates)\n      holes.push(linearRing)\n    }\n    return this.geometryFactory.createPolygon(shell, holes)\n  },\n\n  /**\n   * Convert an Array to a MultiPolygon\n   *\n   * @param {Array}\n   *          array Array of arrays with shell and rings.\n   *\n   * @return {MultiPolygon} MultiPolygon.\n   */\n  MultiPolygon: function (array) {\n    const polygons = []\n    for (let i = 0; i < array.length; ++i) {\n      const polygon = array[i]\n      polygons.push(parse.Polygon.call(this, polygon))\n    }\n    return this.geometryFactory.createMultiPolygon(polygons)\n  },\n\n  /**\n   * Convert an Array to a GeometryCollection\n   *\n   * @param {Array}\n   *          array Array of GeoJSON geometries.\n   *\n   * @return {GeometryCollection} GeometryCollection.\n   */\n  GeometryCollection: function (array) {\n    const geometries = []\n    for (let i = 0; i < array.length; ++i) {\n      const geometry = array[i]\n      geometries.push(this.read(geometry))\n    }\n    return this.geometryFactory.createGeometryCollection(geometries)\n  }\n}\n\nconst extract = {\n  /**\n   * Convert a Coordinate to an Array\n   *\n   * @param {Coordinate}\n   *          coordinate Coordinate to convert.\n   *\n   * @return {Array} Array of ordinates.\n   */\n  coordinate: function (coordinate) {\n    return [coordinate.x, coordinate.y]\n  },\n\n  /**\n   * Convert a Point to a GeoJSON object\n   *\n   * @param {Point}\n   *          point Point to convert.\n   *\n   * @return {Array} Array of 2 ordinates (paired to a coordinate).\n   */\n  Point: function (point) {\n    const array = extract.coordinate.call(this, point.getCoordinate())\n    return {\n      type: 'Point',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiPoint to a GeoJSON object\n   *\n   * @param {MultiPoint}\n   *          multipoint MultiPoint to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */\n  MultiPoint: function (multipoint) {\n    const array = []\n    for (let i = 0; i < multipoint._geometries.length; ++i) {\n      const point = multipoint._geometries[i]\n      const geoJson = extract.Point.call(this, point)\n      array.push(geoJson.coordinates)\n    }\n    return {\n      type: 'MultiPoint',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a LineString to a GeoJSON object\n   *\n   * @param {LineString}\n   *          linestring LineString to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */\n  LineString: function (linestring) {\n    const array = []\n    const coordinates = linestring.getCoordinates()\n    for (let i = 0; i < coordinates.length; ++i) {\n      const coordinate = coordinates[i]\n      array.push(extract.coordinate.call(this, coordinate))\n    }\n    return {\n      type: 'LineString',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiLineString to a GeoJSON object\n   *\n   * @param {MultiLineString}\n   *          multilinestring MultiLineString to convert.\n   *\n   * @return {Array} Array of Array of coordinates.\n   */\n  MultiLineString: function (multilinestring) {\n    const array = []\n    for (let i = 0; i < multilinestring._geometries.length; ++i) {\n      const linestring = multilinestring._geometries[i]\n      const geoJson = extract.LineString.call(this, linestring)\n      array.push(geoJson.coordinates)\n    }\n    return {\n      type: 'MultiLineString',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a Polygon to a GeoJSON object\n   *\n   * @param {Polygon}\n   *          polygon Polygon to convert.\n   *\n   * @return {Array} Array with shell, holes.\n   */\n  Polygon: function (polygon) {\n    const array = []\n    const shellGeoJson = extract.LineString.call(this, polygon._shell)\n    array.push(shellGeoJson.coordinates)\n    for (let i = 0; i < polygon._holes.length; ++i) {\n      const hole = polygon._holes[i]\n      const holeGeoJson = extract.LineString.call(this, hole)\n      array.push(holeGeoJson.coordinates)\n    }\n    return {\n      type: 'Polygon',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiPolygon to a GeoJSON object\n   *\n   * @param {MultiPolygon}\n   *          multipolygon MultiPolygon to convert.\n   *\n   * @return {Array} Array of polygons.\n   */\n  MultiPolygon: function (multipolygon) {\n    const array = []\n    for (let i = 0; i < multipolygon._geometries.length; ++i) {\n      const polygon = multipolygon._geometries[i]\n      const geoJson = extract.Polygon.call(this, polygon)\n      array.push(geoJson.coordinates)\n    }\n    return {\n      type: 'MultiPolygon',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a GeometryCollection to a GeoJSON object\n   *\n   * @param {GeometryCollection}\n   *          collection GeometryCollection to convert.\n   *\n   * @return {Array} Array of geometries.\n   */\n  GeometryCollection: function (collection) {\n    const array = []\n    for (let i = 0; i < collection._geometries.length; ++i) {\n      const geometry = collection._geometries[i]\n      const type = geometry.getGeometryType()\n      array.push(extract[type].call(this, geometry))\n    }\n    return {\n      type: 'GeometryCollection',\n      geometries: array\n    }\n  }\n}\n","/**\n * @module org/locationtech/jts/io/GeoJSONReader\n */\n\nimport GeometryFactory from '../geom/GeometryFactory'\nimport GeoJSONParser from './GeoJSONParser'\n\n/**\n * Converts a geometry in GeoJSON to a {@link Geometry}.\n */\nexport default class GeoJSONReader {\n  /**\n   * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,\n   * to allow it to create <code>Geometry</code> objects of the appropriate\n   * implementation. In particular, the <code>GeometryFactory</code> determines\n   * the <code>PrecisionModel</code> and <code>SRID</code> that is used.\n   *\n   * @param {GeometryFactory} geometryFactory\n   */\n  constructor(geometryFactory) {\n    this.parser = new GeoJSONParser(geometryFactory || new GeometryFactory())\n  }\n\n  /**\n   * Reads a GeoJSON representation of a {@link Geometry}\n   *\n   * Will also parse GeoJSON Features/FeatureCollections as custom objects.\n   *\n   * @param {Object|String} geoJson a GeoJSON Object or String.\n   * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>\n   * @memberof module:org/locationtech/jts/io/GeoJSONReader#\n   */\n  read (geoJson) {\n    var geometry = this.parser.read(geoJson)\n    return geometry\n  }\n}\n","import Coordinate from '../geom/Coordinate'\nimport GeometryFactory from '../geom/GeometryFactory'\n\nconst regExes = {\n  'typeStr': /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n  'emptyTypeStr': /^\\s*(\\w+)\\s*EMPTY\\s*$/,\n  'spaces': /\\s+/,\n  'parenComma': /\\)\\s*,\\s*\\(/,\n  'doubleParenComma': /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/, // can't use {2} here\n  'trimParens': /^\\s*\\(?(.*?)\\)?\\s*$/\n}\n\n/**\n * Class for reading and writing Well-Known Text.\n *\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */\n\nexport default class WKTParser {\n  /** Create a new parser for WKT\n   *\n   * @param {GeometryFactory} geometryFactory\n   * @return An instance of WKTParser.\n   * @private\n   */\n  constructor(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory()\n    this.precisionModel = this.geometryFactory.getPrecisionModel()\n  }\n\n  /**\n   * Deserialize a WKT string and return a geometry. Supports WKT for POINT,\n   * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,\n   * and GEOMETRYCOLLECTION.\n   *\n   * @param {String} wkt A WKT string.\n   * @return {Geometry} A geometry instance.\n   * @private\n   */\n  read (wkt) {\n    var geometry, type, str\n    wkt = wkt.replace(/[\\n\\r]/g, ' ')\n    var matches = regExes.typeStr.exec(wkt)\n    if (wkt.search('EMPTY') !== -1) {\n      matches = regExes.emptyTypeStr.exec(wkt)\n      matches[2] = undefined\n    }\n    if (matches) {\n      type = matches[1].toLowerCase()\n      str = matches[2]\n      if (parse[type]) {\n        geometry = parse[type].call(this, str)\n      }\n    }\n\n    if (geometry === undefined) throw new Error('Could not parse WKT ' + wkt)\n\n    return geometry\n  }\n\n  /**\n   * Serialize a geometry into a WKT string.\n   *\n   * @param {Geometry} geometry A feature or array of features.\n   * @return {String} The WKT string representation of the input geometries.\n   * @private\n   */\n  write (geometry) {\n    return this.extractGeometry(geometry)\n  }\n\n  /**\n   * Entry point to construct the WKT for a single Geometry object.\n   *\n   * @param {Geometry} geometry\n   * @return {String} A WKT string of representing the geometry.\n   * @private\n   */\n  extractGeometry (geometry) {\n    var type = geometry.getGeometryType().toLowerCase()\n    if (!extract[type]) {\n      return null\n    }\n    var wktType = type.toUpperCase()\n    var data\n    if (geometry.isEmpty()) {\n      data = wktType + ' EMPTY'\n    } else {\n      data = wktType + '(' + extract[type].call(this, geometry) + ')'\n    }\n    return data\n  }\n}\n\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual data extraction.\n * @private\n */\nconst extract = {\n  coordinate (coordinate) {\n    this.precisionModel.makePrecise(coordinate)\n    return coordinate.x + ' ' + coordinate.y\n  },\n\n  /**\n   * Return a space delimited string of point coordinates.\n   *\n   * @param {Point}\n   *          point\n   * @return {String} A string of coordinates representing the point.\n   */\n  point (point) {\n    return extract.coordinate.call(this, point._coordinates._coordinates[0])\n  },\n\n  /**\n   * Return a comma delimited string of point coordinates from a multipoint.\n   *\n   * @param {MultiPoint}\n   *          multipoint\n   * @return {String} A string of point coordinate strings representing the\n   *         multipoint.\n   */\n  multipoint (multipoint) {\n    var array = []\n    for (let i = 0, len = multipoint._geometries.length; i < len; ++i) {\n      array.push('(' + extract.point.call(this, multipoint._geometries[i]) + ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of point coordinates from a line.\n   *\n   * @param {LineString} linestring\n   * @return {String} A string of point coordinate strings representing the linestring.\n   */\n  linestring (linestring) {\n    var array = []\n    for (let i = 0, len = linestring._points._coordinates.length; i < len; ++i) {\n      array.push(extract.coordinate.call(this, linestring._points._coordinates[i]))\n    }\n    return array.join(',')\n  },\n\n  linearring (linearring) {\n    var array = []\n    for (let i = 0, len = linearring._points._coordinates.length; i < len; ++i) {\n      array.push(extract.coordinate.call(this, linearring._points._coordinates[i]))\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of linestring strings from a\n   * multilinestring.\n   *\n   * @param {MultiLineString} multilinestring\n   * @return {String} A string of of linestring strings representing the multilinestring.\n   */\n  multilinestring (multilinestring) {\n    var array = []\n    for (let i = 0, len = multilinestring._geometries.length; i < len; ++i) {\n      array.push('(' +\n        extract.linestring.call(this, multilinestring._geometries[i]) +\n        ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of linear ring arrays from a polygon.\n   *\n   * @param {Polygon} polygon\n   * @return {String} An array of linear ring arrays representing the polygon.\n   */\n  polygon (polygon) {\n    var array = []\n    array.push('(' + extract.linestring.call(this, polygon._shell) + ')')\n    for (let i = 0, len = polygon._holes.length; i < len; ++i) {\n      array.push('(' + extract.linestring.call(this, polygon._holes[i]) + ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return an array of polygon arrays from a multipolygon.\n   *\n   * @param {MultiPolygon} multipolygon\n   * @return {String} An array of polygon arrays representing the multipolygon.\n   */\n  multipolygon (multipolygon) {\n    var array = []\n    for (let i = 0, len = multipolygon._geometries.length; i < len; ++i) {\n      array.push('(' + extract.polygon.call(this, multipolygon._geometries[i]) + ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an\n   * geometrycollection.\n   *\n   * @param {GeometryCollection} collection\n   * @return {String} internal WKT representation of the collection.\n   */\n  geometrycollection (collection) {\n    var array = []\n    for (let i = 0, len = collection._geometries.length; i < len; ++i) {\n      array.push(this.extractGeometry(collection._geometries[i]))\n    }\n    return array.join(',')\n  }\n}\n\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual parsing.\n * @private\n */\nconst parse = {\n  \n  coord (str) {\n    var coords = str.trim().split(regExes.spaces)\n    var coord = new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1]))\n    this.precisionModel.makePrecise(coord)\n    return coord\n  },\n\n  /**\n   * Return point geometry given a point WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the point.\n   * @return {Point} A point geometry.\n   * @private\n   */\n  point (str) {\n    if (str === undefined)\n      return this.geometryFactory.createPoint()\n    return this.geometryFactory.createPoint(parse.coord.call(this, str))\n  },\n\n  /**\n   * Return a multipoint geometry given a multipoint WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipoint.\n   * @return {Point} A multipoint feature.\n   * @private\n   */\n  multipoint (str) {\n    if (str === undefined)\n      return this.geometryFactory.createMultiPoint()\n    var point\n    var points = str.trim().split(',')\n    var components = []\n    for (let i = 0, len = points.length; i < len; ++i) {\n      point = points[i].replace(regExes.trimParens, '$1')\n      components.push(parse.point.call(this, point))\n    }\n    return this.geometryFactory.createMultiPoint(components)\n  },\n\n  /**\n   * Return a linestring geometry given a linestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linestring.\n   * @return {LineString} A linestring geometry.\n   * @private\n   */\n  linestring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createLineString()\n    }\n\n    var points = str.trim().split(',')\n    var components = []\n    var coords\n    for (let i = 0, len = points.length; i < len; ++i) {\n      components.push(parse.coord.call(this, points[i]))\n    }\n    return this.geometryFactory.createLineString(components)\n  },\n\n  /**\n   * Return a linearring geometry given a linearring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linearring.\n   * @return {LinearRing} A linearring geometry.\n   * @private\n   */\n  linearring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createLinearRing()\n    }\n\n    var points = str.trim().split(',')\n    var components = []\n    var coords\n    for (let i = 0, len = points.length; i < len; ++i) {\n      components.push(parse.coord.call(this, points[i]))\n    }\n    return this.geometryFactory.createLinearRing(components)\n  },\n\n  /**\n   * Return a multilinestring geometry given a multilinestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multilinestring.\n   * @return {MultiLineString} A multilinestring geometry.\n   * @private\n   */\n  multilinestring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createMultiLineString()\n    }\n\n    var line\n    var lines = str.trim().split(regExes.parenComma)\n    var components = []\n    for (let i = 0, len = lines.length; i < len; ++i) {\n      line = lines[i].replace(regExes.trimParens, '$1')\n      components.push(parse.linestring.call(this, line))\n    }\n    return this.geometryFactory.createMultiLineString(components)\n  },\n\n  /**\n   * Return a polygon geometry given a polygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the polygon.\n   * @return {Polygon} A polygon geometry.\n   * @private\n   */\n  polygon (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createPolygon()\n    }\n\n    var ring, linestring, linearring\n    var rings = str.trim().split(regExes.parenComma)\n    var shell\n    var holes = []\n    for (let i = 0, len = rings.length; i < len; ++i) {\n      ring = rings[i].replace(regExes.trimParens, '$1')\n      linestring = parse.linestring.call(this, ring)\n      linearring = this.geometryFactory.createLinearRing(linestring._points)\n      if (i === 0) {\n        shell = linearring\n      } else {\n        holes.push(linearring)\n      }\n    }\n    return this.geometryFactory.createPolygon(shell, holes)\n  },\n\n  /**\n   * Return a multipolygon geometry given a multipolygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipolygon.\n   * @return {MultiPolygon} A multipolygon geometry.\n   * @private\n   */\n  multipolygon (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createMultiPolygon()\n    }\n\n    var polygon\n    var polygons = str.trim().split(regExes.doubleParenComma)\n    var components = []\n    for (let i = 0, len = polygons.length; i < len; ++i) {\n      polygon = polygons[i].replace(regExes.trimParens, '$1')\n      components.push(parse.polygon.call(this, polygon))\n    }\n    return this.geometryFactory.createMultiPolygon(components)\n  },\n\n  /**\n   * Return a geometrycollection given a geometrycollection WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the geometrycollection.\n   * @return {GeometryCollection}\n   * @private\n   */\n  geometrycollection (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createGeometryCollection()\n    }\n\n    // separate components of the collection with |\n    str = str.replace(/,\\s*([A-Za-z])/g, '|$1')\n    var wktArray = str.trim().split('|')\n    var components = []\n    for (let i = 0, len = wktArray.length; i < len; ++i) {\n      components.push(this.read(wktArray[i]))\n    }\n    return this.geometryFactory.createGeometryCollection(components)\n  }\n}\n","/**\n * @module org/locationtech/jts/io/WKTWriter\n */\n\nimport WKTParser from './WKTParser'\n\n/**\n * Writes the Well-Known Text representation of a {@link Geometry}. The\n * Well-Known Text format is defined in the <A\n * HREF=\"http://www.opengis.org/techno/specs.htm\"> OGC Simple Features\n * Specification for SQL</A>.\n * <p>\n * The <code>WKTWriter</code> outputs coordinates rounded to the precision\n * model. Only the maximum number of decimal places necessary to represent the\n * ordinates to the required precision will be output.\n * <p>\n * The SFS WKT spec does not define a special tag for {@link LinearRing}s.\n * Under the spec, rings are output as <code>LINESTRING</code>s.\n */\nexport default class WKTWriter {\n  /**\n   * @param {GeometryFactory} geometryFactory\n   */\n  constructor(geometryFactory) {\n    this.parser = new WKTParser(geometryFactory)\n  }\n  /**\n   * Converts a <code>Geometry</code> to its Well-known Text representation.\n   *\n   * @param {Geometry} geometry a <code>Geometry</code> to process.\n   * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple\n   *         Features Specification).\n   * @memberof module:org/locationtech/jts/io/WKTWriter#\n   */\n  write (geometry) {\n    return this.parser.write(geometry)\n  }\n  /**\n   * Generates the WKT for a <tt>LINESTRING</tt> specified by two\n   * {@link Coordinate}s.\n   *\n   * @param p0 the first coordinate.\n   * @param p1 the second coordinate.\n   *\n   * @return the WKT.\n   * @private\n   */\n  static toLineString (p0, p1) {\n    if (arguments.length !== 2) {\n      throw new Error('Not implemented')\n    }\n\n    return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )'\n  }\n}\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nexport default class Location {\n\tconstructor() {\n\t\tLocation.constructor_.apply(this, arguments);\n\t}\n\tstatic toLocationSymbol(locationValue) {\n\t\tswitch (locationValue) {\n\t\t\tcase Location.EXTERIOR:\n\t\t\t\treturn 'e';\n\t\t\tcase Location.BOUNDARY:\n\t\t\t\treturn 'b';\n\t\t\tcase Location.INTERIOR:\n\t\t\t\treturn 'i';\n\t\t\tcase Location.NONE:\n\t\t\t\treturn '-';\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Unknown location value: \" + locationValue);\n\t}\n\tgetClass() {\n\t\treturn Location;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nLocation.constructor_ = function () {};\nLocation.INTERIOR = 0;\nLocation.BOUNDARY = 1;\nLocation.EXTERIOR = 2;\nLocation.NONE = -1;\n","export default function Exception () {}\n","import Exception from '../../../../java/lang/Exception';\nexport default class NotRepresentableException extends Exception {\n\tconstructor() {\n\t\tsuper();\n\t\tNotRepresentableException.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn NotRepresentableException;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nNotRepresentableException.constructor_ = function () {\n\tException.constructor_.call(this, \"Projective point not representable on the Cartesian plane.\");\n};\n","import NotRepresentableException from './NotRepresentableException';\nimport Coordinate from '../geom/Coordinate';\nimport Double from '../../../../java/lang/Double';\nexport default class HCoordinate {\n\tconstructor() {\n\t\tHCoordinate.constructor_.apply(this, arguments);\n\t}\n\tstatic intersection(p1, p2, q1, q2) {\n\t\tvar px = p1.y - p2.y;\n\t\tvar py = p2.x - p1.x;\n\t\tvar pw = p1.x * p2.y - p2.x * p1.y;\n\t\tvar qx = q1.y - q2.y;\n\t\tvar qy = q2.x - q1.x;\n\t\tvar qw = q1.x * q2.y - q2.x * q1.y;\n\t\tvar x = py * qw - qy * pw;\n\t\tvar y = qx * pw - px * qw;\n\t\tvar w = px * qy - qx * py;\n\t\tvar xInt = x / w;\n\t\tvar yInt = y / w;\n\t\tif (Double.isNaN(xInt) || (Double.isInfinite(xInt) || Double.isNaN(yInt)) || Double.isInfinite(yInt)) {\n\t\t\tthrow new NotRepresentableException();\n\t\t}\n\t\treturn new Coordinate(xInt, yInt);\n\t}\n\tgetY() {\n\t\tvar a = this.y / this.w;\n\t\tif (Double.isNaN(a) || Double.isInfinite(a)) {\n\t\t\tthrow new NotRepresentableException();\n\t\t}\n\t\treturn a;\n\t}\n\tgetX() {\n\t\tvar a = this.x / this.w;\n\t\tif (Double.isNaN(a) || Double.isInfinite(a)) {\n\t\t\tthrow new NotRepresentableException();\n\t\t}\n\t\treturn a;\n\t}\n\tgetCoordinate() {\n\t\tvar p = new Coordinate();\n\t\tp.x = this.getX();\n\t\tp.y = this.getY();\n\t\treturn p;\n\t}\n\tgetClass() {\n\t\treturn HCoordinate;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nHCoordinate.constructor_ = function () {\n\tthis.x = null;\n\tthis.y = null;\n\tthis.w = null;\n\tif (arguments.length === 0) {\n\t\tthis.x = 0.0;\n\t\tthis.y = 0.0;\n\t\tthis.w = 1.0;\n\t} else if (arguments.length === 1) {\n\t\tlet p = arguments[0];\n\t\tthis.x = p.x;\n\t\tthis.y = p.y;\n\t\tthis.w = 1.0;\n\t} else if (arguments.length === 2) {\n\t\tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\t\tlet _x = arguments[0], _y = arguments[1];\n\t\t\tthis.x = _x;\n\t\t\tthis.y = _y;\n\t\t\tthis.w = 1.0;\n\t\t} else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\t\tthis.x = p1.y * p2.w - p2.y * p1.w;\n\t\t\tthis.y = p2.x * p1.w - p1.x * p2.w;\n\t\t\tthis.w = p1.x * p2.y - p2.x * p1.y;\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\t\tthis.x = p1.y - p2.y;\n\t\t\tthis.y = p2.x - p1.x;\n\t\t\tthis.w = p1.x * p2.y - p2.x * p1.y;\n\t\t}\n\t} else if (arguments.length === 3) {\n\t\tlet _x = arguments[0], _y = arguments[1], _w = arguments[2];\n\t\tthis.x = _x;\n\t\tthis.y = _y;\n\t\tthis.w = _w;\n\t} else if (arguments.length === 4) {\n\t\tlet p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3];\n\t\tvar px = p1.y - p2.y;\n\t\tvar py = p2.x - p1.x;\n\t\tvar pw = p1.x * p2.y - p2.x * p1.y;\n\t\tvar qx = q1.y - q2.y;\n\t\tvar qy = q2.x - q1.x;\n\t\tvar qw = q1.x * q2.y - q2.x * q1.y;\n\t\tthis.x = py * qw - qy * pw;\n\t\tthis.y = qx * pw - px * qw;\n\t\tthis.w = px * qy - qx * py;\n\t}\n};\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport MathUtil from '../math/MathUtil';\nimport Envelope from '../geom/Envelope';\nexport default class Distance {\n\tconstructor() {\n\t\tDistance.constructor_.apply(this, arguments);\n\t}\n\tstatic segmentToSegment(A, B, C, D) {\n\t\tif (A.equals(B)) return Distance.pointToSegment(A, C, D);\n\t\tif (C.equals(D)) return Distance.pointToSegment(D, A, B);\n\t\tvar noIntersection = false;\n\t\tif (!Envelope.intersects(A, B, C, D)) {\n\t\t\tnoIntersection = true;\n\t\t} else {\n\t\t\tvar denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);\n\t\t\tif (denom === 0) {\n\t\t\t\tnoIntersection = true;\n\t\t\t} else {\n\t\t\t\tvar r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);\n\t\t\t\tvar s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);\n\t\t\t\tvar s = s_num / denom;\n\t\t\t\tvar r = r_num / denom;\n\t\t\t\tif (r < 0 || r > 1 || s < 0 || s > 1) {\n\t\t\t\t\tnoIntersection = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (noIntersection) {\n\t\t\treturn MathUtil.min(Distance.pointToSegment(A, C, D), Distance.pointToSegment(B, C, D), Distance.pointToSegment(C, A, B), Distance.pointToSegment(D, A, B));\n\t\t}\n\t\treturn 0.0;\n\t}\n\tstatic pointToSegment(p, A, B) {\n\t\tif (A.x === B.x && A.y === B.y) return p.distance(A);\n\t\tvar len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n\t\tvar r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) / len2;\n\t\tif (r <= 0.0) return p.distance(A);\n\t\tif (r >= 1.0) return p.distance(B);\n\t\tvar s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n\t\treturn Math.abs(s) * Math.sqrt(len2);\n\t}\n\tstatic pointToLinePerpendicular(p, A, B) {\n\t\tvar len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n\t\tvar s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n\t\treturn Math.abs(s) * Math.sqrt(len2);\n\t}\n\tstatic pointToSegmentString(p, line) {\n\t\tif (line.length === 0) throw new IllegalArgumentException(\"Line array must contain at least one vertex\");\n\t\tvar minDistance = p.distance(line[0]);\n\t\tfor (var i = 0; i < line.length - 1; i++) {\n\t\t\tvar dist = Distance.pointToSegment(p, line[i], line[i + 1]);\n\t\t\tif (dist < minDistance) {\n\t\t\t\tminDistance = dist;\n\t\t\t}\n\t\t}\n\t\treturn minDistance;\n\t}\n\tgetClass() {\n\t\treturn Distance;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nDistance.constructor_ = function () {};\n","import WKTWriter from '../io/WKTWriter';\nimport Coordinate from '../geom/Coordinate';\nimport Assert from '../util/Assert';\nimport StringBuilder from '../../../../java/lang/StringBuilder';\nexport default class LineIntersector {\n\tconstructor() {\n\t\tLineIntersector.constructor_.apply(this, arguments);\n\t}\n\tstatic computeEdgeDistance(p, p0, p1) {\n\t\tvar dx = Math.abs(p1.x - p0.x);\n\t\tvar dy = Math.abs(p1.y - p0.y);\n\t\tvar dist = -1.0;\n\t\tif (p.equals(p0)) {\n\t\t\tdist = 0.0;\n\t\t} else if (p.equals(p1)) {\n\t\t\tif (dx > dy) dist = dx; else dist = dy;\n\t\t} else {\n\t\t\tvar pdx = Math.abs(p.x - p0.x);\n\t\t\tvar pdy = Math.abs(p.y - p0.y);\n\t\t\tif (dx > dy) dist = pdx; else dist = pdy;\n\t\t\tif (dist === 0.0 && !p.equals(p0)) {\n\t\t\t\tdist = Math.max(pdx, pdy);\n\t\t\t}\n\t\t}\n\t\tAssert.isTrue(!(dist === 0.0 && !p.equals(p0)), \"Bad distance calculation\");\n\t\treturn dist;\n\t}\n\tstatic nonRobustComputeEdgeDistance(p, p1, p2) {\n\t\tvar dx = p.x - p1.x;\n\t\tvar dy = p.y - p1.y;\n\t\tvar dist = Math.sqrt(dx * dx + dy * dy);\n\t\tAssert.isTrue(!(dist === 0.0 && !p.equals(p1)), \"Invalid distance calculation\");\n\t\treturn dist;\n\t}\n\tgetIndexAlongSegment(segmentIndex, intIndex) {\n\t\tthis.computeIntLineIndex();\n\t\treturn this._intLineIndex[segmentIndex][intIndex];\n\t}\n\tgetTopologySummary() {\n\t\tvar catBuilder = new StringBuilder();\n\t\tif (this.isEndPoint()) catBuilder.append(\" endpoint\");\n\t\tif (this._isProper) catBuilder.append(\" proper\");\n\t\tif (this.isCollinear()) catBuilder.append(\" collinear\");\n\t\treturn catBuilder.toString();\n\t}\n\tcomputeIntersection(p1, p2, p3, p4) {\n\t\tthis._inputLines[0][0] = p1;\n\t\tthis._inputLines[0][1] = p2;\n\t\tthis._inputLines[1][0] = p3;\n\t\tthis._inputLines[1][1] = p4;\n\t\tthis._result = this.computeIntersect(p1, p2, p3, p4);\n\t}\n\tgetIntersectionNum() {\n\t\treturn this._result;\n\t}\n\tcomputeIntLineIndex() {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this._intLineIndex === null) {\n\t\t\t\tthis._intLineIndex = Array(2).fill().map(() => Array(2));\n\t\t\t\tthis.computeIntLineIndex(0);\n\t\t\t\tthis.computeIntLineIndex(1);\n\t\t\t}\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet segmentIndex = arguments[0];\n\t\t\tvar dist0 = this.getEdgeDistance(segmentIndex, 0);\n\t\t\tvar dist1 = this.getEdgeDistance(segmentIndex, 1);\n\t\t\tif (dist0 > dist1) {\n\t\t\t\tthis._intLineIndex[segmentIndex][0] = 0;\n\t\t\t\tthis._intLineIndex[segmentIndex][1] = 1;\n\t\t\t} else {\n\t\t\t\tthis._intLineIndex[segmentIndex][0] = 1;\n\t\t\t\tthis._intLineIndex[segmentIndex][1] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tisProper() {\n\t\treturn this.hasIntersection() && this._isProper;\n\t}\n\tsetPrecisionModel(precisionModel) {\n\t\tthis._precisionModel = precisionModel;\n\t}\n\tisInteriorIntersection() {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.isInteriorIntersection(0)) return true;\n\t\t\tif (this.isInteriorIntersection(1)) return true;\n\t\t\treturn false;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet inputLineIndex = arguments[0];\n\t\t\tfor (var i = 0; i < this._result; i++) {\n\t\t\t\tif (!(this._intPt[i].equals2D(this._inputLines[inputLineIndex][0]) || this._intPt[i].equals2D(this._inputLines[inputLineIndex][1]))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\tgetIntersection(intIndex) {\n\t\treturn this._intPt[intIndex];\n\t}\n\tisEndPoint() {\n\t\treturn this.hasIntersection() && !this._isProper;\n\t}\n\thasIntersection() {\n\t\treturn this._result !== LineIntersector.NO_INTERSECTION;\n\t}\n\tgetEdgeDistance(segmentIndex, intIndex) {\n\t\tvar dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);\n\t\treturn dist;\n\t}\n\tisCollinear() {\n\t\treturn this._result === LineIntersector.COLLINEAR_INTERSECTION;\n\t}\n\ttoString() {\n\t\treturn WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + \" - \" + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();\n\t}\n\tgetEndpoint(segmentIndex, ptIndex) {\n\t\treturn this._inputLines[segmentIndex][ptIndex];\n\t}\n\tisIntersection(pt) {\n\t\tfor (var i = 0; i < this._result; i++) {\n\t\t\tif (this._intPt[i].equals2D(pt)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tgetIntersectionAlongSegment(segmentIndex, intIndex) {\n\t\tthis.computeIntLineIndex();\n\t\treturn this._intPt[this._intLineIndex[segmentIndex][intIndex]];\n\t}\n\tgetClass() {\n\t\treturn LineIntersector;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nLineIntersector.constructor_ = function () {\n\tthis._result = null;\n\tthis._inputLines = Array(2).fill().map(() => Array(2));\n\tthis._intPt = new Array(2).fill(null);\n\tthis._intLineIndex = null;\n\tthis._isProper = null;\n\tthis._pa = null;\n\tthis._pb = null;\n\tthis._precisionModel = null;\n\tthis._intPt[0] = new Coordinate();\n\tthis._intPt[1] = new Coordinate();\n\tthis._pa = this._intPt[0];\n\tthis._pb = this._intPt[1];\n\tthis._result = 0;\n};\nLineIntersector.DONT_INTERSECT = 0;\nLineIntersector.DO_INTERSECT = 1;\nLineIntersector.COLLINEAR = 2;\nLineIntersector.NO_INTERSECTION = 0;\nLineIntersector.POINT_INTERSECTION = 1;\nLineIntersector.COLLINEAR_INTERSECTION = 2;\n","import NotRepresentableException from './NotRepresentableException';\nimport Coordinate from '../geom/Coordinate';\nimport Orientation from './Orientation';\nimport CGAlgorithmsDD from './CGAlgorithmsDD';\nimport System from '../../../../java/lang/System';\nimport HCoordinate from './HCoordinate';\nimport Envelope from '../geom/Envelope';\nimport Distance from './Distance';\nimport LineIntersector from './LineIntersector';\nexport default class RobustLineIntersector extends LineIntersector {\n\tconstructor() {\n\t\tsuper();\n\t\tRobustLineIntersector.constructor_.apply(this, arguments);\n\t}\n\tstatic nearestEndpoint(p1, p2, q1, q2) {\n\t\tvar nearestPt = p1;\n\t\tvar minDist = Distance.pointToSegment(p1, q1, q2);\n\t\tvar dist = Distance.pointToSegment(p2, q1, q2);\n\t\tif (dist < minDist) {\n\t\t\tminDist = dist;\n\t\t\tnearestPt = p2;\n\t\t}\n\t\tdist = Distance.pointToSegment(q1, p1, p2);\n\t\tif (dist < minDist) {\n\t\t\tminDist = dist;\n\t\t\tnearestPt = q1;\n\t\t}\n\t\tdist = Distance.pointToSegment(q2, p1, p2);\n\t\tif (dist < minDist) {\n\t\t\tminDist = dist;\n\t\t\tnearestPt = q2;\n\t\t}\n\t\treturn nearestPt;\n\t}\n\tisInSegmentEnvelopes(intPt) {\n\t\tvar env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);\n\t\tvar env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);\n\t\treturn env0.contains(intPt) && env1.contains(intPt);\n\t}\n\tcomputeIntersection() {\n\t\tif (arguments.length === 3) {\n\t\t\tlet p = arguments[0], p1 = arguments[1], p2 = arguments[2];\n\t\t\tthis._isProper = false;\n\t\t\tif (Envelope.intersects(p1, p2, p)) {\n\t\t\t\tif (Orientation.index(p1, p2, p) === 0 && Orientation.index(p2, p1, p) === 0) {\n\t\t\t\t\tthis._isProper = true;\n\t\t\t\t\tif (p.equals(p1) || p.equals(p2)) {\n\t\t\t\t\t\tthis._isProper = false;\n\t\t\t\t\t}\n\t\t\t\t\tthis._result = LineIntersector.POINT_INTERSECTION;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._result = LineIntersector.NO_INTERSECTION;\n\t\t} else return super.computeIntersection.apply(this, arguments);\n\t}\n\tnormalizeToMinimum(n1, n2, n3, n4, normPt) {\n\t\tnormPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);\n\t\tnormPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);\n\t\tn1.x -= normPt.x;\n\t\tn1.y -= normPt.y;\n\t\tn2.x -= normPt.x;\n\t\tn2.y -= normPt.y;\n\t\tn3.x -= normPt.x;\n\t\tn3.y -= normPt.y;\n\t\tn4.x -= normPt.x;\n\t\tn4.y -= normPt.y;\n\t}\n\tsafeHCoordinateIntersection(p1, p2, q1, q2) {\n\t\tvar intPt = null;\n\t\ttry {\n\t\t\tintPt = HCoordinate.intersection(p1, p2, q1, q2);\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotRepresentableException) {\n\t\t\t\tintPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);\n\t\t\t} else throw e;\n\t\t} finally {}\n\t\treturn intPt;\n\t}\n\tintersection(p1, p2, q1, q2) {\n\t\tvar intPt = this.intersectionWithNormalization(p1, p2, q1, q2);\n\t\tif (!this.isInSegmentEnvelopes(intPt)) {\n\t\t\tintPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));\n\t\t}\n\t\tif (this._precisionModel !== null) {\n\t\t\tthis._precisionModel.makePrecise(intPt);\n\t\t}\n\t\treturn intPt;\n\t}\n\tsmallestInAbsValue(x1, x2, x3, x4) {\n\t\tvar x = x1;\n\t\tvar xabs = Math.abs(x);\n\t\tif (Math.abs(x2) < xabs) {\n\t\t\tx = x2;\n\t\t\txabs = Math.abs(x2);\n\t\t}\n\t\tif (Math.abs(x3) < xabs) {\n\t\t\tx = x3;\n\t\t\txabs = Math.abs(x3);\n\t\t}\n\t\tif (Math.abs(x4) < xabs) {\n\t\t\tx = x4;\n\t\t}\n\t\treturn x;\n\t}\n\tcheckDD(p1, p2, q1, q2, intPt) {\n\t\tvar intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);\n\t\tvar isIn = this.isInSegmentEnvelopes(intPtDD);\n\t\tSystem.out.println(\"DD in env = \" + isIn + \"  --------------------- \" + intPtDD);\n\t\tif (intPt.distance(intPtDD) > 0.0001) {\n\t\t\tSystem.out.println(\"Distance = \" + intPt.distance(intPtDD));\n\t\t}\n\t}\n\tintersectionWithNormalization(p1, p2, q1, q2) {\n\t\tvar n1 = new Coordinate(p1);\n\t\tvar n2 = new Coordinate(p2);\n\t\tvar n3 = new Coordinate(q1);\n\t\tvar n4 = new Coordinate(q2);\n\t\tvar normPt = new Coordinate();\n\t\tthis.normalizeToEnvCentre(n1, n2, n3, n4, normPt);\n\t\tvar intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);\n\t\tintPt.x += normPt.x;\n\t\tintPt.y += normPt.y;\n\t\treturn intPt;\n\t}\n\tcomputeCollinearIntersection(p1, p2, q1, q2) {\n\t\tvar p1q1p2 = Envelope.intersects(p1, p2, q1);\n\t\tvar p1q2p2 = Envelope.intersects(p1, p2, q2);\n\t\tvar q1p1q2 = Envelope.intersects(q1, q2, p1);\n\t\tvar q1p2q2 = Envelope.intersects(q1, q2, p2);\n\t\tif (p1q1p2 && p1q2p2) {\n\t\t\tthis._intPt[0] = q1;\n\t\t\tthis._intPt[1] = q2;\n\t\t\treturn LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (q1p1q2 && q1p2q2) {\n\t\t\tthis._intPt[0] = p1;\n\t\t\tthis._intPt[1] = p2;\n\t\t\treturn LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q1p2 && q1p1q2) {\n\t\t\tthis._intPt[0] = q1;\n\t\t\tthis._intPt[1] = p1;\n\t\t\treturn q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q1p2 && q1p2q2) {\n\t\t\tthis._intPt[0] = q1;\n\t\t\tthis._intPt[1] = p2;\n\t\t\treturn q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q2p2 && q1p1q2) {\n\t\t\tthis._intPt[0] = q2;\n\t\t\tthis._intPt[1] = p1;\n\t\t\treturn q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q2p2 && q1p2q2) {\n\t\t\tthis._intPt[0] = q2;\n\t\t\tthis._intPt[1] = p2;\n\t\t\treturn q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\treturn LineIntersector.NO_INTERSECTION;\n\t}\n\tnormalizeToEnvCentre(n00, n01, n10, n11, normPt) {\n\t\tvar minX0 = n00.x < n01.x ? n00.x : n01.x;\n\t\tvar minY0 = n00.y < n01.y ? n00.y : n01.y;\n\t\tvar maxX0 = n00.x > n01.x ? n00.x : n01.x;\n\t\tvar maxY0 = n00.y > n01.y ? n00.y : n01.y;\n\t\tvar minX1 = n10.x < n11.x ? n10.x : n11.x;\n\t\tvar minY1 = n10.y < n11.y ? n10.y : n11.y;\n\t\tvar maxX1 = n10.x > n11.x ? n10.x : n11.x;\n\t\tvar maxY1 = n10.y > n11.y ? n10.y : n11.y;\n\t\tvar intMinX = minX0 > minX1 ? minX0 : minX1;\n\t\tvar intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;\n\t\tvar intMinY = minY0 > minY1 ? minY0 : minY1;\n\t\tvar intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;\n\t\tvar intMidX = (intMinX + intMaxX) / 2.0;\n\t\tvar intMidY = (intMinY + intMaxY) / 2.0;\n\t\tnormPt.x = intMidX;\n\t\tnormPt.y = intMidY;\n\t\tn00.x -= normPt.x;\n\t\tn00.y -= normPt.y;\n\t\tn01.x -= normPt.x;\n\t\tn01.y -= normPt.y;\n\t\tn10.x -= normPt.x;\n\t\tn10.y -= normPt.y;\n\t\tn11.x -= normPt.x;\n\t\tn11.y -= normPt.y;\n\t}\n\tcomputeIntersect(p1, p2, q1, q2) {\n\t\tthis._isProper = false;\n\t\tif (!Envelope.intersects(p1, p2, q1, q2)) return LineIntersector.NO_INTERSECTION;\n\t\tvar Pq1 = Orientation.index(p1, p2, q1);\n\t\tvar Pq2 = Orientation.index(p1, p2, q2);\n\t\tif (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) {\n\t\t\treturn LineIntersector.NO_INTERSECTION;\n\t\t}\n\t\tvar Qp1 = Orientation.index(q1, q2, p1);\n\t\tvar Qp2 = Orientation.index(q1, q2, p2);\n\t\tif (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) {\n\t\t\treturn LineIntersector.NO_INTERSECTION;\n\t\t}\n\t\tvar collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;\n\t\tif (collinear) {\n\t\t\treturn this.computeCollinearIntersection(p1, p2, q1, q2);\n\t\t}\n\t\tif (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {\n\t\t\tthis._isProper = false;\n\t\t\tif (p1.equals2D(q1) || p1.equals2D(q2)) {\n\t\t\t\tthis._intPt[0] = p1;\n\t\t\t} else if (p2.equals2D(q1) || p2.equals2D(q2)) {\n\t\t\t\tthis._intPt[0] = p2;\n\t\t\t} else if (Pq1 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(q1);\n\t\t\t} else if (Pq2 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(q2);\n\t\t\t} else if (Qp1 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(p1);\n\t\t\t} else if (Qp2 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(p2);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._isProper = true;\n\t\t\tthis._intPt[0] = this.intersection(p1, p2, q1, q2);\n\t\t}\n\t\treturn LineIntersector.POINT_INTERSECTION;\n\t}\n\tgetClass() {\n\t\treturn RobustLineIntersector;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRobustLineIntersector.constructor_ = function () {};\n","import Location from '../geom/Location';\nimport hasInterface from '../../../../hasInterface';\nimport Coordinate from '../geom/Coordinate';\nimport Orientation from './Orientation';\nimport CoordinateSequence from '../geom/CoordinateSequence';\nexport default class RayCrossingCounter {\n\tconstructor() {\n\t\tRayCrossingCounter.constructor_.apply(this, arguments);\n\t}\n\tstatic locatePointInRing() {\n\t\tif (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n\t\t\tlet p = arguments[0], ring = arguments[1];\n\t\t\tvar counter = new RayCrossingCounter(p);\n\t\t\tvar p1 = new Coordinate();\n\t\t\tvar p2 = new Coordinate();\n\t\t\tfor (var i = 1; i < ring.size(); i++) {\n\t\t\t\tring.getCoordinate(i, p1);\n\t\t\t\tring.getCoordinate(i - 1, p2);\n\t\t\t\tcounter.countSegment(p1, p2);\n\t\t\t\tif (counter.isOnSegment()) return counter.getLocation();\n\t\t\t}\n\t\t\treturn counter.getLocation();\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n\t\t\tlet p = arguments[0], ring = arguments[1];\n\t\t\tvar counter = new RayCrossingCounter(p);\n\t\t\tfor (var i = 1; i < ring.length; i++) {\n\t\t\t\tvar p1 = ring[i];\n\t\t\t\tvar p2 = ring[i - 1];\n\t\t\t\tcounter.countSegment(p1, p2);\n\t\t\t\tif (counter.isOnSegment()) return counter.getLocation();\n\t\t\t}\n\t\t\treturn counter.getLocation();\n\t\t}\n\t}\n\tcountSegment(p1, p2) {\n\t\tif (p1.x < this._p.x && p2.x < this._p.x) return null;\n\t\tif (this._p.x === p2.x && this._p.y === p2.y) {\n\t\t\tthis._isPointOnSegment = true;\n\t\t\treturn null;\n\t\t}\n\t\tif (p1.y === this._p.y && p2.y === this._p.y) {\n\t\t\tvar minx = p1.x;\n\t\t\tvar maxx = p2.x;\n\t\t\tif (minx > maxx) {\n\t\t\t\tminx = p2.x;\n\t\t\t\tmaxx = p1.x;\n\t\t\t}\n\t\t\tif (this._p.x >= minx && this._p.x <= maxx) {\n\t\t\t\tthis._isPointOnSegment = true;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tif (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {\n\t\t\tvar orient = Orientation.index(p1, p2, this._p);\n\t\t\tif (orient === Orientation.COLLINEAR) {\n\t\t\t\tthis._isPointOnSegment = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (p2.y < p1.y) {\n\t\t\t\torient = -orient;\n\t\t\t}\n\t\t\tif (orient === Orientation.LEFT) {\n\t\t\t\tthis._crossingCount++;\n\t\t\t}\n\t\t}\n\t}\n\tisPointInPolygon() {\n\t\treturn this.getLocation() !== Location.EXTERIOR;\n\t}\n\tgetLocation() {\n\t\tif (this._isPointOnSegment) return Location.BOUNDARY;\n\t\tif (this._crossingCount % 2 === 1) {\n\t\t\treturn Location.INTERIOR;\n\t\t}\n\t\treturn Location.EXTERIOR;\n\t}\n\tisOnSegment() {\n\t\treturn this._isPointOnSegment;\n\t}\n\tgetClass() {\n\t\treturn RayCrossingCounter;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRayCrossingCounter.constructor_ = function () {\n\tthis._p = null;\n\tthis._crossingCount = 0;\n\tthis._isPointOnSegment = false;\n\tlet p = arguments[0];\n\tthis._p = p;\n};\n","import Location from '../geom/Location';\nimport hasInterface from '../../../../hasInterface';\nimport Coordinate from '../geom/Coordinate';\nimport CoordinateSequence from '../geom/CoordinateSequence';\nimport RobustLineIntersector from './RobustLineIntersector';\nimport RayCrossingCounter from './RayCrossingCounter';\nexport default class PointLocation {\n\tconstructor() {\n\t\tPointLocation.constructor_.apply(this, arguments);\n\t}\n\tstatic isOnLine() {\n\t\tif (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n\t\t\tlet p = arguments[0], line = arguments[1];\n\t\t\tvar lineIntersector = new RobustLineIntersector();\n\t\t\tvar p0 = new Coordinate();\n\t\t\tvar p1 = new Coordinate();\n\t\t\tvar n = line.size();\n\t\t\tfor (var i = 1; i < n; i++) {\n\t\t\t\tline.getCoordinate(i - 1, p0);\n\t\t\t\tline.getCoordinate(i, p1);\n\t\t\t\tlineIntersector.computeIntersection(p, p0, p1);\n\t\t\t\tif (lineIntersector.hasIntersection()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n\t\t\tlet p = arguments[0], line = arguments[1];\n\t\t\tvar lineIntersector = new RobustLineIntersector();\n\t\t\tfor (var i = 1; i < line.length; i++) {\n\t\t\t\tvar p0 = line[i - 1];\n\t\t\t\tvar p1 = line[i];\n\t\t\t\tlineIntersector.computeIntersection(p, p0, p1);\n\t\t\t\tif (lineIntersector.hasIntersection()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\tstatic locateInRing(p, ring) {\n\t\treturn RayCrossingCounter.locatePointInRing(p, ring);\n\t}\n\tstatic isInRing(p, ring) {\n\t\treturn PointLocation.locateInRing(p, ring) !== Location.EXTERIOR;\n\t}\n\tgetClass() {\n\t\treturn PointLocation;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPointLocation.constructor_ = function () {};\n","import Iterator from '../../../../java/util/Iterator';\nimport NoSuchElementException from '../../../../java/util/NoSuchElementException';\nimport GeometryCollection from './GeometryCollection';\nexport default class GeometryCollectionIterator {\n\tconstructor() {\n\t\tGeometryCollectionIterator.constructor_.apply(this, arguments);\n\t}\n\tstatic isAtomic(geom) {\n\t\treturn !(geom instanceof GeometryCollection);\n\t}\n\tnext() {\n\t\tif (this._atStart) {\n\t\t\tthis._atStart = false;\n\t\t\tif (GeometryCollectionIterator.isAtomic(this._parent)) this._index++;\n\t\t\treturn this._parent;\n\t\t}\n\t\tif (this._subcollectionIterator !== null) {\n\t\t\tif (this._subcollectionIterator.hasNext()) {\n\t\t\t\treturn this._subcollectionIterator.next();\n\t\t\t} else {\n\t\t\t\tthis._subcollectionIterator = null;\n\t\t\t}\n\t\t}\n\t\tif (this._index >= this._max) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tvar obj = this._parent.getGeometryN(this._index++);\n\t\tif (obj instanceof GeometryCollection) {\n\t\t\tthis._subcollectionIterator = new GeometryCollectionIterator(obj);\n\t\t\treturn this._subcollectionIterator.next();\n\t\t}\n\t\treturn obj;\n\t}\n\tremove() {\n\t\tthrow new UnsupportedOperationException(this.getClass().getName());\n\t}\n\thasNext() {\n\t\tif (this._atStart) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this._subcollectionIterator !== null) {\n\t\t\tif (this._subcollectionIterator.hasNext()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tthis._subcollectionIterator = null;\n\t\t}\n\t\tif (this._index >= this._max) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tgetClass() {\n\t\treturn GeometryCollectionIterator;\n\t}\n\tget interfaces_() {\n\t\treturn [Iterator];\n\t}\n}\nGeometryCollectionIterator.constructor_ = function () {\n\tthis._parent = null;\n\tthis._atStart = null;\n\tthis._max = null;\n\tthis._index = null;\n\tthis._subcollectionIterator = null;\n\tlet parent = arguments[0];\n\tthis._parent = parent;\n\tthis._atStart = true;\n\tthis._index = 0;\n\tthis._max = parent.getNumGeometries();\n};\n","import Location from '../geom/Location';\nimport LineString from '../geom/LineString';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Point from '../geom/Point';\nimport Polygon from '../geom/Polygon';\nimport PointLocation from './PointLocation';\nimport BoundaryNodeRule from './BoundaryNodeRule';\nimport MultiPolygon from '../geom/MultiPolygon';\nimport GeometryCollectionIterator from '../geom/GeometryCollectionIterator';\nimport GeometryCollection from '../geom/GeometryCollection';\nimport MultiLineString from '../geom/MultiLineString';\nexport default class PointLocator {\n\tconstructor() {\n\t\tPointLocator.constructor_.apply(this, arguments);\n\t}\n\tlocateInPolygonRing(p, ring) {\n\t\tif (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n\t\treturn PointLocation.locateInRing(p, ring.getCoordinates());\n\t}\n\tintersects(p, geom) {\n\t\treturn this.locate(p, geom) !== Location.EXTERIOR;\n\t}\n\tupdateLocationInfo(loc) {\n\t\tif (loc === Location.INTERIOR) this._isIn = true;\n\t\tif (loc === Location.BOUNDARY) this._numBoundaries++;\n\t}\n\tcomputeLocation(p, geom) {\n\t\tif (geom instanceof Point) {\n\t\t\tthis.updateLocationInfo(this.locateOnPoint(p, geom));\n\t\t}\n\t\tif (geom instanceof LineString) {\n\t\t\tthis.updateLocationInfo(this.locateOnLineString(p, geom));\n\t\t} else if (geom instanceof Polygon) {\n\t\t\tthis.updateLocationInfo(this.locateInPolygon(p, geom));\n\t\t} else if (geom instanceof MultiLineString) {\n\t\t\tvar ml = geom;\n\t\t\tfor (var i = 0; i < ml.getNumGeometries(); i++) {\n\t\t\t\tvar l = ml.getGeometryN(i);\n\t\t\t\tthis.updateLocationInfo(this.locateOnLineString(p, l));\n\t\t\t}\n\t\t} else if (geom instanceof MultiPolygon) {\n\t\t\tvar mpoly = geom;\n\t\t\tfor (var i = 0; i < mpoly.getNumGeometries(); i++) {\n\t\t\t\tvar poly = mpoly.getGeometryN(i);\n\t\t\t\tthis.updateLocationInfo(this.locateInPolygon(p, poly));\n\t\t\t}\n\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\tvar geomi = new GeometryCollectionIterator(geom);\n\t\t\twhile (geomi.hasNext()) {\n\t\t\t\tvar g2 = geomi.next();\n\t\t\t\tif (g2 !== geom) this.computeLocation(p, g2);\n\t\t\t}\n\t\t}\n\t}\n\tlocateOnPoint(p, pt) {\n\t\tvar ptCoord = pt.getCoordinate();\n\t\tif (ptCoord.equals2D(p)) return Location.INTERIOR;\n\t\treturn Location.EXTERIOR;\n\t}\n\tlocateOnLineString(p, l) {\n\t\tif (!l.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n\t\tvar seq = l.getCoordinateSequence();\n\t\tif (!l.isClosed()) {\n\t\t\tif (p.equals(seq.getCoordinate(0)) || p.equals(seq.getCoordinate(seq.size() - 1))) {\n\t\t\t\treturn Location.BOUNDARY;\n\t\t\t}\n\t\t}\n\t\tif (PointLocation.isOnLine(p, seq)) {\n\t\t\treturn Location.INTERIOR;\n\t\t}\n\t\treturn Location.EXTERIOR;\n\t}\n\tlocateInPolygon(p, poly) {\n\t\tif (poly.isEmpty()) return Location.EXTERIOR;\n\t\tvar shell = poly.getExteriorRing();\n\t\tvar shellLoc = this.locateInPolygonRing(p, shell);\n\t\tif (shellLoc === Location.EXTERIOR) return Location.EXTERIOR;\n\t\tif (shellLoc === Location.BOUNDARY) return Location.BOUNDARY;\n\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n\t\t\tvar hole = poly.getInteriorRingN(i);\n\t\t\tvar holeLoc = this.locateInPolygonRing(p, hole);\n\t\t\tif (holeLoc === Location.INTERIOR) return Location.EXTERIOR;\n\t\t\tif (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;\n\t\t}\n\t\treturn Location.INTERIOR;\n\t}\n\tlocate(p, geom) {\n\t\tif (geom.isEmpty()) return Location.EXTERIOR;\n\t\tif (geom instanceof LineString) {\n\t\t\treturn this.locateOnLineString(p, geom);\n\t\t} else if (geom instanceof Polygon) {\n\t\t\treturn this.locateInPolygon(p, geom);\n\t\t}\n\t\tthis._isIn = false;\n\t\tthis._numBoundaries = 0;\n\t\tthis.computeLocation(p, geom);\n\t\tif (this._boundaryRule.isInBoundary(this._numBoundaries)) return Location.BOUNDARY;\n\t\tif (this._numBoundaries > 0 || this._isIn) return Location.INTERIOR;\n\t\treturn Location.EXTERIOR;\n\t}\n\tgetClass() {\n\t\treturn PointLocator;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPointLocator.constructor_ = function () {\n\tthis._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n\tthis._isIn = null;\n\tthis._numBoundaries = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet boundaryRule = arguments[0];\n\t\tif (boundaryRule === null) throw new IllegalArgumentException(\"Rule must be non-null\");\n\t\tthis._boundaryRule = boundaryRule;\n\t}\n};\n","import Location from './Location';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Dimension from './Dimension';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport StringBuilder from '../../../../java/lang/StringBuilder';\nexport default class IntersectionMatrix {\n\tconstructor() {\n\t\tIntersectionMatrix.constructor_.apply(this, arguments);\n\t}\n\tstatic matches() {\n\t\tif (Number.isInteger(arguments[0]) && typeof arguments[1] === \"string\") {\n\t\t\tlet actualDimensionValue = arguments[0], requiredDimensionSymbol = arguments[1];\n\t\t\tif (requiredDimensionSymbol === Dimension.SYM_DONTCARE) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (requiredDimensionSymbol === Dimension.SYM_TRUE && (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (requiredDimensionSymbol === Dimension.SYM_FALSE && actualDimensionValue === Dimension.FALSE) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (requiredDimensionSymbol === Dimension.SYM_P && actualDimensionValue === Dimension.P) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (requiredDimensionSymbol === Dimension.SYM_L && actualDimensionValue === Dimension.L) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (requiredDimensionSymbol === Dimension.SYM_A && actualDimensionValue === Dimension.A) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (typeof arguments[0] === \"string\" && typeof arguments[1] === \"string\") {\n\t\t\tlet actualDimensionSymbols = arguments[0], requiredDimensionSymbols = arguments[1];\n\t\t\tvar m = new IntersectionMatrix(actualDimensionSymbols);\n\t\t\treturn m.matches(requiredDimensionSymbols);\n\t\t}\n\t}\n\tstatic isTrue(actualDimensionValue) {\n\t\tif (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tisIntersects() {\n\t\treturn !this.isDisjoint();\n\t}\n\tisCovers() {\n\t\tvar hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);\n\t\treturn hasPointInCommon && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n\t}\n\tisCoveredBy() {\n\t\tvar hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);\n\t\treturn hasPointInCommon && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n\t}\n\tset() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet dimensionSymbols = arguments[0];\n\t\t\tfor (var i = 0; i < dimensionSymbols.length; i++) {\n\t\t\t\tvar row = Math.trunc(i / 3);\n\t\t\t\tvar col = i % 3;\n\t\t\t\tthis._matrix[row][col] = Dimension.toDimensionValue(dimensionSymbols.charAt(i));\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet row = arguments[0], column = arguments[1], dimensionValue = arguments[2];\n\t\t\tthis._matrix[row][column] = dimensionValue;\n\t\t}\n\t}\n\tisContains() {\n\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n\t}\n\tsetAtLeast() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet minimumDimensionSymbols = arguments[0];\n\t\t\tfor (var i = 0; i < minimumDimensionSymbols.length; i++) {\n\t\t\t\tvar row = Math.trunc(i / 3);\n\t\t\t\tvar col = i % 3;\n\t\t\t\tthis.setAtLeast(row, col, Dimension.toDimensionValue(minimumDimensionSymbols.charAt(i)));\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet row = arguments[0], column = arguments[1], minimumDimensionValue = arguments[2];\n\t\t\tif (this._matrix[row][column] < minimumDimensionValue) {\n\t\t\t\tthis._matrix[row][column] = minimumDimensionValue;\n\t\t\t}\n\t\t}\n\t}\n\tsetAtLeastIfValid(row, column, minimumDimensionValue) {\n\t\tif (row >= 0 && column >= 0) {\n\t\t\tthis.setAtLeast(row, column, minimumDimensionValue);\n\t\t}\n\t}\n\tisWithin() {\n\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n\t}\n\tisTouches(dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA > dimensionOfGeometryB) {\n\t\t\treturn this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && (IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]));\n\t\t}\n\t\treturn false;\n\t}\n\tisOverlaps(dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A) {\n\t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === 1 && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n\t\t}\n\t\treturn false;\n\t}\n\tisEquals(dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA !== dimensionOfGeometryB) {\n\t\t\treturn false;\n\t\t}\n\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n\t}\n\ttoString() {\n\t\tvar builder = new StringBuilder(\"123456789\");\n\t\tfor (var ai = 0; ai < 3; ai++) {\n\t\t\tfor (var bi = 0; bi < 3; bi++) {\n\t\t\t\tbuilder.setCharAt(3 * ai + bi, Dimension.toDimensionSymbol(this._matrix[ai][bi]));\n\t\t\t}\n\t\t}\n\t\treturn builder.toString();\n\t}\n\tsetAll(dimensionValue) {\n\t\tfor (var ai = 0; ai < 3; ai++) {\n\t\t\tfor (var bi = 0; bi < 3; bi++) {\n\t\t\t\tthis._matrix[ai][bi] = dimensionValue;\n\t\t\t}\n\t\t}\n\t}\n\tget(row, column) {\n\t\treturn this._matrix[row][column];\n\t}\n\ttranspose() {\n\t\tvar temp = this._matrix[1][0];\n\t\tthis._matrix[1][0] = this._matrix[0][1];\n\t\tthis._matrix[0][1] = temp;\n\t\ttemp = this._matrix[2][0];\n\t\tthis._matrix[2][0] = this._matrix[0][2];\n\t\tthis._matrix[0][2] = temp;\n\t\ttemp = this._matrix[2][1];\n\t\tthis._matrix[2][1] = this._matrix[1][2];\n\t\tthis._matrix[1][2] = temp;\n\t\treturn this;\n\t}\n\tmatches(requiredDimensionSymbols) {\n\t\tif (requiredDimensionSymbols.length !== 9) {\n\t\t\tthrow new IllegalArgumentException(\"Should be length 9: \" + requiredDimensionSymbols);\n\t\t}\n\t\tfor (var ai = 0; ai < 3; ai++) {\n\t\t\tfor (var bi = 0; bi < 3; bi++) {\n\t\t\t\tif (!IntersectionMatrix.matches(this._matrix[ai][bi], requiredDimensionSymbols.charAt(3 * ai + bi))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tadd(im) {\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\tfor (var j = 0; j < 3; j++) {\n\t\t\t\tthis.setAtLeast(i, j, im.get(i, j));\n\t\t\t}\n\t\t}\n\t}\n\tisDisjoint() {\n\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.INTERIOR][Location.BOUNDARY] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.BOUNDARY] === Dimension.FALSE;\n\t}\n\tisCrosses(dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A) {\n\t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === 0;\n\t\t}\n\t\treturn false;\n\t}\n\tgetClass() {\n\t\treturn IntersectionMatrix;\n\t}\n\tget interfaces_() {\n\t\treturn [Cloneable];\n\t}\n}\nIntersectionMatrix.constructor_ = function () {\n\tthis._matrix = null;\n\tif (arguments.length === 0) {\n\t\tthis._matrix = Array(3).fill().map(() => Array(3));\n\t\tthis.setAll(Dimension.FALSE);\n\t} else if (arguments.length === 1) {\n\t\tif (typeof arguments[0] === \"string\") {\n\t\t\tlet elements = arguments[0];\n\t\t\tIntersectionMatrix.constructor_.call(this);\n\t\t\tthis.set(elements);\n\t\t} else if (arguments[0] instanceof IntersectionMatrix) {\n\t\t\tlet other = arguments[0];\n\t\t\tIntersectionMatrix.constructor_.call(this);\n\t\t\tthis._matrix[Location.INTERIOR][Location.INTERIOR] = other._matrix[Location.INTERIOR][Location.INTERIOR];\n\t\t\tthis._matrix[Location.INTERIOR][Location.BOUNDARY] = other._matrix[Location.INTERIOR][Location.BOUNDARY];\n\t\t\tthis._matrix[Location.INTERIOR][Location.EXTERIOR] = other._matrix[Location.INTERIOR][Location.EXTERIOR];\n\t\t\tthis._matrix[Location.BOUNDARY][Location.INTERIOR] = other._matrix[Location.BOUNDARY][Location.INTERIOR];\n\t\t\tthis._matrix[Location.BOUNDARY][Location.BOUNDARY] = other._matrix[Location.BOUNDARY][Location.BOUNDARY];\n\t\t\tthis._matrix[Location.BOUNDARY][Location.EXTERIOR] = other._matrix[Location.BOUNDARY][Location.EXTERIOR];\n\t\t\tthis._matrix[Location.EXTERIOR][Location.INTERIOR] = other._matrix[Location.EXTERIOR][Location.INTERIOR];\n\t\t\tthis._matrix[Location.EXTERIOR][Location.BOUNDARY] = other._matrix[Location.EXTERIOR][Location.BOUNDARY];\n\t\t\tthis._matrix[Location.EXTERIOR][Location.EXTERIOR] = other._matrix[Location.EXTERIOR][Location.EXTERIOR];\n\t\t}\n\t}\n};\n","import Coordinate from '../geom/Coordinate';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nexport default class Quadrant {\n\tconstructor() {\n\t\tQuadrant.constructor_.apply(this, arguments);\n\t}\n\tstatic isNorthern(quad) {\n\t\treturn quad === Quadrant.NE || quad === Quadrant.NW;\n\t}\n\tstatic isOpposite(quad1, quad2) {\n\t\tif (quad1 === quad2) return false;\n\t\tvar diff = (quad1 - quad2 + 4) % 4;\n\t\tif (diff === 2) return true;\n\t\treturn false;\n\t}\n\tstatic commonHalfPlane(quad1, quad2) {\n\t\tif (quad1 === quad2) return quad1;\n\t\tvar diff = (quad1 - quad2 + 4) % 4;\n\t\tif (diff === 2) return -1;\n\t\tvar min = quad1 < quad2 ? quad1 : quad2;\n\t\tvar max = quad1 > quad2 ? quad1 : quad2;\n\t\tif (min === 0 && max === 3) return 3;\n\t\treturn min;\n\t}\n\tstatic isInHalfPlane(quad, halfPlane) {\n\t\tif (halfPlane === Quadrant.SE) {\n\t\t\treturn quad === Quadrant.SE || quad === Quadrant.SW;\n\t\t}\n\t\treturn quad === halfPlane || quad === halfPlane + 1;\n\t}\n\tstatic quadrant() {\n\t\tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\t\tlet dx = arguments[0], dy = arguments[1];\n\t\t\tif (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the quadrant for point ( \" + dx + \", \" + dy + \" )\");\n\t\t\tif (dx >= 0.0) {\n\t\t\t\tif (dy >= 0.0) return Quadrant.NE; else return Quadrant.SE;\n\t\t\t} else {\n\t\t\t\tif (dy >= 0.0) return Quadrant.NW; else return Quadrant.SW;\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\t\tif (p1.x === p0.x && p1.y === p0.y) throw new IllegalArgumentException(\"Cannot compute the quadrant for two identical points \" + p0);\n\t\t\tif (p1.x >= p0.x) {\n\t\t\t\tif (p1.y >= p0.y) return Quadrant.NE; else return Quadrant.SE;\n\t\t\t} else {\n\t\t\t\tif (p1.y >= p0.y) return Quadrant.NW; else return Quadrant.SW;\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn Quadrant;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nQuadrant.constructor_ = function () {};\nQuadrant.NE = 0;\nQuadrant.NW = 1;\nQuadrant.SW = 2;\nQuadrant.SE = 3;\n","import Orientation from '../algorithm/Orientation';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Quadrant from './Quadrant';\nimport Assert from '../util/Assert';\nexport default class EdgeEnd {\n\tconstructor() {\n\t\tEdgeEnd.constructor_.apply(this, arguments);\n\t}\n\tcompareDirection(e) {\n\t\tif (this._dx === e._dx && this._dy === e._dy) return 0;\n\t\tif (this._quadrant > e._quadrant) return 1;\n\t\tif (this._quadrant < e._quadrant) return -1;\n\t\treturn Orientation.index(e._p0, e._p1, this._p1);\n\t}\n\tgetDy() {\n\t\treturn this._dy;\n\t}\n\tgetCoordinate() {\n\t\treturn this._p0;\n\t}\n\tsetNode(node) {\n\t\tthis._node = node;\n\t}\n\tprint(out) {\n\t\tvar angle = Math.atan2(this._dy, this._dx);\n\t\tvar className = this.getClass().getName();\n\t\tvar lastDotPos = className.lastIndexOf('.');\n\t\tvar name = className.substring(lastDotPos + 1);\n\t\tout.print(\"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + angle + \"   \" + this._label);\n\t}\n\tcompareTo(obj) {\n\t\tvar e = obj;\n\t\treturn this.compareDirection(e);\n\t}\n\tgetDirectedCoordinate() {\n\t\treturn this._p1;\n\t}\n\tgetDx() {\n\t\treturn this._dx;\n\t}\n\tgetLabel() {\n\t\treturn this._label;\n\t}\n\tgetEdge() {\n\t\treturn this._edge;\n\t}\n\tgetQuadrant() {\n\t\treturn this._quadrant;\n\t}\n\tgetNode() {\n\t\treturn this._node;\n\t}\n\ttoString() {\n\t\tvar angle = Math.atan2(this._dy, this._dx);\n\t\tvar className = this.getClass().getName();\n\t\tvar lastDotPos = className.lastIndexOf('.');\n\t\tvar name = className.substring(lastDotPos + 1);\n\t\treturn \"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + angle + \"   \" + this._label;\n\t}\n\tcomputeLabel(boundaryNodeRule) {}\n\tinit(p0, p1) {\n\t\tthis._p0 = p0;\n\t\tthis._p1 = p1;\n\t\tthis._dx = p1.x - p0.x;\n\t\tthis._dy = p1.y - p0.y;\n\t\tthis._quadrant = Quadrant.quadrant(this._dx, this._dy);\n\t\tAssert.isTrue(!(this._dx === 0 && this._dy === 0), \"EdgeEnd with identical endpoints found\");\n\t}\n\tgetClass() {\n\t\treturn EdgeEnd;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparable];\n\t}\n}\nEdgeEnd.constructor_ = function () {\n\tthis._edge = null;\n\tthis._label = null;\n\tthis._node = null;\n\tthis._p0 = null;\n\tthis._p1 = null;\n\tthis._dx = null;\n\tthis._dy = null;\n\tthis._quadrant = null;\n\tif (arguments.length === 1) {\n\t\tlet edge = arguments[0];\n\t\tthis._edge = edge;\n\t} else if (arguments.length === 3) {\n\t\tlet edge = arguments[0], p0 = arguments[1], p1 = arguments[2];\n\t\tEdgeEnd.constructor_.call(this, edge, p0, p1, null);\n\t} else if (arguments.length === 4) {\n\t\tlet edge = arguments[0], p0 = arguments[1], p1 = arguments[2], label = arguments[3];\n\t\tEdgeEnd.constructor_.call(this, edge);\n\t\tthis.init(p0, p1);\n\t\tthis._label = label;\n\t}\n};\n","export default class Position {\n\tconstructor() {\n\t\tPosition.constructor_.apply(this, arguments);\n\t}\n\tstatic opposite(position) {\n\t\tif (position === Position.LEFT) return Position.RIGHT;\n\t\tif (position === Position.RIGHT) return Position.LEFT;\n\t\treturn position;\n\t}\n\tgetClass() {\n\t\treturn Position;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPosition.constructor_ = function () {};\nPosition.ON = 0;\nPosition.LEFT = 1;\nPosition.RIGHT = 2;\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Location from '../geom/Location';\nimport Position from './Position';\nexport default class TopologyLocation {\n\tconstructor() {\n\t\tTopologyLocation.constructor_.apply(this, arguments);\n\t}\n\tsetAllLocations(locValue) {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tthis.location[i] = locValue;\n\t\t}\n\t}\n\tisNull() {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] !== Location.NONE) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tsetAllLocationsIfNull(locValue) {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] === Location.NONE) this.location[i] = locValue;\n\t\t}\n\t}\n\tisLine() {\n\t\treturn this.location.length === 1;\n\t}\n\tmerge(gl) {\n\t\tif (gl.location.length > this.location.length) {\n\t\t\tvar newLoc = new Array(3).fill(null);\n\t\t\tnewLoc[Position.ON] = this.location[Position.ON];\n\t\t\tnewLoc[Position.LEFT] = Location.NONE;\n\t\t\tnewLoc[Position.RIGHT] = Location.NONE;\n\t\t\tthis.location = newLoc;\n\t\t}\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] === Location.NONE && i < gl.location.length) this.location[i] = gl.location[i];\n\t\t}\n\t}\n\tgetLocations() {\n\t\treturn this.location;\n\t}\n\tflip() {\n\t\tif (this.location.length <= 1) return null;\n\t\tvar temp = this.location[Position.LEFT];\n\t\tthis.location[Position.LEFT] = this.location[Position.RIGHT];\n\t\tthis.location[Position.RIGHT] = temp;\n\t}\n\ttoString() {\n\t\tvar buf = new StringBuffer();\n\t\tif (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.LEFT]));\n\t\tbuf.append(Location.toLocationSymbol(this.location[Position.ON]));\n\t\tif (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]));\n\t\treturn buf.toString();\n\t}\n\tsetLocations(on, left, right) {\n\t\tthis.location[Position.ON] = on;\n\t\tthis.location[Position.LEFT] = left;\n\t\tthis.location[Position.RIGHT] = right;\n\t}\n\tget(posIndex) {\n\t\tif (posIndex < this.location.length) return this.location[posIndex];\n\t\treturn Location.NONE;\n\t}\n\tisArea() {\n\t\treturn this.location.length > 1;\n\t}\n\tisAnyNull() {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] === Location.NONE) return true;\n\t\t}\n\t\treturn false;\n\t}\n\tsetLocation() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet locValue = arguments[0];\n\t\t\tthis.setLocation(Position.ON, locValue);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet locIndex = arguments[0], locValue = arguments[1];\n\t\t\tthis.location[locIndex] = locValue;\n\t\t}\n\t}\n\tinit(size) {\n\t\tthis.location = new Array(size).fill(null);\n\t\tthis.setAllLocations(Location.NONE);\n\t}\n\tisEqualOnSide(le, locIndex) {\n\t\treturn this.location[locIndex] === le.location[locIndex];\n\t}\n\tallPositionsEqual(loc) {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] !== loc) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tgetClass() {\n\t\treturn TopologyLocation;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nTopologyLocation.constructor_ = function () {\n\tthis.location = null;\n\tif (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tlet location = arguments[0];\n\t\t\tthis.init(location.length);\n\t\t} else if (Number.isInteger(arguments[0])) {\n\t\t\tlet on = arguments[0];\n\t\t\tthis.init(1);\n\t\t\tthis.location[Position.ON] = on;\n\t\t} else if (arguments[0] instanceof TopologyLocation) {\n\t\t\tlet gl = arguments[0];\n\t\t\tthis.init(gl.location.length);\n\t\t\tif (gl !== null) {\n\t\t\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\t\t\tthis.location[i] = gl.location[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (arguments.length === 3) {\n\t\tlet on = arguments[0], left = arguments[1], right = arguments[2];\n\t\tthis.init(3);\n\t\tthis.location[Position.ON] = on;\n\t\tthis.location[Position.LEFT] = left;\n\t\tthis.location[Position.RIGHT] = right;\n\t}\n};\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Location from '../geom/Location';\nimport Position from './Position';\nimport TopologyLocation from './TopologyLocation';\nexport default class Label {\n\tconstructor() {\n\t\tLabel.constructor_.apply(this, arguments);\n\t}\n\tstatic toLineLabel(label) {\n\t\tvar lineLabel = new Label(Location.NONE);\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tlineLabel.setLocation(i, label.getLocation(i));\n\t\t}\n\t\treturn lineLabel;\n\t}\n\tgetGeometryCount() {\n\t\tvar count = 0;\n\t\tif (!this.elt[0].isNull()) count++;\n\t\tif (!this.elt[1].isNull()) count++;\n\t\treturn count;\n\t}\n\tsetAllLocations(geomIndex, location) {\n\t\tthis.elt[geomIndex].setAllLocations(location);\n\t}\n\tisNull(geomIndex) {\n\t\treturn this.elt[geomIndex].isNull();\n\t}\n\tsetAllLocationsIfNull() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet location = arguments[0];\n\t\t\tthis.setAllLocationsIfNull(0, location);\n\t\t\tthis.setAllLocationsIfNull(1, location);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], location = arguments[1];\n\t\t\tthis.elt[geomIndex].setAllLocationsIfNull(location);\n\t\t}\n\t}\n\tisLine(geomIndex) {\n\t\treturn this.elt[geomIndex].isLine();\n\t}\n\tmerge(lbl) {\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (this.elt[i] === null && lbl.elt[i] !== null) {\n\t\t\t\tthis.elt[i] = new TopologyLocation(lbl.elt[i]);\n\t\t\t} else {\n\t\t\t\tthis.elt[i].merge(lbl.elt[i]);\n\t\t\t}\n\t\t}\n\t}\n\tflip() {\n\t\tthis.elt[0].flip();\n\t\tthis.elt[1].flip();\n\t}\n\tgetLocation() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet geomIndex = arguments[0];\n\t\t\treturn this.elt[geomIndex].get(Position.ON);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1];\n\t\t\treturn this.elt[geomIndex].get(posIndex);\n\t\t}\n\t}\n\ttoString() {\n\t\tvar buf = new StringBuffer();\n\t\tif (this.elt[0] !== null) {\n\t\t\tbuf.append(\"A:\");\n\t\t\tbuf.append(this.elt[0].toString());\n\t\t}\n\t\tif (this.elt[1] !== null) {\n\t\t\tbuf.append(\" B:\");\n\t\t\tbuf.append(this.elt[1].toString());\n\t\t}\n\t\treturn buf.toString();\n\t}\n\tisArea() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.elt[0].isArea() || this.elt[1].isArea();\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet geomIndex = arguments[0];\n\t\t\treturn this.elt[geomIndex].isArea();\n\t\t}\n\t}\n\tisAnyNull(geomIndex) {\n\t\treturn this.elt[geomIndex].isAnyNull();\n\t}\n\tsetLocation() {\n\t\tif (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], location = arguments[1];\n\t\t\tthis.elt[geomIndex].setLocation(Position.ON, location);\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2];\n\t\t\tthis.elt[geomIndex].setLocation(posIndex, location);\n\t\t}\n\t}\n\tisEqualOnSide(lbl, side) {\n\t\treturn this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);\n\t}\n\tallPositionsEqual(geomIndex, loc) {\n\t\treturn this.elt[geomIndex].allPositionsEqual(loc);\n\t}\n\ttoLine(geomIndex) {\n\t\tif (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]);\n\t}\n\tgetClass() {\n\t\treturn Label;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nLabel.constructor_ = function () {\n\tthis.elt = new Array(2).fill(null);\n\tif (arguments.length === 1) {\n\t\tif (Number.isInteger(arguments[0])) {\n\t\t\tlet onLoc = arguments[0];\n\t\t\tthis.elt[0] = new TopologyLocation(onLoc);\n\t\t\tthis.elt[1] = new TopologyLocation(onLoc);\n\t\t} else if (arguments[0] instanceof Label) {\n\t\t\tlet lbl = arguments[0];\n\t\t\tthis.elt[0] = new TopologyLocation(lbl.elt[0]);\n\t\t\tthis.elt[1] = new TopologyLocation(lbl.elt[1]);\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet geomIndex = arguments[0], onLoc = arguments[1];\n\t\tthis.elt[0] = new TopologyLocation(Location.NONE);\n\t\tthis.elt[1] = new TopologyLocation(Location.NONE);\n\t\tthis.elt[geomIndex].setLocation(onLoc);\n\t} else if (arguments.length === 3) {\n\t\tlet onLoc = arguments[0], leftLoc = arguments[1], rightLoc = arguments[2];\n\t\tthis.elt[0] = new TopologyLocation(onLoc, leftLoc, rightLoc);\n\t\tthis.elt[1] = new TopologyLocation(onLoc, leftLoc, rightLoc);\n\t} else if (arguments.length === 4) {\n\t\tlet geomIndex = arguments[0], onLoc = arguments[1], leftLoc = arguments[2], rightLoc = arguments[3];\n\t\tthis.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n\t\tthis.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n\t\tthis.elt[geomIndex].setLocations(onLoc, leftLoc, rightLoc);\n\t}\n};\n","import EdgeEnd from '../../geomgraph/EdgeEnd';\nimport Label from '../../geomgraph/Label';\nimport ArrayList from '../../../../../java/util/ArrayList';\nexport default class EdgeEndBuilder {\n\tconstructor() {\n\t\tEdgeEndBuilder.constructor_.apply(this, arguments);\n\t}\n\tcreateEdgeEndForNext(edge, l, eiCurr, eiNext) {\n\t\tvar iNext = eiCurr.segmentIndex + 1;\n\t\tif (iNext >= edge.getNumPoints() && eiNext === null) return null;\n\t\tvar pNext = edge.getCoordinate(iNext);\n\t\tif (eiNext !== null && eiNext.segmentIndex === eiCurr.segmentIndex) pNext = eiNext.coord;\n\t\tvar e = new EdgeEnd(edge, eiCurr.coord, pNext, new Label(edge.getLabel()));\n\t\tl.add(e);\n\t}\n\tcreateEdgeEndForPrev(edge, l, eiCurr, eiPrev) {\n\t\tvar iPrev = eiCurr.segmentIndex;\n\t\tif (eiCurr.dist === 0.0) {\n\t\t\tif (iPrev === 0) return null;\n\t\t\tiPrev--;\n\t\t}\n\t\tvar pPrev = edge.getCoordinate(iPrev);\n\t\tif (eiPrev !== null && eiPrev.segmentIndex >= iPrev) pPrev = eiPrev.coord;\n\t\tvar label = new Label(edge.getLabel());\n\t\tlabel.flip();\n\t\tvar e = new EdgeEnd(edge, eiCurr.coord, pPrev, label);\n\t\tl.add(e);\n\t}\n\tcomputeEdgeEnds() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet edges = arguments[0];\n\t\t\tvar l = new ArrayList();\n\t\t\tfor (var i = edges; i.hasNext(); ) {\n\t\t\t\tvar e = i.next();\n\t\t\t\tthis.computeEdgeEnds(e, l);\n\t\t\t}\n\t\t\treturn l;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet edge = arguments[0], l = arguments[1];\n\t\t\tvar eiList = edge.getEdgeIntersectionList();\n\t\t\teiList.addEndpoints();\n\t\t\tvar it = eiList.iterator();\n\t\t\tvar eiPrev = null;\n\t\t\tvar eiCurr = null;\n\t\t\tif (!it.hasNext()) return null;\n\t\t\tvar eiNext = it.next();\n\t\t\tdo {\n\t\t\t\teiPrev = eiCurr;\n\t\t\t\teiCurr = eiNext;\n\t\t\t\teiNext = null;\n\t\t\t\tif (it.hasNext()) eiNext = it.next();\n\t\t\t\tif (eiCurr !== null) {\n\t\t\t\t\tthis.createEdgeEndForPrev(edge, l, eiCurr, eiPrev);\n\t\t\t\t\tthis.createEdgeEndForNext(edge, l, eiCurr, eiNext);\n\t\t\t\t}\n\t\t\t} while (eiCurr !== null);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn EdgeEndBuilder;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdgeEndBuilder.constructor_ = function () {};\n","import Assert from '../util/Assert';\nexport default class GraphComponent {\n\tconstructor() {\n\t\tGraphComponent.constructor_.apply(this, arguments);\n\t}\n\tsetVisited(isVisited) {\n\t\tthis._isVisited = isVisited;\n\t}\n\tsetInResult(isInResult) {\n\t\tthis._isInResult = isInResult;\n\t}\n\tisCovered() {\n\t\treturn this._isCovered;\n\t}\n\tisCoveredSet() {\n\t\treturn this._isCoveredSet;\n\t}\n\tsetLabel(label) {\n\t\tthis._label = label;\n\t}\n\tgetLabel() {\n\t\treturn this._label;\n\t}\n\tsetCovered(isCovered) {\n\t\tthis._isCovered = isCovered;\n\t\tthis._isCoveredSet = true;\n\t}\n\tupdateIM(im) {\n\t\tAssert.isTrue(this._label.getGeometryCount() >= 2, \"found partial label\");\n\t\tthis.computeIM(im);\n\t}\n\tisInResult() {\n\t\treturn this._isInResult;\n\t}\n\tisVisited() {\n\t\treturn this._isVisited;\n\t}\n\tgetClass() {\n\t\treturn GraphComponent;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGraphComponent.constructor_ = function () {\n\tthis._label = null;\n\tthis._isInResult = false;\n\tthis._isCovered = false;\n\tthis._isCoveredSet = false;\n\tthis._isVisited = false;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet label = arguments[0];\n\t\tthis._label = label;\n\t}\n};\n","import Location from '../geom/Location';\nimport Label from './Label';\nimport GraphComponent from './GraphComponent';\nexport default class Node extends GraphComponent {\n\tconstructor() {\n\t\tsuper();\n\t\tNode.constructor_.apply(this, arguments);\n\t}\n\tisIncidentEdgeInResult() {\n\t\tfor (var it = this.getEdges().getEdges().iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.getEdge().isInResult()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\tisIsolated() {\n\t\treturn this._label.getGeometryCount() === 1;\n\t}\n\tgetCoordinate() {\n\t\treturn this._coord;\n\t}\n\tprint(out) {\n\t\tout.println(\"node \" + this._coord + \" lbl: \" + this._label);\n\t}\n\tcomputeIM(im) {}\n\tcomputeMergedLocation(label2, eltIndex) {\n\t\tvar loc = Location.NONE;\n\t\tloc = this._label.getLocation(eltIndex);\n\t\tif (!label2.isNull(eltIndex)) {\n\t\t\tvar nLoc = label2.getLocation(eltIndex);\n\t\t\tif (loc !== Location.BOUNDARY) loc = nLoc;\n\t\t}\n\t\treturn loc;\n\t}\n\tsetLabel() {\n\t\tif (arguments.length === 2 && (Number.isInteger(arguments[1]) && Number.isInteger(arguments[0]))) {\n\t\t\tlet argIndex = arguments[0], onLocation = arguments[1];\n\t\t\tif (this._label === null) {\n\t\t\t\tthis._label = new Label(argIndex, onLocation);\n\t\t\t} else this._label.setLocation(argIndex, onLocation);\n\t\t} else return super.setLabel.apply(this, arguments);\n\t}\n\tgetEdges() {\n\t\treturn this._edges;\n\t}\n\tmergeLabel() {\n\t\tif (arguments[0] instanceof Node) {\n\t\t\tlet n = arguments[0];\n\t\t\tthis.mergeLabel(n._label);\n\t\t} else if (arguments[0] instanceof Label) {\n\t\t\tlet label2 = arguments[0];\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tvar loc = this.computeMergedLocation(label2, i);\n\t\t\t\tvar thisLoc = this._label.getLocation(i);\n\t\t\t\tif (thisLoc === Location.NONE) this._label.setLocation(i, loc);\n\t\t\t}\n\t\t}\n\t}\n\tadd(e) {\n\t\tthis._edges.insert(e);\n\t\te.setNode(this);\n\t}\n\tsetLabelBoundary(argIndex) {\n\t\tif (this._label === null) return null;\n\t\tvar loc = Location.NONE;\n\t\tif (this._label !== null) loc = this._label.getLocation(argIndex);\n\t\tvar newLoc = null;\n\t\tswitch (loc) {\n\t\t\tcase Location.BOUNDARY:\n\t\t\t\tnewLoc = Location.INTERIOR;\n\t\t\t\tbreak;\n\t\t\tcase Location.INTERIOR:\n\t\t\t\tnewLoc = Location.BOUNDARY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnewLoc = Location.BOUNDARY;\n\t\t\t\tbreak;\n\t\t}\n\t\tthis._label.setLocation(argIndex, newLoc);\n\t}\n\tgetClass() {\n\t\treturn Node;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nNode.constructor_ = function () {\n\tthis._coord = null;\n\tthis._edges = null;\n\tlet coord = arguments[0], edges = arguments[1];\n\tthis._coord = coord;\n\tthis._edges = edges;\n\tthis._label = new Label(0, Location.NONE);\n};\n","import Location from '../geom/Location';\nimport Coordinate from '../geom/Coordinate';\nimport Node from './Node';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default class NodeMap {\n\tconstructor() {\n\t\tNodeMap.constructor_.apply(this, arguments);\n\t}\n\tfind(coord) {\n\t\treturn this.nodeMap.get(coord);\n\t}\n\taddNode() {\n\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\tlet coord = arguments[0];\n\t\t\tvar node = this.nodeMap.get(coord);\n\t\t\tif (node === null) {\n\t\t\t\tnode = this.nodeFact.createNode(coord);\n\t\t\t\tthis.nodeMap.put(coord, node);\n\t\t\t}\n\t\t\treturn node;\n\t\t} else if (arguments[0] instanceof Node) {\n\t\t\tlet n = arguments[0];\n\t\t\tvar node = this.nodeMap.get(n.getCoordinate());\n\t\t\tif (node === null) {\n\t\t\t\tthis.nodeMap.put(n.getCoordinate(), n);\n\t\t\t\treturn n;\n\t\t\t}\n\t\t\tnode.mergeLabel(n);\n\t\t\treturn node;\n\t\t}\n\t}\n\tprint(out) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar n = it.next();\n\t\t\tn.print(out);\n\t\t}\n\t}\n\titerator() {\n\t\treturn this.nodeMap.values().iterator();\n\t}\n\tvalues() {\n\t\treturn this.nodeMap.values();\n\t}\n\tgetBoundaryNodes(geomIndex) {\n\t\tvar bdyNodes = new ArrayList();\n\t\tfor (var i = this.iterator(); i.hasNext(); ) {\n\t\t\tvar node = i.next();\n\t\t\tif (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) bdyNodes.add(node);\n\t\t}\n\t\treturn bdyNodes;\n\t}\n\tadd(e) {\n\t\tvar p = e.getCoordinate();\n\t\tvar n = this.addNode(p);\n\t\tn.add(e);\n\t}\n\tgetClass() {\n\t\treturn NodeMap;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nNodeMap.constructor_ = function () {\n\tthis.nodeMap = new TreeMap();\n\tthis.nodeFact = null;\n\tlet nodeFact = arguments[0];\n\tthis.nodeFact = nodeFact;\n};\n","import Coordinate from './Coordinate';\nimport RuntimeException from '../../../../java/lang/RuntimeException';\nexport default class TopologyException extends RuntimeException {\n\tconstructor() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet msg = arguments[0];\n\t\t\tsuper(msg)\n\t\t\tRuntimeException.call(this, msg);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet msg = arguments[0], pt = arguments[1];\n\t\t\tsuper(TopologyException.msgWithCoord(msg, pt))\n\t\t\tthis.name = 'TopologyException';\n\t\t\tthis.pt = new Coordinate(pt);\n\t\t}\n\t}\n\tgetCoordinate() {\n\t\treturn this.pt;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n\tgetClass() {\n\t\treturn TopologyException;\n\t}\n\tstatic msgWithCoord (msg, pt) {\n\t\tif (pt !== null) return msg + \" [ \" + pt + \" ]\";\n\t\treturn msg;\n\t}\n}","export default class PointOnGeometryLocator {\n\tconstructor() {\n\t\tPointOnGeometryLocator.constructor_.apply(this, arguments);\n\t}\n\tlocate(p) {}\n\tgetClass() {\n\t\treturn PointOnGeometryLocator;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPointOnGeometryLocator.constructor_ = function () {};\n","import Location from '../../geom/Location';\nimport Polygon from '../../geom/Polygon';\nimport PointLocation from '../PointLocation';\nimport PointOnGeometryLocator from './PointOnGeometryLocator';\nimport GeometryCollectionIterator from '../../geom/GeometryCollectionIterator';\nimport GeometryCollection from '../../geom/GeometryCollection';\nexport default class SimplePointInAreaLocator {\n\tconstructor() {\n\t\tSimplePointInAreaLocator.constructor_.apply(this, arguments);\n\t}\n\tstatic locatePointInPolygon(p, poly) {\n\t\tif (poly.isEmpty()) return Location.EXTERIOR;\n\t\tvar shell = poly.getExteriorRing();\n\t\tvar shellLoc = SimplePointInAreaLocator.locatePointInRing(p, shell);\n\t\tif (shellLoc !== Location.INTERIOR) return shellLoc;\n\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n\t\t\tvar hole = poly.getInteriorRingN(i);\n\t\t\tvar holeLoc = SimplePointInAreaLocator.locatePointInRing(p, hole);\n\t\t\tif (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;\n\t\t\tif (holeLoc === Location.INTERIOR) return Location.EXTERIOR;\n\t\t}\n\t\treturn Location.INTERIOR;\n\t}\n\tstatic locatePointInRing(p, ring) {\n\t\tif (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n\t\treturn PointLocation.locateInRing(p, ring.getCoordinates());\n\t}\n\tstatic containsPointInPolygon(p, poly) {\n\t\treturn Location.EXTERIOR !== SimplePointInAreaLocator.locatePointInPolygon(p, poly);\n\t}\n\tstatic locateInGeometry(p, geom) {\n\t\tif (geom instanceof Polygon) {\n\t\t\treturn SimplePointInAreaLocator.locatePointInPolygon(p, geom);\n\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\tvar geomi = new GeometryCollectionIterator(geom);\n\t\t\twhile (geomi.hasNext()) {\n\t\t\t\tvar g2 = geomi.next();\n\t\t\t\tif (g2 !== geom) {\n\t\t\t\t\tvar loc = SimplePointInAreaLocator.locateInGeometry(p, g2);\n\t\t\t\t\tif (loc !== Location.EXTERIOR) return loc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Location.EXTERIOR;\n\t}\n\tstatic locate(p, geom) {\n\t\tif (geom.isEmpty()) return Location.EXTERIOR;\n\t\treturn SimplePointInAreaLocator.locateInGeometry(p, geom);\n\t}\n\tlocate(p) {\n\t\treturn SimplePointInAreaLocator.locate(p, this._geom);\n\t}\n\tgetClass() {\n\t\treturn SimplePointInAreaLocator;\n\t}\n\tget interfaces_() {\n\t\treturn [PointOnGeometryLocator];\n\t}\n}\nSimplePointInAreaLocator.constructor_ = function () {\n\tthis._geom = null;\n\tlet geom = arguments[0];\n\tthis._geom = geom;\n};\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Location from '../geom/Location';\nimport Position from './Position';\nimport TopologyException from '../geom/TopologyException';\nimport System from '../../../../java/lang/System';\nimport SimplePointInAreaLocator from '../algorithm/locate/SimplePointInAreaLocator';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Assert from '../util/Assert';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default class EdgeEndStar {\n\tconstructor() {\n\t\tEdgeEndStar.constructor_.apply(this, arguments);\n\t}\n\tgetNextCW(ee) {\n\t\tthis.getEdges();\n\t\tvar i = this._edgeList.indexOf(ee);\n\t\tvar iNextCW = i - 1;\n\t\tif (i === 0) iNextCW = this._edgeList.size() - 1;\n\t\treturn this._edgeList.get(iNextCW);\n\t}\n\tpropagateSideLabels(geomIndex) {\n\t\tvar startLoc = Location.NONE;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tif (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) startLoc = label.getLocation(geomIndex, Position.LEFT);\n\t\t}\n\t\tif (startLoc === Location.NONE) return null;\n\t\tvar currLoc = startLoc;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tif (label.getLocation(geomIndex, Position.ON) === Location.NONE) label.setLocation(geomIndex, Position.ON, currLoc);\n\t\t\tif (label.isArea(geomIndex)) {\n\t\t\t\tvar leftLoc = label.getLocation(geomIndex, Position.LEFT);\n\t\t\t\tvar rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n\t\t\t\tif (rightLoc !== Location.NONE) {\n\t\t\t\t\tif (rightLoc !== currLoc) throw new TopologyException(\"side location conflict\", e.getCoordinate());\n\t\t\t\t\tif (leftLoc === Location.NONE) {\n\t\t\t\t\t\tAssert.shouldNeverReachHere(\"found single null side (at \" + e.getCoordinate() + \")\");\n\t\t\t\t\t}\n\t\t\t\t\tcurrLoc = leftLoc;\n\t\t\t\t} else {\n\t\t\t\t\tAssert.isTrue(label.getLocation(geomIndex, Position.LEFT) === Location.NONE, \"found single null side\");\n\t\t\t\t\tlabel.setLocation(geomIndex, Position.RIGHT, currLoc);\n\t\t\t\t\tlabel.setLocation(geomIndex, Position.LEFT, currLoc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgetCoordinate() {\n\t\tvar it = this.iterator();\n\t\tif (!it.hasNext()) return null;\n\t\tvar e = it.next();\n\t\treturn e.getCoordinate();\n\t}\n\tprint(out) {\n\t\tSystem.out.println(\"EdgeEndStar:   \" + this.getCoordinate());\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\te.print(out);\n\t\t}\n\t}\n\tisAreaLabelsConsistent(geomGraph) {\n\t\tthis.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());\n\t\treturn this.checkAreaLabelsConsistent(0);\n\t}\n\tcheckAreaLabelsConsistent(geomIndex) {\n\t\tvar edges = this.getEdges();\n\t\tif (edges.size() <= 0) return true;\n\t\tvar lastEdgeIndex = edges.size() - 1;\n\t\tvar startLabel = edges.get(lastEdgeIndex).getLabel();\n\t\tvar startLoc = startLabel.getLocation(geomIndex, Position.LEFT);\n\t\tAssert.isTrue(startLoc !== Location.NONE, \"Found unlabelled area edge\");\n\t\tvar currLoc = startLoc;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tAssert.isTrue(label.isArea(geomIndex), \"Found non-area edge\");\n\t\t\tvar leftLoc = label.getLocation(geomIndex, Position.LEFT);\n\t\t\tvar rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n\t\t\tif (leftLoc === rightLoc) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rightLoc !== currLoc) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcurrLoc = leftLoc;\n\t\t}\n\t\treturn true;\n\t}\n\tfindIndex(eSearch) {\n\t\tthis.iterator();\n\t\tfor (var i = 0; i < this._edgeList.size(); i++) {\n\t\t\tvar e = this._edgeList.get(i);\n\t\t\tif (e === eSearch) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\titerator() {\n\t\treturn this.getEdges().iterator();\n\t}\n\tgetEdges() {\n\t\tif (this._edgeList === null) {\n\t\t\tthis._edgeList = new ArrayList(this._edgeMap.values());\n\t\t}\n\t\treturn this._edgeList;\n\t}\n\tgetLocation(geomIndex, p, geom) {\n\t\tif (this._ptInAreaLocation[geomIndex] === Location.NONE) {\n\t\t\tthis._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());\n\t\t}\n\t\treturn this._ptInAreaLocation[geomIndex];\n\t}\n\ttoString() {\n\t\tvar buf = new StringBuffer();\n\t\tbuf.append(\"EdgeEndStar:   \" + this.getCoordinate());\n\t\tbuf.append(\"\\n\");\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tbuf.append(e);\n\t\t\tbuf.append(\"\\n\");\n\t\t}\n\t\treturn buf.toString();\n\t}\n\tcomputeEdgeEndLabels(boundaryNodeRule) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ee = it.next();\n\t\t\tee.computeLabel(boundaryNodeRule);\n\t\t}\n\t}\n\tcomputeLabelling(geomGraph) {\n\t\tthis.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());\n\t\tthis.propagateSideLabels(0);\n\t\tthis.propagateSideLabels(1);\n\t\tvar hasDimensionalCollapseEdge = [false, false];\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tfor (var geomi = 0; geomi < 2; geomi++) {\n\t\t\t\tif (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) hasDimensionalCollapseEdge[geomi] = true;\n\t\t\t}\n\t\t}\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tfor (var geomi = 0; geomi < 2; geomi++) {\n\t\t\t\tif (label.isAnyNull(geomi)) {\n\t\t\t\t\tvar loc = Location.NONE;\n\t\t\t\t\tif (hasDimensionalCollapseEdge[geomi]) {\n\t\t\t\t\t\tloc = Location.EXTERIOR;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar p = e.getCoordinate();\n\t\t\t\t\t\tloc = this.getLocation(geomi, p, geomGraph);\n\t\t\t\t\t}\n\t\t\t\t\tlabel.setAllLocationsIfNull(geomi, loc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgetDegree() {\n\t\treturn this._edgeMap.size();\n\t}\n\tinsertEdgeEnd(e, obj) {\n\t\tthis._edgeMap.put(e, obj);\n\t\tthis._edgeList = null;\n\t}\n\tgetClass() {\n\t\treturn EdgeEndStar;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdgeEndStar.constructor_ = function () {\n\tthis._edgeMap = new TreeMap();\n\tthis._edgeList = null;\n\tthis._ptInAreaLocation = [Location.NONE, Location.NONE];\n};\n","export default class MonotoneChain {\n\tconstructor() {\n\t\tMonotoneChain.constructor_.apply(this, arguments);\n\t}\n\tcomputeIntersections(mc, si) {\n\t\tthis.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);\n\t}\n\tgetClass() {\n\t\treturn MonotoneChain;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nMonotoneChain.constructor_ = function () {\n\tthis.mce = null;\n\tthis.chainIndex = null;\n\tlet mce = arguments[0], chainIndex = arguments[1];\n\tthis.mce = mce;\n\tthis.chainIndex = chainIndex;\n};\n","import Comparable from '../../../../../java/lang/Comparable';\nexport default class SweepLineEvent {\n\tconstructor() {\n\t\tSweepLineEvent.constructor_.apply(this, arguments);\n\t}\n\tisDelete() {\n\t\treturn this._eventType === SweepLineEvent.DELETE;\n\t}\n\tsetDeleteEventIndex(deleteEventIndex) {\n\t\tthis._deleteEventIndex = deleteEventIndex;\n\t}\n\tgetObject() {\n\t\treturn this._obj;\n\t}\n\tcompareTo(o) {\n\t\tvar pe = o;\n\t\tif (this._xValue < pe._xValue) return -1;\n\t\tif (this._xValue > pe._xValue) return 1;\n\t\tif (this._eventType < pe._eventType) return -1;\n\t\tif (this._eventType > pe._eventType) return 1;\n\t\treturn 0;\n\t}\n\tgetInsertEvent() {\n\t\treturn this._insertEvent;\n\t}\n\tisInsert() {\n\t\treturn this._eventType === SweepLineEvent.INSERT;\n\t}\n\tisSameLabel(ev) {\n\t\tif (this._label === null) return false;\n\t\treturn this._label === ev._label;\n\t}\n\tgetDeleteEventIndex() {\n\t\treturn this._deleteEventIndex;\n\t}\n\tgetClass() {\n\t\treturn SweepLineEvent;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparable];\n\t}\n}\nSweepLineEvent.constructor_ = function () {\n\tthis._label = null;\n\tthis._xValue = null;\n\tthis._eventType = null;\n\tthis._insertEvent = null;\n\tthis._deleteEventIndex = null;\n\tthis._obj = null;\n\tif (arguments.length === 2) {\n\t\tlet x = arguments[0], insertEvent = arguments[1];\n\t\tthis._eventType = SweepLineEvent.DELETE;\n\t\tthis._xValue = x;\n\t\tthis._insertEvent = insertEvent;\n\t} else if (arguments.length === 3) {\n\t\tlet label = arguments[0], x = arguments[1], obj = arguments[2];\n\t\tthis._eventType = SweepLineEvent.INSERT;\n\t\tthis._label = label;\n\t\tthis._xValue = x;\n\t\tthis._obj = obj;\n\t}\n};\nSweepLineEvent.INSERT = 1;\nSweepLineEvent.DELETE = 2;\n","export default class EdgeSetIntersector {\n\tconstructor() {\n\t\tEdgeSetIntersector.constructor_.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn EdgeSetIntersector;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdgeSetIntersector.constructor_ = function () {};\n","import Arrays from './Arrays'\nimport ArrayList from './ArrayList'\n\nconst Collections = {\n  reverseOrder: function () {\n    return {\n      compare (a, b) {\n        return b.compareTo(a)\n      }\n    }\n  },\n  min: function (l) {\n    Collections.sort(l)\n    return l.get(0)\n  },\n  sort: function (l, c) {\n    const a = l.toArray()\n    if (c) {\n      Arrays.sort(a, c)\n    } else {\n      Arrays.sort(a)\n    }\n    const i = l.iterator()\n    for (let pos = 0, alen = a.length; pos < alen; pos++) {\n      i.next()\n      i.set(a[pos])\n    }\n  },\n  singletonList: function (o) {\n    const arrayList = new ArrayList()\n    arrayList.add(o)\n    return arrayList\n  }\n}\n\nexport default Collections\n","export default class SegmentIntersector {\n\tconstructor() {\n\t\tSegmentIntersector.constructor_.apply(this, arguments);\n\t}\n\tstatic isAdjacentSegments(i1, i2) {\n\t\treturn Math.abs(i1 - i2) === 1;\n\t}\n\tisTrivialIntersection(e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1) {\n\t\t\tif (this._li.getIntersectionNum() === 1) {\n\t\t\t\tif (SegmentIntersector.isAdjacentSegments(segIndex0, segIndex1)) return true;\n\t\t\t\tif (e0.isClosed()) {\n\t\t\t\t\tvar maxSegIndex = e0.getNumPoints() - 1;\n\t\t\t\t\tif (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tgetProperIntersectionPoint() {\n\t\treturn this._properIntersectionPoint;\n\t}\n\tsetIsDoneIfProperInt(isDoneWhenProperInt) {\n\t\tthis._isDoneWhenProperInt = isDoneWhenProperInt;\n\t}\n\thasProperInteriorIntersection() {\n\t\treturn this._hasProperInterior;\n\t}\n\tisBoundaryPointInternal(li, bdyNodes) {\n\t\tfor (var i = bdyNodes.iterator(); i.hasNext(); ) {\n\t\t\tvar node = i.next();\n\t\t\tvar pt = node.getCoordinate();\n\t\t\tif (li.isIntersection(pt)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\thasProperIntersection() {\n\t\treturn this._hasProper;\n\t}\n\thasIntersection() {\n\t\treturn this._hasIntersection;\n\t}\n\tisDone() {\n\t\treturn this._isDone;\n\t}\n\tisBoundaryPoint(li, bdyNodes) {\n\t\tif (bdyNodes === null) return false;\n\t\tif (this.isBoundaryPointInternal(li, bdyNodes[0])) return true;\n\t\tif (this.isBoundaryPointInternal(li, bdyNodes[1])) return true;\n\t\treturn false;\n\t}\n\tsetBoundaryNodes(bdyNodes0, bdyNodes1) {\n\t\tthis._bdyNodes = new Array(2).fill(null);\n\t\tthis._bdyNodes[0] = bdyNodes0;\n\t\tthis._bdyNodes[1] = bdyNodes1;\n\t}\n\taddIntersections(e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n\t\tthis.numTests++;\n\t\tvar p00 = e0.getCoordinates()[segIndex0];\n\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n\t\tvar p10 = e1.getCoordinates()[segIndex1];\n\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n\t\tthis._li.computeIntersection(p00, p01, p10, p11);\n\t\tif (this._li.hasIntersection()) {\n\t\t\tif (this._recordIsolated) {\n\t\t\t\te0.setIsolated(false);\n\t\t\t\te1.setIsolated(false);\n\t\t\t}\n\t\t\tthis._numIntersections++;\n\t\t\tif (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n\t\t\t\tthis._hasIntersection = true;\n\t\t\t\tif (this._includeProper || !this._li.isProper()) {\n\t\t\t\t\te0.addIntersections(this._li, segIndex0, 0);\n\t\t\t\t\te1.addIntersections(this._li, segIndex1, 1);\n\t\t\t\t}\n\t\t\t\tif (this._li.isProper()) {\n\t\t\t\t\tthis._properIntersectionPoint = this._li.getIntersection(0).copy();\n\t\t\t\t\tthis._hasProper = true;\n\t\t\t\t\tif (this._isDoneWhenProperInt) {\n\t\t\t\t\t\tthis._isDone = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!this.isBoundaryPoint(this._li, this._bdyNodes)) this._hasProperInterior = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn SegmentIntersector;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nSegmentIntersector.constructor_ = function () {\n\tthis._hasIntersection = false;\n\tthis._hasProper = false;\n\tthis._hasProperInterior = false;\n\tthis._properIntersectionPoint = null;\n\tthis._li = null;\n\tthis._includeProper = null;\n\tthis._recordIsolated = null;\n\tthis._isSelfIntersection = null;\n\tthis._numIntersections = 0;\n\tthis.numTests = 0;\n\tthis._bdyNodes = null;\n\tthis._isDone = false;\n\tthis._isDoneWhenProperInt = false;\n\tlet li = arguments[0], includeProper = arguments[1], recordIsolated = arguments[2];\n\tthis._li = li;\n\tthis._includeProper = includeProper;\n\tthis._recordIsolated = recordIsolated;\n};\n","import hasInterface from '../../../../../hasInterface';\nimport MonotoneChain from './MonotoneChain';\nimport SweepLineEvent from './SweepLineEvent';\nimport EdgeSetIntersector from './EdgeSetIntersector';\nimport Collections from '../../../../../java/util/Collections';\nimport SegmentIntersector from './SegmentIntersector';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport List from '../../../../../java/util/List';\nexport default class SimpleMCSweepLineIntersector extends EdgeSetIntersector {\n\tconstructor() {\n\t\tsuper();\n\t\tSimpleMCSweepLineIntersector.constructor_.apply(this, arguments);\n\t}\n\tprepareEvents() {\n\t\tCollections.sort(this.events);\n\t\tfor (var i = 0; i < this.events.size(); i++) {\n\t\t\tvar ev = this.events.get(i);\n\t\t\tif (ev.isDelete()) {\n\t\t\t\tev.getInsertEvent().setDeleteEventIndex(i);\n\t\t\t}\n\t\t}\n\t}\n\tcomputeIntersections() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet si = arguments[0];\n\t\t\tthis.nOverlaps = 0;\n\t\t\tthis.prepareEvents();\n\t\t\tfor (var i = 0; i < this.events.size(); i++) {\n\t\t\t\tvar ev = this.events.get(i);\n\t\t\t\tif (ev.isInsert()) {\n\t\t\t\t\tthis.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);\n\t\t\t\t}\n\t\t\t\tif (si.isDone()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (arguments[2] instanceof SegmentIntersector && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {\n\t\t\t\tlet edges0 = arguments[0], edges1 = arguments[1], si = arguments[2];\n\t\t\t\tthis.addEdges(edges0, edges0);\n\t\t\t\tthis.addEdges(edges1, edges1);\n\t\t\t\tthis.computeIntersections(si);\n\t\t\t} else if (typeof arguments[2] === \"boolean\" && (hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector)) {\n\t\t\t\tlet edges = arguments[0], si = arguments[1], testAllSegments = arguments[2];\n\t\t\t\tif (testAllSegments) this.addEdges(edges, null); else this.addEdges(edges);\n\t\t\t\tthis.computeIntersections(si);\n\t\t\t}\n\t\t}\n\t}\n\taddEdge(edge, edgeSet) {\n\t\tvar mce = edge.getMonotoneChainEdge();\n\t\tvar startIndex = mce.getStartIndexes();\n\t\tfor (var i = 0; i < startIndex.length - 1; i++) {\n\t\t\tvar mc = new MonotoneChain(mce, i);\n\t\t\tvar insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);\n\t\t\tthis.events.add(insertEvent);\n\t\t\tthis.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));\n\t\t}\n\t}\n\tprocessOverlaps(start, end, ev0, si) {\n\t\tvar mc0 = ev0.getObject();\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar ev1 = this.events.get(i);\n\t\t\tif (ev1.isInsert()) {\n\t\t\t\tvar mc1 = ev1.getObject();\n\t\t\t\tif (!ev0.isSameLabel(ev1)) {\n\t\t\t\t\tmc0.computeIntersections(mc1, si);\n\t\t\t\t\tthis.nOverlaps++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taddEdges() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet edges = arguments[0];\n\t\t\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\t\t\tvar edge = i.next();\n\t\t\t\tthis.addEdge(edge, edge);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet edges = arguments[0], edgeSet = arguments[1];\n\t\t\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\t\t\tvar edge = i.next();\n\t\t\t\tthis.addEdge(edge, edgeSet);\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn SimpleMCSweepLineIntersector;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nSimpleMCSweepLineIntersector.constructor_ = function () {\n\tthis.events = new ArrayList();\n\tthis.nOverlaps = null;\n};\n","export default class ItemVisitor {\n\tconstructor() {\n\t\tItemVisitor.constructor_.apply(this, arguments);\n\t}\n\tvisitItem(item) {}\n\tgetClass() {\n\t\treturn ItemVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nItemVisitor.constructor_ = function () {};\n","import WKTWriter from '../../io/WKTWriter';\nimport Coordinate from '../../geom/Coordinate';\nimport Double from '../../../../../java/lang/Double';\nimport Comparator from '../../../../../java/util/Comparator';\nexport default class IntervalRTreeNode {\n\tconstructor() {\n\t\tIntervalRTreeNode.constructor_.apply(this, arguments);\n\t}\n\tgetMin() {\n\t\treturn this._min;\n\t}\n\tintersects(queryMin, queryMax) {\n\t\tif (this._min > queryMax || this._max < queryMin) return false;\n\t\treturn true;\n\t}\n\tgetMax() {\n\t\treturn this._max;\n\t}\n\ttoString() {\n\t\treturn WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0));\n\t}\n\tgetClass() {\n\t\treturn IntervalRTreeNode;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nclass NodeComparator {\n\tconstructor() {\n\t\tNodeComparator.constructor_.apply(this, arguments);\n\t}\n\tcompare(o1, o2) {\n\t\tvar n1 = o1;\n\t\tvar n2 = o2;\n\t\tvar mid1 = (n1._min + n1._max) / 2;\n\t\tvar mid2 = (n2._min + n2._max) / 2;\n\t\tif (mid1 < mid2) return -1;\n\t\tif (mid1 > mid2) return 1;\n\t\treturn 0;\n\t}\n\tgetClass() {\n\t\treturn NodeComparator;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparator];\n\t}\n}\nNodeComparator.constructor_ = function () {};\nIntervalRTreeNode.NodeComparator = NodeComparator;\nIntervalRTreeNode.constructor_ = function () {\n\tthis._min = Double.POSITIVE_INFINITY;\n\tthis._max = Double.NEGATIVE_INFINITY;\n};\n","import IntervalRTreeNode from './IntervalRTreeNode';\nexport default class IntervalRTreeLeafNode extends IntervalRTreeNode {\n\tconstructor() {\n\t\tsuper();\n\t\tIntervalRTreeLeafNode.constructor_.apply(this, arguments);\n\t}\n\tquery(queryMin, queryMax, visitor) {\n\t\tif (!this.intersects(queryMin, queryMax)) return null;\n\t\tvisitor.visitItem(this._item);\n\t}\n\tgetClass() {\n\t\treturn IntervalRTreeLeafNode;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nIntervalRTreeLeafNode.constructor_ = function () {\n\tthis._item = null;\n\tlet min = arguments[0], max = arguments[1], item = arguments[2];\n\tthis._min = min;\n\tthis._max = max;\n\tthis._item = item;\n};\n","import IntervalRTreeNode from './IntervalRTreeNode';\nexport default class IntervalRTreeBranchNode extends IntervalRTreeNode {\n\tconstructor() {\n\t\tsuper();\n\t\tIntervalRTreeBranchNode.constructor_.apply(this, arguments);\n\t}\n\tbuildExtent(n1, n2) {\n\t\tthis._min = Math.min(n1._min, n2._min);\n\t\tthis._max = Math.max(n1._max, n2._max);\n\t}\n\tquery(queryMin, queryMax, visitor) {\n\t\tif (!this.intersects(queryMin, queryMax)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this._node1 !== null) this._node1.query(queryMin, queryMax, visitor);\n\t\tif (this._node2 !== null) this._node2.query(queryMin, queryMax, visitor);\n\t}\n\tgetClass() {\n\t\treturn IntervalRTreeBranchNode;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nIntervalRTreeBranchNode.constructor_ = function () {\n\tthis._node1 = null;\n\tthis._node2 = null;\n\tlet n1 = arguments[0], n2 = arguments[1];\n\tthis._node1 = n1;\n\tthis._node2 = n2;\n\tthis.buildExtent(this._node1, this._node2);\n};\n","import WKTWriter from '../../io/WKTWriter';\nimport Coordinate from '../../geom/Coordinate';\nimport IntervalRTreeLeafNode from './IntervalRTreeLeafNode';\nimport IntervalRTreeNode from './IntervalRTreeNode';\nimport Collections from '../../../../../java/util/Collections';\nimport System from '../../../../../java/lang/System';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport IntervalRTreeBranchNode from './IntervalRTreeBranchNode';\nexport default class SortedPackedIntervalRTree {\n\tconstructor() {\n\t\tSortedPackedIntervalRTree.constructor_.apply(this, arguments);\n\t}\n\tbuildTree() {\n\t\tCollections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());\n\t\tvar src = this._leaves;\n\t\tvar temp = null;\n\t\tvar dest = new ArrayList();\n\t\twhile (true) {\n\t\t\tthis.buildLevel(src, dest);\n\t\t\tif (dest.size() === 1) return dest.get(0);\n\t\t\ttemp = src;\n\t\t\tsrc = dest;\n\t\t\tdest = temp;\n\t\t}\n\t}\n\tinsert(min, max, item) {\n\t\tif (this._root !== null) throw new IllegalStateException(\"Index cannot be added to once it has been queried\");\n\t\tthis._leaves.add(new IntervalRTreeLeafNode(min, max, item));\n\t}\n\tquery(min, max, visitor) {\n\t\tthis.init();\n\t\tthis._root.query(min, max, visitor);\n\t}\n\tbuildRoot() {\n\t\tif (this._root !== null) return null;\n\t\tthis._root = this.buildTree();\n\t}\n\tprintNode(node) {\n\t\tSystem.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));\n\t}\n\tinit() {\n\t\tif (this._root !== null) return null;\n\t\tthis.buildRoot();\n\t}\n\tbuildLevel(src, dest) {\n\t\tthis._level++;\n\t\tdest.clear();\n\t\tfor (var i = 0; i < src.size(); i += 2) {\n\t\t\tvar n1 = src.get(i);\n\t\t\tvar n2 = i + 1 < src.size() ? src.get(i) : null;\n\t\t\tif (n2 === null) {\n\t\t\t\tdest.add(n1);\n\t\t\t} else {\n\t\t\t\tvar node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));\n\t\t\t\tdest.add(node);\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn SortedPackedIntervalRTree;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nSortedPackedIntervalRTree.constructor_ = function () {\n\tthis._leaves = new ArrayList();\n\tthis._root = null;\n\tthis._level = 0;\n};\n","import NotRepresentableException from '../algorithm/NotRepresentableException';\nimport Coordinate from './Coordinate';\nimport Double from '../../../../java/lang/Double';\nimport Orientation from '../algorithm/Orientation';\nimport Comparable from '../../../../java/lang/Comparable';\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector';\nimport HCoordinate from '../algorithm/HCoordinate';\nimport Serializable from '../../../../java/io/Serializable';\nimport Distance from '../algorithm/Distance';\nexport default class LineSegment {\n\tconstructor() {\n\t\tLineSegment.constructor_.apply(this, arguments);\n\t}\n\tstatic midPoint(p0, p1) {\n\t\treturn new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);\n\t}\n\tminX() {\n\t\treturn Math.min(this.p0.x, this.p1.x);\n\t}\n\torientationIndex() {\n\t\tif (arguments[0] instanceof LineSegment) {\n\t\t\tlet seg = arguments[0];\n\t\t\tvar orient0 = Orientation.index(this.p0, this.p1, seg.p0);\n\t\t\tvar orient1 = Orientation.index(this.p0, this.p1, seg.p1);\n\t\t\tif (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1);\n\t\t\tif (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1);\n\t\t\treturn 0;\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\treturn Orientation.index(this.p0, this.p1, p);\n\t\t}\n\t}\n\ttoGeometry(geomFactory) {\n\t\treturn geomFactory.createLineString([this.p0, this.p1]);\n\t}\n\tisVertical() {\n\t\treturn this.p0.x === this.p1.x;\n\t}\n\tequals(o) {\n\t\tif (!(o instanceof LineSegment)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar other = o;\n\t\treturn this.p0.equals(other.p0) && this.p1.equals(other.p1);\n\t}\n\tintersection(line) {\n\t\tvar li = new RobustLineIntersector();\n\t\tli.computeIntersection(this.p0, this.p1, line.p0, line.p1);\n\t\tif (li.hasIntersection()) return li.getIntersection(0);\n\t\treturn null;\n\t}\n\tproject() {\n\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\tif (p.equals(this.p0) || p.equals(this.p1)) return new Coordinate(p);\n\t\t\tvar r = this.projectionFactor(p);\n\t\t\tvar coord = new Coordinate();\n\t\t\tcoord.x = this.p0.x + r * (this.p1.x - this.p0.x);\n\t\t\tcoord.y = this.p0.y + r * (this.p1.y - this.p0.y);\n\t\t\treturn coord;\n\t\t} else if (arguments[0] instanceof LineSegment) {\n\t\t\tlet seg = arguments[0];\n\t\t\tvar pf0 = this.projectionFactor(seg.p0);\n\t\t\tvar pf1 = this.projectionFactor(seg.p1);\n\t\t\tif (pf0 >= 1.0 && pf1 >= 1.0) return null;\n\t\t\tif (pf0 <= 0.0 && pf1 <= 0.0) return null;\n\t\t\tvar newp0 = this.project(seg.p0);\n\t\t\tif (pf0 < 0.0) newp0 = this.p0;\n\t\t\tif (pf0 > 1.0) newp0 = this.p1;\n\t\t\tvar newp1 = this.project(seg.p1);\n\t\t\tif (pf1 < 0.0) newp1 = this.p0;\n\t\t\tif (pf1 > 1.0) newp1 = this.p1;\n\t\t\treturn new LineSegment(newp0, newp1);\n\t\t}\n\t}\n\tnormalize() {\n\t\tif (this.p1.compareTo(this.p0) < 0) this.reverse();\n\t}\n\tangle() {\n\t\treturn Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);\n\t}\n\tgetCoordinate(i) {\n\t\tif (i === 0) return this.p0;\n\t\treturn this.p1;\n\t}\n\tdistancePerpendicular(p) {\n\t\treturn Distance.pointToLinePerpendicular(p, this.p0, this.p1);\n\t}\n\tminY() {\n\t\treturn Math.min(this.p0.y, this.p1.y);\n\t}\n\tmidPoint() {\n\t\treturn LineSegment.midPoint(this.p0, this.p1);\n\t}\n\tprojectionFactor(p) {\n\t\tif (p.equals(this.p0)) return 0.0;\n\t\tif (p.equals(this.p1)) return 1.0;\n\t\tvar dx = this.p1.x - this.p0.x;\n\t\tvar dy = this.p1.y - this.p0.y;\n\t\tvar len = dx * dx + dy * dy;\n\t\tif (len <= 0.0) return Double.NaN;\n\t\tvar r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;\n\t\treturn r;\n\t}\n\tclosestPoints(line) {\n\t\tvar intPt = this.intersection(line);\n\t\tif (intPt !== null) {\n\t\t\treturn [intPt, intPt];\n\t\t}\n\t\tvar closestPt = new Array(2).fill(null);\n\t\tvar minDistance = Double.MAX_VALUE;\n\t\tvar dist = null;\n\t\tvar close00 = this.closestPoint(line.p0);\n\t\tminDistance = close00.distance(line.p0);\n\t\tclosestPt[0] = close00;\n\t\tclosestPt[1] = line.p0;\n\t\tvar close01 = this.closestPoint(line.p1);\n\t\tdist = close01.distance(line.p1);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t\tclosestPt[0] = close01;\n\t\t\tclosestPt[1] = line.p1;\n\t\t}\n\t\tvar close10 = line.closestPoint(this.p0);\n\t\tdist = close10.distance(this.p0);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t\tclosestPt[0] = this.p0;\n\t\t\tclosestPt[1] = close10;\n\t\t}\n\t\tvar close11 = line.closestPoint(this.p1);\n\t\tdist = close11.distance(this.p1);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t\tclosestPt[0] = this.p1;\n\t\t\tclosestPt[1] = close11;\n\t\t}\n\t\treturn closestPt;\n\t}\n\tclosestPoint(p) {\n\t\tvar factor = this.projectionFactor(p);\n\t\tif (factor > 0 && factor < 1) {\n\t\t\treturn this.project(p);\n\t\t}\n\t\tvar dist0 = this.p0.distance(p);\n\t\tvar dist1 = this.p1.distance(p);\n\t\tif (dist0 < dist1) return this.p0;\n\t\treturn this.p1;\n\t}\n\tmaxX() {\n\t\treturn Math.max(this.p0.x, this.p1.x);\n\t}\n\tgetLength() {\n\t\treturn this.p0.distance(this.p1);\n\t}\n\tcompareTo(o) {\n\t\tvar other = o;\n\t\tvar comp0 = this.p0.compareTo(other.p0);\n\t\tif (comp0 !== 0) return comp0;\n\t\treturn this.p1.compareTo(other.p1);\n\t}\n\treverse() {\n\t\tvar temp = this.p0;\n\t\tthis.p0 = this.p1;\n\t\tthis.p1 = temp;\n\t}\n\tequalsTopo(other) {\n\t\treturn this.p0.equals(other.p0) && this.p1.equals(other.p1) || this.p0.equals(other.p1) && this.p1.equals(other.p0);\n\t}\n\tlineIntersection(line) {\n\t\ttry {\n\t\t\tvar intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);\n\t\t\treturn intPt;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof NotRepresentableException) {} else throw ex;\n\t\t} finally {}\n\t\treturn null;\n\t}\n\tmaxY() {\n\t\treturn Math.max(this.p0.y, this.p1.y);\n\t}\n\tpointAlongOffset(segmentLengthFraction, offsetDistance) {\n\t\tvar segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n\t\tvar segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n\t\tvar dx = this.p1.x - this.p0.x;\n\t\tvar dy = this.p1.y - this.p0.y;\n\t\tvar len = Math.sqrt(dx * dx + dy * dy);\n\t\tvar ux = 0.0;\n\t\tvar uy = 0.0;\n\t\tif (offsetDistance !== 0.0) {\n\t\t\tif (len <= 0.0) throw new IllegalStateException(\"Cannot compute offset from zero-length line segment\");\n\t\t\tux = offsetDistance * dx / len;\n\t\t\tuy = offsetDistance * dy / len;\n\t\t}\n\t\tvar offsetx = segx - uy;\n\t\tvar offsety = segy + ux;\n\t\tvar coord = new Coordinate(offsetx, offsety);\n\t\treturn coord;\n\t}\n\tsetCoordinates() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet ls = arguments[0];\n\t\t\tthis.setCoordinates(ls.p0, ls.p1);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\t\tthis.p0.x = p0.x;\n\t\t\tthis.p0.y = p0.y;\n\t\t\tthis.p1.x = p1.x;\n\t\t\tthis.p1.y = p1.y;\n\t\t}\n\t}\n\tsegmentFraction(inputPt) {\n\t\tvar segFrac = this.projectionFactor(inputPt);\n\t\tif (segFrac < 0.0) segFrac = 0.0; else if (segFrac > 1.0 || Double.isNaN(segFrac)) segFrac = 1.0;\n\t\treturn segFrac;\n\t}\n\ttoString() {\n\t\treturn \"LINESTRING( \" + this.p0.x + \" \" + this.p0.y + \", \" + this.p1.x + \" \" + this.p1.y + \")\";\n\t}\n\tisHorizontal() {\n\t\treturn this.p0.y === this.p1.y;\n\t}\n\tdistance() {\n\t\tif (arguments[0] instanceof LineSegment) {\n\t\t\tlet ls = arguments[0];\n\t\t\treturn Distance.segmentToSegment(this.p0, this.p1, ls.p0, ls.p1);\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\treturn Distance.pointToSegment(p, this.p0, this.p1);\n\t\t}\n\t}\n\tpointAlong(segmentLengthFraction) {\n\t\tvar coord = new Coordinate();\n\t\tcoord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n\t\tcoord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n\t\treturn coord;\n\t}\n\thashCode() {\n\t\tvar bits0 = java.lang.Double.doubleToLongBits(this.p0.x);\n\t\tbits0 ^= java.lang.Double.doubleToLongBits(this.p0.y) * 31;\n\t\tvar hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);\n\t\tvar bits1 = java.lang.Double.doubleToLongBits(this.p1.x);\n\t\tbits1 ^= java.lang.Double.doubleToLongBits(this.p1.y) * 31;\n\t\tvar hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);\n\t\treturn hash0 ^ hash1;\n\t}\n\tgetClass() {\n\t\treturn LineSegment;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparable, Serializable];\n\t}\n}\nLineSegment.constructor_ = function () {\n\tthis.p0 = null;\n\tthis.p1 = null;\n\tif (arguments.length === 0) {\n\t\tLineSegment.constructor_.call(this, new Coordinate(), new Coordinate());\n\t} else if (arguments.length === 1) {\n\t\tlet ls = arguments[0];\n\t\tLineSegment.constructor_.call(this, ls.p0, ls.p1);\n\t} else if (arguments.length === 2) {\n\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\tthis.p0 = p0;\n\t\tthis.p1 = p1;\n\t} else if (arguments.length === 4) {\n\t\tlet x0 = arguments[0], y0 = arguments[1], x1 = arguments[2], y1 = arguments[3];\n\t\tLineSegment.constructor_.call(this, new Coordinate(x0, y0), new Coordinate(x1, y1));\n\t}\n};\nLineSegment.serialVersionUID = 3252005833466256227;\n","import LineString from '../LineString';\nimport Geometry from '../Geometry';\nimport hasInterface from '../../../../../hasInterface';\nimport Collection from '../../../../../java/util/Collection';\nimport LinearRing from '../LinearRing';\nimport GeometryComponentFilter from '../GeometryComponentFilter';\nimport ArrayList from '../../../../../java/util/ArrayList';\nexport default class LinearComponentExtracter {\n\tconstructor() {\n\t\tLinearComponentExtracter.constructor_.apply(this, arguments);\n\t}\n\tstatic getGeometry() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet geom = arguments[0];\n\t\t\treturn geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet geom = arguments[0], forceToLineString = arguments[1];\n\t\t\treturn geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom, forceToLineString));\n\t\t}\n\t}\n\tstatic getLines() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet geom = arguments[0];\n\t\t\treturn LinearComponentExtracter.getLines(geom, false);\n\t\t} else if (arguments.length === 2) {\n\t\t\tif (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n\t\t\t\tlet geoms = arguments[0], lines = arguments[1];\n\t\t\t\tfor (var i = geoms.iterator(); i.hasNext(); ) {\n\t\t\t\t\tvar g = i.next();\n\t\t\t\t\tLinearComponentExtracter.getLines(g, lines);\n\t\t\t\t}\n\t\t\t\treturn lines;\n\t\t\t} else if (arguments[0] instanceof Geometry && typeof arguments[1] === \"boolean\") {\n\t\t\t\tlet geom = arguments[0], forceToLineString = arguments[1];\n\t\t\t\tvar lines = new ArrayList();\n\t\t\t\tgeom.apply(new LinearComponentExtracter(lines, forceToLineString));\n\t\t\t\treturn lines;\n\t\t\t} else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n\t\t\t\tlet geom = arguments[0], lines = arguments[1];\n\t\t\t\tif (geom instanceof LineString) {\n\t\t\t\t\tlines.add(geom);\n\t\t\t\t} else {\n\t\t\t\t\tgeom.apply(new LinearComponentExtracter(lines));\n\t\t\t\t}\n\t\t\t\treturn lines;\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (typeof arguments[2] === \"boolean\" && (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection))) {\n\t\t\t\tlet geoms = arguments[0], lines = arguments[1], forceToLineString = arguments[2];\n\t\t\t\tfor (var i = geoms.iterator(); i.hasNext(); ) {\n\t\t\t\t\tvar g = i.next();\n\t\t\t\t\tLinearComponentExtracter.getLines(g, lines, forceToLineString);\n\t\t\t\t}\n\t\t\t\treturn lines;\n\t\t\t} else if (typeof arguments[2] === \"boolean\" && (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection))) {\n\t\t\t\tlet geom = arguments[0], lines = arguments[1], forceToLineString = arguments[2];\n\t\t\t\tgeom.apply(new LinearComponentExtracter(lines, forceToLineString));\n\t\t\t\treturn lines;\n\t\t\t}\n\t\t}\n\t}\n\tfilter(geom) {\n\t\tif (this._isForcedToLineString && geom instanceof LinearRing) {\n\t\t\tvar line = geom.getFactory().createLineString(geom.getCoordinateSequence());\n\t\t\tthis._lines.add(line);\n\t\t\treturn null;\n\t\t}\n\t\tif (geom instanceof LineString) this._lines.add(geom);\n\t}\n\tsetForceToLineString(isForcedToLineString) {\n\t\tthis._isForcedToLineString = isForcedToLineString;\n\t}\n\tgetClass() {\n\t\treturn LinearComponentExtracter;\n\t}\n\tget interfaces_() {\n\t\treturn [GeometryComponentFilter];\n\t}\n}\nLinearComponentExtracter.constructor_ = function () {\n\tthis._lines = null;\n\tthis._isForcedToLineString = false;\n\tif (arguments.length === 1) {\n\t\tlet lines = arguments[0];\n\t\tthis._lines = lines;\n\t} else if (arguments.length === 2) {\n\t\tlet lines = arguments[0], isForcedToLineString = arguments[1];\n\t\tthis._lines = lines;\n\t\tthis._isForcedToLineString = isForcedToLineString;\n\t}\n};\n","import ItemVisitor from './ItemVisitor';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default class ArrayListVisitor {\n\tconstructor() {\n\t\tArrayListVisitor.constructor_.apply(this, arguments);\n\t}\n\tvisitItem(item) {\n\t\tthis._items.add(item);\n\t}\n\tgetItems() {\n\t\treturn this._items;\n\t}\n\tgetClass() {\n\t\treturn ArrayListVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [ItemVisitor];\n\t}\n}\nArrayListVisitor.constructor_ = function () {\n\tthis._items = new ArrayList();\n};\n","import hasInterface from '../../../../../hasInterface';\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport ItemVisitor from '../../index/ItemVisitor';\nimport PointOnGeometryLocator from './PointOnGeometryLocator';\nimport LinearRing from '../../geom/LinearRing';\nimport SortedPackedIntervalRTree from '../../index/intervalrtree/SortedPackedIntervalRTree';\nimport LineSegment from '../../geom/LineSegment';\nimport Polygonal from '../../geom/Polygonal';\nimport LinearComponentExtracter from '../../geom/util/LinearComponentExtracter';\nimport ArrayListVisitor from '../../index/ArrayListVisitor';\nimport RayCrossingCounter from '../RayCrossingCounter';\nexport default class IndexedPointInAreaLocator {\n\tconstructor() {\n\t\tIndexedPointInAreaLocator.constructor_.apply(this, arguments);\n\t}\n\tlocate(p) {\n\t\tvar rcc = new RayCrossingCounter(p);\n\t\tvar visitor = new SegmentVisitor(rcc);\n\t\tthis._index.query(p.y, p.y, visitor);\n\t\treturn rcc.getLocation();\n\t}\n\tgetClass() {\n\t\treturn IndexedPointInAreaLocator;\n\t}\n\tget interfaces_() {\n\t\treturn [PointOnGeometryLocator];\n\t}\n}\nclass SegmentVisitor {\n\tconstructor() {\n\t\tSegmentVisitor.constructor_.apply(this, arguments);\n\t}\n\tvisitItem(item) {\n\t\tvar seg = item;\n\t\tthis._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));\n\t}\n\tgetClass() {\n\t\treturn SegmentVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [ItemVisitor];\n\t}\n}\nSegmentVisitor.constructor_ = function () {\n\tthis._counter = null;\n\tlet counter = arguments[0];\n\tthis._counter = counter;\n};\nclass IntervalIndexedGeometry {\n\tconstructor() {\n\t\tIntervalIndexedGeometry.constructor_.apply(this, arguments);\n\t}\n\tinit(geom) {\n\t\tvar lines = LinearComponentExtracter.getLines(geom);\n\t\tfor (var i = lines.iterator(); i.hasNext(); ) {\n\t\t\tvar line = i.next();\n\t\t\tvar pts = line.getCoordinates();\n\t\t\tthis.addLine(pts);\n\t\t}\n\t}\n\taddLine(pts) {\n\t\tfor (var i = 1; i < pts.length; i++) {\n\t\t\tvar seg = new LineSegment(pts[i - 1], pts[i]);\n\t\t\tvar min = Math.min(seg.p0.y, seg.p1.y);\n\t\t\tvar max = Math.max(seg.p0.y, seg.p1.y);\n\t\t\tthis._index.insert(min, max, seg);\n\t\t}\n\t}\n\tquery() {\n\t\tif (arguments.length === 2) {\n\t\t\tlet min = arguments[0], max = arguments[1];\n\t\t\tvar visitor = new ArrayListVisitor();\n\t\t\tthis._index.query(min, max, visitor);\n\t\t\treturn visitor.getItems();\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet min = arguments[0], max = arguments[1], visitor = arguments[2];\n\t\t\tthis._index.query(min, max, visitor);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn IntervalIndexedGeometry;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nIntervalIndexedGeometry.constructor_ = function () {\n\tthis._index = new SortedPackedIntervalRTree();\n\tlet geom = arguments[0];\n\tthis.init(geom);\n};\nIndexedPointInAreaLocator.SegmentVisitor = SegmentVisitor;\nIndexedPointInAreaLocator.IntervalIndexedGeometry = IntervalIndexedGeometry;\nIndexedPointInAreaLocator.constructor_ = function () {\n\tthis._index = null;\n\tlet g = arguments[0];\n\tif (!(hasInterface(g, Polygonal) || g instanceof LinearRing)) throw new IllegalArgumentException(\"Argument must be Polygonal or LinearRing\");\n\tthis._index = new IntervalIndexedGeometry(g);\n};\n","import Coordinate from '../geom/Coordinate';\nimport Comparable from '../../../../java/lang/Comparable';\nexport default class EdgeIntersection {\n\tconstructor() {\n\t\tEdgeIntersection.constructor_.apply(this, arguments);\n\t}\n\tgetSegmentIndex() {\n\t\treturn this.segmentIndex;\n\t}\n\tgetCoordinate() {\n\t\treturn this.coord;\n\t}\n\tprint(out) {\n\t\tout.print(this.coord);\n\t\tout.print(\" seg # = \" + this.segmentIndex);\n\t\tout.println(\" dist = \" + this.dist);\n\t}\n\tcompareTo(obj) {\n\t\tvar other = obj;\n\t\treturn this.compare(other.segmentIndex, other.dist);\n\t}\n\tisEndPoint(maxSegmentIndex) {\n\t\tif (this.segmentIndex === 0 && this.dist === 0.0) return true;\n\t\tif (this.segmentIndex === maxSegmentIndex) return true;\n\t\treturn false;\n\t}\n\ttoString() {\n\t\treturn this.coord + \" seg # = \" + this.segmentIndex + \" dist = \" + this.dist;\n\t}\n\tgetDistance() {\n\t\treturn this.dist;\n\t}\n\tcompare(segmentIndex, dist) {\n\t\tif (this.segmentIndex < segmentIndex) return -1;\n\t\tif (this.segmentIndex > segmentIndex) return 1;\n\t\tif (this.dist < dist) return -1;\n\t\tif (this.dist > dist) return 1;\n\t\treturn 0;\n\t}\n\tgetClass() {\n\t\treturn EdgeIntersection;\n\t}\n\tget interfaces_() {\n\t\treturn [Comparable];\n\t}\n}\nEdgeIntersection.constructor_ = function () {\n\tthis.coord = null;\n\tthis.segmentIndex = null;\n\tthis.dist = null;\n\tlet coord = arguments[0], segmentIndex = arguments[1], dist = arguments[2];\n\tthis.coord = new Coordinate(coord);\n\tthis.segmentIndex = segmentIndex;\n\tthis.dist = dist;\n};\n","import EdgeIntersection from './EdgeIntersection';\nimport Coordinate from '../geom/Coordinate';\nimport Label from './Label';\nimport Edge from './Edge';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default class EdgeIntersectionList {\n\tconstructor() {\n\t\tEdgeIntersectionList.constructor_.apply(this, arguments);\n\t}\n\tprint(out) {\n\t\tout.println(\"Intersections:\");\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ei = it.next();\n\t\t\tei.print(out);\n\t\t}\n\t}\n\titerator() {\n\t\treturn this._nodeMap.values().iterator();\n\t}\n\taddSplitEdges(edgeList) {\n\t\tthis.addEndpoints();\n\t\tvar it = this.iterator();\n\t\tvar eiPrev = it.next();\n\t\twhile (it.hasNext()) {\n\t\t\tvar ei = it.next();\n\t\t\tvar newEdge = this.createSplitEdge(eiPrev, ei);\n\t\t\tedgeList.add(newEdge);\n\t\t\teiPrev = ei;\n\t\t}\n\t}\n\taddEndpoints() {\n\t\tvar maxSegIndex = this.edge.pts.length - 1;\n\t\tthis.add(this.edge.pts[0], 0, 0.0);\n\t\tthis.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);\n\t}\n\tcreateSplitEdge(ei0, ei1) {\n\t\tvar npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n\t\tvar lastSegStartPt = this.edge.pts[ei1.segmentIndex];\n\t\tvar useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);\n\t\tif (!useIntPt1) {\n\t\t\tnpts--;\n\t\t}\n\t\tvar pts = new Array(npts).fill(null);\n\t\tvar ipt = 0;\n\t\tpts[ipt++] = new Coordinate(ei0.coord);\n\t\tfor (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n\t\t\tpts[ipt++] = this.edge.pts[i];\n\t\t}\n\t\tif (useIntPt1) pts[ipt] = ei1.coord;\n\t\treturn new Edge(pts, new Label(this.edge._label));\n\t}\n\tadd(intPt, segmentIndex, dist) {\n\t\tvar eiNew = new EdgeIntersection(intPt, segmentIndex, dist);\n\t\tvar ei = this._nodeMap.get(eiNew);\n\t\tif (ei !== null) {\n\t\t\treturn ei;\n\t\t}\n\t\tthis._nodeMap.put(eiNew, eiNew);\n\t\treturn eiNew;\n\t}\n\tisIntersection(pt) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ei = it.next();\n\t\t\tif (ei.coord.equals(pt)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\tgetClass() {\n\t\treturn EdgeIntersectionList;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdgeIntersectionList.constructor_ = function () {\n\tthis._nodeMap = new TreeMap();\n\tthis.edge = null;\n\tlet edge = arguments[0];\n\tthis.edge = edge;\n};\n","import Integer from '../../../../../java/lang/Integer';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Quadrant from '../Quadrant';\nexport default class MonotoneChainIndexer {\n\tconstructor() {\n\t\tMonotoneChainIndexer.constructor_.apply(this, arguments);\n\t}\n\tstatic toIntArray(list) {\n\t\tvar array = new Array(list.size()).fill(null);\n\t\tfor (var i = 0; i < array.length; i++) {\n\t\t\tarray[i] = list.get(i).intValue();\n\t\t}\n\t\treturn array;\n\t}\n\tgetChainStartIndices(pts) {\n\t\tvar start = 0;\n\t\tvar startIndexList = new ArrayList();\n\t\tstartIndexList.add(new Integer(start));\n\t\tdo {\n\t\t\tvar last = this.findChainEnd(pts, start);\n\t\t\tstartIndexList.add(new Integer(last));\n\t\t\tstart = last;\n\t\t} while (start < pts.length - 1);\n\t\tvar startIndex = MonotoneChainIndexer.toIntArray(startIndexList);\n\t\treturn startIndex;\n\t}\n\tfindChainEnd(pts, start) {\n\t\tvar chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);\n\t\tvar last = start + 1;\n\t\twhile (last < pts.length) {\n\t\t\tvar quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n\t\t\tif (quad !== chainQuad) break;\n\t\t\tlast++;\n\t\t}\n\t\treturn last - 1;\n\t}\n\tgetClass() {\n\t\treturn MonotoneChainIndexer;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nMonotoneChainIndexer.constructor_ = function () {};\n","import MonotoneChainIndexer from './MonotoneChainIndexer';\nimport Envelope from '../../geom/Envelope';\nexport default class MonotoneChainEdge {\n\tconstructor() {\n\t\tMonotoneChainEdge.constructor_.apply(this, arguments);\n\t}\n\tgetCoordinates() {\n\t\treturn this.pts;\n\t}\n\tgetMaxX(chainIndex) {\n\t\tvar x1 = this.pts[this.startIndex[chainIndex]].x;\n\t\tvar x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n\t\treturn x1 > x2 ? x1 : x2;\n\t}\n\tgetMinX(chainIndex) {\n\t\tvar x1 = this.pts[this.startIndex[chainIndex]].x;\n\t\tvar x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n\t\treturn x1 < x2 ? x1 : x2;\n\t}\n\tcomputeIntersectsForChain() {\n\t\tif (arguments.length === 4) {\n\t\t\tlet chainIndex0 = arguments[0], mce = arguments[1], chainIndex1 = arguments[2], si = arguments[3];\n\t\t\tthis.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);\n\t\t} else if (arguments.length === 6) {\n\t\t\tlet start0 = arguments[0], end0 = arguments[1], mce = arguments[2], start1 = arguments[3], end1 = arguments[4], ei = arguments[5];\n\t\t\tif (end0 - start0 === 1 && end1 - start1 === 1) {\n\t\t\t\tei.addIntersections(this.e, start0, mce.e, start1);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!this.overlaps(start0, end0, mce, start1, end1)) return null;\n\t\t\tvar mid0 = Math.trunc((start0 + end0) / 2);\n\t\t\tvar mid1 = Math.trunc((start1 + end1) / 2);\n\t\t\tif (start0 < mid0) {\n\t\t\t\tif (start1 < mid1) this.computeIntersectsForChain(start0, mid0, mce, start1, mid1, ei);\n\t\t\t\tif (mid1 < end1) this.computeIntersectsForChain(start0, mid0, mce, mid1, end1, ei);\n\t\t\t}\n\t\t\tif (mid0 < end0) {\n\t\t\t\tif (start1 < mid1) this.computeIntersectsForChain(mid0, end0, mce, start1, mid1, ei);\n\t\t\t\tif (mid1 < end1) this.computeIntersectsForChain(mid0, end0, mce, mid1, end1, ei);\n\t\t\t}\n\t\t}\n\t}\n\toverlaps(start0, end0, mce, start1, end1) {\n\t\treturn Envelope.intersects(this.pts[start0], this.pts[end0], mce.pts[start1], mce.pts[end1]);\n\t}\n\tgetStartIndexes() {\n\t\treturn this.startIndex;\n\t}\n\tcomputeIntersects(mce, si) {\n\t\tfor (var i = 0; i < this.startIndex.length - 1; i++) {\n\t\t\tfor (var j = 0; j < mce.startIndex.length - 1; j++) {\n\t\t\t\tthis.computeIntersectsForChain(i, mce, j, si);\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn MonotoneChainEdge;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nMonotoneChainEdge.constructor_ = function () {\n\tthis.e = null;\n\tthis.pts = null;\n\tthis.startIndex = null;\n\tlet e = arguments[0];\n\tthis.e = e;\n\tthis.pts = e.getCoordinates();\n\tvar mcb = new MonotoneChainIndexer();\n\tthis.startIndex = mcb.getChainStartIndices(this.pts);\n};\n","import Location from '../geom/Location';\nimport Position from './Position';\nexport default class Depth {\n\tconstructor() {\n\t\tDepth.constructor_.apply(this, arguments);\n\t}\n\tstatic depthAtLocation(location) {\n\t\tif (location === Location.EXTERIOR) return 0;\n\t\tif (location === Location.INTERIOR) return 1;\n\t\treturn Depth.NULL_VALUE;\n\t}\n\tgetDepth(geomIndex, posIndex) {\n\t\treturn this._depth[geomIndex][posIndex];\n\t}\n\tsetDepth(geomIndex, posIndex, depthValue) {\n\t\tthis._depth[geomIndex][posIndex] = depthValue;\n\t}\n\tisNull() {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tfor (var j = 0; j < 3; j++) {\n\t\t\t\t\tif (this._depth[i][j] !== Depth.NULL_VALUE) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet geomIndex = arguments[0];\n\t\t\treturn this._depth[geomIndex][1] === Depth.NULL_VALUE;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1];\n\t\t\treturn this._depth[geomIndex][posIndex] === Depth.NULL_VALUE;\n\t\t}\n\t}\n\tnormalize() {\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (!this.isNull(i)) {\n\t\t\t\tvar minDepth = this._depth[i][1];\n\t\t\t\tif (this._depth[i][2] < minDepth) minDepth = this._depth[i][2];\n\t\t\t\tif (minDepth < 0) minDepth = 0;\n\t\t\t\tfor (var j = 1; j < 3; j++) {\n\t\t\t\t\tvar newValue = 0;\n\t\t\t\t\tif (this._depth[i][j] > minDepth) newValue = 1;\n\t\t\t\t\tthis._depth[i][j] = newValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgetDelta(geomIndex) {\n\t\treturn this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT];\n\t}\n\tgetLocation(geomIndex, posIndex) {\n\t\tif (this._depth[geomIndex][posIndex] <= 0) return Location.EXTERIOR;\n\t\treturn Location.INTERIOR;\n\t}\n\ttoString() {\n\t\treturn \"A: \" + this._depth[0][1] + \",\" + this._depth[0][2] + \" B: \" + this._depth[1][1] + \",\" + this._depth[1][2];\n\t}\n\tadd() {\n\t\tif (arguments.length === 1) {\n\t\t\tlet lbl = arguments[0];\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tfor (var j = 1; j < 3; j++) {\n\t\t\t\t\tvar loc = lbl.getLocation(i, j);\n\t\t\t\t\tif (loc === Location.EXTERIOR || loc === Location.INTERIOR) {\n\t\t\t\t\t\tif (this.isNull(i, j)) {\n\t\t\t\t\t\t\tthis._depth[i][j] = Depth.depthAtLocation(loc);\n\t\t\t\t\t\t} else this._depth[i][j] += Depth.depthAtLocation(loc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2];\n\t\t\tif (location === Location.INTERIOR) this._depth[geomIndex][posIndex]++;\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn Depth;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nDepth.constructor_ = function () {\n\tthis._depth = Array(2).fill().map(() => Array(3));\n\tfor (var i = 0; i < 2; i++) {\n\t\tfor (var j = 0; j < 3; j++) {\n\t\t\tthis._depth[i][j] = Depth.NULL_VALUE;\n\t\t}\n\t}\n};\nDepth.NULL_VALUE = -1;\n","import EdgeIntersectionList from './EdgeIntersectionList';\nimport IntersectionMatrix from '../geom/IntersectionMatrix';\nimport MonotoneChainEdge from './index/MonotoneChainEdge';\nimport Position from './Position';\nimport Coordinate from '../geom/Coordinate';\nimport Label from './Label';\nimport Envelope from '../geom/Envelope';\nimport StringBuilder from '../../../../java/lang/StringBuilder';\nimport Depth from './Depth';\nimport GraphComponent from './GraphComponent';\nexport default class Edge extends GraphComponent {\n\tconstructor() {\n\t\tsuper();\n\t\tEdge.constructor_.apply(this, arguments);\n\t}\n\tstatic updateIM() {\n\t\tif (arguments.length === 2 && (arguments[1] instanceof IntersectionMatrix && arguments[0] instanceof Label)) {\n\t\t\tlet label = arguments[0], im = arguments[1];\n\t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);\n\t\t\tif (label.isArea()) {\n\t\t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);\n\t\t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);\n\t\t\t}\n\t\t} else return super.updateIM.apply(this, arguments);\n\t}\n\tgetDepth() {\n\t\treturn this._depth;\n\t}\n\tgetCollapsedEdge() {\n\t\tvar newPts = new Array(2).fill(null);\n\t\tnewPts[0] = this.pts[0];\n\t\tnewPts[1] = this.pts[1];\n\t\tvar newe = new Edge(newPts, Label.toLineLabel(this._label));\n\t\treturn newe;\n\t}\n\tisIsolated() {\n\t\treturn this._isIsolated;\n\t}\n\tgetCoordinates() {\n\t\treturn this.pts;\n\t}\n\tsetIsolated(isIsolated) {\n\t\tthis._isIsolated = isIsolated;\n\t}\n\tsetName(name) {\n\t\tthis._name = name;\n\t}\n\tequals(o) {\n\t\tif (!(o instanceof Edge)) return false;\n\t\tvar e = o;\n\t\tif (this.pts.length !== e.pts.length) return false;\n\t\tvar isEqualForward = true;\n\t\tvar isEqualReverse = true;\n\t\tvar iRev = this.pts.length;\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (!this.pts[i].equals2D(e.pts[i])) {\n\t\t\t\tisEqualForward = false;\n\t\t\t}\n\t\t\tif (!this.pts[i].equals2D(e.pts[-- iRev])) {\n\t\t\t\tisEqualReverse = false;\n\t\t\t}\n\t\t\tif (!isEqualForward && !isEqualReverse) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tgetCoordinate() {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.pts.length > 0) return this.pts[0];\n\t\t\treturn null;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet i = arguments[0];\n\t\t\treturn this.pts[i];\n\t\t}\n\t}\n\tprint(out) {\n\t\tout.print(\"edge \" + this._name + \": \");\n\t\tout.print(\"LINESTRING (\");\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (i > 0) out.print(\",\");\n\t\t\tout.print(this.pts[i].x + \" \" + this.pts[i].y);\n\t\t}\n\t\tout.print(\")  \" + this._label + \" \" + this._depthDelta);\n\t}\n\tcomputeIM(im) {\n\t\tEdge.updateIM(this._label, im);\n\t}\n\tisCollapsed() {\n\t\tif (!this._label.isArea()) return false;\n\t\tif (this.pts.length !== 3) return false;\n\t\tif (this.pts[0].equals(this.pts[2])) return true;\n\t\treturn false;\n\t}\n\tisClosed() {\n\t\treturn this.pts[0].equals(this.pts[this.pts.length - 1]);\n\t}\n\tgetMaximumSegmentIndex() {\n\t\treturn this.pts.length - 1;\n\t}\n\tgetDepthDelta() {\n\t\treturn this._depthDelta;\n\t}\n\tgetNumPoints() {\n\t\treturn this.pts.length;\n\t}\n\tprintReverse(out) {\n\t\tout.print(\"edge \" + this._name + \": \");\n\t\tfor (var i = this.pts.length - 1; i >= 0; i--) {\n\t\t\tout.print(this.pts[i] + \" \");\n\t\t}\n\t\tout.println(\"\");\n\t}\n\tgetMonotoneChainEdge() {\n\t\tif (this._mce === null) this._mce = new MonotoneChainEdge(this);\n\t\treturn this._mce;\n\t}\n\tgetEnvelope() {\n\t\tif (this._env === null) {\n\t\t\tthis._env = new Envelope();\n\t\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\t\tthis._env.expandToInclude(this.pts[i]);\n\t\t\t}\n\t\t}\n\t\treturn this._env;\n\t}\n\taddIntersection(li, segmentIndex, geomIndex, intIndex) {\n\t\tvar intPt = new Coordinate(li.getIntersection(intIndex));\n\t\tvar normalizedSegmentIndex = segmentIndex;\n\t\tvar dist = li.getEdgeDistance(geomIndex, intIndex);\n\t\tvar nextSegIndex = normalizedSegmentIndex + 1;\n\t\tif (nextSegIndex < this.pts.length) {\n\t\t\tvar nextPt = this.pts[nextSegIndex];\n\t\t\tif (intPt.equals2D(nextPt)) {\n\t\t\t\tnormalizedSegmentIndex = nextSegIndex;\n\t\t\t\tdist = 0.0;\n\t\t\t}\n\t\t}\n\t\tvar ei = this.eiList.add(intPt, normalizedSegmentIndex, dist);\n\t}\n\ttoString() {\n\t\tvar builder = new StringBuilder();\n\t\tbuilder.append(\"edge \" + this._name + \": \");\n\t\tbuilder.append(\"LINESTRING (\");\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (i > 0) builder.append(\",\");\n\t\t\tbuilder.append(this.pts[i].x + \" \" + this.pts[i].y);\n\t\t}\n\t\tbuilder.append(\")  \" + this._label + \" \" + this._depthDelta);\n\t\treturn builder.toString();\n\t}\n\tisPointwiseEqual(e) {\n\t\tif (this.pts.length !== e.pts.length) return false;\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (!this.pts[i].equals2D(e.pts[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tsetDepthDelta(depthDelta) {\n\t\tthis._depthDelta = depthDelta;\n\t}\n\tgetEdgeIntersectionList() {\n\t\treturn this.eiList;\n\t}\n\taddIntersections(li, segmentIndex, geomIndex) {\n\t\tfor (var i = 0; i < li.getIntersectionNum(); i++) {\n\t\t\tthis.addIntersection(li, segmentIndex, geomIndex, i);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn Edge;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdge.constructor_ = function () {\n\tthis.pts = null;\n\tthis._env = null;\n\tthis.eiList = new EdgeIntersectionList(this);\n\tthis._name = null;\n\tthis._mce = null;\n\tthis._isIsolated = true;\n\tthis._depth = new Depth();\n\tthis._depthDelta = 0;\n\tif (arguments.length === 1) {\n\t\tlet pts = arguments[0];\n\t\tEdge.constructor_.call(this, pts, null);\n\t} else if (arguments.length === 2) {\n\t\tlet pts = arguments[0], label = arguments[1];\n\t\tthis.pts = pts;\n\t\tthis._label = label;\n\t}\n};\n","import Location from '../geom/Location';\nimport EdgeEnd from './EdgeEnd';\nimport Position from './Position';\nimport TopologyException from '../geom/TopologyException';\nimport Label from './Label';\nexport default class DirectedEdge extends EdgeEnd {\n\tconstructor() {\n\t\tsuper();\n\t\tDirectedEdge.constructor_.apply(this, arguments);\n\t}\n\tstatic depthFactor(currLocation, nextLocation) {\n\t\tif (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) return 1; else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) return -1;\n\t\treturn 0;\n\t}\n\tgetNextMin() {\n\t\treturn this._nextMin;\n\t}\n\tgetDepth(position) {\n\t\treturn this._depth[position];\n\t}\n\tsetVisited(isVisited) {\n\t\tthis._isVisited = isVisited;\n\t}\n\tcomputeDirectedLabel() {\n\t\tthis._label = new Label(this._edge.getLabel());\n\t\tif (!this._isForward) this._label.flip();\n\t}\n\tgetNext() {\n\t\treturn this._next;\n\t}\n\tsetDepth(position, depthVal) {\n\t\tif (this._depth[position] !== -999) {\n\t\t\tif (this._depth[position] !== depthVal) throw new TopologyException(\"assigned depths do not match\", this.getCoordinate());\n\t\t}\n\t\tthis._depth[position] = depthVal;\n\t}\n\tisInteriorAreaEdge() {\n\t\tvar isInteriorAreaEdge = true;\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (!(this._label.isArea(i) && this._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {\n\t\t\t\tisInteriorAreaEdge = false;\n\t\t\t}\n\t\t}\n\t\treturn isInteriorAreaEdge;\n\t}\n\tsetNextMin(nextMin) {\n\t\tthis._nextMin = nextMin;\n\t}\n\tprint(out) {\n\t\tsuper.print.call(this, out);\n\t\tout.print(\" \" + this._depth[Position.LEFT] + \"/\" + this._depth[Position.RIGHT]);\n\t\tout.print(\" (\" + this.getDepthDelta() + \")\");\n\t\tif (this._isInResult) out.print(\" inResult\");\n\t}\n\tsetMinEdgeRing(minEdgeRing) {\n\t\tthis._minEdgeRing = minEdgeRing;\n\t}\n\tisLineEdge() {\n\t\tvar isLine = this._label.isLine(0) || this._label.isLine(1);\n\t\tvar isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);\n\t\tvar isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);\n\t\treturn isLine && isExteriorIfArea0 && isExteriorIfArea1;\n\t}\n\tsetEdgeRing(edgeRing) {\n\t\tthis._edgeRing = edgeRing;\n\t}\n\tgetMinEdgeRing() {\n\t\treturn this._minEdgeRing;\n\t}\n\tgetDepthDelta() {\n\t\tvar depthDelta = this._edge.getDepthDelta();\n\t\tif (!this._isForward) depthDelta = -depthDelta;\n\t\treturn depthDelta;\n\t}\n\tsetInResult(isInResult) {\n\t\tthis._isInResult = isInResult;\n\t}\n\tgetSym() {\n\t\treturn this._sym;\n\t}\n\tisForward() {\n\t\treturn this._isForward;\n\t}\n\tgetEdge() {\n\t\treturn this._edge;\n\t}\n\tprintEdge(out) {\n\t\tthis.print(out);\n\t\tout.print(\" \");\n\t\tif (this._isForward) this._edge.print(out); else this._edge.printReverse(out);\n\t}\n\tsetSym(de) {\n\t\tthis._sym = de;\n\t}\n\tsetVisitedEdge(isVisited) {\n\t\tthis.setVisited(isVisited);\n\t\tthis._sym.setVisited(isVisited);\n\t}\n\tsetEdgeDepths(position, depth) {\n\t\tvar depthDelta = this.getEdge().getDepthDelta();\n\t\tif (!this._isForward) depthDelta = -depthDelta;\n\t\tvar directionFactor = 1;\n\t\tif (position === Position.LEFT) directionFactor = -1;\n\t\tvar oppositePos = Position.opposite(position);\n\t\tvar delta = depthDelta * directionFactor;\n\t\tvar oppositeDepth = depth + delta;\n\t\tthis.setDepth(position, depth);\n\t\tthis.setDepth(oppositePos, oppositeDepth);\n\t}\n\tgetEdgeRing() {\n\t\treturn this._edgeRing;\n\t}\n\tisInResult() {\n\t\treturn this._isInResult;\n\t}\n\tsetNext(next) {\n\t\tthis._next = next;\n\t}\n\tisVisited() {\n\t\treturn this._isVisited;\n\t}\n\tgetClass() {\n\t\treturn DirectedEdge;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nDirectedEdge.constructor_ = function () {\n\tthis._isForward = null;\n\tthis._isInResult = false;\n\tthis._isVisited = false;\n\tthis._sym = null;\n\tthis._next = null;\n\tthis._nextMin = null;\n\tthis._edgeRing = null;\n\tthis._minEdgeRing = null;\n\tthis._depth = [0, -999, -999];\n\tlet edge = arguments[0], isForward = arguments[1];\n\tEdgeEnd.constructor_.call(this, edge);\n\tthis._isForward = isForward;\n\tif (isForward) {\n\t\tthis.init(edge.getCoordinate(0), edge.getCoordinate(1));\n\t} else {\n\t\tvar n = edge.getNumPoints() - 1;\n\t\tthis.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));\n\t}\n\tthis.computeDirectedLabel();\n};\n","import Node from './Node';\nexport default class NodeFactory {\n\tconstructor() {\n\t\tNodeFactory.constructor_.apply(this, arguments);\n\t}\n\tcreateNode(coord) {\n\t\treturn new Node(coord, null);\n\t}\n\tgetClass() {\n\t\treturn NodeFactory;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nNodeFactory.constructor_ = function () {};\n","import Location from '../geom/Location';\nimport Coordinate from '../geom/Coordinate';\nimport Node from './Node';\nimport NodeMap from './NodeMap';\nimport Orientation from '../algorithm/Orientation';\nimport DirectedEdge from './DirectedEdge';\nimport System from '../../../../java/lang/System';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Quadrant from './Quadrant';\nimport NodeFactory from './NodeFactory';\nexport default class PlanarGraph {\n\tconstructor() {\n\t\tPlanarGraph.constructor_.apply(this, arguments);\n\t}\n\tstatic linkResultDirectedEdges(nodes) {\n\t\tfor (var nodeit = nodes.iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().linkResultDirectedEdges();\n\t\t}\n\t}\n\tprintEdges(out) {\n\t\tout.println(\"Edges:\");\n\t\tfor (var i = 0; i < this._edges.size(); i++) {\n\t\t\tout.println(\"edge \" + i + \":\");\n\t\t\tvar e = this._edges.get(i);\n\t\t\te.print(out);\n\t\t\te.eiList.print(out);\n\t\t}\n\t}\n\tfind(coord) {\n\t\treturn this._nodes.find(coord);\n\t}\n\taddNode() {\n\t\tif (arguments[0] instanceof Node) {\n\t\t\tlet node = arguments[0];\n\t\t\treturn this._nodes.addNode(node);\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet coord = arguments[0];\n\t\t\treturn this._nodes.addNode(coord);\n\t\t}\n\t}\n\tgetNodeIterator() {\n\t\treturn this._nodes.iterator();\n\t}\n\tlinkResultDirectedEdges() {\n\t\tfor (var nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().linkResultDirectedEdges();\n\t\t}\n\t}\n\tdebugPrintln(o) {\n\t\tSystem.out.println(o);\n\t}\n\tisBoundaryNode(geomIndex, coord) {\n\t\tvar node = this._nodes.find(coord);\n\t\tif (node === null) return false;\n\t\tvar label = node.getLabel();\n\t\tif (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) return true;\n\t\treturn false;\n\t}\n\tlinkAllDirectedEdges() {\n\t\tfor (var nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().linkAllDirectedEdges();\n\t\t}\n\t}\n\tmatchInSameDirection(p0, p1, ep0, ep1) {\n\t\tif (!p0.equals(ep0)) return false;\n\t\tif (Orientation.index(p0, p1, ep1) === Orientation.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) return true;\n\t\treturn false;\n\t}\n\tgetEdgeEnds() {\n\t\treturn this._edgeEndList;\n\t}\n\tdebugPrint(o) {\n\t\tSystem.out.print(o);\n\t}\n\tgetEdgeIterator() {\n\t\treturn this._edges.iterator();\n\t}\n\tfindEdgeInSameDirection(p0, p1) {\n\t\tfor (var i = 0; i < this._edges.size(); i++) {\n\t\t\tvar e = this._edges.get(i);\n\t\t\tvar eCoord = e.getCoordinates();\n\t\t\tif (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e;\n\t\t\tif (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e;\n\t\t}\n\t\treturn null;\n\t}\n\tinsertEdge(e) {\n\t\tthis._edges.add(e);\n\t}\n\tfindEdgeEnd(e) {\n\t\tfor (var i = this.getEdgeEnds().iterator(); i.hasNext(); ) {\n\t\t\tvar ee = i.next();\n\t\t\tif (ee.getEdge() === e) return ee;\n\t\t}\n\t\treturn null;\n\t}\n\taddEdges(edgesToAdd) {\n\t\tfor (var it = edgesToAdd.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tthis._edges.add(e);\n\t\t\tvar de1 = new DirectedEdge(e, true);\n\t\t\tvar de2 = new DirectedEdge(e, false);\n\t\t\tde1.setSym(de2);\n\t\t\tde2.setSym(de1);\n\t\t\tthis.add(de1);\n\t\t\tthis.add(de2);\n\t\t}\n\t}\n\tadd(e) {\n\t\tthis._nodes.add(e);\n\t\tthis._edgeEndList.add(e);\n\t}\n\tgetNodes() {\n\t\treturn this._nodes.values();\n\t}\n\tfindEdge(p0, p1) {\n\t\tfor (var i = 0; i < this._edges.size(); i++) {\n\t\t\tvar e = this._edges.get(i);\n\t\t\tvar eCoord = e.getCoordinates();\n\t\t\tif (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e;\n\t\t}\n\t\treturn null;\n\t}\n\tgetClass() {\n\t\treturn PlanarGraph;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nPlanarGraph.constructor_ = function () {\n\tthis._edges = new ArrayList();\n\tthis._nodes = null;\n\tthis._edgeEndList = new ArrayList();\n\tif (arguments.length === 0) {\n\t\tthis._nodes = new NodeMap(new NodeFactory());\n\t} else if (arguments.length === 1) {\n\t\tlet nodeFact = arguments[0];\n\t\tthis._nodes = new NodeMap(nodeFact);\n\t}\n};\n","import PointLocator from '../algorithm/PointLocator';\nimport Location from '../geom/Location';\nimport LineString from '../geom/LineString';\nimport HashMap from '../../../../java/util/HashMap';\nimport Geometry from '../geom/Geometry';\nimport hasInterface from '../../../../hasInterface';\nimport Position from './Position';\nimport Coordinate from '../geom/Coordinate';\nimport Point from '../geom/Point';\nimport Polygon from '../geom/Polygon';\nimport MultiPoint from '../geom/MultiPoint';\nimport SimpleMCSweepLineIntersector from './index/SimpleMCSweepLineIntersector';\nimport LinearRing from '../geom/LinearRing';\nimport BoundaryNodeRule from '../algorithm/BoundaryNodeRule';\nimport Orientation from '../algorithm/Orientation';\nimport SegmentIntersector from './index/SegmentIntersector';\nimport MultiPolygon from '../geom/MultiPolygon';\nimport Label from './Label';\nimport GeometryCollection from '../geom/GeometryCollection';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nimport Polygonal from '../geom/Polygonal';\nimport IndexedPointInAreaLocator from '../algorithm/locate/IndexedPointInAreaLocator';\nimport Assert from '../util/Assert';\nimport Edge from './Edge';\nimport MultiLineString from '../geom/MultiLineString';\nimport PlanarGraph from './PlanarGraph';\nexport default class GeometryGraph extends PlanarGraph {\n\tconstructor() {\n\t\tsuper();\n\t\tGeometryGraph.constructor_.apply(this, arguments);\n\t}\n\tstatic determineBoundary(boundaryNodeRule, boundaryCount) {\n\t\treturn boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR;\n\t}\n\tinsertBoundaryPoint(argIndex, coord) {\n\t\tvar n = this._nodes.addNode(coord);\n\t\tvar lbl = n.getLabel();\n\t\tvar boundaryCount = 1;\n\t\tvar loc = Location.NONE;\n\t\tloc = lbl.getLocation(argIndex, Position.ON);\n\t\tif (loc === Location.BOUNDARY) boundaryCount++;\n\t\tvar newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);\n\t\tlbl.setLocation(argIndex, newLoc);\n\t}\n\tcomputeSelfNodes() {\n\t\tif (arguments.length === 2) {\n\t\t\tlet li = arguments[0], computeRingSelfNodes = arguments[1];\n\t\t\treturn this.computeSelfNodes(li, computeRingSelfNodes, false);\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet li = arguments[0], computeRingSelfNodes = arguments[1], isDoneIfProperInt = arguments[2];\n\t\t\tvar si = new SegmentIntersector(li, true, false);\n\t\t\tsi.setIsDoneIfProperInt(isDoneIfProperInt);\n\t\t\tvar esi = this.createEdgeSetIntersector();\n\t\t\tvar isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;\n\t\t\tvar computeAllSegments = computeRingSelfNodes || !isRings;\n\t\t\tesi.computeIntersections(this._edges, si, computeAllSegments);\n\t\t\tthis.addSelfIntersectionNodes(this._argIndex);\n\t\t\treturn si;\n\t\t}\n\t}\n\tcomputeSplitEdges(edgelist) {\n\t\tfor (var i = this._edges.iterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\te.eiList.addSplitEdges(edgelist);\n\t\t}\n\t}\n\tcomputeEdgeIntersections(g, li, includeProper) {\n\t\tvar si = new SegmentIntersector(li, includeProper, true);\n\t\tsi.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());\n\t\tvar esi = this.createEdgeSetIntersector();\n\t\tesi.computeIntersections(this._edges, g._edges, si);\n\t\treturn si;\n\t}\n\tgetGeometry() {\n\t\treturn this._parentGeom;\n\t}\n\tgetBoundaryNodeRule() {\n\t\treturn this._boundaryNodeRule;\n\t}\n\thasTooFewPoints() {\n\t\treturn this._hasTooFewPoints;\n\t}\n\taddPoint() {\n\t\tif (arguments[0] instanceof Point) {\n\t\t\tlet p = arguments[0];\n\t\t\tvar coord = p.getCoordinate();\n\t\t\tthis.insertPoint(this._argIndex, coord, Location.INTERIOR);\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet pt = arguments[0];\n\t\t\tthis.insertPoint(this._argIndex, pt, Location.INTERIOR);\n\t\t}\n\t}\n\taddPolygon(p) {\n\t\tthis.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);\n\t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n\t\t\tvar hole = p.getInteriorRingN(i);\n\t\t\tthis.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);\n\t\t}\n\t}\n\taddEdge(e) {\n\t\tthis.insertEdge(e);\n\t\tvar coord = e.getCoordinates();\n\t\tthis.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n\t\tthis.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);\n\t}\n\taddLineString(line) {\n\t\tvar coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n\t\tif (coord.length < 2) {\n\t\t\tthis._hasTooFewPoints = true;\n\t\t\tthis._invalidPoint = coord[0];\n\t\t\treturn null;\n\t\t}\n\t\tvar e = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));\n\t\tthis._lineEdgeMap.put(line, e);\n\t\tthis.insertEdge(e);\n\t\tAssert.isTrue(coord.length >= 2, \"found LineString with single point\");\n\t\tthis.insertBoundaryPoint(this._argIndex, coord[0]);\n\t\tthis.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);\n\t}\n\tgetInvalidPoint() {\n\t\treturn this._invalidPoint;\n\t}\n\tgetBoundaryPoints() {\n\t\tvar coll = this.getBoundaryNodes();\n\t\tvar pts = new Array(coll.size()).fill(null);\n\t\tvar i = 0;\n\t\tfor (var it = coll.iterator(); it.hasNext(); ) {\n\t\t\tvar node = it.next();\n\t\t\tpts[i++] = node.getCoordinate().copy();\n\t\t}\n\t\treturn pts;\n\t}\n\tgetBoundaryNodes() {\n\t\tif (this._boundaryNodes === null) this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);\n\t\treturn this._boundaryNodes;\n\t}\n\taddSelfIntersectionNode(argIndex, coord, loc) {\n\t\tif (this.isBoundaryNode(argIndex, coord)) return null;\n\t\tif (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) this.insertBoundaryPoint(argIndex, coord); else this.insertPoint(argIndex, coord, loc);\n\t}\n\taddPolygonRing(lr, cwLeft, cwRight) {\n\t\tif (lr.isEmpty()) return null;\n\t\tvar coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());\n\t\tif (coord.length < 4) {\n\t\t\tthis._hasTooFewPoints = true;\n\t\t\tthis._invalidPoint = coord[0];\n\t\t\treturn null;\n\t\t}\n\t\tvar left = cwLeft;\n\t\tvar right = cwRight;\n\t\tif (Orientation.isCCW(coord)) {\n\t\t\tleft = cwRight;\n\t\t\tright = cwLeft;\n\t\t}\n\t\tvar e = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));\n\t\tthis._lineEdgeMap.put(lr, e);\n\t\tthis.insertEdge(e);\n\t\tthis.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n\t}\n\tinsertPoint(argIndex, coord, onLocation) {\n\t\tvar n = this._nodes.addNode(coord);\n\t\tvar lbl = n.getLabel();\n\t\tif (lbl === null) {\n\t\t\tn._label = new Label(argIndex, onLocation);\n\t\t} else lbl.setLocation(argIndex, onLocation);\n\t}\n\tcreateEdgeSetIntersector() {\n\t\treturn new SimpleMCSweepLineIntersector();\n\t}\n\taddSelfIntersectionNodes(argIndex) {\n\t\tfor (var i = this._edges.iterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n\t\t\tfor (var eiIt = e.eiList.iterator(); eiIt.hasNext(); ) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tthis.addSelfIntersectionNode(argIndex, ei.coord, eLoc);\n\t\t\t}\n\t\t}\n\t}\n\tadd() {\n\t\tif (arguments.length === 1 && arguments[0] instanceof Geometry) {\n\t\t\tlet g = arguments[0];\n\t\t\tif (g.isEmpty()) return null;\n\t\t\tif (g instanceof MultiPolygon) this._useBoundaryDeterminationRule = false;\n\t\t\tif (g instanceof Polygon) this.addPolygon(g); else if (g instanceof LineString) this.addLineString(g); else if (g instanceof Point) this.addPoint(g); else if (g instanceof MultiPoint) this.addCollection(g); else if (g instanceof MultiLineString) this.addCollection(g); else if (g instanceof MultiPolygon) this.addCollection(g); else if (g instanceof GeometryCollection) this.addCollection(g); else throw new UnsupportedOperationException(g.getClass().getName());\n\t\t} else return super.add.apply(this, arguments);\n\t}\n\taddCollection(gc) {\n\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\tvar g = gc.getGeometryN(i);\n\t\t\tthis.add(g);\n\t\t}\n\t}\n\tlocate(pt) {\n\t\tif (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {\n\t\t\tif (this._areaPtLocator === null) {\n\t\t\t\tthis._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);\n\t\t\t}\n\t\t\treturn this._areaPtLocator.locate(pt);\n\t\t}\n\t\treturn this._ptLocator.locate(pt, this._parentGeom);\n\t}\n\tfindEdge() {\n\t\tif (arguments.length === 1 && arguments[0] instanceof LineString) {\n\t\t\tlet line = arguments[0];\n\t\t\treturn this._lineEdgeMap.get(line);\n\t\t} else return super.findEdge.apply(this, arguments);\n\t}\n\tgetClass() {\n\t\treturn GeometryGraph;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGeometryGraph.constructor_ = function () {\n\tthis._parentGeom = null;\n\tthis._lineEdgeMap = new HashMap();\n\tthis._boundaryNodeRule = null;\n\tthis._useBoundaryDeterminationRule = true;\n\tthis._argIndex = null;\n\tthis._boundaryNodes = null;\n\tthis._hasTooFewPoints = false;\n\tthis._invalidPoint = null;\n\tthis._areaPtLocator = null;\n\tthis._ptLocator = new PointLocator();\n\tif (arguments.length === 2) {\n\t\tlet argIndex = arguments[0], parentGeom = arguments[1];\n\t\tGeometryGraph.constructor_.call(this, argIndex, parentGeom, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n\t} else if (arguments.length === 3) {\n\t\tlet argIndex = arguments[0], parentGeom = arguments[1], boundaryNodeRule = arguments[2];\n\t\tthis._argIndex = argIndex;\n\t\tthis._parentGeom = parentGeom;\n\t\tthis._boundaryNodeRule = boundaryNodeRule;\n\t\tif (parentGeom !== null) {\n\t\t\tthis.add(parentGeom);\n\t\t}\n\t}\n};\n","import Location from '../../geom/Location';\nimport EdgeEnd from '../../geomgraph/EdgeEnd';\nimport Position from '../../geomgraph/Position';\nimport GeometryGraph from '../../geomgraph/GeometryGraph';\nimport Label from '../../geomgraph/Label';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Edge from '../../geomgraph/Edge';\nexport default class EdgeEndBundle extends EdgeEnd {\n\tconstructor() {\n\t\tsuper();\n\t\tEdgeEndBundle.constructor_.apply(this, arguments);\n\t}\n\tinsert(e) {\n\t\tthis._edgeEnds.add(e);\n\t}\n\tprint(out) {\n\t\tout.println(\"EdgeEndBundle--> Label: \" + this._label);\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ee = it.next();\n\t\t\tee.print(out);\n\t\t\tout.println();\n\t\t}\n\t}\n\titerator() {\n\t\treturn this._edgeEnds.iterator();\n\t}\n\tgetEdgeEnds() {\n\t\treturn this._edgeEnds;\n\t}\n\tcomputeLabelOn(geomIndex, boundaryNodeRule) {\n\t\tvar boundaryCount = 0;\n\t\tvar foundInterior = false;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar loc = e.getLabel().getLocation(geomIndex);\n\t\t\tif (loc === Location.BOUNDARY) boundaryCount++;\n\t\t\tif (loc === Location.INTERIOR) foundInterior = true;\n\t\t}\n\t\tvar loc = Location.NONE;\n\t\tif (foundInterior) loc = Location.INTERIOR;\n\t\tif (boundaryCount > 0) {\n\t\t\tloc = GeometryGraph.determineBoundary(boundaryNodeRule, boundaryCount);\n\t\t}\n\t\tthis._label.setLocation(geomIndex, loc);\n\t}\n\tcomputeLabelSide(geomIndex, side) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tif (e.getLabel().isArea()) {\n\t\t\t\tvar loc = e.getLabel().getLocation(geomIndex, side);\n\t\t\t\tif (loc === Location.INTERIOR) {\n\t\t\t\t\tthis._label.setLocation(geomIndex, side, Location.INTERIOR);\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (loc === Location.EXTERIOR) this._label.setLocation(geomIndex, side, Location.EXTERIOR);\n\t\t\t}\n\t\t}\n\t}\n\tgetLabel() {\n\t\treturn this._label;\n\t}\n\tcomputeLabelSides(geomIndex) {\n\t\tthis.computeLabelSide(geomIndex, Position.LEFT);\n\t\tthis.computeLabelSide(geomIndex, Position.RIGHT);\n\t}\n\tupdateIM(im) {\n\t\tEdge.updateIM(this._label, im);\n\t}\n\tcomputeLabel(boundaryNodeRule) {\n\t\tvar isArea = false;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tif (e.getLabel().isArea()) isArea = true;\n\t\t}\n\t\tif (isArea) this._label = new Label(Location.NONE, Location.NONE, Location.NONE); else this._label = new Label(Location.NONE);\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tthis.computeLabelOn(i, boundaryNodeRule);\n\t\t\tif (isArea) this.computeLabelSides(i);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn EdgeEndBundle;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdgeEndBundle.constructor_ = function () {\n\tthis._edgeEnds = new ArrayList();\n\tif (arguments.length === 1) {\n\t\tlet e = arguments[0];\n\t\tEdgeEndBundle.constructor_.call(this, null, e);\n\t} else if (arguments.length === 2) {\n\t\tlet boundaryNodeRule = arguments[0], e = arguments[1];\n\t\tEdgeEnd.constructor_.call(this, e.getEdge(), e.getCoordinate(), e.getDirectedCoordinate(), new Label(e.getLabel()));\n\t\tthis.insert(e);\n\t}\n};\n","import EdgeEndStar from '../../geomgraph/EdgeEndStar';\nimport EdgeEndBundle from './EdgeEndBundle';\nexport default class EdgeEndBundleStar extends EdgeEndStar {\n\tconstructor() {\n\t\tsuper();\n\t\tEdgeEndBundleStar.constructor_.apply(this, arguments);\n\t}\n\tupdateIM(im) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar esb = it.next();\n\t\t\tesb.updateIM(im);\n\t\t}\n\t}\n\tinsert(e) {\n\t\tvar eb = this._edgeMap.get(e);\n\t\tif (eb === null) {\n\t\t\teb = new EdgeEndBundle(e);\n\t\t\tthis.insertEdgeEnd(e, eb);\n\t\t} else {\n\t\t\teb.insert(e);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn EdgeEndBundleStar;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEdgeEndBundleStar.constructor_ = function () {};\n","import Node from '../../geomgraph/Node';\nexport default class RelateNode extends Node {\n\tconstructor() {\n\t\tsuper();\n\t\tRelateNode.constructor_.apply(this, arguments);\n\t}\n\tupdateIMFromEdges(im) {\n\t\tthis._edges.updateIM(im);\n\t}\n\tcomputeIM(im) {\n\t\tim.setAtLeastIfValid(this._label.getLocation(0), this._label.getLocation(1), 0);\n\t}\n\tgetClass() {\n\t\treturn RelateNode;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRelateNode.constructor_ = function () {\n\tlet coord = arguments[0], edges = arguments[1];\n\tNode.constructor_.call(this, coord, edges);\n};\n","import EdgeEndBundleStar from './EdgeEndBundleStar';\nimport RelateNode from './RelateNode';\nimport NodeFactory from '../../geomgraph/NodeFactory';\nexport default class RelateNodeFactory extends NodeFactory {\n\tconstructor() {\n\t\tsuper();\n\t\tRelateNodeFactory.constructor_.apply(this, arguments);\n\t}\n\tcreateNode(coord) {\n\t\treturn new RelateNode(coord, new EdgeEndBundleStar());\n\t}\n\tgetClass() {\n\t\treturn RelateNodeFactory;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRelateNodeFactory.constructor_ = function () {};\n","import PointLocator from '../../algorithm/PointLocator';\nimport Location from '../../geom/Location';\nimport IntersectionMatrix from '../../geom/IntersectionMatrix';\nimport EdgeEndBuilder from './EdgeEndBuilder';\nimport NodeMap from '../../geomgraph/NodeMap';\nimport RelateNodeFactory from './RelateNodeFactory';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport RobustLineIntersector from '../../algorithm/RobustLineIntersector';\nimport Assert from '../../util/Assert';\nexport default class RelateComputer {\n\tconstructor() {\n\t\tRelateComputer.constructor_.apply(this, arguments);\n\t}\n\tinsertEdgeEnds(ee) {\n\t\tfor (var i = ee.iterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tthis._nodes.add(e);\n\t\t}\n\t}\n\tcomputeProperIntersectionIM(intersector, im) {\n\t\tvar dimA = this._arg[0].getGeometry().getDimension();\n\t\tvar dimB = this._arg[1].getGeometry().getDimension();\n\t\tvar hasProper = intersector.hasProperIntersection();\n\t\tvar hasProperInterior = intersector.hasProperInteriorIntersection();\n\t\tif (dimA === 2 && dimB === 2) {\n\t\t\tif (hasProper) im.setAtLeast(\"212101212\");\n\t\t} else if (dimA === 2 && dimB === 1) {\n\t\t\tif (hasProper) im.setAtLeast(\"FFF0FFFF2\");\n\t\t\tif (hasProperInterior) im.setAtLeast(\"1FFFFF1FF\");\n\t\t} else if (dimA === 1 && dimB === 2) {\n\t\t\tif (hasProper) im.setAtLeast(\"F0FFFFFF2\");\n\t\t\tif (hasProperInterior) im.setAtLeast(\"1F1FFFFFF\");\n\t\t} else if (dimA === 1 && dimB === 1) {\n\t\t\tif (hasProperInterior) im.setAtLeast(\"0FFFFFFFF\");\n\t\t}\n\t}\n\tlabelIsolatedEdges(thisIndex, targetIndex) {\n\t\tfor (var ei = this._arg[thisIndex].getEdgeIterator(); ei.hasNext(); ) {\n\t\t\tvar e = ei.next();\n\t\t\tif (e.isIsolated()) {\n\t\t\t\tthis.labelIsolatedEdge(e, targetIndex, this._arg[targetIndex].getGeometry());\n\t\t\t\tthis._isolatedEdges.add(e);\n\t\t\t}\n\t\t}\n\t}\n\tlabelIsolatedEdge(e, targetIndex, target) {\n\t\tif (target.getDimension() > 0) {\n\t\t\tvar loc = this._ptLocator.locate(e.getCoordinate(), target);\n\t\t\te.getLabel().setAllLocations(targetIndex, loc);\n\t\t} else {\n\t\t\te.getLabel().setAllLocations(targetIndex, Location.EXTERIOR);\n\t\t}\n\t}\n\tcomputeIM() {\n\t\tvar im = new IntersectionMatrix();\n\t\tim.set(Location.EXTERIOR, Location.EXTERIOR, 2);\n\t\tif (!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal())) {\n\t\t\tthis.computeDisjointIM(im);\n\t\t\treturn im;\n\t\t}\n\t\tthis._arg[0].computeSelfNodes(this._li, false);\n\t\tthis._arg[1].computeSelfNodes(this._li, false);\n\t\tvar intersector = this._arg[0].computeEdgeIntersections(this._arg[1], this._li, false);\n\t\tthis.computeIntersectionNodes(0);\n\t\tthis.computeIntersectionNodes(1);\n\t\tthis.copyNodesAndLabels(0);\n\t\tthis.copyNodesAndLabels(1);\n\t\tthis.labelIsolatedNodes();\n\t\tthis.computeProperIntersectionIM(intersector, im);\n\t\tvar eeBuilder = new EdgeEndBuilder();\n\t\tvar ee0 = eeBuilder.computeEdgeEnds(this._arg[0].getEdgeIterator());\n\t\tthis.insertEdgeEnds(ee0);\n\t\tvar ee1 = eeBuilder.computeEdgeEnds(this._arg[1].getEdgeIterator());\n\t\tthis.insertEdgeEnds(ee1);\n\t\tthis.labelNodeEdges();\n\t\tthis.labelIsolatedEdges(0, 1);\n\t\tthis.labelIsolatedEdges(1, 0);\n\t\tthis.updateIM(im);\n\t\treturn im;\n\t}\n\tlabelNodeEdges() {\n\t\tfor (var ni = this._nodes.iterator(); ni.hasNext(); ) {\n\t\t\tvar node = ni.next();\n\t\t\tnode.getEdges().computeLabelling(this._arg);\n\t\t}\n\t}\n\tcopyNodesAndLabels(argIndex) {\n\t\tfor (var i = this._arg[argIndex].getNodeIterator(); i.hasNext(); ) {\n\t\t\tvar graphNode = i.next();\n\t\t\tvar newNode = this._nodes.addNode(graphNode.getCoordinate());\n\t\t\tnewNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n\t\t}\n\t}\n\tlabelIntersectionNodes(argIndex) {\n\t\tfor (var i = this._arg[argIndex].getEdgeIterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n\t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext(); ) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tvar n = this._nodes.find(ei.coord);\n\t\t\t\tif (n.getLabel().isNull(argIndex)) {\n\t\t\t\t\tif (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex); else n.setLabel(argIndex, Location.INTERIOR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlabelIsolatedNode(n, targetIndex) {\n\t\tvar loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());\n\t\tn.getLabel().setAllLocations(targetIndex, loc);\n\t}\n\tcomputeIntersectionNodes(argIndex) {\n\t\tfor (var i = this._arg[argIndex].getEdgeIterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n\t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext(); ) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tvar n = this._nodes.addNode(ei.coord);\n\t\t\t\tif (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex); else {\n\t\t\t\t\tif (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, Location.INTERIOR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlabelIsolatedNodes() {\n\t\tfor (var ni = this._nodes.iterator(); ni.hasNext(); ) {\n\t\t\tvar n = ni.next();\n\t\t\tvar label = n.getLabel();\n\t\t\tAssert.isTrue(label.getGeometryCount() > 0, \"node with empty label found\");\n\t\t\tif (n.isIsolated()) {\n\t\t\t\tif (label.isNull(0)) this.labelIsolatedNode(n, 0); else this.labelIsolatedNode(n, 1);\n\t\t\t}\n\t\t}\n\t}\n\tupdateIM(im) {\n\t\tfor (var ei = this._isolatedEdges.iterator(); ei.hasNext(); ) {\n\t\t\tvar e = ei.next();\n\t\t\te.updateIM(im);\n\t\t}\n\t\tfor (var ni = this._nodes.iterator(); ni.hasNext(); ) {\n\t\t\tvar node = ni.next();\n\t\t\tnode.updateIM(im);\n\t\t\tnode.updateIMFromEdges(im);\n\t\t}\n\t}\n\tcomputeDisjointIM(im) {\n\t\tvar ga = this._arg[0].getGeometry();\n\t\tif (!ga.isEmpty()) {\n\t\t\tim.set(Location.INTERIOR, Location.EXTERIOR, ga.getDimension());\n\t\t\tim.set(Location.BOUNDARY, Location.EXTERIOR, ga.getBoundaryDimension());\n\t\t}\n\t\tvar gb = this._arg[1].getGeometry();\n\t\tif (!gb.isEmpty()) {\n\t\t\tim.set(Location.EXTERIOR, Location.INTERIOR, gb.getDimension());\n\t\t\tim.set(Location.EXTERIOR, Location.BOUNDARY, gb.getBoundaryDimension());\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn RelateComputer;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRelateComputer.constructor_ = function () {\n\tthis._li = new RobustLineIntersector();\n\tthis._ptLocator = new PointLocator();\n\tthis._arg = null;\n\tthis._nodes = new NodeMap(new RelateNodeFactory());\n\tthis._im = null;\n\tthis._isolatedEdges = new ArrayList();\n\tthis._invalidPoint = null;\n\tlet arg = arguments[0];\n\tthis._arg = arg;\n};\n","import BoundaryNodeRule from '../algorithm/BoundaryNodeRule';\nimport GeometryGraph from '../geomgraph/GeometryGraph';\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector';\nexport default class GeometryGraphOperation {\n\tconstructor() {\n\t\tGeometryGraphOperation.constructor_.apply(this, arguments);\n\t}\n\tgetArgGeometry(i) {\n\t\treturn this._arg[i].getGeometry();\n\t}\n\tsetComputationPrecision(pm) {\n\t\tthis._resultPrecisionModel = pm;\n\t\tthis._li.setPrecisionModel(this._resultPrecisionModel);\n\t}\n\tgetClass() {\n\t\treturn GeometryGraphOperation;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGeometryGraphOperation.constructor_ = function () {\n\tthis._li = new RobustLineIntersector();\n\tthis._resultPrecisionModel = null;\n\tthis._arg = null;\n\tif (arguments.length === 1) {\n\t\tlet g0 = arguments[0];\n\t\tthis.setComputationPrecision(g0.getPrecisionModel());\n\t\tthis._arg = new Array(1).fill(null);\n\t\tthis._arg[0] = new GeometryGraph(0, g0);\n\t\t;\n\t} else if (arguments.length === 2) {\n\t\tlet g0 = arguments[0], g1 = arguments[1];\n\t\tGeometryGraphOperation.constructor_.call(this, g0, g1, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n\t} else if (arguments.length === 3) {\n\t\tlet g0 = arguments[0], g1 = arguments[1], boundaryNodeRule = arguments[2];\n\t\tif (g0.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) this.setComputationPrecision(g0.getPrecisionModel()); else this.setComputationPrecision(g1.getPrecisionModel());\n\t\tthis._arg = new Array(2).fill(null);\n\t\tthis._arg[0] = new GeometryGraph(0, g0, boundaryNodeRule);\n\t\tthis._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);\n\t}\n};\n","import LineString from '../../geom/LineString';\nimport Coordinate from '../../geom/Coordinate';\nimport Point from '../../geom/Point';\nimport Polygon from '../../geom/Polygon';\nexport default class RectangleContains {\n\tconstructor() {\n\t\tRectangleContains.constructor_.apply(this, arguments);\n\t}\n\tstatic contains(rectangle, b) {\n\t\tvar rc = new RectangleContains(rectangle);\n\t\treturn rc.contains(b);\n\t}\n\tisContainedInBoundary(geom) {\n\t\tif (geom instanceof Polygon) return false;\n\t\tif (geom instanceof Point) return this.isPointContainedInBoundary(geom);\n\t\tif (geom instanceof LineString) return this.isLineStringContainedInBoundary(geom);\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar comp = geom.getGeometryN(i);\n\t\t\tif (!this.isContainedInBoundary(comp)) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tisLineSegmentContainedInBoundary(p0, p1) {\n\t\tif (p0.equals(p1)) return this.isPointContainedInBoundary(p0);\n\t\tif (p0.x === p1.x) {\n\t\t\tif (p0.x === this._rectEnv.getMinX() || p0.x === this._rectEnv.getMaxX()) return true;\n\t\t} else if (p0.y === p1.y) {\n\t\t\tif (p0.y === this._rectEnv.getMinY() || p0.y === this._rectEnv.getMaxY()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\tisLineStringContainedInBoundary(line) {\n\t\tvar seq = line.getCoordinateSequence();\n\t\tvar p0 = new Coordinate();\n\t\tvar p1 = new Coordinate();\n\t\tfor (var i = 0; i < seq.size() - 1; i++) {\n\t\t\tseq.getCoordinate(i, p0);\n\t\t\tseq.getCoordinate(i + 1, p1);\n\t\t\tif (!this.isLineSegmentContainedInBoundary(p0, p1)) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tisPointContainedInBoundary() {\n\t\tif (arguments[0] instanceof Point) {\n\t\t\tlet point = arguments[0];\n\t\t\treturn this.isPointContainedInBoundary(point.getCoordinate());\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet pt = arguments[0];\n\t\t\treturn pt.x === this._rectEnv.getMinX() || pt.x === this._rectEnv.getMaxX() || pt.y === this._rectEnv.getMinY() || pt.y === this._rectEnv.getMaxY();\n\t\t}\n\t}\n\tcontains(geom) {\n\t\tif (!this._rectEnv.contains(geom.getEnvelopeInternal())) return false;\n\t\tif (this.isContainedInBoundary(geom)) return false;\n\t\treturn true;\n\t}\n\tgetClass() {\n\t\treturn RectangleContains;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRectangleContains.constructor_ = function () {\n\tthis._rectEnv = null;\n\tlet rectangle = arguments[0];\n\tthis._rectEnv = rectangle.getEnvelopeInternal();\n};\n","import Coordinate from '../geom/Coordinate';\nimport RobustLineIntersector from './RobustLineIntersector';\nimport Envelope from '../geom/Envelope';\nexport default class RectangleLineIntersector {\n\tconstructor() {\n\t\tRectangleLineIntersector.constructor_.apply(this, arguments);\n\t}\n\tintersects(p0, p1) {\n\t\tvar segEnv = new Envelope(p0, p1);\n\t\tif (!this._rectEnv.intersects(segEnv)) return false;\n\t\tif (this._rectEnv.intersects(p0)) return true;\n\t\tif (this._rectEnv.intersects(p1)) return true;\n\t\tif (p0.compareTo(p1) > 0) {\n\t\t\tvar tmp = p0;\n\t\t\tp0 = p1;\n\t\t\tp1 = tmp;\n\t\t}\n\t\tvar isSegUpwards = false;\n\t\tif (p1.y > p0.y) isSegUpwards = true;\n\t\tif (isSegUpwards) {\n\t\t\tthis._li.computeIntersection(p0, p1, this._diagDown0, this._diagDown1);\n\t\t} else {\n\t\t\tthis._li.computeIntersection(p0, p1, this._diagUp0, this._diagUp1);\n\t\t}\n\t\tif (this._li.hasIntersection()) return true;\n\t\treturn false;\n\t}\n\tgetClass() {\n\t\treturn RectangleLineIntersector;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRectangleLineIntersector.constructor_ = function () {\n\tthis._li = new RobustLineIntersector();\n\tthis._rectEnv = null;\n\tthis._diagUp0 = null;\n\tthis._diagUp1 = null;\n\tthis._diagDown0 = null;\n\tthis._diagDown1 = null;\n\tlet rectEnv = arguments[0];\n\tthis._rectEnv = rectEnv;\n\tthis._diagUp0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMinY());\n\tthis._diagUp1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMaxY());\n\tthis._diagDown0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMaxY());\n\tthis._diagDown1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMinY());\n};\n","import GeometryCollection from '../GeometryCollection';\nexport default class ShortCircuitedGeometryVisitor {\n\tconstructor() {\n\t\tShortCircuitedGeometryVisitor.constructor_.apply(this, arguments);\n\t}\n\tapplyTo(geom) {\n\t\tfor (var i = 0; i < geom.getNumGeometries() && !this._isDone; i++) {\n\t\t\tvar element = geom.getGeometryN(i);\n\t\t\tif (!(element instanceof GeometryCollection)) {\n\t\t\t\tthis.visit(element);\n\t\t\t\tif (this.isDone()) {\n\t\t\t\t\tthis._isDone = true;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else this.applyTo(element);\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn ShortCircuitedGeometryVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nShortCircuitedGeometryVisitor.constructor_ = function () {\n\tthis._isDone = false;\n};\n","import Coordinate from '../../geom/Coordinate';\nimport Polygon from '../../geom/Polygon';\nimport RectangleLineIntersector from '../../algorithm/RectangleLineIntersector';\nimport ShortCircuitedGeometryVisitor from '../../geom/util/ShortCircuitedGeometryVisitor';\nimport SimplePointInAreaLocator from '../../algorithm/locate/SimplePointInAreaLocator';\nimport LinearComponentExtracter from '../../geom/util/LinearComponentExtracter';\nexport default class RectangleIntersects {\n\tconstructor() {\n\t\tRectangleIntersects.constructor_.apply(this, arguments);\n\t}\n\tstatic intersects(rectangle, b) {\n\t\tvar rp = new RectangleIntersects(rectangle);\n\t\treturn rp.intersects(b);\n\t}\n\tintersects(geom) {\n\t\tif (!this._rectEnv.intersects(geom.getEnvelopeInternal())) return false;\n\t\tvar visitor = new EnvelopeIntersectsVisitor(this._rectEnv);\n\t\tvisitor.applyTo(geom);\n\t\tif (visitor.intersects()) return true;\n\t\tvar ecpVisitor = new GeometryContainsPointVisitor(this._rectangle);\n\t\tecpVisitor.applyTo(geom);\n\t\tif (ecpVisitor.containsPoint()) return true;\n\t\tvar riVisitor = new RectangleIntersectsSegmentVisitor(this._rectangle);\n\t\triVisitor.applyTo(geom);\n\t\tif (riVisitor.intersects()) return true;\n\t\treturn false;\n\t}\n\tgetClass() {\n\t\treturn RectangleIntersects;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRectangleIntersects.constructor_ = function () {\n\tthis._rectangle = null;\n\tthis._rectEnv = null;\n\tlet rectangle = arguments[0];\n\tthis._rectangle = rectangle;\n\tthis._rectEnv = rectangle.getEnvelopeInternal();\n};\nclass EnvelopeIntersectsVisitor extends ShortCircuitedGeometryVisitor {\n\tconstructor() {\n\t\tsuper();\n\t\tEnvelopeIntersectsVisitor.constructor_.apply(this, arguments);\n\t}\n\tisDone() {\n\t\treturn this._intersects === true;\n\t}\n\tvisit(element) {\n\t\tvar elementEnv = element.getEnvelopeInternal();\n\t\tif (!this._rectEnv.intersects(elementEnv)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this._rectEnv.contains(elementEnv)) {\n\t\t\tthis._intersects = true;\n\t\t\treturn null;\n\t\t}\n\t\tif (elementEnv.getMinX() >= this._rectEnv.getMinX() && elementEnv.getMaxX() <= this._rectEnv.getMaxX()) {\n\t\t\tthis._intersects = true;\n\t\t\treturn null;\n\t\t}\n\t\tif (elementEnv.getMinY() >= this._rectEnv.getMinY() && elementEnv.getMaxY() <= this._rectEnv.getMaxY()) {\n\t\t\tthis._intersects = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\tintersects() {\n\t\treturn this._intersects;\n\t}\n\tgetClass() {\n\t\treturn EnvelopeIntersectsVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nEnvelopeIntersectsVisitor.constructor_ = function () {\n\tthis._rectEnv = null;\n\tthis._intersects = false;\n\tlet rectEnv = arguments[0];\n\tthis._rectEnv = rectEnv;\n};\nclass GeometryContainsPointVisitor extends ShortCircuitedGeometryVisitor {\n\tconstructor() {\n\t\tsuper();\n\t\tGeometryContainsPointVisitor.constructor_.apply(this, arguments);\n\t}\n\tisDone() {\n\t\treturn this._containsPoint === true;\n\t}\n\tvisit(geom) {\n\t\tif (!(geom instanceof Polygon)) return null;\n\t\tvar elementEnv = geom.getEnvelopeInternal();\n\t\tif (!this._rectEnv.intersects(elementEnv)) return null;\n\t\tvar rectPt = new Coordinate();\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tthis._rectSeq.getCoordinate(i, rectPt);\n\t\t\tif (!elementEnv.contains(rectPt)) continue;\n\t\t\tif (SimplePointInAreaLocator.containsPointInPolygon(rectPt, geom)) {\n\t\t\t\tthis._containsPoint = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\tcontainsPoint() {\n\t\treturn this._containsPoint;\n\t}\n\tgetClass() {\n\t\treturn GeometryContainsPointVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nGeometryContainsPointVisitor.constructor_ = function () {\n\tthis._rectSeq = null;\n\tthis._rectEnv = null;\n\tthis._containsPoint = false;\n\tlet rectangle = arguments[0];\n\tthis._rectSeq = rectangle.getExteriorRing().getCoordinateSequence();\n\tthis._rectEnv = rectangle.getEnvelopeInternal();\n};\nclass RectangleIntersectsSegmentVisitor extends ShortCircuitedGeometryVisitor {\n\tconstructor() {\n\t\tsuper();\n\t\tRectangleIntersectsSegmentVisitor.constructor_.apply(this, arguments);\n\t}\n\tintersects() {\n\t\treturn this._hasIntersection;\n\t}\n\tisDone() {\n\t\treturn this._hasIntersection === true;\n\t}\n\tvisit(geom) {\n\t\tvar elementEnv = geom.getEnvelopeInternal();\n\t\tif (!this._rectEnv.intersects(elementEnv)) return null;\n\t\tvar lines = LinearComponentExtracter.getLines(geom);\n\t\tthis.checkIntersectionWithLineStrings(lines);\n\t}\n\tcheckIntersectionWithLineStrings(lines) {\n\t\tfor (var i = lines.iterator(); i.hasNext(); ) {\n\t\t\tvar testLine = i.next();\n\t\t\tthis.checkIntersectionWithSegments(testLine);\n\t\t\tif (this._hasIntersection) return null;\n\t\t}\n\t}\n\tcheckIntersectionWithSegments(testLine) {\n\t\tvar seq1 = testLine.getCoordinateSequence();\n\t\tfor (var j = 1; j < seq1.size(); j++) {\n\t\t\tseq1.getCoordinate(j - 1, this._p0);\n\t\t\tseq1.getCoordinate(j, this._p1);\n\t\t\tif (this._rectIntersector.intersects(this._p0, this._p1)) {\n\t\t\t\tthis._hasIntersection = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\tgetClass() {\n\t\treturn RectangleIntersectsSegmentVisitor;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRectangleIntersectsSegmentVisitor.constructor_ = function () {\n\tthis._rectEnv = null;\n\tthis._rectIntersector = null;\n\tthis._hasIntersection = false;\n\tthis._p0 = new Coordinate();\n\tthis._p1 = new Coordinate();\n\tlet rectangle = arguments[0];\n\tthis._rectEnv = rectangle.getEnvelopeInternal();\n\tthis._rectIntersector = new RectangleLineIntersector(this._rectEnv);\n};\n","import RelateComputer from './RelateComputer';\nimport GeometryGraphOperation from '../GeometryGraphOperation';\nimport RectangleContains from '../predicate/RectangleContains';\nimport RectangleIntersects from '../predicate/RectangleIntersects';\nexport default class RelateOp extends GeometryGraphOperation {\n\tconstructor() {\n\t\tsuper();\n\t\tRelateOp.constructor_.apply(this, arguments);\n\t}\n\tstatic covers(g1, g2) {\n\t\tif (g2.getDimension() === 2 && g1.getDimension() < 2) {\n\t\t\treturn false;\n\t\t}\n\t\tif (g2.getDimension() === 1 && g1.getDimension() < 1 && g2.getLength() > 0.0) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!g1.getEnvelopeInternal().covers(g2.getEnvelopeInternal())) return false;\n\t\tif (g1.isRectangle()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn new RelateOp(g1, g2).getIntersectionMatrix().isCovers();\n\t}\n\tstatic intersects(g1, g2) {\n\t\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\t\tif (g1.isRectangle()) {\n\t\t\treturn RectangleIntersects.intersects(g1, g2);\n\t\t}\n\t\tif (g2.isRectangle()) {\n\t\t\treturn RectangleIntersects.intersects(g2, g1);\n\t\t}\n\t\tif (g1.isGeometryCollection() || g2.isGeometryCollection()) {\n\t\t\tvar r = false;\n\t\t\tfor (var i = 0; i < g1.getNumGeometries(); i++) {\n\t\t\t\tfor (var j = 0; j < g2.getNumGeometries(); j++) {\n\t\t\t\t\tif (g1.getGeometryN(i).intersects(g2.getGeometryN(j))) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn new RelateOp(g1, g2).getIntersectionMatrix().isIntersects();\n\t}\n\tstatic touches(g1, g2) {\n\t\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\t\treturn new RelateOp(g1, g2).getIntersectionMatrix().isTouches(g1.getDimension(), g2.getDimension());\n\t}\n\tstatic relate() {\n\t\tif (arguments.length === 2) {\n\t\t\tlet a = arguments[0], b = arguments[1];\n\t\t\tvar relOp = new RelateOp(a, b);\n\t\t\tvar im = relOp.getIntersectionMatrix();\n\t\t\treturn im;\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet a = arguments[0], b = arguments[1], boundaryNodeRule = arguments[2];\n\t\t\tvar relOp = new RelateOp(a, b, boundaryNodeRule);\n\t\t\tvar im = relOp.getIntersectionMatrix();\n\t\t\treturn im;\n\t\t}\n\t}\n\tstatic overlaps(g1, g2) {\n\t\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\t\treturn new RelateOp(g1, g2).getIntersectionMatrix().isOverlaps(g1.getDimension(), g2.getDimension());\n\t}\n\tstatic crosses(g1, g2) {\n\t\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\t\treturn new RelateOp(g1, g2).getIntersectionMatrix().isCrosses(g1.getDimension(), g2.getDimension());\n\t}\n\tstatic contains(g1, g2) {\n\t\tif (g2.getDimension() === 2 && g1.getDimension() < 2) {\n\t\t\treturn false;\n\t\t}\n\t\tif (g2.getDimension() === 1 && g1.getDimension() < 1 && g2.getLength() > 0.0) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!g1.getEnvelopeInternal().contains(g2.getEnvelopeInternal())) return false;\n\t\tif (g1.isRectangle()) {\n\t\t\treturn RectangleContains.contains(g1, g2);\n\t\t}\n\t\treturn new RelateOp(g1, g2).getIntersectionMatrix().isContains();\n\t}\n\tgetIntersectionMatrix() {\n\t\treturn this._relate.computeIM();\n\t}\n\tgetClass() {\n\t\treturn RelateOp;\n\t}\n\tget interfaces_() {\n\t\treturn [];\n\t}\n}\nRelateOp.constructor_ = function () {\n\tthis._relate = null;\n\tif (arguments.length === 2) {\n\t\tlet g0 = arguments[0], g1 = arguments[1];\n\t\tGeometryGraphOperation.constructor_.call(this, g0, g1);\n\t\tthis._relate = new RelateComputer(this._arg);\n\t} else if (arguments.length === 3) {\n\t\tlet g0 = arguments[0], g1 = arguments[1], boundaryNodeRule = arguments[2];\n\t\tGeometryGraphOperation.constructor_.call(this, g0, g1, boundaryNodeRule);\n\t\tthis._relate = new RelateComputer(this._arg);\n\t}\n};\n","import { GeoJSONReader } from 'jsts/org/locationtech/jts/io';\nimport RelateOp from 'jsts/org/locationtech/jts/operation/relate/RelateOp';\n\n/**\n * @classdesc\n * @api\n */\nclass Base {\n  /**\n   * This function get a function filter\n   *\n   * @public\n   * @protected\n   * @function\n   */\n  getFunctionFilter() {}\n\n  /**\n   * This function execute a function filter\n   *\n   * @protected\n   * @param {Array<M.Feature>} features - Features on which the filter runs\n   * @function\n   */\n  execute(features) {}\n\n  /**\n   * This function execute a function filter\n   *\n   * @protected\n   * @param {Array<M.Feature>} features - Features on which the filter runs\n   * @return {Array<M.Feature>} Result of execute\n   * @function\n   */\n  toCQL() {}\n}\n\n/**\n * @classdesc\n * @api\n */\nclass Function extends Base {\n  /**\n   * Creates a Filter Function to filter features\n   *\n   * @param {function} filterFunction - Function to execute\n   * @api\n   */\n  constructor(filterFunction, options = {}) {\n    super();\n    /**\n     * Function to execute\n     * @private\n     * @type {function}\n     */\n    this.filterFunction_ = filterFunction;\n\n    /**\n     * Filter CQL\n     * @private\n     * @type {String}\n     */\n    this.cqlFilter_ = '';\n    if (!M.utils.isNullOrEmpty(options.cqlFilter)) {\n      this.cqlFilter_ = options.cqlFilter;\n    }\n  }\n\n  /**\n   * This function set a function filter\n   *\n   * @public\n   * @function\n   * @api\n   */\n  setFunction(filterFunction) {\n    this.filterFunction_ = filterFunction;\n  }\n\n  /**\n   * This function get a function filter\n   *\n   * @public\n   * @function\n   * @return {M.filter.Function} filter to execute\n   * @api\n   */\n  getFunctionFilter() {\n    return this.filterFunction_;\n  }\n\n  /**\n   * This function execute a function filter\n   *\n   * @public\n   * @function\n   * @param {Array<M.Feature>} features - Features on which the filter runs\n   * @return {Array<M.Feature>} features to passed filter\n   * @api\n   */\n  execute(features) {\n    return features.filter(this.filterFunction_);\n  }\n\n  /**\n   * This function return CQL\n   *\n   * @public\n   * @function\n   * @api\n   * @return {string} CQL\n   */\n  toCQL() {\n    return this.cqlFilter_;\n  }\n}\n\n/**\n * @classdesc\n * @api\n */\nclass Spatial extends Function {\n  /**\n   * Creates a Filter Spatial to filter features\n   *\n   * @api\n   */\n  constructor(FunctionParam, options) {\n    const filterFunction = (feature, index) => {\n      let geometry = null;\n      if (!M.utils.isNullOrEmpty(feature)) {\n        geometry = feature.getGeometry();\n      }\n      return FunctionParam(geometry, index);\n    };\n    super(filterFunction, options);\n  }\n}\n\n/**\n * @function\n * @api\n */\nexport const parseParamToGeometries = (paramParameter) => {\n  let param = paramParameter;\n  let geometries = [];\n  if (param instanceof M.layer.Vector) {\n    geometries = [...param.getFeatures().map(feature => feature.getGeometry())];\n  } else {\n    if (!M.utils.isArray(param)) {\n      param = [param];\n    }\n    geometries = param.map((p) => {\n      let geom;\n      if (p instanceof M.Feature) {\n        geom = p.getGeometry();\n      } else if (M.isObject(p)) {\n        geom = p;\n      }\n      return geom;\n    });\n  }\n\n  return geometries;\n};\n\n/**\n * @private\n * @function\n */\nconst toCQLFilter = (operation, geometries) => {\n  let cqlFilter = '';\n  const wktFormat = new M.format.WKT();\n  geometries.forEach((value, index) => {\n    if (index !== 0) {\n      // es un OR porque se hace una interseccion completa con todas\n      // las geometries\n      cqlFilter += ' OR ';\n    }\n    const geometry = new M.Feature('filtered_geom', {\n      type: 'Feature',\n      geometry: value,\n    });\n    const formatedGeometry = wktFormat.write(geometry);\n    cqlFilter += `${operation}({{geometryName}}, ${formatedGeometry})`;\n  });\n  return cqlFilter;\n};\n\n/**\n * This function creates a spatial filter to know which features intersects\n * another feature or layer\n *\n * @function\n * @api\n */\nexport const intersect = (param) => {\n  const geometries = parseParamToGeometries(param);\n  return new Spatial((geometryToFilter, index) => {\n    const geojsonParser = new GeoJSONReader();\n    const jtsGeomToFilter = geojsonParser.read(geometryToFilter);\n    return geometries.some((geom) => {\n      const jtsGeom = geojsonParser.read(geom);\n      return RelateOp.intersects(jtsGeomToFilter, jtsGeom);\n    });\n  }, {\n    cqlFilter: toCQLFilter('INTERSECTS', geometries),\n  });\n};\n","/* eslint-disable max-len */\n/**\n * @module M/plugin/Attributions\n */\nimport '../assets/css/attributions';\nimport AttributionsImpl from '../../impl/ol/js/attributions';\nimport AttributionsControl from './attributionscontrol';\nimport { intersect } from './filter';\nimport { getValue } from './i18n/language';\n\nimport es from './i18n/es';\nimport en from './i18n/en';\n\nconst MODES = {\n  mapAttributions: 1, // Map attributions from vector layer\n  layerAttributions: 2, // Attributions layer from its capabilities wms service\n  mixed: 3, // Mixed mode ( 1 + 2)\n};\n\n/**\n * @typedef {AttributionsOptions}\n *\n * The mode according to which the plugin will consult the attributions.\n * @param {mode}\n * @type {number}\n *\n *\n * @param {url}\n * @type {URLLike}\n */\n\n/**\n * Class of attributions plugin\n * @param {object}\n * @classdesc\n */\nexport default class Attributions extends M.Plugin {\n  /**\n   * @constructor\n   * @extends {M.Plugin}\n   * @param {AttributionsOptions} options\n   * @api\n   */\n  constructor(options = {}) {\n    super();\n\n    if (M.utils.isNullOrEmpty(options.mode) || !Object.values(MODES).includes(options.mode)) {\n      throw new Error(getValue('exception.mode'));\n    }\n\n    if (options.mode === MODES.mapAttributions && !M.utils.isNullOrEmpty(options.url)) {\n      if (M.utils.isNullOrEmpty(options.type)) {\n        throw new Error(getValue('exception.type'));\n      }\n    }\n\n    if (options.mode === MODES.mapAttributions && !M.utils.isNullOrEmpty(options.layerName)) {\n      if (M.utils.isNullOrEmpty(options.type)) {\n        throw new Error(getValue('exception.layerName'));\n      }\n    }\n\n    /**\n     * Facade of the map\n     *\n     * @private\n     * @type {M.Map}\n     */\n    this.map_ = null;\n\n    /**\n     * Array of controls\n     *\n     * @private\n     * @type {Array<M.Control>}\n     */\n    this.controls_ = [];\n\n    /**\n     * Mode of the plugin\n     *\n     * @private\n     * @type {number}\n     */\n    this.mode_ = Number.parseInt(options.mode, 10);\n\n    /**\n     * Vectorial service attributions\n     *\n     * @private\n     * @type {URLLike}\n     */\n    this.url_ = options.url || M.config.attributions.url;\n    /**\n     * Type of the data url\n     *\n     * @private\n     * @type {string}\n     */\n    this.type_ = options.type || 'kml';\n\n    /**\n     * The name of the vector layer hat contains the attribution information.\n     *\n     * @private\n     * @type {string}\n     */\n    this.layerName_ = options.layerName || 'attributions';\n\n    /**\n     * Layer of Mapea with attributions\n     *\n     * @private\n     * @type {M.layer.GeoJSON | M.layer.KML}\n     */\n    this.layer_ = options.layer;\n\n    /**\n     * Zoom from which attributions are displayed\n     *\n     * @private\n     * @type {number}\n     */\n    this.scale_ = Number.parseInt(options.scale, 10) || 10000;\n\n    /**\n     * Parameter of the features of the layer that contains the information of the attributions.\n     *\n     * @private\n     * @type {string}\n     */\n    this.attributionParam_ = options.attributionParam || 'atribucion';\n\n    /**\n     * Parameter of the features of the layer that contains the information of the URL.\n     * @private\n     * @type {URLLike}\n     */\n    this.urlParam_ = options.urlParam || 'url';\n\n    /**\n     * Minimum width of the view control\n     * @private\n     * @type {string}\n     */\n    this.minWidth_ = options.minWidth || '100px';\n\n    /**\n     * Minimum width of the view control\n     * @private\n     * @type {string}\n     */\n    this.maxWidth_ = options.maxWidth || '200px';\n\n    /**\n     * Position of the view control\n     * @private\n     * @type {string}\n     */\n    this.position_ = options.position || 'BL';\n\n    /**\n     * Default text attribution\n     *\n     * @private\n     * @type {string}\n     */\n    // eslint-disable-next-line max-len\n    this.defaultAttribution_ = options.defaultAttribution || M.config.attributions.defaultAttribution;\n\n    /**\n     * Default url attribution\n     *\n     * @private\n     * @type {string}\n     */\n    // eslint-disable-next-line max-len\n    this.defaultURL_ = options.defaultURL || M.config.attributions.defaultURL;\n\n    /**\n     * Tooltip of the UI Plugin\n     *\n     * @private\n     * @type {string}\n     */\n    this.tooltip_ = options.tooltip || getValue('tooltip');\n\n    /**\n     * Position of the view control\n     * @private\n     * @type {string}\n     */\n    this.urlAttribute = options.urlAttribute || 'Gobierno de Espaa';\n\n    window.addEventListener('resize', e => this.setCollapsiblePanel(e));\n  }\n\n  /**\n   * Return plugin language\n   *\n   * @public\n   * @function\n   * @param {string} lang type language\n   * @api stable\n   */\n  static getJSONTranslations(lang) {\n    if (lang === 'en' || lang === 'es') {\n      return (lang === 'en') ? en : es;\n    }\n    return M.language.getTranslation(lang).attributions;\n  }\n\n  /**\n   * This function adds this plugin into the map\n   *\n   * @public\n   * @function\n   * @param {M.Map} map the map to add the plugin\n   * @api stable\n   */\n  addTo(map) {\n    this.map_ = map;\n    this.impl_ = new AttributionsImpl(map);\n    this.control_ = new AttributionsControl(this.position_, this.closePanel);\n    this.controls_.push(this.control_);\n\n    this.panel_ = new M.ui.Panel('Attributions', {\n      collapsible: window.innerWidth < 769,\n      position: M.ui.position[this.position_],\n      className: 'm-panel-attributions',\n      collapsedButtonClass: 'g-cartografia-info',\n      tooltip: this.tooltip_,\n    });\n\n    this.panel_.addControls(this.control_);\n\n    this.map_.addPanels(this.panel_);\n    this.initMode();\n\n    this.onMoveEnd(() => {\n      this.changeAttributions();\n    });\n  }\n\n  /**\n   * This function destroys this plugin\n   *\n   * @public\n   * @function\n   * @api\n   */\n  destroy() {\n    this.map_.removeControls([this.control_]);\n    this.panel_ = null;\n  }\n\n  /**\n   * @public\n   * @function\n   */\n  initMode() {\n    if (this.mode_ === MODES.mapAttributions) {\n      if (!(this.layer_ instanceof M.layer.Vector)) {\n        const optionsLayer = {\n          name: this.layerName_,\n          url: this.url_,\n        };\n\n        if (this.type_ === 'geojson') {\n          this.layer_ = new M.layer.GeoJSON(optionsLayer, { displayInLayerSwitcher: false });\n        } else if (this.type_ === 'kml') {\n          this.layer_ = new M.layer.KML(optionsLayer, { displayInLayerSwitcher: false });\n        } else if (this.type === 'topojson') {\n          // TODO: Implement in Mapea M.layer.TopoJSON\n        }\n      }\n\n      if (this.map_.getLayers({ name: this.layer_ }).length < 1) {\n        this.map_.addLayers(this.layer_);\n        this.layer_.displayInLayerSwitcher = false;\n        this.layer_.setVisible(false);\n      }\n    }\n  }\n\n\n  /**\n   * This method shows the layer attributions\n   *\n   * @function\n   * @public\n   */\n  changeAttributions() {\n    this.clearContent();\n    if (this.map_.getScale() <= this.scale_) {\n      this.setVisible(true);\n      let mapAttributions = [];\n      if (this.mode_ === MODES.mapAttributions) {\n        mapAttributions = this.getMapAttributions();\n        const zoom = this.map_.getZoom();\n        const baseLayer = this.map_.getBaseLayers()[0];\n        const isHybrid = this.map_.getLayers().filter((l) => {\n          return l.type === 'WMTS' && !l.displayInLayerSwitcher && l.name === 'OI.OrthoimageCoverage';\n        }).length > 0;\n        if ((baseLayer !== undefined && baseLayer.name === 'OI.OrthoimageCoverage') || isHybrid) {\n          if (zoom < 14) {\n            mapAttributions = [{ attribution: 'Copernicus Sentinel 2019', url: 'https://sentinel.esa.int/web/sentinel/home' }].concat(mapAttributions);\n          } else {\n            mapAttributions = [{ attribution: 'Sistema Cartogrfico Nacional', url: 'http://www.scne.es/' }].concat(mapAttributions);\n          }\n        } else if (baseLayer !== undefined && (baseLayer.name === 'IGNBaseTodo' || baseLayer.name === 'EL.GridCoverageDSM')) {\n          mapAttributions = [{ attribution: 'Sistema Cartogrfico Nacional', url: 'http://www.scne.es/' }].concat(mapAttributions);\n        } else if (baseLayer !== undefined && baseLayer.name === 'LC.LandCoverSurfaces') {\n          if (zoom < 14) {\n            mapAttributions = [{ attribution: 'CORINE-Land Cover. Instituto Geogrfico Nacional', url: this.defaultURL_ }].concat(mapAttributions);\n          } else {\n            mapAttributions = [{ attribution: 'Sistema Cartogrfico Nacional', url: 'http://www.scne.es/' }].concat(mapAttributions);\n          }\n        } else {\n          mapAttributions = [{ attribution: this.defaultAttribution_, url: this.defaultURL_ }].concat(mapAttributions);\n        }\n      }\n\n      this.addContent(mapAttributions);\n    } else {\n      const zoom = this.map_.getZoom();\n      const baseLayer = this.map_.getBaseLayers()[0];\n      let mapAttributions = [{ attribution: this.defaultAttribution_, url: this.defaultURL_ }];\n      const isHybrid = this.map_.getLayers().filter((l) => {\n        return l.type === 'WMTS' && !l.displayInLayerSwitcher && l.name === 'OI.OrthoimageCoverage';\n      }).length > 0;\n      if ((baseLayer !== undefined && baseLayer.name === 'OI.OrthoimageCoverage') || isHybrid) {\n        if (zoom < 14) {\n          mapAttributions = [{ attribution: 'Copernicus Sentinel 2019', url: 'https://sentinel.esa.int/web/sentinel/home' }];\n        } else {\n          mapAttributions = [{ attribution: 'Sistema Cartogrfico Nacional', url: 'http://www.scne.es/' }];\n        }\n      } else if (baseLayer !== undefined && (baseLayer.name === 'IGNBaseTodo' || baseLayer.name === 'EL.GridCoverageDSM')) {\n        mapAttributions = [{ attribution: 'Sistema Cartogrfico Nacional', url: 'http://www.scne.es/' }];\n      } else if (baseLayer !== undefined && baseLayer.name === 'LC.LandCoverSurfaces') {\n        if (zoom < 14) {\n          mapAttributions = [{ attribution: 'CORINE-Land Cover. Instituto Geogrfico Nacional', url: this.defaultURL_ }];\n        } else {\n          mapAttributions = [{ attribution: 'Sistema Cartogrfico Nacional', url: 'http://www.scne.es/' }];\n        }\n      }\n\n      this.addContent(mapAttributions);\n    }\n  }\n\n  /**\n   * This method adds the text content to the view attribution\n   *\n   * @function\n   * @public\n   */\n  addContent(attributions) {\n    const html = this.control_.getElement();\n    const links = attributions.map((attrOpt, index, arr) => {\n      const link = document.createElement('a');\n      link.target = '_blank';\n      link.href = attrOpt.url;\n      link.innerHTML = attrOpt.attribution;\n      const attributeURL = this.map_.getScale() > this.scale_ ? '' : ', '.concat(this.urlAttribute);\n      link.innerHTML += arr.length - 1 === index ? attributeURL : ',';\n      return link;\n    });\n    const div = document.createElement('div');\n    links.forEach((link) => {\n      div.append(link);\n    });\n    html.append(div);\n  }\n\n  /**\n   * This method adds the text content to the view attribution\n   *\n   * @function\n   * @public\n   */\n  clearContent() {\n    if (!M.utils.isNullOrEmpty(this.control_)) {\n      const html = this.control_.getElement();\n      html.querySelectorAll('div').forEach(child => html.removeChild(child));\n    }\n  }\n\n  /**\n   * This method toggle de visibility of the view attribution\n   */\n  setVisible(visibility) {\n    const html = this.control_.getElement();\n    html.style.display = visibility === false ? 'none' : '';\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  getMapAttributions() {\n    this.updateBBoxFeature();\n    const featuresAttributions = this.map_.getLayers().filter(l => l.name.includes('attributions'))[0].getFeatures();\n    const interFilter = intersect(this.bboxFeature_);\n    const filteredFeatures = interFilter.execute(featuresAttributions);\n    return filteredFeatures.map((feature) => {\n      return {\n        attribution: feature.getAttribute(this.attributionParam_) || '',\n        url: feature.getAttribute(this.urlParam_) || this.defaultURL_,\n      };\n    }).filter((element, index, array) => // remove repeat elements\n      array.map(e => e.attribution).indexOf(element.attribution) === index);\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  getLayerAttributions() {\n    // TODO:\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  closePanel() {\n    this.getPanel().collapse();\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  changeContentAttribution(content) {\n    this.control_.changeContent(content);\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  updateBBoxFeature() {\n    const { x, y } = this.map_.getBbox();\n    this.bboxFeature_ = new M.Feature('bbox_feature', {\n      type: 'Feature',\n      properties: {},\n      geometry: {\n        type: 'Polygon',\n        coordinates: [\n          [\n            [x.min, y.min],\n            [x.min, y.max],\n            [x.max, y.max],\n            [x.max, y.min],\n            [x.min, y.min],\n          ],\n        ],\n      },\n    });\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  setCollapsiblePanel(e) {\n    if (this.getPanel() && this.getPanel().getTemplatePanel()) {\n      if (e.target.innerWidth < 769) {\n        this.getPanel().getTemplatePanel().classList.remove('no-collapsible');\n        this.closePanel();\n      } else {\n        this.getPanel().getTemplatePanel().classList.add('no-collapsible');\n        this.getPanel().getTemplatePanel().classList.remove('collapsed');\n      }\n    }\n  }\n  /**\n   * @function\n   * @public\n   */\n  onMoveEnd(callback) {\n    this.impl_.registerEvent('moveend', e => callback(e));\n  }\n\n  /**\n   * @function\n   * @public\n   */\n  getPanel() {\n    return this.panel_;\n  }\n\n  /**\n   * Name of the plugin\n   *\n   * @getter\n   * @function\n   */\n  get name() {\n    return 'attributions';\n  }\n\n  /**\n   * Mode of the plugin\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get mode() {\n    return this.mode_;\n  }\n\n  /**\n   * Position of the plugin\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get position() {\n    return this.position_;\n  }\n\n  /**\n   * Scale of the plugin\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get scale() {\n    return this.scale_;\n  }\n\n  /**\n   * Attribution of the plugin\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get defaultAttribution() {\n    return this.defaultAttribution_;\n  }\n\n  /**\n   * Default url of the plugin\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get defaultURL() {\n    return this.defaultURL_;\n  }\n\n  /**\n   * url of the layer\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get url() {\n    return this.url_;\n  }\n\n  /**\n   * Type\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get type() {\n    return this.type_;\n  }\n\n  /**\n   * Layer name\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get layerName() {\n    return this.layerName_;\n  }\n\n  /**\n   * Parameter of the features of the layer that contains the information of the attributions.\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get attributionParam() {\n    return this.attributionParam_;\n  }\n\n  /**\n   * Parameter of the features of the layer that contains the information of the URL.\n   *\n   * @public\n   * @function\n   * @api\n   */\n  get urlParam() {\n    return this.urlParam_;\n  }\n\n  /**\n   * Get the API REST Parameters of the plugin\n   *\n   * @function\n   * @public\n   * @api\n   */\n  getAPIRest() {\n    return `${this.name}=${this.position}*${this.mode}*${this.scale}*${this.defaultAttribution}*${this.defaultURL}*${this.url}*${this.type}*${this.layerName}*${this.attributionParam}*${this.urlParam}*${this.urlAttribute}`;\n  }\n}\n","import M$plugin$Attributions from './/facade/js/attributions';\nimport M$control$AttributionsControl from './/facade/js/attributionscontrol';\nimport M$impl$control$AttributionsControl from './/impl/ol/js/attributionscontrol';\n\nif (!window.M.plugin) window.M.plugin = {};\nif (!window.M.control) window.M.control = {};\nif (!window.M.impl) window.M.impl = {};\nif (!window.M.impl.control) window.M.impl.control = {};\nwindow.M.plugin.Attributions = M$plugin$Attributions;\nwindow.M.control.AttributionsControl = M$control$AttributionsControl;\nwindow.M.impl.control.AttributionsControl = M$impl$control$AttributionsControl;\n"],"sourceRoot":""}